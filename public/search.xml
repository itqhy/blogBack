<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-toup10]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup10%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java-toup9]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java-toup8]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java提高篇（六）-----关键字static]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup7%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/13004291 static代表着什么在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 12345678910111213141516171819public class User &#123; private static int userNumber = 0 ; public User()&#123; userNumber ++; &#125; public static void main(String[] args) &#123; User user1 = new User(); User user2 = new User(); System.out.println("user1 userNumber：" + User.userNumber); System.out.println("user2 userNumber：" + User.userNumber); &#125; &#125; ------------ Output: user1 userNumber：2 user2 userNumber：2 怎么使用staticstatic可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。ClassName..propertyNameClassName.methodName(……)Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注） static变量static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。 static方法static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。 static代码块被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。 Static的局限Static确实是存在诸多的作用，但是它也存在一些缺陷。 1、它只能调用static变量。 2、它只能调用static方法。 3、不能以任何形式引用this、super。 4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。 总结：无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇（五）-----使用序列化实现对象的拷贝]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup6%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/12952063 我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝 浅拷贝问题我们先看如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Person implements Cloneable&#123; /** 姓名 **/ private String name; /** 电子邮件 **/ private Email email; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Email getEmail() &#123; return email; &#125; public void setEmail(Email email) &#123; this.email = email; &#125; public Person(String name,Email email)&#123; this.name = name; this.email = email; &#125; public Person(String name)&#123; this.name = name; &#125; protected Person clone() &#123; Person person = null; try &#123; person = (Person) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return person; &#125; &#125; public class Client &#123; public static void main(String[] args) &#123; //写封邮件 Email email = new Email("请参加会议","请与今天12:30到二会议室参加会议..."); Person person1 = new Person("张三",email); Person person2 = person1.clone(); person2.setName("李四"); Person person3 = person1.clone(); person3.setName("王五"); System.out.println(person1.getName() + "的邮件内容是：" + person1.getEmail().getContent()); System.out.println(person2.getName() + "的邮件内容是：" + person2.getEmail().getContent()); System.out.println(person3.getName() + "的邮件内容是：" + person3.getEmail().getContent()); &#125; &#125; -------------------- Output: 张三的邮件内容是：请与今天12:30到二会议室参加会议... 李四的邮件内容是：请与今天12:30到二会议室参加会议... 王五的邮件内容是：请与今天12:30到二会议室参加会议... 在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; //写封邮件 Email email = new Email("请参加会议","请与今天12:30到二会议室参加会议..."); Person person1 = new Person("张三",email); Person person2 = person1.clone(); person2.setName("李四"); Person person3 = person1.clone(); person3.setName("王五"); person1.getEmail().setContent("请与今天12:00到二会议室参加会议..."); System.out.println(person1.getName() + "的邮件内容是：" + person1.getEmail().getContent()); System.out.println(person2.getName() + "的邮件内容是：" + person2.getEmail().getContent()); System.out.println(person3.getName() + "的邮件内容是：" + person3.getEmail().getContent()); &#125; &#125; 在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：123张三的邮件内容是：请与今天12:00到二会议室参加会议... 李四的邮件内容是：请与今天12:00到二会议室参加会议... 王五的邮件内容是：请与今天12:00到二会议室参加会议... 这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：1、 基本类型 如果变量是基本很类型，则拷贝其值，比如int、float等。2、 对象 如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。3、 String字符串 若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：1234567891011protected Person clone() &#123; Person person = null; try &#123; person = (Person) super.clone(); person.setEmail(new Email(person.getEmail().getObject(),person.getEmail().getContent())); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return person; &#125; 所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。 利用序列化实现对象的拷贝如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。1234567891011121314151617181920212223public class CloneUtils &#123; @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj)&#123; T cloneObj = null; try &#123; //写入字节流 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream obs = new ObjectOutputStream(out); obs.writeObject(obj); obs.close(); //分配内存，写入原始对象，生成新对象 ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray()); ObjectInputStream ois = new ObjectInputStream(ios); //返回生成的新对象 cloneObj = (T) ois.readObject(); ois.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125; &#125; 使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。12345678910111213public class Person implements Serializable&#123; private static final long serialVersionUID = 2631590509760908280L; .................. //去除clone()方法 &#125; public class Email implements Serializable&#123; private static final long serialVersionUID = 1267293988171991494L; .................... &#125; 所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; //写封邮件 Email email = new Email("请参加会议","请与今天12:30到二会议室参加会议..."); Person person1 = new Person("张三",email); Person person2 = CloneUtils.clone(person1); person2.setName("李四"); Person person3 = CloneUtils.clone(person1); person3.setName("王五"); person1.getEmail().setContent("请与今天12:00到二会议室参加会议..."); System.out.println(person1.getName() + "的邮件内容是：" + person1.getEmail().getContent()); System.out.println(person2.getName() + "的邮件内容是：" + person2.getEmail().getContent()); System.out.println(person3.getName() + "的邮件内容是：" + person3.getEmail().getContent()); &#125; &#125; ------------------- Output: 张三的邮件内容是：请与今天12:00到二会议室参加会议... 李四的邮件内容是：请与今天12:30到二会议室参加会议... 王五的邮件内容是：请与今天12:30到二会议室参加会议...]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇（四）-----抽象类与接口]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup5%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/12858267 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。 抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。 抽象类我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）在使用抽象类时需要注意几点： 1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。 2、抽象方法必须由子类来进行重写。 3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。 4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。 5、子类中的抽象方法不能与父类的抽象方法同名。 6、abstract不能与final并列修饰同一个类。 7、abstract 不能与private、static、final或native并列修饰同一个方法。 实例：定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下： 123456789101112131415161718192021222324252627282930313233343536public abstract class Animal &#123; public abstract void cry(); &#125; public class Cat extends Animal&#123; @Override public void cry() &#123; System.out.println("猫叫：喵喵..."); &#125; &#125; public class Dog extends Animal&#123; @Override public void cry() &#123; System.out.println("狗叫:汪汪..."); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; Animal a1 = new Cat(); Animal a2 = new Dog(); a1.cry(); a2.cry(); &#125; &#125; -------------------------------------------------------------------- Output: 猫叫：喵喵... 狗叫:汪汪... 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ） 接口接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。在使用接口过程中需要注意如下几个问题： 1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！ 2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。 3、接口中不存在实现的方法。 4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。 5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。 例如：if(anObject instanceof Comparable){}。 6、在实现多接口的时候一定要避免方法名的重复。 抽象类与接口的区别 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。 语法层次 在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。 使用抽象类来实现: 12345678public abstract class Demo &#123; abstract void method1(); void method2()&#123; //实现 &#125; &#125; 使用接口来实现 1234interface Demo &#123; void method1(); void method2(); &#125; 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点： 1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可， 但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为， 这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系， 即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。 3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可， 至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类， 猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞， 我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 （上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：http://blog.csdn.net/ttgjz/article/details/2960451我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：抽象类： 1234abstract class Door&#123; abstract void open(); abstract void close()； &#125; 接口：1234interface Door&#123; void open(); void close(); &#125; 至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。但是现在如果我们需要门具有报警的功能，那么该如何实现呢？ 解决方案一：给Door增加一个报警方法:clarm();12345abstract class Door&#123; abstract void open(); abstract void close(); abstract void alarm(); &#125; 或者 12345interface Door&#123; void open(); void close(); void alarm(); &#125; 这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。 解决方案二 既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种： 1、两个都使用抽象类来定义。 2、两个都使用接口来定义。 3、一个使用抽象类定义，一个是用接口定义。 由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。 如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。 第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下： 1234567891011121314abstract class Door&#123; abstract void open(); abstract void close(); &#125; interface Alarm&#123; void alarm(); &#125; class AlarmDoor extends Door implements Alarm&#123; void open()&#123;&#125; void close()&#123;&#125; void alarm()&#123;&#125; &#125; 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。 批注： ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。 一个类对另外一个类的依赖性应当是建立在最小的接口上的。 一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。 总结1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。 3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。 抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。 只有对问题域的本质有良好的理解，才能做出正确、合理的设计。]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇（三）-----理解java的三大特性之多态]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup4%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/12786385 面向对象编程有三大特性：封装、继承、多态。封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开： 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下： 酒 a = 剑南春 酒 b = 五粮液 酒 c = 酒鬼酒 … 这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码： JNC a = new JNC(); 对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？ Wine a = new JNC(); 在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。 但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Wine &#123; public void fun1()&#123; System.out.println("Wine 的Fun....."); fun2(); &#125; public void fun2()&#123; System.out.println("Wine 的Fun2..."); &#125; &#125; public class JNC extends Wine&#123; /** * @desc 子类重写父类方法 * 父类中不存在该方法，向上转型后，父类是不能引用该方法的 * @param a * @return void */ public void fun1(String a)&#123; System.out.println("JNC 的 Fun1..."); fun2(); &#125; /** * 子类重写父类方法 * 指向子类的父类引用调用fun2时，必定是调用该方法 */ public void fun2()&#123; System.out.println("JNC 的Fun2..."); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; Wine a = new JNC(); a.fun1(); &#125; &#125; ------------------------------------------------- Output: Wine 的Fun..... JNC 的Fun2... 从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。 分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。 所以对于多态我们可以总结如下： 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。 对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。 多态的实现实现条件在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。 Java实现多态有三个必要条件：继承、重写、向上转型。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 实现形式在Java中有两种形式可以实现多态。继承和接口。 基于继承实现的多态基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class Wine &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Wine()&#123; &#125; public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return null; &#125; &#125; public class JNC extends Wine&#123; public JNC()&#123; setName("JNC"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125; public class JGJ extends Wine&#123; public JGJ()&#123; setName("JGJ"); &#125; /** * 重写父类方法，实现多态 */ public String drink()&#123; return "喝的是 " + getName(); &#125; /** * 重写toString() */ public String toString()&#123; return "Wine : " + getName(); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; //定义父类数组 Wine[] wines = new Wine[2]; //定义两个子类 JNC jnc = new JNC(); JGJ jgj = new JGJ(); //父类引用子类对象 wines[0] = jnc; wines[1] = jgj; for(int i = 0 ; i &lt; 2 ; i++)&#123; System.out.println(wines[i].toString() + "--" + wines[i].drink()); &#125; System.out.println("-------------------------------"); &#125; &#125; OUTPUT: Wine : JNC--喝的是 JNC Wine : JGJ--喝的是 JGJ ------------------------------- 在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：12Object o = new JGJ(); System.out.println(o.toString()); 输出的结果是Wine : JGJ。 Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用。但是注意如果这样写：12Object o = new Wine(); System.out.println(o.toString()); 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。所以基于继承实现的多态可以总结如下：对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。 基于接口实现的多态继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。 经典实例通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class A &#123; public String show(D obj) &#123; return ("A and D"); &#125; public String show(A obj) &#123; return ("A and A"); &#125; &#125; public class B extends A&#123; public String show(B obj)&#123; return ("B and B"); &#125; public String show(A obj)&#123; return ("B and A"); &#125; &#125; public class C extends B&#123; &#125; public class D extends B&#123; &#125; public class Test &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125; &#125; 运行结果： 12345678910 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D ` 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。分析：从上面的程序中我们可以看出A、B、C、D存在如下关系。 首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。 按照同样的方法我也可以确认其他的答案。 方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)； 这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。 所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 参考资料：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx 百度文库：http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇（二）-----理解java的三大特性之继承]]></title>
    <url>%2F2017%2F10%2F23%2Fjava-toup3%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/12785831 在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—继承。 继承在讲解之前我们先看一个例子，该例子是前篇博文（java提高篇—–理解java的三大特性之封装）的。 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？利用继承！！首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。从上面我们就可以基本了解了继承的概念了，继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。诚然，继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。同时在使用继承时需要记住三句话： 1、子类拥有父类非private的属性和方法。 2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 3、子类可以用自己的方式实现父类的方法。（以后介绍）。 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。 构造器 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。 12345678910111213141516171819202122232425 public class Person &#123; protected String name; protected int age; protected String sex; Person()&#123; System.out.println("Person Constrctor..."); &#125; &#125; public class Husband extends Person&#123; private Wife wife; Husband()&#123; System.out.println("Husband Constructor..."); &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); &#125; &#125; Output: Person Constrctor... Husband Constructor... 通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。 1234567891011121314151617181920212223242526public class Person &#123; protected String name; protected int age; protected String sex; Person(String name)&#123; System.out.println("Person Constrctor-----" + name); &#125; &#125; public class Husband extends Person&#123; private Wife wife; Husband()&#123; super("chenssy"); System.out.println("Husband Constructor..."); &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); &#125; &#125; Output: Person Constrctor-----chenssy Husband Constructor... 所以综上所述：对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。 protected关键字 private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。12345678910111213141516171819202122232425262728293031323334353637public class Person &#123; private String name; private int age; private String sex; protected String getName() &#123; return name; &#125; protected void setName(String name) &#123; this.name = name; &#125; public String toString()&#123; return "this name is " + name; &#125; /** 省略其他setter、getter方法 **/ &#125; public class Husband extends Person&#123; private Wife wife; public String toString()&#123; setName("chenssy"); //调用父类的setName(); return super.toString(); //调用父类的toString()方法 &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); System.out.println(husband.toString()); &#125; &#125; Output： this name is chenssy 从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限。 向上转型在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：12345678910111213141516public class Person &#123; public void display()&#123; System.out.println("Play Person..."); &#125; static void display(Person person)&#123; person.display(); &#125; &#125; public class Husband extends Person&#123; public static void main(String[] args) &#123; Husband husband = new Husband(); Person.display(husband); //向上转型 &#125; &#125; 在这我们通过Person.display(husband)。这句话可以看出husband是person类型。将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。 谨慎继承上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。首先我们需要明确，继承存在如下缺陷： 1、父类变，子类就必须变。 2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。 3、继承是一种强耦合关系。 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。 慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇(一)-----理解java的三大特性之封装]]></title>
    <url>%2F2017%2F10%2F21%2Fjava-toup2%2F</url>
    <content type="text"><![CDATA[转载： http://blog.csdn.net/chenssy/article/details/12757911 从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—封装!!!!!! 三大特性之—封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有三大好处：1、良好的封装能够减少耦合。2、类内部的结构可以自由修改。3、可以对成员进行更精确的控制。4、隐藏信息，实现细节。首先我们先来看两个类：Husband.java、Wife.java 123456789101112131415161718192021222324252627282930313233343536373839404142 public class Husband &#123; /* * 对属性的封装 * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 */ private String name ; private String sex ; private int age ; private Wife wife; /* * setter()、getter()是该对象对外开发的接口 */ public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setWife(Wife wife) &#123; this.wife = wife; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435 public class Wife &#123; private String name; private int age; private String sex; private Husband husband; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setHusband(Husband husband) &#123; this.husband = husband; &#125; public Husband getHusband() &#123; return husband; &#125; &#125; 从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写： 123456public class Husband &#123; public String name ; public String sex ; public int age ; public Wife wife; &#125; 我们应该这样来使用它： 1234Husband husband = new Husband(); husband.age = 30; husband.name = "张三"; husband.sex = "男"; //貌似有点儿多余 但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。 12345678910111213141516171819202122public class Husband &#123; /* * 对属性的封装 * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 */ private String name ; private String sex ; private String age ; /* 改成 String类型的*/ private Wife wife; public String getAge() &#123; return age; &#125; public void setAge(int age) &#123; //转换即可 this.age = String.valueOf(age); &#125; /** 省略其他属性的setter、getter **/ &#125; 其他的地方依然那样引用(husband.setAge(22))保持不变。到了这里我们确实可以看出，封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。我们在看这个好处：可以对成员变量进行更精确的控制。 还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样： 12Husband husband = new Husband(); husband.age = 300; 也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如： 12345678910111213141516171819202122232425262728public class Husband &#123; /* * 对属性的封装 * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 */ private String name ; private String sex ; private int age ; /* 改成 String类型的*/ private Wife wife; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if(age &gt; 120)&#123; //提示錯誤信息 System.out.println("ERROR：error age input...."); &#125;else&#123; this.age = age; &#125; &#125; /** 省略其他属性的setter、getter **/ &#125; 上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。 123456789101112public String getSexName() &#123; if("0".equals(sex))&#123; sexName = "女"; &#125; else if("1".equals(sex))&#123; sexName = "男"; &#125; else&#123; sexName = "人妖???"; &#125; return sexName; &#125; 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。 1234567891011public String getCzHTML()&#123; if("1".equals(zt))&#123; czHTML = "&lt;a href='javascript:void(0)'" + " onclick='qy("+id+")'&gt;启用&lt;/a&gt;"; &#125; else&#123; czHTML = "&lt;a href='javascript:void(0)'" + " onclick='jy("+id+")'&gt;禁用&lt;/a&gt;"; &#125; return czHTML; &#125;]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java提高篇-----详解java的四舍五入与保留位]]></title>
    <url>%2F2017%2F10%2F20%2Fjava-toup1%2F</url>
    <content type="text"><![CDATA[转载：http://blog.csdn.net/chenssy/article/details/12719811 四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。在讲解之前，我们先看一个经典的案例： 1234567public static void main(String[] args)&#123; System.out.println("12.5的四舍五入值："+Math.round(12.5)); System.out.println("-12.5的四舍五入值：" + Math.round(-12.5)); &#125; Output: 12.5的四舍五入值：13 -12.5的四舍五入值：-12 这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。 四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下： 四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。 五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。 所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下： 舍去位的数值小于5时，直接舍去。 舍去位的数值大于5时，进位后舍去。 当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。 对于上面的规则我们举例说明 11.556 = 11.56 ——六入 11.554 = 11.55 —–四舍 11.5551 = 11.56 —–五后有数进位 11.545 = 11.54 —–五后无数，若前位为偶数应舍去 11.555 = 11.56 —–五后无数，若前位为奇数应进位 下面实例是使用银行家舍入法： 12345678910 public static void main(String[] args) &#123; BigDecimal d = new BigDecimal(100000); //存款 BigDecimal r = new BigDecimal(0.001875*3); //利息 //使用银行家算法 BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN); System.out.println("季利息是："+i); &#125; Output: 季利息是：562.50 在上面简单地介绍了银行家舍入法，目前java支持7中舍入法： 1、 ROUND_UP：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。 2、 ROUND_DOWN：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。 3、 ROUND_CEILING：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。 4、 ROUND_FLOOR：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。 5、 HALF_UP：最近数字舍入(5进)。这是我们最经典的四舍五入。 6、 HALF_DOWN：最近数字舍入(5舍)。在这里5是要舍弃的。 7、 HAIL_EVEN：银行家舍入法。 提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。 保留位方法一：四舍五入123double f = 111231.5585; BigDecimal b = new BigDecimal(f); double f1 = b.setScale(2, RoundingMode.HALF_UP).doubleValue(); 在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。 方法二：12java.text.DecimalFormat df =new java.text.DecimalFormat(”#.00″); df.format(你要格式化的数字); 例：new java.text.DecimalFormat(”#.00″).format(3.1415926) #.00 表示两位小数 #.0000四位小数 以此类推… 方法三：12345double d = 3.1415926; String result = String .format(”%.2f”); %.2f %. 表示 小数点前任意位数 2 表示两位小数 格式后的结果为f 表示浮点型。 方法四：此外如果使用struts标签做输出的话，有个format属性,设置为format=”0.00”就是保留两位小数 例如：12345678&lt;bean:write name="entity" property="dkhAFSumPl" format="0.00" /&gt; 或者 &lt;fmt:formatNumber type="number" value="$&#123;10000.22/100&#125;" maxFractionDigits="0"/&gt; maxFractionDigits表示保留的位数]]></content>
      <categories>
        <category>java开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx能为前端开发带来什么？]]></title>
    <url>%2F2017%2F10%2F20%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx那么好，我想去看看。接连逛了两个书城后，我发现并没有Nginx相关的书籍。这就很奇怪！ Nginx，一名网红（网络服务器红人…)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。 后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。后来发现了原因，大概是因为“使用太简单了，都不值得出书“。是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。当它呈现到你面前时，感觉独具匠心。 Nginx与NodeJs（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。） 有人说，作为一名前端，我的真爱是NodeJs。同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。 这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。 在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。 合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。 以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。 场景一：环境切换前端开发中，经常面临多个部署环境切换的问题。我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 然而在拓展性和易用性方面，还不足够好。而Nginx作为反向代理，就很容易处理资源转发的问题。 思路很简单： 1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）; 12345678set $env_id "1.1.1.1";if ( $http_cookie ~* "host_id=(\S+)(;.*|$)") &#123; set $env_id $1;&#125;location / &#123; proxy_set_header Host $host; proxy_pass http://$env_id:80;&#125; 123456789 public boolean isPosupplier(String opacct) throws TException &#123; String qrystr = " e.cfgsct ='posper' and e.cfgval ='"+opacct+"'"; List&lt;Appcfg&gt; appcfgs = this.jdsdb.APPCFG().list(qrystr); if(appcfgs == null || appcfgs.size()&lt;=0)&#123; return false; &#125; return true;&#125; 那接下来的事情，就是怎样用最简便的方式，把IP种在cookie里？我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。 这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。 切换环境，如今只需点击一次。 场景二：SourceMap在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。 而SourceMap正好可以解决此问题。 在最新的各版本浏览器里，如果满足： 压缩后的js文件后面有 //# sourceMappingURL=xxx.map格式的注释2.浏览器能正常访问到sourceMappingURL那么，就能把压缩过的代码还原。要实现这样的功能，就必须： 1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）2.测试环境带注释，能访问sourceMap 这样的模型，用反向代理+内容篡改的思路再合适不过。每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加.map后缀。随后，使用Nginx，通过这几行配置就能把此功能实现： 1234location ~ \.js$&#123; footer &quot;\n//# sourceMappingURL=$request_uri.map&quot;; footer_types &quot;*&quot;;&#125; 只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。 场景三：内容纂改其实在以上两个场景里，都涉及了“内容纂改”。无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。 统一介绍下，Nginx涉及纂改的模块有： nginx_http_footer_filter:往文件的底部添加文字，可包含Nginx的内置变量； nginx_http_addition_module：从一个url去读取内容，将之添加到文件的头部或顶部； nginx_http_sub_module：替换字符 除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。单单针对移动web前端开发，就可以实现： 将weinre脚本插入到html里，让移动web调试更加便捷。 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等 场景四：本地映射在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。 比如：线上接口映射到本地文件。想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。 而且，我们可以做得更灵活，比如： 同时支持慢速调试 同时支持目录层级映射 同时支持正则匹配 JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据 这些场景，只运用到Nginx里的“rewrite规则”。从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 最简单的模型中，我们把所有带cgi-bin路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，仅需这三行配置即可：123location ~ /cgi-bin/* &#123; rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;&#125; 后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 场景五：移动侧调试Fiddler 有一个勾选项 Allow remote computers to connect，并可以指定 listen port 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 hosts 配合会很实用。 这个功能，用Nginx也很容易做到。通过 default_server 作为代理，手机终端通过设置网络代理为本机IP和相应的 listen port，从而可以访问本机的 Web 服务。 其中也是用到了ngx_http_proxy_module模块的配置：12345678910111213141516171819202122 server &#123; listen 80 default_server; server_name localhost; resolver 8.8.8.8; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://$host; &#125;&#125;server &#123; listen 80; server_name ke.qq.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:9091/; &#125;&#125; 边角料除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。 1.nginx_http_concat资源合并，处理CDN combo。例如通过这样的方式http://example.com/??style1.css,style2.css,foo/style3.css访问合并后的资源。 2.ngx_http_image_filter_module图片处理。提供图片缩放，jpg压缩，旋转等特性。 3.适配PC与移动web总体可运用ngx_http_proxy_module，去实现路径转发。判断平台类型的Nginx配置，在开源项目detectmobilebrowsers中可以找到。 后记学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。但既然是工具，熟手就好。 比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。 话说回来，后来心情有些惆怅。想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。不过我又想，既然我已经花了时间去写，为什么还要花时间去用？！ 心情又好起来了。（等等有什么不对，管它呢…）]]></content>
      <categories>
        <category>-转载</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[薛定谔的年 1.1 -1.7]]></title>
    <url>%2F2017%2F10%2F20%2Fxuedinge%2F</url>
    <content type="text"><![CDATA[传说中，现在这段元旦到除夕的时间由于不知该称之“今年”或“明年”有人就说，叫薛定谔的年好了！这么一想，好像许多东西都可以跟薛定谔扯上关系了。 比如这周，每天醒来第一件事就是到12306查一下有没有薛定谔的票有了，就输入那个神才知道对不对的薛定谔验证码去完成这笔鬼才知道成不成功的薛定谔订单 这世道，上半年的代码，到下半年能不能编译都要打个问号就不要试想真切地看清这繁华世界啦。Mr.Big不断重复着：Oh baby baby it’s a wild world ….有时候发现我等的就是这几个字。 这周把kindle的书摘和笔记导了出来，是时候整理一下了。不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。 以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？但批判一件事，就得先完成它。等到真正看完，你又突然明白了喜爱的理由。这种奇妙感觉已经太久没遇到了。 然后友谊书城变得越来越吵而且很会调果茶的那个漂亮姐姐也走了不知道这两回事有没有必然联系…反正我是很少再去。 不过看着笔记还是能想起很多事情。有些摘录根本不知所以，但模糊不清反而会更有意思仿佛一种梦境的延伸。它们的存在，证明时光的缝隙里出现过一瞬间薛定谔式的触动与喜欢 仅此而已，就可知足，就能圆满。因为有时候，一瞬间的心有灵犀比一万年的细水长流要隽永得多。]]></content>
      <categories>
        <category>-转载</category>
      </categories>
      <tags>
        <tag>旧事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记“刺客信条”三部曲：水月镜像，无心去来]]></title>
    <url>%2F2017%2F10%2F19%2FmyFirstBlog%2F</url>
    <content type="text"><![CDATA[Nothing is true,everything is permitted. 万事皆虚，万物皆允。 —— 《刺客信条2》 《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。 虚Ezio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。 以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。 Ezio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。 因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。 允任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。 他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。 游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。 到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。 Ezio最后的信： When I was a young man,当我还是个年轻的小伙子I had liberty, but I did not see it.我拥有自由，却从未认知I had time, but I did not know it.我拥有时间，却毫不知情And I had love, but I did not feel it.而我亦拥有爱，却从未感觉到Many decades would pass before I understood the meaning of all three.直到数十年过去后，我才真正理解这三项的意义And now, the twilight of my life, misunderstanding has past into contentment.而现在，垂暮之年的我，这领悟让我感到满足Love, liberty, and time: once was so disposable, are the fuels that drive me forward.曾经能自由支配的爱，自由以及时间，是支持我前进的动力And love, most especially, mia caro.而爱，是最特别的一个， 亲爱的For you, our children, our brothers and sisters.为你，为我们的孩子以及为我们的兄弟姐妹们And for the vast and wonderful world that gives us lives and keeps us guessing,为这赐予我们生命与惊奇的广阔，精彩的世界endless affection，mio Sofia,至死不渝的挚爱， 我的索菲亚Forever yours, Ezio Auditore永远属于你的， Ezio Auditore]]></content>
      <categories>
        <category>-转载</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>旧事</tag>
      </tags>
  </entry>
</search>
