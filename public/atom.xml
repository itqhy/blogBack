<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Carlos的个人博客</title>
  
  <subtitle>不厌其烦  周而复始</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-23T14:38:59.914Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Carlos</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-toup20</title>
    <link href="http://yoursite.com/2017/10/23/java-toup20/"/>
    <id>http://yoursite.com/2017/10/23/java-toup20/</id>
    <published>2017-10-23T14:38:59.000Z</published>
    <updated>2017-10-23T14:38:59.914Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-toup19</title>
    <link href="http://yoursite.com/2017/10/23/java-toup19/"/>
    <id>http://yoursite.com/2017/10/23/java-toup19/</id>
    <published>2017-10-23T14:38:55.000Z</published>
    <updated>2017-10-23T14:38:55.593Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-toup18</title>
    <link href="http://yoursite.com/2017/10/23/java-toup18/"/>
    <id>http://yoursite.com/2017/10/23/java-toup18/</id>
    <published>2017-10-23T14:38:52.000Z</published>
    <updated>2017-10-23T14:38:52.078Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-toup17</title>
    <link href="http://yoursite.com/2017/10/23/java-toup17/"/>
    <id>http://yoursite.com/2017/10/23/java-toup17/</id>
    <published>2017-10-23T14:38:47.000Z</published>
    <updated>2017-10-23T14:38:47.848Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-toup16</title>
    <link href="http://yoursite.com/2017/10/23/java-toup16/"/>
    <id>http://yoursite.com/2017/10/23/java-toup16/</id>
    <published>2017-10-23T14:38:43.000Z</published>
    <updated>2017-10-23T14:38:43.695Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java-toup15</title>
    <link href="http://yoursite.com/2017/10/23/java-toup15/"/>
    <id>http://yoursite.com/2017/10/23/java-toup15/</id>
    <published>2017-10-23T14:38:39.000Z</published>
    <updated>2017-10-23T14:38:39.995Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java提高篇（十三）-----字符串</title>
    <link href="http://yoursite.com/2017/10/23/java-toup14/"/>
    <id>http://yoursite.com/2017/10/23/java-toup14/</id>
    <published>2017-10-23T14:38:36.000Z</published>
    <updated>2017-10-23T15:09:39.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/17591363" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/17591363</a></p></blockquote><p>可以证明，字符串操作是计算机程序设计中最常见的行为。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。<br>字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。<br><a id="more"></a><br>在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。<br>对于字符串的使用无非就是这几个方面：</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><pre><code>equals() ------判断内容是否相同。compareTo() ------判断字符串的大小关系。compareToIgnoreCase(String int) ------在比较时忽略字母大小写。== ------判断内容与地址是否相同。equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。</code></pre><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><pre><code>charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。lastIndexOf(String str)------查找最后一次出现的位置。lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。starWith(String prefix)------测试此字符串是否以指定的前缀开始。endsWith(String suffix)------测试此字符串是否以指定的后缀结束。</code></pre><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><pre><code>------返回一个新的字符串，它是此字符串的一个子字符串。public String subString(int beginIndex)------返回的字符串是从beginIndex开始到endIndex-1的串。public String subString(int beginIndex，int endIndex)</code></pre><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><pre><code>public String replace(char oldChar，char newChar)。public String replace(CharSequence target，CharSequence replacement)------把原来的etarget子序列替换为replacement序列，返回新串。public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。</code></pre><h3 id="更多方法请参考API"><a href="#更多方法请参考API" class="headerlink" title="更多方法请参考API"></a>更多方法请参考API</h3><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。<br>其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。<br>同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。<br>在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：</p><pre><code>1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。2、insert：该类方法主要是在StringBuffer对象中插入内容。3、delete：该类方法主要用于移除StringBuffer对象中的内容。</code></pre><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。<br>上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。</p><h2 id="正确使用String、StringBuffer、StringBuilder"><a href="#正确使用String、StringBuffer、StringBuilder" class="headerlink" title="正确使用String、StringBuffer、StringBuilder"></a>正确使用String、StringBuffer、StringBuilder</h2><p>我们先看如下表格：<br>    <img src="/uploads/string.png" alt=""></p><p>这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。<br>      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。<br>      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：<br>      String name = ”I ” + ”am ” + ”chenssy ” ;<br>      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);<br>      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。<br>      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：<br>         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。<br>         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。<br>         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。<br>      更多有关于他们之间区别，请参考：<a href="http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。" target="_blank" rel="external">http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。</a></p><h2 id="字符串拼接方式"><a href="#字符串拼接方式" class="headerlink" title="字符串拼接方式"></a>字符串拼接方式</h2><p>对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * <span class="doctag">@desc</span> 使用+、concat()、append()方法循环10W次 </span></div><div class="line"><span class="comment">    * <span class="doctag">@author</span> chenssy </span></div><div class="line"><span class="comment">    * <span class="doctag">@data</span> 2013-11-16 </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> args </span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> void </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//+  </span></div><div class="line">        <span class="keyword">long</span> start_01 = System.currentTimeMillis();  </div><div class="line">        String a = <span class="string">"a"</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;  </div><div class="line">            a += <span class="string">"b"</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">long</span> end_01 = System.currentTimeMillis();  </div><div class="line">        System.out.println(<span class="string">"  +   所消耗的时间："</span> + (end_01 - start_01) + <span class="string">"毫米"</span>);  </div><div class="line">        </div><div class="line">        <span class="comment">//concat()  </span></div><div class="line">        <span class="keyword">long</span> start_02 = System.currentTimeMillis();  </div><div class="line">        String c = <span class="string">"c"</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;  </div><div class="line">            c = c.concat(<span class="string">"d"</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">long</span> end_02 = System.currentTimeMillis();  </div><div class="line">        System.out.println(<span class="string">"concat所消耗的时间："</span> + (end_02 - start_02) + <span class="string">"毫米"</span>);  </div><div class="line">        </div><div class="line">        <span class="comment">//append  </span></div><div class="line">        <span class="keyword">long</span> start_03 = System.currentTimeMillis();  </div><div class="line">        StringBuffer e = <span class="keyword">new</span> StringBuffer(<span class="string">"e"</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;  </div><div class="line">            e.append(<span class="string">"d"</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">long</span> end_03 = System.currentTimeMillis();  </div><div class="line">        System.out.println(<span class="string">"append所消耗的时间："</span> + (end_03 - start_03) + <span class="string">"毫米"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">------------  </div><div class="line">Output:  </div><div class="line">+   所消耗的时间：<span class="number">19080</span>毫米  </div><div class="line">concat所消耗的时间：<span class="number">9089</span>毫米  </div><div class="line">append所消耗的时间：<span class="number">10</span>毫米</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * <span class="doctag">@desc</span> 使用+、concat()、append()方法循环10W次</span></div><div class="line"><span class="comment">    * <span class="doctag">@author</span> chenssy</span></div><div class="line"><span class="comment">    * <span class="doctag">@data</span> 2013-11-16</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> void</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//+</span></div><div class="line">        <span class="keyword">long</span> start_01 = System.currentTimeMillis();</div><div class="line">        String a = <span class="string">"a"</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;</div><div class="line">            a += <span class="string">"b"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end_01 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"  +   所消耗的时间："</span> + (end_01 - start_01) + <span class="string">"毫米"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//concat()</span></div><div class="line">        <span class="keyword">long</span> start_02 = System.currentTimeMillis();</div><div class="line">        String c = <span class="string">"c"</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;</div><div class="line">            c = c.concat(<span class="string">"d"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end_02 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"concat所消耗的时间："</span> + (end_02 - start_02) + <span class="string">"毫米"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//append</span></div><div class="line">        <span class="keyword">long</span> start_03 = System.currentTimeMillis();</div><div class="line">        StringBuffer e = <span class="keyword">new</span> StringBuffer(<span class="string">"e"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;</div><div class="line">            e.append(<span class="string">"d"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> end_03 = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"append所消耗的时间："</span> + (end_03 - start_03) + <span class="string">"毫米"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">------------</div><div class="line">Output:</div><div class="line">+   所消耗的时间：<span class="number">19080</span>毫米</div><div class="line">concat所消耗的时间：<span class="number">9089</span>毫米</div><div class="line">append所消耗的时间：<span class="number">10</span>毫米</div></pre></td></tr></table></figure><p>从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:</p><h3 id="方式拼接字符串"><a href="#方式拼接字符串" class="headerlink" title="+方式拼接字符串"></a>+方式拼接字符串</h3><p>在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<br>str = new StringBuilder(str).append(“b”).toString();<br>它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？</p><h3 id="concat-方法拼接字符串"><a href="#concat-方法拼接字符串" class="headerlink" title="concat()方法拼接字符串"></a>concat()方法拼接字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> otherLen = str.length();  </div><div class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];  </div><div class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);  </div><div class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。</p><h3 id="append-方法拼接字符串"><a href="#append-方法拼接字符串" class="headerlink" title="append()方法拼接字符串"></a>append()方法拼接字符串</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.append(str);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：</p><pre><code class="java"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>{      <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;          <span class="keyword">int</span> len = str.length();      <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>;      <span class="keyword">int</span> newCount = count + len;      <span class="keyword">if</span> (newCount &gt; value.length)          expandCapacity(newCount);      str.getChars(<span class="number">0</span>, len, value, count);      count = newCount;      <span class="keyword">return</span> <span class="keyword">this</span>;  }</code></pre><p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/17591363&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/17591363&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以证明，字符串操作是计算机程序设计中最常见的行为。&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;p&gt;首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。&lt;br&gt;字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（十二）-----equals()</title>
    <link href="http://yoursite.com/2017/10/23/java-toup13/"/>
    <id>http://yoursite.com/2017/10/23/java-toup13/</id>
    <published>2017-10-23T14:38:32.000Z</published>
    <updated>2017-10-23T14:57:19.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/14963073" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/14963073</a></p></blockquote><p> equals()<br>       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object obj) &#123;  </div><div class="line">    return (this == obj);  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;  </div><div class="line">        String anotherString = (String)anObject;  </div><div class="line">        <span class="keyword">int</span> n = count;  </div><div class="line">        <span class="keyword">if</span> (n == anotherString.count) &#123;  </div><div class="line">        <span class="keyword">char</span> v1[] = value;  </div><div class="line">        <span class="keyword">char</span> v2[] = anotherString.value;  </div><div class="line">        <span class="keyword">int</span> i = offset;  </div><div class="line">        <span class="keyword">int</span> j = anotherString.offset;  </div><div class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (v1[i++] != v2[j++])  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。<br>在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：<br>equals 方法在非空对象引用上实现相等关系：<br>      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。<br>       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。<br>       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：<br>      1) 对象域，使用equals方法 。<br>       2) 类型安全的枚举，使用equals或== 。<br>       3) 可能为null的对象域 : 使用 == 和 equals 。<br>       4) 数组域 : 使用 Arrays.equals 。<br>       5) 除float和double外的原始数据类型 : 使用 == 。<br>       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。<br>       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。<br>       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)  </div><div class="line">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>原因嘛，里面提到了两点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">However, there are two exceptions:  </div><div class="line">If f1 and f2 both represent  </div><div class="line">Float.NaN, then the equals method returns  </div><div class="line"><span class="keyword">true</span>, even though Float.NaN==Float.NaN  </div><div class="line">has the value <span class="keyword">false</span>.  </div><div class="line">If &lt;code&gt;f1 represents +<span class="number">0.0f</span> <span class="keyword">while</span>  </div><div class="line">f2 represents -<span class="number">0.0f</span>, or vice  </div><div class="line">versa, the equal test has the value  </div><div class="line"><span class="keyword">false</span>, even though <span class="number">0.0f</span>==-<span class="number">0.0f</span>  </div><div class="line">has the value <span class="keyword">true</span>.</div></pre></td></tr></table></figure></p><p>在equals()中使用getClass进行类型判断<br>我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。<br>父类：Person<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </div><div class="line">    <span class="keyword">protected</span> String name;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Person)&#123;  </div><div class="line">            Person p = (Person) object;  </div><div class="line">            <span class="keyword">if</span>(p.getName() == <span class="keyword">null</span> || name == <span class="keyword">null</span>)&#123;  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span>&#123;  </div><div class="line">                <span class="keyword">return</span> name.equalsIgnoreCase(p.getName());  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>子类：Employee<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> id;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.id = id;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">int</span> id)</span></span>&#123;  </div><div class="line">        <span class="keyword">super</span>(name);  </div><div class="line">        <span class="keyword">this</span>.id = id;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">     * 重写equals()方法 </span></div><div class="line"><span class="comment">     */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(object <span class="keyword">instanceof</span> Employee)&#123;  </div><div class="line">            Employee e = (Employee) object;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.equals(object) &amp;&amp; e.getId() == id;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Employee e1 = <span class="keyword">new</span> Employee(<span class="string">"chenssy"</span>, <span class="number">23</span>);  </div><div class="line">        Employee e2 = <span class="keyword">new</span> Employee(<span class="string">"chenssy"</span>, <span class="number">24</span>);  </div><div class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"chenssy"</span>);  </div><div class="line">          </div><div class="line">        System.out.println(p1.equals(e1));  </div><div class="line">        System.out.println(p1.equals(e2));  </div><div class="line">        System.out.println(e1.equals(e2));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。<br>对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。<br>所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/14963073&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/14963073&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; equals()&lt;br&gt;       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public boolean equals(Object obj) &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return (this == obj);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（十一）-----代码块</title>
    <link href="http://yoursite.com/2017/10/23/java-toup12/"/>
    <id>http://yoursite.com/2017/10/23/java-toup12/</id>
    <published>2017-10-23T14:38:24.000Z</published>
    <updated>2017-10-23T14:44:40.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/14486833" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/14486833</a></p></blockquote><p>在编程过程中我们可能会遇到如下这种形式的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">////  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：<br><a id="more"></a></p><h2 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h2><p>普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"普通代码块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"静态代码块"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 构造代码 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(<span class="string">"执行构造代码块..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 无参构造函数 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行无参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 有参构造函数 </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> id  id </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String id)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行有参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 无参构造函数 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行构造代码块..."</span>);  </div><div class="line">        System.out.println(<span class="string">"执行无参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 有参构造函数 </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> id  id </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String id)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行构造代码块..."</span>);  </div><div class="line">        System.out.println(<span class="string">"执行有参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line">    运行结果  </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">new</span> Test();  </div><div class="line">        System.out.println(<span class="string">"----------------"</span>);  </div><div class="line">        <span class="keyword">new</span> Test(<span class="string">"1"</span>);  </div><div class="line">    &#125;  </div><div class="line">------------  </div><div class="line">Output:  </div><div class="line">执行构造代码块...  </div><div class="line">执行无参构造函数...  </div><div class="line">----------------  </div><div class="line">执行构造代码块...  </div><div class="line">执行有参构造函数...</div></pre></td></tr></table></figure></p><p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：<br>1、 初始化实例变量<br>如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。<br>2、 初始化实例环境<br>一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。<br>上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。<br>五、 静态代码块、构造代码块、构造函数执行顺序<br>从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。<br>1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。<br>2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。<br>3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。<br>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="comment">/**  </span></div><div class="line"><span class="comment">    * 静态代码块  </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行静态代码块..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/**  </span></div><div class="line"><span class="comment">    * 构造代码块  </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    &#123;  </div><div class="line">        System.out.println(<span class="string">"执行构造代码块..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/**  </span></div><div class="line"><span class="comment">    * 无参构造函数  </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行无参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/**  </span></div><div class="line"><span class="comment">    * 有参构造函数  </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> id  </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String id)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"执行有参构造函数..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"----------------------"</span>);  </div><div class="line">        <span class="keyword">new</span> Test();  </div><div class="line">        System.out.println(<span class="string">"----------------------"</span>);  </div><div class="line">        <span class="keyword">new</span> Test(<span class="string">"1"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">-----------  </div><div class="line">Output:  </div><div class="line">执行静态代码块...  </div><div class="line">----------------------  </div><div class="line">执行构造代码块...  </div><div class="line">执行无参构造函数...  </div><div class="line">----------------------  </div><div class="line">执行构造代码块...  </div><div class="line">执行有参构造函数...</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/14486833&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/14486833&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编程过程中我们可能会遇到如下这种形式的程序：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;////  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（十）-----强制类型转换</title>
    <link href="http://yoursite.com/2017/10/23/java-toup11/"/>
    <id>http://yoursite.com/2017/10/23/java-toup11/</id>
    <published>2017-10-23T14:38:15.000Z</published>
    <updated>2017-10-23T14:41:30.809Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/14111307" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/14111307</a></p></blockquote><p>在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。<br>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。<br>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。<br><a id="more"></a><br>举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：<br>Father father = new Son();<br>在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！<br>Son son = (Son)father;<br>这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。<br>前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？<br>当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：<br>Father father = new Father();<br>Son son = (Son) father;<br>这个系统会抛出ClassCastException异常信息。<br>所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。<br>所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/14111307&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/14111307&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。&lt;br&gt;在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。&lt;br&gt;当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（九）-----详解匿名内部类</title>
    <link href="http://yoursite.com/2017/10/23/java-toup10/"/>
    <id>http://yoursite.com/2017/10/23/java-toup10/</id>
    <published>2017-10-23T05:38:35.000Z</published>
    <updated>2017-10-23T14:37:14.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/13170015" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/13170015</a></p></blockquote><p>在java提高篇—–详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。</p><h2 id="使用匿名内部类内部类"><a href="#使用匿名内部类内部类" class="headerlink" title="使用匿名内部类内部类"></a>使用匿名内部类内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）    </div><div class="line">    &#123;    </div><div class="line">    <span class="comment">//匿名内部类的类体部分    </span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><a id="more"></a><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Bird bird)</span></span>&#123;  </div><div class="line">        System.out.println(bird.getName() + <span class="string">"能够飞 "</span> + bird.fly() + <span class="string">"米"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Test test = <span class="keyword">new</span> Test();  </div><div class="line">        test.test(<span class="keyword">new</span> Bird() &#123;  </div><div class="line">            </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">return</span> <span class="number">10000</span>;  </div><div class="line">            &#125;  </div><div class="line">            </div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">return</span> <span class="string">"大雁"</span>;  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">------------------  </div><div class="line">Output：  </div><div class="line">大雁能够飞 <span class="number">10000</span>米</div></pre></td></tr></table></figure></p><p>在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。<br>由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。<br>对于这段匿名内部类代码其实是可以拆分为如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildGoose</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">10000</span>;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"大雁"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">WildGoose wildGoose = <span class="keyword">new</span> WildGoose();  </div><div class="line">test.test(wildGoose);</div></pre></td></tr></table></figure></p><p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><pre><code>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。2、匿名内部类中是不能定义构造函数的。3、匿名内部类中不能存在任何的静态成员变量和静态方法。4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</code></pre><h2 id="使用的形参为何要为final"><a href="#使用的形参为何要为final" class="headerlink" title="使用的形参为何要为final"></a>使用的形参为何要为final</h2><p>参考文件：<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="external">http://android.blog.51cto.com/268543/384844</a><br>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：<strong>当所在的方法的形参需要被内部类里面使用时，该形参必须为final</strong>。</p><p>为什么必须要为final呢？<br>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">final</span> String name,String age)</span></span>&#123;  </div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;  </div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">                System.out.println(name);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>$<span class="title">InnerClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String name,String age)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.InnerClass$name = name;  </div><div class="line">        <span class="keyword">this</span>.InnerClass$age = age;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="keyword">this</span>.InnerClass$name + <span class="string">"----"</span> + <span class="keyword">this</span>.InnerClass$age );  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p><p><font color="#3366ff"><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的</strong></font>。</p><h2 id="匿名内部类初始化"><a href="#匿名内部类初始化" class="headerlink" title="匿名内部类初始化"></a>匿名内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的<code>初始化</code>工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> age,<span class="keyword">final</span> String name)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass() &#123;  </div><div class="line">            <span class="keyword">int</span> age_ ;  </div><div class="line">            String name_;  </div><div class="line">            <span class="comment">//构造代码块完成初始化工作  </span></div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">if</span>(<span class="number">0</span> &lt; age &amp;&amp; age &lt; <span class="number">200</span>)&#123;  </div><div class="line">                    age_ = age;  </div><div class="line">                    name_ = name;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">return</span> name_;  </div><div class="line">            &#125;  </div><div class="line">            </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">return</span> age_;  </div><div class="line">            &#125;  </div><div class="line">        &#125;;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OutClass out = <span class="keyword">new</span> OutClass();  </div><div class="line">        </div><div class="line">        InnerClass inner_1 = out.getInnerClass(<span class="number">201</span>, <span class="string">"chenssy"</span>);  </div><div class="line">        System.out.println(inner_1.getName());  </div><div class="line">        </div><div class="line">        InnerClass inner_2 = out.getInnerClass(<span class="number">23</span>, <span class="string">"chenssy"</span>);  </div><div class="line">        System.out.println(inner_2.getName());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/13170015&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/13170015&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在java提高篇—–详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。&lt;/p&gt;
&lt;h2 id=&quot;使用匿名内部类内部类&quot;&gt;&lt;a href=&quot;#使用匿名内部类内部类&quot; class=&quot;headerlink&quot; title=&quot;使用匿名内部类内部类&quot;&gt;&lt;/a&gt;使用匿名内部类内部类&lt;/h2&gt;&lt;p&gt;匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; 父类构造器（参数列表）|实现接口（）    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//匿名内部类的类体部分    &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（八）-----实现多重继承</title>
    <link href="http://yoursite.com/2017/10/23/java-toup9/"/>
    <id>http://yoursite.com/2017/10/23/java-toup9/</id>
    <published>2017-10-23T05:38:22.000Z</published>
    <updated>2017-10-23T13:23:34.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/13168265" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/13168265</a></p></blockquote><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br><a id="more"></a><br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>,<span class="title">CanFly</span>,<span class="title">CanSwim</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">9</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kind</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">8</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重头戏在这里，儿子类Son：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 内部类继承Father类 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father_1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.strong() + <span class="number">1</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mother_1</span> <span class="keyword">extends</span>  <span class="title">Mother</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kind</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.kind() - <span class="number">2</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStrong</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Father_1().strong();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKind</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mother_1().kind();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Son son = <span class="keyword">new</span> Son();  </div><div class="line">        System.out.println(<span class="string">"Son 的Strong："</span> + son.getStrong());  </div><div class="line">        System.out.println(<span class="string">"Son 的kind："</span> + son.getKind());  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line">----------------------------------------  </div><div class="line">Output:  </div><div class="line">Son 的Strong：<span class="number">10</span>  </div><div class="line">Son 的kind：<span class="number">6</span></div></pre></td></tr></table></figure></p><p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/13168265&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/13168265&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。&lt;/p&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（八）-----实现多重继承</title>
    <link href="http://yoursite.com/2017/10/23/java-toup9.1/"/>
    <id>http://yoursite.com/2017/10/23/java-toup9.1/</id>
    <published>2017-10-23T05:38:22.000Z</published>
    <updated>2017-10-23T14:39:24.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/13168265" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/13168265</a></p></blockquote><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br><a id="more"></a><br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFight</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanSwim</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CanFly</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionCharacter</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span></span>&#123;  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">ActionCharacter</span> <span class="keyword">implements</span> <span class="title">CanFight</span>,<span class="title">CanFly</span>,<span class="title">CanSwim</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">9</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kind</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="number">8</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>重头戏在这里，儿子类Son：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 内部类继承Father类 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father_1</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strong</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.strong() + <span class="number">1</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mother_1</span> <span class="keyword">extends</span>  <span class="title">Mother</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kind</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.kind() - <span class="number">2</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStrong</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Father_1().strong();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKind</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mother_1().kind();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Son son = <span class="keyword">new</span> Son();  </div><div class="line">        System.out.println(<span class="string">"Son 的Strong："</span> + son.getStrong());  </div><div class="line">        System.out.println(<span class="string">"Son 的kind："</span> + son.getKind());  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line">----------------------------------------  </div><div class="line">Output:  </div><div class="line">Son 的Strong：<span class="number">10</span>  </div><div class="line">Son 的kind：<span class="number">6</span></div></pre></td></tr></table></figure></p><p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/13168265&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/13168265&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。&lt;/p&gt;
&lt;h2 id=&quot;接口&quot;&gt;&lt;a href=&quot;#接口&quot; class=&quot;headerlink&quot; title=&quot;接口&quot;&gt;&lt;/a&gt;接口&lt;/h2&gt;&lt;p&gt;在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（七）-----详解内部类</title>
    <link href="http://yoursite.com/2017/10/23/java-toup8/"/>
    <id>http://yoursite.com/2017/10/23/java-toup8/</id>
    <published>2017-10-23T05:38:12.000Z</published>
    <updated>2017-10-23T13:23:34.770Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="http://blog.csdn.net/chenssy/article/details/13024951" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/13024951</a></p></blockquote><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。<br>内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。<br>第一次见面<br>内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name ;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;  </div><div class="line">            name = <span class="string">"chenssy"</span>;  </div><div class="line">            age = <span class="number">23</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。<br><a id="more"></a></p><h2 id="为什么要使用内部类"><a href="#为什么要使用内部类" class="headerlink" title="为什么要使用内部类"></a>为什么要使用内部类</h2><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Father</span> </span>&#123;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mother</span> </span>&#123;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Father</span>, <span class="title">Mother</span> </span>&#123;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">implements</span> <span class="title">Father</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mother_</span> <span class="keyword">implements</span> <span class="title">Mother</span></span>&#123;  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p><pre><code>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。3、创建内部类对象的时刻并不依赖于外围类对象的创建。4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</code></pre><h2 id="内部类基础"><a href="#内部类基础" class="headerlink" title="内部类基础"></a>内部类基础</h2><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name ;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line"></div><div class="line">    <span class="comment">/**省略getter和setter方法**/</span>  </div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;  </div><div class="line">            name = <span class="string">"chenssy"</span>;  </div><div class="line">            age = <span class="number">23</span>;  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">            System.out.println(<span class="string">"name："</span> + getName() +<span class="string">"   ;age："</span> + getAge());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();  </div><div class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class="line">        innerClass.display();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">--------------  </div><div class="line">Output：  </div><div class="line">name：chenssy   ;age：<span class="number">23</span></div></pre></td></tr></table></figure></p><p>在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。<br>同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"OuterClass..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();  </div><div class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class="line">        innerClass.getOuterClass().display();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">-------------  </div><div class="line">Output:  </div><div class="line">OuterClass...</div></pre></td></tr></table></figure></p><p>到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String str;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerDisplay</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"outerClass..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerDisplay</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="comment">//使用外围内的属性  </span></div><div class="line">            str = <span class="string">"chenssy..."</span>;  </div><div class="line">            System.out.println(str);  </div><div class="line">            <span class="comment">//使用外围内的方法  </span></div><div class="line">            outerDisplay();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();  </div><div class="line">        OuterClass.InnerClass inner = outer.getInnerClass();  </div><div class="line">        inner.innerDisplay();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">--------------------  </div><div class="line">chenssy...  </div><div class="line">outerClass...</div></pre></td></tr></table></figure></p><p>推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。<br>定义在方法里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel5</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Destionation <span class="title">destionation</span><span class="params">(String str)</span></span>&#123;  </div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PDestionation</span> <span class="keyword">implements</span> <span class="title">Destionation</span></span>&#123;  </div><div class="line">            <span class="keyword">private</span> String label;  </div><div class="line">            <span class="function"><span class="keyword">private</span> <span class="title">PDestionation</span><span class="params">(String whereTo)</span></span>&#123;  </div><div class="line">                label = whereTo;  </div><div class="line">            &#125;  </div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;  </div><div class="line">                <span class="keyword">return</span> label;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PDestionation(str);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Parcel5 parcel5 = <span class="keyword">new</span> Parcel5();  </div><div class="line">        Destionation d = parcel5.destionation(<span class="string">"chenssy"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>定义在作用域内:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel6</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalTracking</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>&#123;  </div><div class="line">        <span class="keyword">if</span>(b)&#123;  </div><div class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TrackingSlip</span></span>&#123;  </div><div class="line">                <span class="keyword">private</span> String id;  </div><div class="line">                TrackingSlip(String s) &#123;  </div><div class="line">                    id = s;  </div><div class="line">                &#125;  </div><div class="line">                <span class="function">String <span class="title">getSlip</span><span class="params">()</span></span>&#123;  </div><div class="line">                    <span class="keyword">return</span> id;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">            TrackingSlip ts = <span class="keyword">new</span> TrackingSlip(<span class="string">"chenssy"</span>);  </div><div class="line">            String string = ts.getSlip();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">()</span></span>&#123;  </div><div class="line">        internalTracking(<span class="keyword">true</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Parcel6 parcel6 = <span class="keyword">new</span> Parcel6();  </div><div class="line">        parcel6.track();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button2.addActionListener(    </div><div class="line">                <span class="keyword">new</span> ActionListener()&#123;    </div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;    </div><div class="line">                        System.out.println(<span class="string">"你按了按钮二"</span>);    </div><div class="line">                    &#125;    </div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p><pre><code>我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">getInnerClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num,String str2)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass()&#123;  </div><div class="line">            <span class="keyword">int</span> number = num + <span class="number">3</span>;  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>&#123;  </div><div class="line">                <span class="keyword">return</span> number;  </div><div class="line">            &#125;  </div><div class="line">        &#125;;        <span class="comment">/* 注意：分号不能省 */</span>  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OuterClass out = <span class="keyword">new</span> OuterClass();  </div><div class="line">        InnerClass inner = out.getInnerClass(<span class="number">2</span>, <span class="string">"chenssy"</span>);  </div><div class="line">        System.out.println(inner.getNumber());  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InnerClass</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">----------------  </div><div class="line">Output:  </div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure><p>这里我们就需要看清几个地方<br>1、 匿名内部类是没有访问修饰符的。<br>2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。<br>PS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇—–详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>在java提高篇—–关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：<br>1、 它的创建是不需要依赖于外围类的。<br>2、 它不能使用任何外围类的非static成员变量和方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String sex;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"chenssy"</span>;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    *静态内部类 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass1</span></span>&#123;  </div><div class="line">        <span class="comment">/* 在静态内部类中可以存在静态成员 */</span>  </div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String _name1 = <span class="string">"chenssy_static"</span>;  </div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="comment">/*  </span></div><div class="line"><span class="comment">            * 静态内部类只能访问外围类的静态成员变量和方法 </span></div><div class="line"><span class="comment">            * 不能访问外围类的非静态成员变量和方法 </span></div><div class="line"><span class="comment">            */</span>  </div><div class="line">            System.out.println(<span class="string">"OutClass name :"</span> + name);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 非静态内部类 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass2</span></span>&#123;  </div><div class="line">        <span class="comment">/* 非静态内部类中不能存在静态成员 */</span>  </div><div class="line">        <span class="keyword">public</span> String _name2 = <span class="string">"chenssy_inner"</span>;  </div><div class="line">        <span class="comment">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">            System.out.println(<span class="string">"OuterClass name："</span> + name);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * <span class="doctag">@desc</span> 外围类方法 </span></div><div class="line"><span class="comment">    * <span class="doctag">@author</span> chenssy </span></div><div class="line"><span class="comment">    * <span class="doctag">@data</span> 2013-10-25 </span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> void </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="comment">/* 外围类访问静态内部类：内部类. */</span>  </div><div class="line">        System.out.println(InnerClass1._name1);  </div><div class="line">        <span class="comment">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span>  </div><div class="line">        <span class="keyword">new</span> InnerClass1().display();  </div><div class="line">        </div><div class="line">        <span class="comment">/* 非静态内部的创建需要依赖于外围类 */</span>  </div><div class="line">        OuterClass.InnerClass2 inner2 = <span class="keyword">new</span> OuterClass().new InnerClass2();  </div><div class="line">        <span class="comment">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span>  </div><div class="line">        System.out.println(inner2._name2);  </div><div class="line">        inner2.display();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();  </div><div class="line">        outer.display();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">----------------  </div><div class="line">Output:  </div><div class="line">chenssy_static  </div><div class="line">OutClass name :chenssy  </div><div class="line">chenssy_inner  </div><div class="line">OuterClass name：chenssy</div></pre></td></tr></table></figure></p><p>上面这个例子充分展现了静态内部类和非静态内部类的区别。<br>到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载：&lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/13024951&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/13024951&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以将一个类的定义放在另一个类的定义内部，这就是内部类。&lt;br&gt;内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。&lt;br&gt;第一次见面&lt;br&gt;内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OuterClass&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name ;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InnerClass&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InnerClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            name = &lt;span class=&quot;string&quot;&gt;&quot;chenssy&quot;&lt;/span&gt;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            age = &lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（六）-----关键字static</title>
    <link href="http://yoursite.com/2017/10/23/java-toup7/"/>
    <id>http://yoursite.com/2017/10/23/java-toup7/</id>
    <published>2017-10-23T05:38:04.000Z</published>
    <updated>2017-10-23T13:23:34.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/13004291" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/13004291</a></p></blockquote><h2 id="static代表着什么"><a href="#static代表着什么" class="headerlink" title="static代表着什么"></a>static代表着什么</h2><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。<br>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> userNumber  = <span class="number">0</span> ;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;  </div><div class="line">        userNumber ++;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        User user1 = <span class="keyword">new</span> User();  </div><div class="line">        User user2 = <span class="keyword">new</span> User();  </div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"user1 userNumber："</span> + User.userNumber);  </div><div class="line">        System.out.println(<span class="string">"user2 userNumber："</span> + User.userNumber);  </div><div class="line">    &#125;  </div><div class="line">&#125;      </div><div class="line">------------  </div><div class="line">Output:  </div><div class="line">user1 userNumber：<span class="number">2</span>  </div><div class="line">user2 userNumber：<span class="number">2</span></div></pre></td></tr></table></figure></p><h2 id="怎么使用static"><a href="#怎么使用static" class="headerlink" title="怎么使用static"></a>怎么使用static</h2><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。<br>ClassName..propertyName<br>ClassName.methodName(……)<br>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）</p><h3 id="static变量"><a href="#static变量" class="headerlink" title="static变量"></a>static变量</h3><p>static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。<br>但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。<br>所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。</p><h3 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h3><p>static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。<br>Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p><h3 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h3><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。</p><h2 id="Static的局限"><a href="#Static的局限" class="headerlink" title="Static的局限"></a>Static的局限</h2><p>Static确实是存在诸多的作用，但是它也存在一些缺陷。</p><pre><code>1、它只能调用static变量。2、它只能调用static方法。3、不能以任何形式引用this、super。4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。</code></pre><p>总结：<font color="#3366ff">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/13004291&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/13004291&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;static代表着什么&quot;&gt;&lt;a href=&quot;#static代表着什么&quot; class=&quot;headerlink&quot; title=&quot;static代表着什么&quot;&gt;&lt;/a&gt;static代表着什么&lt;/h2&gt;&lt;p&gt;在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。&lt;br&gt;Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。&lt;br&gt;同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（五）-----使用序列化实现对象的拷贝</title>
    <link href="http://yoursite.com/2017/10/23/java-toup6/"/>
    <id>http://yoursite.com/2017/10/23/java-toup6/</id>
    <published>2017-10-23T05:22:02.000Z</published>
    <updated>2017-10-23T13:23:34.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/12952063" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/12952063</a></p></blockquote><p>我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝</p><h2 id="浅拷贝问题"><a href="#浅拷贝问题" class="headerlink" title="浅拷贝问题"></a>浅拷贝问题</h2><p>我们先看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;  </div><div class="line">    <span class="comment">/** 姓名 **/</span>  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    </div><div class="line">    <span class="comment">/** 电子邮件 **/</span>  </div><div class="line">    <span class="keyword">private</span> Email email;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Email <span class="title">getEmail</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> email;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(Email email)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.email = email;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,Email email)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name  = name;  </div><div class="line">        <span class="keyword">this</span>.email = email;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">        Person person = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            person = (Person) <span class="keyword">super</span>.clone();  </div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">        <span class="keyword">return</span> person;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//写封邮件  </span></div><div class="line">        Email email = <span class="keyword">new</span> Email(<span class="string">"请参加会议"</span>,<span class="string">"请与今天12:30到二会议室参加会议..."</span>);  </div><div class="line">        </div><div class="line">        Person person1 =  <span class="keyword">new</span> Person(<span class="string">"张三"</span>,email);  </div><div class="line">        </div><div class="line">        Person person2 =  person1.clone();  </div><div class="line">        person2.setName(<span class="string">"李四"</span>);  </div><div class="line">        Person person3 =  person1.clone();  </div><div class="line">        person3.setName(<span class="string">"王五"</span>);  </div><div class="line">        </div><div class="line">        System.out.println(person1.getName() + <span class="string">"的邮件内容是："</span> + person1.getEmail().getContent());  </div><div class="line">        System.out.println(person2.getName() + <span class="string">"的邮件内容是："</span> + person2.getEmail().getContent());  </div><div class="line">        System.out.println(person3.getName() + <span class="string">"的邮件内容是："</span> + person3.getEmail().getContent());  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">--------------------  </div><div class="line">Output:  </div><div class="line">张三的邮件内容是：请与今天<span class="number">12</span>:<span class="number">30</span>到二会议室参加会议...  </div><div class="line">李四的邮件内容是：请与今天<span class="number">12</span>:<span class="number">30</span>到二会议室参加会议...  </div><div class="line">王五的邮件内容是：请与今天<span class="number">12</span>:<span class="number">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p><a id="more"></a><p>在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//写封邮件  </span></div><div class="line">        Email email = <span class="keyword">new</span> Email(<span class="string">"请参加会议"</span>,<span class="string">"请与今天12:30到二会议室参加会议..."</span>);  </div><div class="line">        </div><div class="line">        Person person1 =  <span class="keyword">new</span> Person(<span class="string">"张三"</span>,email);  </div><div class="line">        </div><div class="line">        Person person2 =  person1.clone();  </div><div class="line">        person2.setName(<span class="string">"李四"</span>);  </div><div class="line">        Person person3 =  person1.clone();  </div><div class="line">        person3.setName(<span class="string">"王五"</span>);  </div><div class="line">        </div><div class="line">        person1.getEmail().setContent(<span class="string">"请与今天12:00到二会议室参加会议..."</span>);  </div><div class="line">        </div><div class="line">        System.out.println(person1.getName() + <span class="string">"的邮件内容是："</span> + person1.getEmail().getContent());  </div><div class="line">        System.out.println(person2.getName() + <span class="string">"的邮件内容是："</span> + person2.getEmail().getContent());  </div><div class="line">        System.out.println(person3.getName() + <span class="string">"的邮件内容是："</span> + person3.getEmail().getContent());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">张三的邮件内容是：请与今天<span class="number">12</span>:<span class="number">00</span>到二会议室参加会议...  </div><div class="line">李四的邮件内容是：请与今天<span class="number">12</span>:<span class="number">00</span>到二会议室参加会议...  </div><div class="line">王五的邮件内容是：请与今天<span class="number">12</span>:<span class="number">00</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p><p>这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！<br>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：<br>1、 基本类型<br>    如果变量是基本很类型，则拷贝其值，比如int、float等。<br>2、 对象<br>    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。<br>3、 String字符串<br>    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。<br>对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;  </div><div class="line">    Person person = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        person = (Person) <span class="keyword">super</span>.clone();  </div><div class="line">        person.setEmail(<span class="keyword">new</span> Email(person.getEmail().getObject(),person.getEmail().getContent()));  </div><div class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </div><div class="line">        e.printStackTrace();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> person;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。<br>对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。</p><h2 id="利用序列化实现对象的拷贝"><a href="#利用序列化实现对象的拷贝" class="headerlink" title="利用序列化实现对象的拷贝"></a>利用序列化实现对象的拷贝</h2><p>如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;  </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span></span>&#123;  </div><div class="line">        T cloneObj = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="comment">//写入字节流  </span></div><div class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();  </div><div class="line">            ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);  </div><div class="line">            obs.writeObject(obj);  </div><div class="line">            obs.close();  </div><div class="line">            </div><div class="line">            <span class="comment">//分配内存，写入原始对象，生成新对象  </span></div><div class="line">            ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());  </div><div class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);  </div><div class="line">            <span class="comment">//返回生成的新对象  </span></div><div class="line">            cloneObj = (T) ois.readObject();  </div><div class="line">            ois.close();  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> cloneObj;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2631590509760908280L</span>;  </div><div class="line"></div><div class="line">    ..................  </div><div class="line">    <span class="comment">//去除clone()方法  </span></div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1267293988171991494L</span>;  </div><div class="line">    </div><div class="line">    ....................  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//写封邮件  </span></div><div class="line">        Email email = <span class="keyword">new</span> Email(<span class="string">"请参加会议"</span>,<span class="string">"请与今天12:30到二会议室参加会议..."</span>);  </div><div class="line">        </div><div class="line">        Person person1 =  <span class="keyword">new</span> Person(<span class="string">"张三"</span>,email);  </div><div class="line">        </div><div class="line">        Person person2 =  CloneUtils.clone(person1);  </div><div class="line">        person2.setName(<span class="string">"李四"</span>);  </div><div class="line">        Person person3 =  CloneUtils.clone(person1);  </div><div class="line">        person3.setName(<span class="string">"王五"</span>);  </div><div class="line">        person1.getEmail().setContent(<span class="string">"请与今天12:00到二会议室参加会议..."</span>);  </div><div class="line">        </div><div class="line">        System.out.println(person1.getName() + <span class="string">"的邮件内容是："</span> + person1.getEmail().getContent());  </div><div class="line">        System.out.println(person2.getName() + <span class="string">"的邮件内容是："</span> + person2.getEmail().getContent());  </div><div class="line">        System.out.println(person3.getName() + <span class="string">"的邮件内容是："</span> + person3.getEmail().getContent());  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">-------------------  </div><div class="line">Output:  </div><div class="line">张三的邮件内容是：请与今天<span class="number">12</span>:<span class="number">00</span>到二会议室参加会议...  </div><div class="line">李四的邮件内容是：请与今天<span class="number">12</span>:<span class="number">30</span>到二会议室参加会议...  </div><div class="line">王五的邮件内容是：请与今天<span class="number">12</span>:<span class="number">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12952063&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/12952063&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝&lt;/p&gt;
&lt;h2 id=&quot;浅拷贝问题&quot;&gt;&lt;a href=&quot;#浅拷贝问题&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝问题&quot;&gt;&lt;/a&gt;浅拷贝问题&lt;/h2&gt;&lt;p&gt;我们先看如下代码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cloneable&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 姓名 **/&lt;/span&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** 电子邮件 **/&lt;/span&gt;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Email email;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Email &lt;span class=&quot;title&quot;&gt;getEmail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; email;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setEmail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Email email)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.email = email;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name,Email email)&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name  = name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.email = email;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt;&lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Person &lt;span class=&quot;title&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Person person = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            person = (Person) &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.clone();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (CloneNotSupportedException e) &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            e.printStackTrace();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; person;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Client&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//写封邮件  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Email email = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Email(&lt;span class=&quot;string&quot;&gt;&quot;请参加会议&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;请与今天12:30到二会议室参加会议...&quot;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Person person1 =  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;,email);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Person person2 =  person1.clone();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        person2.setName(&lt;span class=&quot;string&quot;&gt;&quot;李四&quot;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Person person3 =  person1.clone();  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        person3.setName(&lt;span class=&quot;string&quot;&gt;&quot;王五&quot;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(person1.getName() + &lt;span class=&quot;string&quot;&gt;&quot;的邮件内容是：&quot;&lt;/span&gt; + person1.getEmail().getContent());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(person2.getName() + &lt;span class=&quot;string&quot;&gt;&quot;的邮件内容是：&quot;&lt;/span&gt; + person2.getEmail().getContent());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(person3.getName() + &lt;span class=&quot;string&quot;&gt;&quot;的邮件内容是：&quot;&lt;/span&gt; + person3.getEmail().getContent());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--------------------  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Output:  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;张三的邮件内容是：请与今天&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;到二会议室参加会议...  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;李四的邮件内容是：请与今天&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;到二会议室参加会议...  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;王五的邮件内容是：请与今天&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;到二会议室参加会议...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（四）-----抽象类与接口</title>
    <link href="http://yoursite.com/2017/10/23/java-toup5/"/>
    <id>http://yoursite.com/2017/10/23/java-toup5/</id>
    <published>2017-10-23T05:04:03.000Z</published>
    <updated>2017-10-23T13:23:34.769Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/12858267" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/12858267</a></p></blockquote><p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。<br>       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。<br><a id="more"></a><br>在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。<br>同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）<br>在使用抽象类时需要注意几点：</p><pre><code>1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。2、抽象方法必须由子类来进行重写。3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。5、子类中的抽象方法不能与父类的抽象方法同名。6、abstract不能与final并列修饰同一个类。7、abstract 不能与private、static、final或native并列修饰同一个方法。</code></pre><p>实例：<br>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"猫叫：喵喵..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"狗叫:汪汪..."</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Animal a1 = <span class="keyword">new</span> Cat();  </div><div class="line">        Animal a2 = <span class="keyword">new</span> Dog();  </div><div class="line">        </div><div class="line">        a1.cry();  </div><div class="line">        a2.cry();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">--------------------------------------------------------------------  </div><div class="line">Output:  </div><div class="line">猫叫：喵喵...  </div><div class="line">狗叫:汪汪...</div></pre></td></tr></table></figure><p> 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。<br>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。<br>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。<br>在使用接口过程中需要注意如下几个问题：</p><pre><code>1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。3、接口中不存在实现的方法。4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。6、在实现多接口的时候一定要避免方法名的重复。</code></pre><h2 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h2><p> 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p><h3 id="语法层次"><a href="#语法层次" class="headerlink" title="语法层次"></a>语法层次</h3><p>   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>      使用抽象类来实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="comment">//实现  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 使用接口来实现<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id="设计层次"><a href="#设计层次" class="headerlink" title="设计层次"></a>设计层次</h3><p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p><pre><code>1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。</code></pre><p><strong>（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）</strong><br>为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：<a href="http://blog.csdn.net/ttgjz/article/details/2960451" target="_blank" rel="external">http://blog.csdn.net/ttgjz/article/details/2960451</a><br>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>；  </span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure><p>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。<br>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p><p><strong>解决方案一</strong>：给Door增加一个报警方法:clarm();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p><p><strong>解决方案二</strong><br>      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：<br>       1、两个都使用抽象类来定义。<br>      2、两个都使用接口来定义。<br>      3、一个使用抽象类定义，一个是用接口定义。<br>      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。<br>      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。<br>     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alarm</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p><p> <strong>批注：</strong></p><blockquote> <font color="#3366FF">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。<br>  一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>  一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。只有对问题域的本质有良好的理解，才能做出正确、合理的设计。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12858267&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/12858267&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。&lt;br&gt;       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。&lt;/p&gt;
&lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（三）-----理解java的三大特性之多态</title>
    <link href="http://yoursite.com/2017/10/23/java-toup4/"/>
    <id>http://yoursite.com/2017/10/23/java-toup4/</id>
    <published>2017-10-23T03:23:01.000Z</published>
    <updated>2017-10-23T13:23:34.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/12786385" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/12786385</a></p></blockquote><p>面向对象编程有三大特性：封装、继承、多态。<br>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。<br>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：<br> <font color="#0000ff"><strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></font><br> <a id="more"></a><br>       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：<br>       酒 a = 剑南春<br>       酒 b = 五粮液<br>       酒 c = 酒鬼酒<br>       …<br>       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。<br>       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：<br>       JNC a = new JNC();<br>       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？<br>       Wine a = new JNC();<br>       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Wine 的Fun....."</span>);  </div><div class="line">        fun2();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Wine 的Fun2..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNC</span> <span class="keyword">extends</span> <span class="title">Wine</span></span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * <span class="doctag">@desc</span> 子类重写父类方法 </span></div><div class="line"><span class="comment">    *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 </span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> a </span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> void </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(String a)</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"JNC 的 Fun1..."</span>);  </div><div class="line">        fun2();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 子类重写父类方法 </span></div><div class="line"><span class="comment">    * 指向子类的父类引用调用fun2时，必定是调用该方法 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"JNC 的Fun2..."</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Wine a = <span class="keyword">new</span> JNC();  </div><div class="line">        a.fun1();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">-------------------------------------------------  </div><div class="line">Output:  </div><div class="line">Wine 的Fun.....  </div><div class="line">JNC 的Fun2...</div></pre></td></tr></table></figure><p>从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。<br>      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>      所以对于多态我们可以总结如下：<br>      <font color="#0000ff"><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</strong></font><br>      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><h3 id="实现条件"><a href="#实现条件" class="headerlink" title="实现条件"></a>实现条件</h3><p>在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。</p><font color="#0000ff"><strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong></font><br>继承：在多态中必须存在有继承关系的子类和父类。<br>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。<br>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。<br>对于Java而言，它多态的实现机制遵循一个原则：<font color="#0000ff"><strong>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</strong></font><h3 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a>实现形式</h3><p>在Java中有两种形式可以实现多态。继承和接口。</p><h4 id="基于继承实现的多态"><a href="#基于继承实现的多态" class="headerlink" title="基于继承实现的多态"></a>基于继承实现的多态</h4><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wine</span><span class="params">()</span></span>&#123;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">drink</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"喝的是 "</span> + getName();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 重写toString() </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNC</span> <span class="keyword">extends</span> <span class="title">Wine</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JNC</span><span class="params">()</span></span>&#123;  </div><div class="line">        setName(<span class="string">"JNC"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 重写父类方法，实现多态 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">drink</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"喝的是 "</span> + getName();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 重写toString() </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Wine : "</span> + getName();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JGJ</span> <span class="keyword">extends</span> <span class="title">Wine</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JGJ</span><span class="params">()</span></span>&#123;  </div><div class="line">        setName(<span class="string">"JGJ"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 重写父类方法，实现多态 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">drink</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"喝的是 "</span> + getName();  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** </span></div><div class="line"><span class="comment">    * 重写toString() </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Wine : "</span> + getName();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//定义父类数组  </span></div><div class="line">        Wine[] wines = <span class="keyword">new</span> Wine[<span class="number">2</span>];  </div><div class="line">        <span class="comment">//定义两个子类  </span></div><div class="line">        JNC jnc = <span class="keyword">new</span> JNC();  </div><div class="line">        JGJ jgj = <span class="keyword">new</span> JGJ();  </div><div class="line">        </div><div class="line">        <span class="comment">//父类引用子类对象  </span></div><div class="line">        wines[<span class="number">0</span>] = jnc;  </div><div class="line">        wines[<span class="number">1</span>] = jgj;  </div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span> ; i++)&#123;  </div><div class="line">            System.out.println(wines[i].toString() + <span class="string">"--"</span> + wines[i].drink());  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(<span class="string">"-------------------------------"</span>);  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">OUTPUT:  </div><div class="line">Wine : JNC--喝的是 JNC  </div><div class="line">Wine : JGJ--喝的是 JGJ  </div><div class="line">-------------------------------</div></pre></td></tr></table></figure></p><p>在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。<br>我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object o = new JGJ();  </div><div class="line">System.out.println(o.toString());</div></pre></td></tr></table></figure></p><p>输出的结果是Wine : JGJ。<br>      Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：<font color="#0000ff"><strong>当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用</strong></font>。但是注意如果这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object o = <span class="keyword">new</span> Wine();  </div><div class="line">System.out.println(o.toString());</div></pre></td></tr></table></figure></p><p> 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。<br>所以基于继承实现的多态可以总结如下：<font color="#0000ff"><strong>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</strong></font><br>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</p><h4 id="基于接口实现的多态"><a href="#基于接口实现的多态" class="headerlink" title="基于接口实现的多态"></a>基于接口实现的多态</h4><p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p><h2 id="经典实例"><a href="#经典实例" class="headerlink" title="经典实例"></a>经典实例</h2><p>通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：<a href="http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx" target="_blank" rel="external">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(D obj)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);  </div><div class="line">    &#125;   </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(B obj)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(A obj)</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);  </div><div class="line">    &#125;   </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </div><div class="line"></div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        A a1 = <span class="keyword">new</span> A();  </div><div class="line">        A a2 = <span class="keyword">new</span> B();  </div><div class="line">        B b = <span class="keyword">new</span> B();  </div><div class="line">        C c = <span class="keyword">new</span> C();  </div><div class="line">        D d = <span class="keyword">new</span> D();  </div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"1--"</span> + a1.show(b));  </div><div class="line">        System.out.println(<span class="string">"2--"</span> + a1.show(c));  </div><div class="line">        System.out.println(<span class="string">"3--"</span> + a1.show(d));  </div><div class="line">        System.out.println(<span class="string">"4--"</span> + a2.show(b));  </div><div class="line">        System.out.println(<span class="string">"5--"</span> + a2.show(c));  </div><div class="line">        System.out.println(<span class="string">"6--"</span> + a2.show(d));  </div><div class="line">        System.out.println(<span class="string">"7--"</span> + b.show(b));  </div><div class="line">        System.out.println(<span class="string">"8--"</span> + b.show(c));  </div><div class="line">        System.out.println(<span class="string">"9--"</span> + b.show(d));        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 运行结果：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   <span class="number">1</span>--A and A  </div><div class="line">   <span class="number">2</span>--A and A  </div><div class="line">   <span class="number">3</span>--A and D  </div><div class="line">   <span class="number">4</span>--B and A  </div><div class="line">   <span class="number">5</span>--B and A  </div><div class="line">   <span class="number">6</span>--A and D  </div><div class="line">   <span class="number">7</span>--B and B  </div><div class="line">   <span class="number">8</span>--B and B  </div><div class="line">   <span class="number">9</span>--A and D </div><div class="line">`</div></pre></td></tr></table></figure><p> 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？<br>首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color="#0000ff"><strong>其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></font>。<br>分析：<br>从上面的程序中我们可以看出A、B、C、D存在如下关系。<br><img src="/uploads/java4-1.png" alt=""></p><p>首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。<br>      按照同样的方法我也可以确认其他的答案。<br>      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；<br>      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。<br>      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。<br>      参考资料：<a href="http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx" target="_blank" rel="external">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a><br>      百度文库：<a href="http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html" target="_blank" rel="external">http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12786385&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/12786385&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向对象编程有三大特性：封装、继承、多态。&lt;br&gt;封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。&lt;br&gt;继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：&lt;br&gt; &lt;font color=&quot;#0000ff&quot;&gt;&lt;strong&gt;所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇（二）-----理解java的三大特性之继承</title>
    <link href="http://yoursite.com/2017/10/23/java-toup3/"/>
    <id>http://yoursite.com/2017/10/23/java-toup3/</id>
    <published>2017-10-23T02:54:46.000Z</published>
    <updated>2017-10-23T13:23:34.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/12785831" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/12785831</a></p></blockquote><p>在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—继承。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在讲解之前我们先看一个例子，该例子是前篇博文（<a href="https://itqhy.github.io/2017/10/21/java-toup2/" target="_blank" rel="external">java提高篇—–理解java的三大特性之封装</a>）的。<br><img src="/uploads/java3-1.png" alt=""> </p><a id="more"></a><p> 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？<strong>利用继承！！</strong><br>首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。<br>从上面我们就可以基本了解了继承的概念了，<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。<br><img src="/uploads/java3-2.png" alt=""><br> 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。<br>继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。<br>实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。<br>诚然，<strong>继承定义了类如何相互关联，共享特性</strong>。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br>同时在使用继承时需要记住三句话：</p><pre><code>1、子类拥有父类非private的属性和方法。2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。3、子类可以用自己的方式实现父类的方法。（以后介绍）。</code></pre><p> 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。<br>诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p> 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。<strong>对于构造器而言，它只能够被调用，而不能被继承</strong>。 调用父类的构造方法我们使用super()即可。<br>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </div><div class="line">        <span class="keyword">protected</span> String name;  </div><div class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> age;  </div><div class="line">        <span class="keyword">protected</span> String sex;  </div><div class="line">        </div><div class="line">        Person()&#123;  </div><div class="line">            System.out.println(<span class="string">"Person Constrctor..."</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;  </div><div class="line">        <span class="keyword">private</span> Wife wife;  </div><div class="line">    </div><div class="line">        Husband()&#123;  </div><div class="line">            System.out.println(<span class="string">"Husband Constructor..."</span>);  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">            Husband husband  = <span class="keyword">new</span> Husband();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">Output:  </div><div class="line">Person Constrctor...  </div><div class="line">Husband Constructor...</div></pre></td></tr></table></figure><p>通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。<br>但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </div><div class="line">    <span class="keyword">protected</span> String name;  </div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="keyword">protected</span> String sex;  </div><div class="line">    </div><div class="line">    Person(String name)&#123;  </div><div class="line">        System.out.println(<span class="string">"Person Constrctor-----"</span> + name);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Wife wife;  </div><div class="line"></div><div class="line">    Husband()&#123;  </div><div class="line">        <span class="keyword">super</span>(<span class="string">"chenssy"</span>);  </div><div class="line">        System.out.println(<span class="string">"Husband Constructor..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Husband husband  = <span class="keyword">new</span> Husband();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">Output:  </div><div class="line">Person Constrctor-----chenssy  </div><div class="line">Husband Constructor...</div></pre></td></tr></table></figure><p> 所以综上所述：<strong>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</strong></p><h2 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a>protected关键字</h2><p> private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。<br><strong>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="keyword">private</span> String sex;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"this name is "</span> + name;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** 省略其他setter、getter方法 **/</span>  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Wife wife;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span></span>&#123;  </div><div class="line">        setName(<span class="string">"chenssy"</span>);    <span class="comment">//调用父类的setName();  </span></div><div class="line">        <span class="keyword">return</span>  <span class="keyword">super</span>.toString();    <span class="comment">//调用父类的toString()方法  </span></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Husband husband = <span class="keyword">new</span> Husband();  </div><div class="line">        </div><div class="line">        System.out.println(husband.toString());  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">Output：  </div><div class="line"><span class="keyword">this</span> name is chenssy</div></pre></td></tr></table></figure></p><p>从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。<br>诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是<strong>将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限</strong>。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Play Person..."</span>);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Person person)</span></span>&#123;  </div><div class="line">        person.display();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Husband husband = <span class="keyword">new</span> Husband();  </div><div class="line">        Person.display(husband);      <span class="comment">//向上转型  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这我们通过Person.display(husband)。这句话可以看出husband是person类型。<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p><h2 id="谨慎继承"><a href="#谨慎继承" class="headerlink" title="谨慎继承"></a>谨慎继承</h2><p>上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。<br>首先我们需要明确，继承存在如下缺陷：</p><pre><code>1、父类变，子类就必须变。2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。3、继承是一种强耦合关系。</code></pre><p> 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。<br>      <font color="red"><strong>慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></font></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12785831&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/12785831&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—继承。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;在讲解之前我们先看一个例子，该例子是前篇博文（&lt;a href=&quot;https://itqhy.github.io/2017/10/21/java-toup2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java提高篇—–理解java的三大特性之封装&lt;/a&gt;）的。&lt;br&gt;&lt;img src=&quot;/uploads/java3-1.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>java提高篇(一)-----理解java的三大特性之封装</title>
    <link href="http://yoursite.com/2017/10/21/java-toup2/"/>
    <id>http://yoursite.com/2017/10/21/java-toup2/</id>
    <published>2017-10-20T16:06:18.000Z</published>
    <updated>2017-10-23T13:23:34.767Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载： <a href="http://blog.csdn.net/chenssy/article/details/12757911" target="_blank" rel="external">http://blog.csdn.net/chenssy/article/details/12757911</a></p></blockquote><p>从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！<br>闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—封装!!!!!!</p><a id="more"></a><h2 id="三大特性之—封装"><a href="#三大特性之—封装" class="headerlink" title="三大特性之—封装"></a>三大特性之—封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。<br>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。<br>使用封装有三大好处：<br>1、良好的封装能够减少耦合。<br>2、类内部的结构可以自由修改。<br>3、可以对成员进行更精确的控制。<br>4、隐藏信息，实现细节。<br>首先我们先来看两个类：Husband.java、Wife.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">     * 对属性的封装 </span></div><div class="line"><span class="comment">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class="line"><span class="comment">     */</span>  </div><div class="line">    <span class="keyword">private</span> String name ;  </div><div class="line">    <span class="keyword">private</span> String sex ;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;  </div><div class="line">    <span class="keyword">private</span> Wife wife;  </div><div class="line">      </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">     * setter()、getter()是该对象对外开发的接口 </span></div><div class="line"><span class="comment">     */</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> sex;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.sex = sex;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWife</span><span class="params">(Wife wife)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.wife = wife;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wife</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="keyword">private</span> String sex;  </div><div class="line">    <span class="keyword">private</span> Husband husband;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> sex;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.sex = sex;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHusband</span><span class="params">(Husband husband)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.husband = husband;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> Husband <span class="title">getHusband</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> husband;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。<br>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。<br>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> String name ;  </div><div class="line">    <span class="keyword">public</span> String sex ;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age ;  </div><div class="line">    <span class="keyword">public</span> Wife wife;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们应该这样来使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Husband husband = <span class="keyword">new</span> Husband();  </div><div class="line">husband.age = <span class="number">30</span>;  </div><div class="line">husband.name = <span class="string">"张三"</span>;  </div><div class="line">husband.sex = <span class="string">"男"</span>;    <span class="comment">//貌似有点儿多余</span></div></pre></td></tr></table></figure><p>但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">    * 对属性的封装 </span></div><div class="line"><span class="comment">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="keyword">private</span> String name ;  </div><div class="line">    <span class="keyword">private</span> String sex ;  </div><div class="line">    <span class="keyword">private</span> String age ;    <span class="comment">/* 改成 String类型的*/</span>  </div><div class="line">    <span class="keyword">private</span> Wife wife;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="comment">//转换即可  </span></div><div class="line">        <span class="keyword">this</span>.age = String.valueOf(age);  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** 省略其他属性的setter、getter **/</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其他的地方依然那样引用(husband.setAge(22))保持不变。<br>到了这里我们确实可以看出，<strong>封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</strong><br>我们在看这个好处：<strong>可以对成员变量进行更精确的控制</strong>。</p><p>还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Husband husband = <span class="keyword">new</span> Husband();  </div><div class="line">husband.age = <span class="number">300</span>;</div></pre></td></tr></table></figure><p>也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！<br>但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Husband</span> </span>&#123;  </div><div class="line">    </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">    * 对属性的封装 </span></div><div class="line"><span class="comment">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class="line"><span class="comment">    */</span>  </div><div class="line">    <span class="keyword">private</span> String name ;  </div><div class="line">    <span class="keyword">private</span> String sex ;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age ;    <span class="comment">/* 改成 String类型的*/</span>  </div><div class="line">    <span class="keyword">private</span> Wife wife;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(age &gt; <span class="number">120</span>)&#123;  </div><div class="line">            <span class="comment">//提示錯誤信息  </span></div><div class="line">            System.out.println(<span class="string">"ERROR：error age input...."</span>);    </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">            <span class="keyword">this</span>.age = age;  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    <span class="comment">/** 省略其他属性的setter、getter **/</span>  </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSexName</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span>(<span class="string">"0"</span>.equals(sex))&#123;  </div><div class="line">        sexName = <span class="string">"女"</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"1"</span>.equals(sex))&#123;  </div><div class="line">        sexName = <span class="string">"男"</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>&#123;  </div><div class="line">        sexName = <span class="string">"人妖???"</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> sexName;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCzHTML</span><span class="params">()</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(<span class="string">"1"</span>.equals(zt))&#123;  </div><div class="line">        czHTML = <span class="string">"&lt;a href='javascript:void(0)'"</span></div><div class="line">            + <span class="string">" onclick='qy("</span>+id+<span class="string">")'&gt;启用&lt;/a&gt;"</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span>&#123;  </div><div class="line">        czHTML = <span class="string">"&lt;a href='javascript:void(0)'"</span></div><div class="line">            + <span class="string">" onclick='jy("</span>+id+<span class="string">")'&gt;禁用&lt;/a&gt;"</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> czHTML;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载： &lt;a href=&quot;http://blog.csdn.net/chenssy/article/details/12757911&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenssy/article/details/12757911&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！&lt;br&gt;闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—封装!!!!!!&lt;/p&gt;
    
    </summary>
    
      <category term="java开发" scheme="http://yoursite.com/categories/java%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
