{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"source/uploads/brand.jpg","path":"uploads/brand.jpg","modified":1,"renderable":0},{"_id":"source/uploads/exception.png","path":"uploads/exception.png","modified":1,"renderable":0},{"_id":"source/uploads/exception2.png","path":"uploads/exception2.png","modified":1,"renderable":0},{"_id":"source/uploads/hashcode.png","path":"uploads/hashcode.png","modified":1,"renderable":0},{"_id":"source/uploads/hashcode2.png","path":"uploads/hashcode2.png","modified":1,"renderable":0},{"_id":"source/uploads/hashmap1.png","path":"uploads/hashmap1.png","modified":1,"renderable":0},{"_id":"source/uploads/hashmap2.png","path":"uploads/hashmap2.png","modified":1,"renderable":0},{"_id":"source/uploads/hashmap3.png","path":"uploads/hashmap3.png","modified":1,"renderable":0},{"_id":"source/uploads/hexo-uploads.png","path":"uploads/hexo-uploads.png","modified":1,"renderable":0},{"_id":"source/uploads/java3-2.png","path":"uploads/java3-2.png","modified":1,"renderable":0},{"_id":"source/uploads/java4-1.png","path":"uploads/java4-1.png","modified":1,"renderable":0},{"_id":"source/uploads/list1.png","path":"uploads/list1.png","modified":1,"renderable":0},{"_id":"source/uploads/list2.png","path":"uploads/list2.png","modified":1,"renderable":0},{"_id":"source/uploads/maopao2.png","path":"uploads/maopao2.png","modified":1,"renderable":0},{"_id":"source/uploads/map1.png","path":"uploads/map1.png","modified":1,"renderable":0},{"_id":"source/uploads/map4.gif","path":"uploads/map4.gif","modified":1,"renderable":0},{"_id":"source/uploads/nginx0.jpg","path":"uploads/nginx0.jpg","modified":1,"renderable":0},{"_id":"source/uploads/nginx1.jpg","path":"uploads/nginx1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/nginx2.jpg","path":"uploads/nginx2.jpg","modified":1,"renderable":0},{"_id":"source/uploads/string.png","path":"uploads/string.png","modified":1,"renderable":0},{"_id":"source/uploads/tree10.png","path":"uploads/tree10.png","modified":1,"renderable":0},{"_id":"source/uploads/tree1.png","path":"uploads/tree1.png","modified":1,"renderable":0},{"_id":"source/uploads/tree11.png","path":"uploads/tree11.png","modified":1,"renderable":0},{"_id":"source/uploads/tree12.png","path":"uploads/tree12.png","modified":1,"renderable":0},{"_id":"source/uploads/tree13.png","path":"uploads/tree13.png","modified":1,"renderable":0},{"_id":"source/uploads/tree14.png","path":"uploads/tree14.png","modified":1,"renderable":0},{"_id":"source/uploads/tree2.png","path":"uploads/tree2.png","modified":1,"renderable":0},{"_id":"source/uploads/tree4.png","path":"uploads/tree4.png","modified":1,"renderable":0},{"_id":"source/uploads/tree5.png","path":"uploads/tree5.png","modified":1,"renderable":0},{"_id":"source/uploads/tree6.png","path":"uploads/tree6.png","modified":1,"renderable":0},{"_id":"source/uploads/tree7.png","path":"uploads/tree7.png","modified":1,"renderable":0},{"_id":"source/uploads/tree8.png","path":"uploads/tree8.png","modified":1,"renderable":0},{"_id":"source/uploads/tree9.png","path":"uploads/tree9.png","modified":1,"renderable":0},{"_id":"source/uploads/zhucong1.png","path":"uploads/zhucong1.png","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/uploads/ckxt3.jpg","path":"uploads/ckxt3.jpg","modified":1,"renderable":0},{"_id":"source/uploads/collections.png","path":"uploads/collections.png","modified":1,"renderable":0},{"_id":"source/uploads/diary-18.jpg","path":"uploads/diary-18.jpg","modified":1,"renderable":0},{"_id":"source/uploads/java3-1.png","path":"uploads/java3-1.png","modified":1,"renderable":0},{"_id":"source/uploads/list3.png","path":"uploads/list3.png","modified":1,"renderable":0},{"_id":"source/uploads/map2.png","path":"uploads/map2.png","modified":1,"renderable":0},{"_id":"source/uploads/map3.png","path":"uploads/map3.png","modified":1,"renderable":0},{"_id":"source/uploads/mysql-master.png","path":"uploads/mysql-master.png","modified":1,"renderable":0},{"_id":"source/uploads/mysql-slave.png","path":"uploads/mysql-slave.png","modified":1,"renderable":0},{"_id":"source/uploads/ckxt0.jpg","path":"uploads/ckxt0.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt1.jpg","path":"uploads/ckxt1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt2.jpg","path":"uploads/ckxt2.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt4.jpg","path":"uploads/ckxt4.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/dist/APlayer.min.css","path":"dist/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/dist/APlayer.min.css.map","path":"dist/APlayer.min.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/dist/linkcard.js","path":"dist/linkcard.js","modified":1,"renderable":1},{"_id":"themes/next/source/dist/music.js","path":"dist/music.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.png","path":"images/alipay.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/linkcard.png","path":"images/linkcard.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/scroll.png","path":"images/scroll.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.png","path":"images/wechatpay.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/affix.js","path":"js/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/exturl.js","path":"js/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/post-details.js","path":"js/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"source/uploads/avatar.jpeg","path":"uploads/avatar.jpeg","modified":1,"renderable":0},{"_id":"source/uploads/maopao3.png","path":"uploads/maopao3.png","modified":1,"renderable":0},{"_id":"source/uploads/tree4.gif","path":"uploads/tree4.gif","modified":1,"renderable":0},{"_id":"themes/next/source/dist/css/share.min.css","path":"dist/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/dist/fonts/iconfont.eot","path":"dist/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/dist/fonts/iconfont.svg","path":"dist/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/dist/fonts/iconfont.ttf","path":"dist/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/dist/fonts/iconfont.woff","path":"dist/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/dist/js/jquery.share.min.js","path":"dist/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/dist/js/social-share.min.js","path":"dist/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/uploads/tree3.gif","path":"uploads/tree3.gif","modified":1,"renderable":0},{"_id":"themes/next/source/dist/APlayer.min.js","path":"dist/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/dist/APlayer.min.js.map","path":"dist/APlayer.min.js.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"source/uploads/guibing2.png","path":"uploads/guibing2.png","modified":1,"renderable":0},{"_id":"source/uploads/maopao1.png","path":"uploads/maopao1.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/imgshare.css","path":"static/api/css/imgshare.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/like.css","path":"static/api/css/like.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/select_share.css","path":"static/api/css/select_share.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_popup.css","path":"static/api/css/share_popup.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style0_16.css","path":"static/api/css/share_style0_16.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style0_24.css","path":"static/api/css/share_style0_24.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style0_32.css","path":"static/api/css/share_style0_32.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style1_16.css","path":"static/api/css/share_style1_16.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style1_24.css","path":"static/api/css/share_style1_24.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style1_32.css","path":"static/api/css/share_style1_32.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style2.css","path":"static/api/css/share_style2.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style2_16.css","path":"static/api/css/share_style2_16.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style2_24.css","path":"static/api/css/share_style2_24.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style2_32.css","path":"static/api/css/share_style2_32.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/share_style4.css","path":"static/api/css/share_style4.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/slide_share.css","path":"static/api/css/slide_share.css","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/css/weixin_popup.css","path":"static/api/css/weixin_popup.css","modified":1,"renderable":1},{"_id":"source/uploads/guibing3.gif","path":"uploads/guibing3.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/data.js","path":"static/api/js/trans/data.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/logger.js","path":"static/api/js/trans/logger.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_0_16.png","path":"static/api/img/share/icons_0_16.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_0_24.png","path":"static/api/img/share/icons_0_24.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_0_32.png","path":"static/api/img/share/icons_0_32.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_1_16.png","path":"static/api/img/share/icons_1_16.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_1_24.png","path":"static/api/img/share/icons_1_24.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_1_32.png","path":"static/api/img/share/icons_1_32.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_2_16.png","path":"static/api/img/share/icons_2_16.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_2_24.png","path":"static/api/img/share/icons_2_24.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/icons_2_32.png","path":"static/api/img/share/icons_2_32.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l0.gif","path":"static/api/img/share/l0.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l1.gif","path":"static/api/img/share/l1.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l2.gif","path":"static/api/img/share/l2.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l3.gif","path":"static/api/img/share/l3.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l4.gif","path":"static/api/img/share/l4.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l5.gif","path":"static/api/img/share/l5.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l6.gif","path":"static/api/img/share/l6.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l7.gif","path":"static/api/img/share/l7.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/l8.gif","path":"static/api/img/share/l8.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/pop_c.gif","path":"static/api/img/share/pop_c.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r0.gif","path":"static/api/img/share/r0.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r1.gif","path":"static/api/img/share/r1.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r2.gif","path":"static/api/img/share/r2.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r3.gif","path":"static/api/img/share/r3.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r4.gif","path":"static/api/img/share/r4.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r5.gif","path":"static/api/img/share/r5.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r6.gif","path":"static/api/img/share/r6.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r7.gif","path":"static/api/img/share/r7.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/r8.gif","path":"static/api/img/share/r8.gif","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/sc.png","path":"static/api/img/share/sc.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/selectshare_close.png","path":"static/api/img/share/selectshare_close.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/img/share/share-search-icon.png","path":"static/api/img/share/share-search-icon.png","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/base/class.js","path":"static/api/js/base/class.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/animate.js","path":"static/api/js/component/animate.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/anticheat.js","path":"static/api/js/component/anticheat.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/comm_tools.js","path":"static/api/js/component/comm_tools.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/partners.js","path":"static/api/js/component/partners.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/pop_base.js","path":"static/api/js/component/pop_base.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/pop_dialog.js","path":"static/api/js/component/pop_dialog.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/pop_popup.js","path":"static/api/js/component/pop_popup.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/pop_popup_slide.js","path":"static/api/js/component/pop_popup_slide.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/component/qrcode.js","path":"static/api/js/component/qrcode.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/conf/const.js","path":"static/api/js/conf/const.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/conf/define.js","path":"static/api/js/conf/define.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/api_base.js","path":"static/api/js/share/api_base.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/combine_api.js","path":"static/api/js/share/combine_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/image_api.js","path":"static/api/js/share/image_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/like_api.js","path":"static/api/js/share/like_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/likeshare.js","path":"static/api/js/share/likeshare.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/select_api.js","path":"static/api/js/share/select_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/share_api.js","path":"static/api/js/share/share_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share/slide_api.js","path":"static/api/js/share/slide_api.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/share.js","path":"static/api/js/share.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/start/router.js","path":"static/api/js/start/router.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/trans.js","path":"static/api/js/trans/trans.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/trans_bdxc.js","path":"static/api/js/trans/trans_bdxc.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/trans_bdysc.js","path":"static/api/js/trans/trans_bdysc.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/trans/trans_weixin.js","path":"static/api/js/trans/trans_weixin.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/image_view.js","path":"static/api/js/view/image_view.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/like_view.js","path":"static/api/js/view/like_view.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/select_view.js","path":"static/api/js/view/select_view.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/share_view.js","path":"static/api/js/view/share_view.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/view_base.js","path":"static/api/js/view/view_base.js","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/view/slide_view.js","path":"static/api/js/view/slide_view.js","modified":1,"renderable":1},{"_id":"source/uploads/maopao2.gif","path":"uploads/maopao2.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/static/api/js/base/tangram.js","path":"static/api/js/base/tangram.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"source/uploads/guibing1.png","path":"uploads/guibing1.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"43c7280be9b19cfd23c9562e1d67defbaacaf849","modified":1566971578007},{"_id":"themes/next/.DS_Store","hash":"b0752dd867d8641b7e7667905aa3a3ebfee1308b","modified":1567661901744},{"_id":"themes/next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1564651114948},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1564651114948},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1564651114948},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1564651114948},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1564651114948},{"_id":"themes/next/.gitignore","hash":"b80cec1d5e6a73d1cec382aad8046d1352a1e963","modified":1564651114948},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1564651114949},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1564651114949},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1564651114949},{"_id":"themes/next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1564651114949},{"_id":"themes/next/_config.yml","hash":"235b900a6812c314edcdf5a31fee15e86895000b","modified":1567740399802},{"_id":"themes/next/bower.json","hash":"e6a80b9ed2d618d1cca5781952c67167a7cfac07","modified":1564651114949},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1564651114950},{"_id":"themes/next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1564651114953},{"_id":"themes/next/package.json","hash":"5870ec2b6d2159a57d84c67bad0a535b76398d5a","modified":1564651115264},{"_id":"source/_discarded/二分查找法.md","hash":"668165210bf50f1da52a5797bf65de4fa870edcf","modified":1566537149957},{"_id":"source/_discarded/测试管理博客-1.md","hash":"f00f0135aaa1f61c987c567787ef35b8d7e89b7e","modified":1564651114545},{"_id":"source/_posts/IDEA-Plugin-Mybatis-Generator-PRO.md","hash":"69f7c4bb46c791f57f15b9b87ed915bbb9af37ba","modified":1567482046117},{"_id":"source/_posts/LeetCode-两数之合.md","hash":"6a41390516d44902e03c0bb67fc3eeb0526be61b","modified":1567482046118},{"_id":"source/_posts/LeetCode-无重复字符的最长子串.md","hash":"bce541dde8d506ccc8dbbb328ec8d13d04db7c80","modified":1567564182799},{"_id":"source/_posts/LettCode-求质数.md","hash":"e02458f9c758242c25a683bfd851267416318c8e","modified":1567665649761},{"_id":"source/_posts/Spring-Boot配置动态数据源.md","hash":"2005c4aa2ed3e4a6214a9c925042a83d5d1a8cb7","modified":1567482046149},{"_id":"source/_posts/bug-idea-commands-too-long.md","hash":"25d7a694f9e01f0f1d7034ae8ee9a688af200f26","modified":1567482046150},{"_id":"source/_posts/druid-monitor.md","hash":"9981264f7a156b80e1af55fa8981e4eeb547dafe","modified":1567482046151},{"_id":"source/_posts/idea-rundashboard.md","hash":"02eba87a0b90c2eb46b12817180fb129067d3477","modified":1567482046151},{"_id":"source/_posts/java-toup1.md","hash":"4501b31f33ad233dbcc7205b4063630307e6fadb","modified":1567482046152},{"_id":"source/_posts/java-toup10.md","hash":"c4a75dc996d0b7b71f213ea5c6fbd91f363fabcc","modified":1567482046152},{"_id":"source/_posts/java-toup11.md","hash":"f3156e4792acd9958ca5a9b5610d920eb99e5444","modified":1567482046153},{"_id":"source/_posts/java-toup12.md","hash":"3a01d5b63e74b01c4f1e41bcde490ef5f1e58f61","modified":1567482046152},{"_id":"source/_posts/java-toup13.md","hash":"22f30a2a7c8586c30e9556e6db6492d1a984a262","modified":1567482046153},{"_id":"source/_posts/java-toup14.md","hash":"f5e216030459d592d0de1531d8bbb9753a21a1ec","modified":1567482046154},{"_id":"source/_posts/java-toup15.md","hash":"6212ede83d720f0d1f5209189761abb26a155bd6","modified":1567482046154},{"_id":"source/_posts/java-toup16.md","hash":"64a42cd4538f1abdfad3cd573830e15568a57162","modified":1567482046155},{"_id":"source/_posts/java-toup17.md","hash":"7abf163398917d2495d47338b0c255c1bea91dc7","modified":1567482046155},{"_id":"source/_posts/java-toup18.md","hash":"ba64b3ffb47e055b57d79ff681a966d8ef999c8e","modified":1567482046156},{"_id":"source/_posts/java-toup19.md","hash":"a678bf61c6bae3049e5c4d4b6efdb0f81ca0c340","modified":1567482046156},{"_id":"source/_posts/java-toup2.md","hash":"1b975eea9a87f40f35e069ebf9bebcfda34ade9f","modified":1567482046156},{"_id":"source/_posts/java-toup20.md","hash":"583420a7a525d82bd143ba14e0a6a9e0900f8339","modified":1567482046158},{"_id":"source/_posts/java-toup21.md","hash":"baeb0c9e8e2ebbbc421ca1f9df1525753da7eb93","modified":1567482046157},{"_id":"source/_posts/java-toup22.md","hash":"30b4637bc36e67d102e614e42fdea1ea57bba528","modified":1567482046158},{"_id":"source/_posts/java-toup23.md","hash":"0c43d025de77f7ca70098eba6a8a66bff59a52df","modified":1567482046159},{"_id":"source/_posts/java-toup24.md","hash":"779b87109e875e81621b7eeec663b3839f53dcac","modified":1567482046160},{"_id":"source/_posts/java-toup25.md","hash":"081c6d56014f745033d3aceb19db084ad966bd6b","modified":1567482046161},{"_id":"source/_posts/java-toup26.md","hash":"4c9178f20926ff32ca38b842e64557e9b7e477e4","modified":1567482046162},{"_id":"source/_posts/java-toup27.md","hash":"4441e5de1ec9d30211944616da30d53252130d17","modified":1567482046163},{"_id":"source/_posts/java-toup28.md","hash":"39b61fae7ffda67ef3f53628b76db0c93885e4fd","modified":1567482046164},{"_id":"source/_posts/java-toup29.md","hash":"68323893eb903658d5d7df4a569a39cec50dac33","modified":1567482046164},{"_id":"source/_posts/java-toup3.md","hash":"c155c714215edb97429356967c015a92dd8e2ff9","modified":1567482046165},{"_id":"source/_posts/java-toup30.md","hash":"a692968c6943c8a9ee4fbf3dd6f908701ed43e76","modified":1567482046166},{"_id":"source/_posts/java-toup31.md","hash":"90140e84ef38a471de19172232683e43abf15325","modified":1567482046166},{"_id":"source/_posts/java-toup32.md","hash":"259fc2b2e51bdfa2e434e87f48bb3eca48daa6d4","modified":1567482046167},{"_id":"source/_posts/java-toup33.md","hash":"4174ec2c1294d74840f1f32b85b9f4e8879bab6f","modified":1567482046168},{"_id":"source/_posts/java-toup34.md","hash":"9ca14cbbb76cef4894d1e9bb0446c1579f48c010","modified":1567482046168},{"_id":"source/_posts/java-toup35.md","hash":"6ad9365b9705063589d7b455926d95c4b2eb4457","modified":1567482046169},{"_id":"source/_posts/java-toup36.md","hash":"1d15bd431fa42e74554bfecd0cac947b49b8f996","modified":1567482046195},{"_id":"source/_posts/java-toup37.md","hash":"45381a9be4bf974d3fe6c2583b2dba47a3b9ea74","modified":1567482046196},{"_id":"source/_posts/java-toup4.md","hash":"bdf78236e47a0cc2c8dc86b8e58d91cea973f0d4","modified":1567482046197},{"_id":"source/_posts/java-toup5.md","hash":"23b685fdbe30f1cdd6a13fd58cd51e5d9d5ee354","modified":1567482046198},{"_id":"source/_posts/java-toup6.md","hash":"a5c0f80fcb4cd96398473fa2d1168d14b85cf324","modified":1567482046199},{"_id":"source/_posts/java-toup7.md","hash":"dbc53d8e5744e2bac84175218d903522b8a0e4a4","modified":1567482046199},{"_id":"source/_posts/java-toup8.md","hash":"17b7d64408b3094b2ddaed1f4a2e70565bd55ad4","modified":1567482046200},{"_id":"source/_posts/java-toup9.md","hash":"e7f5209e139c74e7b133eef42f03b5af911fdbe1","modified":1567482046199},{"_id":"source/_posts/myFirstBlog.md","hash":"28c8b5856aa425928a6bef746a9fda81079d8db3","modified":1567482046229},{"_id":"source/_posts/mysql主从同步配置.md","hash":"c46ddb4b9231f266fd7b2e4165db4752cdeee229","modified":1567482046251},{"_id":"source/_posts/nginx.md","hash":"c58110d87a61f1ddda6ec7953ca723357b38dbdc","modified":1567482046274},{"_id":"source/_posts/spring-security-ignore-url.md","hash":"e0b7e2910af44c494e24e0c2faaf1d85be54904d","modified":1567482046275},{"_id":"source/_posts/xuedinge.md","hash":"778e6f69e272826837cb3fb93724c33b8c483f27","modified":1567482046275},{"_id":"source/_posts/冒泡算法.md","hash":"043bbe7be0e5fd8f564cd455d9a9c2f2327a6f2f","modified":1567482046276},{"_id":"source/_posts/归并排序.md","hash":"60700481dc464ff6e7f6cea7fc0d1b3ab9129da6","modified":1567664418550},{"_id":"source/_posts/测试管理博客.md","hash":"ebd2a8b6a623f21e86ed1a32dfbedf802b4b0c48","modified":1567482046276},{"_id":"source/about/index.md","hash":"77e66204b9ac17a881dcee0f52e30acd97bff458","modified":1564651114690},{"_id":"source/archives/index.md","hash":"aa0fdbe32c0c37e49029aa4e12ffb4f0ec971ab2","modified":1564651114691},{"_id":"source/categories/index.md","hash":"ce39e20c67ec384de9764871c1e6c0c3e37207c7","modified":1564651114691},{"_id":"source/comment/index.md","hash":"f1f4456df89dcf1f4f22450568d40c2ea716d85c","modified":1567069564218},{"_id":"source/tags/index.md","hash":"3e2f12259e93dc1a8fb7942fda944f66cefe7639","modified":1564651114691},{"_id":"source/uploads/.DS_Store","hash":"32beb8e50bee4d3c2fd49025e94a6cc410e8f6ca","modified":1567051391122},{"_id":"source/uploads/avatar.jpg","hash":"83a9adfaf2096c5a48cf150e8133d63daee287c4","modified":1564651114703},{"_id":"source/uploads/brand.jpg","hash":"53226933a5b2351eba14c4f23e00052632269479","modified":1564651114703},{"_id":"source/uploads/exception.png","hash":"f5cdebb7149c8d0bff892e9d995ee9e86c5aa107","modified":1564651114723},{"_id":"source/uploads/exception2.png","hash":"bb9ae4f4de72ab3c4d0d3c85529070a041ba1950","modified":1564651114723},{"_id":"source/uploads/hashcode.png","hash":"5773aecf12b3aa2984483d3d3b7dd65e4675800e","modified":1564651114723},{"_id":"source/uploads/hashcode2.png","hash":"95a9e5c0c46e3c7f53cfed8e1aceb2592f2f4384","modified":1564651114724},{"_id":"source/uploads/hashmap1.png","hash":"46f0317a479290f37c9caf7c0b6e1af091f53f19","modified":1564651114724},{"_id":"source/uploads/hashmap2.png","hash":"a637ba13ce147c688a491a61c0f436205b7f3264","modified":1564651114745},{"_id":"source/uploads/hashmap3.png","hash":"cc9a092e9ffd5ab81d9398f2e1c2401928448a81","modified":1564651114745},{"_id":"source/uploads/hexo-uploads.png","hash":"e0e51dea9c22cf1aed4d08e689300b4c64779ce7","modified":1564651114749},{"_id":"source/uploads/java3-2.png","hash":"bea2ffd4d77637ce7f7621d24df2b4c89504191d","modified":1564651114750},{"_id":"source/uploads/java4-1.png","hash":"554406c6c89e72554ba0af3b69fec91798b9298c","modified":1564651114751},{"_id":"source/uploads/list1.png","hash":"ea21960bb4f5dfb7ff3c7669cbed6d7759a2bb36","modified":1564651114757},{"_id":"source/uploads/list2.png","hash":"bb19648c078d671f5c91ee602a19a86fae2611e8","modified":1564651114758},{"_id":"source/uploads/maopao2.png","hash":"625a49aed222db0945481825e299ea5cd1a992a6","modified":1566526229050},{"_id":"source/uploads/map1.png","hash":"6c4a7990bc8b118be5f6b95c1d65a5e6e09be59d","modified":1564651114759},{"_id":"source/uploads/map4.gif","hash":"0e9a7090a5b72c65db1b596c9342801666408b43","modified":1564651114772},{"_id":"source/uploads/nginx0.jpg","hash":"b119e75f9634059bc249b15663d38a36f5247a83","modified":1564651114772},{"_id":"source/uploads/nginx1.jpg","hash":"7acada8f9e0c8ddf9177d83f3c726c42e9e8ed7f","modified":1564651114773},{"_id":"source/uploads/nginx2.jpg","hash":"a9bdbb38876347527dd254bbe5fc9293b95681a4","modified":1564651114773},{"_id":"source/uploads/string.png","hash":"28e88a5d62fa56925cb8a9183ae6f44b7704bfb6","modified":1564651114773},{"_id":"source/uploads/tree10.png","hash":"cb653624214a5fef665de4aeee5637096b4d812e","modified":1564651114774},{"_id":"source/uploads/tree1.png","hash":"470f06fdaff61d47d93eb17b60a5a49eb082ae60","modified":1564651114773},{"_id":"source/uploads/tree11.png","hash":"4d45ff861ef64b8d10ee4f71f36caad9bab2f3f6","modified":1564651114774},{"_id":"source/uploads/tree12.png","hash":"2614f10539f35a4427a3329d0ee21f0855bca458","modified":1564651114774},{"_id":"source/uploads/tree13.png","hash":"83d2bf84f9f8f5b4aeac358beac5ec885846090b","modified":1564651114774},{"_id":"source/uploads/tree14.png","hash":"75472e1eb629fb67512cb08bdfcd6ac360d99621","modified":1564651114775},{"_id":"source/uploads/tree2.png","hash":"14a7385d655389f1fa3974cdfa42c76a8301c0e5","modified":1564651114775},{"_id":"source/uploads/tree4.png","hash":"fef649a02ba682cfa9a46a5759ac1b601e2076c5","modified":1564651114779},{"_id":"source/uploads/tree5.png","hash":"df577a45d876382dc42db6e2b9a2a318c3e4aada","modified":1564651114779},{"_id":"source/uploads/tree6.png","hash":"0901c3ac2e796a8998f431b7353e93fdab8ed587","modified":1564651114780},{"_id":"source/uploads/tree7.png","hash":"9cd220d0b8e00bc0e75381cf15980ca8f84d4f35","modified":1564651114780},{"_id":"source/uploads/tree8.png","hash":"01c7e8db66dbbc3c87b32cce670524fb1158e38a","modified":1564651114780},{"_id":"source/uploads/tree9.png","hash":"dfd7518de3453c231762e432f7c6fa437ed04001","modified":1564651114781},{"_id":"source/uploads/zhucong1.png","hash":"694cf5291a14c4d452809741a9bc6110f456ef67","modified":1566352911022},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1564651114950},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1564651114950},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1564651114950},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1564651114950},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1564651114950},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1564651114951},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1564651114951},{"_id":"themes/next/docs/MATH.md","hash":"026d2cff73c22a30ea39c50783557ff4913aceac","modified":1564651114951},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1564651114951},{"_id":"themes/next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1564651114953},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1564651114953},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1564651114954},{"_id":"themes/next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1564651114954},{"_id":"themes/next/languages/fa.yml","hash":"cd41db832af5e399590b70a5227cfe0b0e98e101","modified":1564651114954},{"_id":"themes/next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1564651114954},{"_id":"themes/next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1564651114954},{"_id":"themes/next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1564651114954},{"_id":"themes/next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1564651114954},{"_id":"themes/next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1564651114954},{"_id":"themes/next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1564651114955},{"_id":"themes/next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1564651114955},{"_id":"themes/next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1564651114955},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1564651114955},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1564651114955},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1564651114955},{"_id":"themes/next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1564651114955},{"_id":"themes/next/languages/zh-CN.yml","hash":"b392a5c44950ef9aa95965da013a57ab1408ddf7","modified":1567064671355},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1564651114955},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1564651114956},{"_id":"themes/next/layout/_layout.swig","hash":"3f3cc236186078425cb5878d2de9b7a660df6475","modified":1567664276413},{"_id":"themes/next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1564651115263},{"_id":"themes/next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1564651115263},{"_id":"themes/next/layout/index.swig","hash":"9b4733d037c360e8504645b1d6c6dd17817c9d7b","modified":1564651115263},{"_id":"themes/next/layout/page.swig","hash":"29c64c7031aaf276d3d11cdf2e95025996fd6eed","modified":1564651115263},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1564651115263},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1564651115264},{"_id":"themes/next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1564651115264},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1564651115265},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1564651115265},{"_id":"themes/next/source/.DS_Store","hash":"3f1c3d21e345c557cc320908b01698a488d790cc","modified":1567661906772},{"_id":"themes/next/source/404.html","hash":"9c9a54f2221fa84b2189f3313fc8686197867cab","modified":1564651115267},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1564651115456},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1564651115456},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1564651115456},{"_id":"source/uploads/ckxt3.jpg","hash":"5cc1b96e85d3d2a8364232fbf85795e4ababe5a6","modified":1564651114721},{"_id":"source/uploads/collections.png","hash":"f17b830cb52ddf1e5aab3d3ac060140819dbe3a6","modified":1564651114722},{"_id":"source/uploads/diary-18.jpg","hash":"e8e9f7e7e336e81416af225e26870b56509b9d68","modified":1564651114723},{"_id":"source/uploads/java3-1.png","hash":"e98d1f2eda99ec521e292bb4cd7bc5b1f25a8704","modified":1564651114750},{"_id":"source/uploads/list3.png","hash":"67cae223d732df449b14dfdf5370cd4170b7c02d","modified":1564651114759},{"_id":"source/uploads/map2.png","hash":"ac535775f14f6bd91a98102c4f977cf05d8e6acf","modified":1564651114760},{"_id":"source/uploads/map3.png","hash":"7995131bc92c470291a06a925a75d936d0b926d1","modified":1564651114771},{"_id":"source/uploads/mysql-master.png","hash":"830111608a0011717cc75d4eeaee9e42f31b178f","modified":1566196153255},{"_id":"source/uploads/mysql-slave.png","hash":"4070b77fd28fc609bfcf8bcb117ad2d11aef0cf2","modified":1566196675385},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115420},{"_id":"source/uploads/ckxt0.jpg","hash":"980ebd08b10b0f3b9bf2603dc38d45842cc50d15","modified":1564651114706},{"_id":"source/uploads/ckxt1.jpg","hash":"a184ba933c5757d9dc200b3c056759387242d1cf","modified":1564651114717},{"_id":"source/uploads/ckxt2.jpg","hash":"f52cfe91b2918bc7d48bcf8dd10f68ea780d29c0","modified":1564651114718},{"_id":"source/uploads/ckxt4.jpg","hash":"ca93f86e826eaaabe375a5b9d0bf4ad79762f558","modified":1564651114722},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1564651114951},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1564651114951},{"_id":"themes/next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1564651114952},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"650fcb9135b6f09d48e866c19e0dbccd831367f1","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1564651114952},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1564651114953},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"83feca62190abcca0332915ffe0eefe582573085","modified":1564651114953},{"_id":"themes/next/docs/zh-CN/README.md","hash":"cdd7a8bdcf4a83ff4c74ee6c95c6bcc0b8c1831c","modified":1564651114953},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1564651114953},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1564651114956},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1564651114956},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1564651114956},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"b759e9b27ffb92f9c826ae2b2527636a2ae65fac","modified":1567068181616},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1564651114988},{"_id":"themes/next/layout/_macro/post.swig","hash":"80b764620695c4f846e4dd441928420c41884d60","modified":1567740766539},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"480d93619479dcfcbec6906803bb38b2dfbeae53","modified":1564651114989},{"_id":"themes/next/layout/_partials/comments.swig","hash":"784356dd77fe96ea1bc4cb0008e2b40de71bf2f0","modified":1564651114989},{"_id":"themes/next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1564651114989},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1564651114989},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1564651115011},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1564651115011},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1564651115098},{"_id":"themes/next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1564651115098},{"_id":"themes/next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1564651115109},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1564651115110},{"_id":"themes/next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1564651115119},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9cd491b8ff2dc9d6976cd9e89c4e56678e3bcefa","modified":1564651115119},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1564651115168},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1564651115168},{"_id":"themes/next/layout/_third-party/chatra.swig","hash":"aa0893cddc803bd3fd34ab78d7d003bd86be86b6","modified":1564651115168},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a7126355227236f9433615edfd89e86fd51ed676","modified":1564651115223},{"_id":"themes/next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1564651115224},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1564651115224},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1564651115224},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1564651115224},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"7757bd285732e857996b99af9d917953589fac5e","modified":1564651115261},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1564651115262},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1564651115262},{"_id":"themes/next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1564651115263},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1564651115264},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1564651115264},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1564651115265},{"_id":"themes/next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1564651115265},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1564651115266},{"_id":"themes/next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1564651115266},{"_id":"themes/next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1564651115266},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1564651115266},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1564651115266},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1564651115266},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1564651115266},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1564651115267},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1564651115267},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1564651115267},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1564651115267},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1564651115420},{"_id":"themes/next/source/dist/APlayer.min.css","hash":"2f8c1f509b86560634cee04695f87117105bbad4","modified":1567156937497},{"_id":"themes/next/source/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1567153835175},{"_id":"themes/next/source/dist/linkcard.js","hash":"5b286a5ec7f6b4d8585418b8b7b6c45493335267","modified":1567664252169},{"_id":"themes/next/source/dist/music.js","hash":"928a33538ae2936c5ce3798c5c9fafc7b11e3592","modified":1567158209470},{"_id":"themes/next/source/images/.DS_Store","hash":"a2044e7c7c5720f5a6adafa7f05968ea7db66a50","modified":1567138682747},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1564651115420},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1564651115420},{"_id":"themes/next/source/images/alipay.png","hash":"841f805799e8bf0a327a7433c63a6f2883c3d7f5","modified":1567148236199},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1564651115420},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1564651115420},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1564651115421},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1564651115427},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1564651115427},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1564651115427},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1564651115427},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1564651115427},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1564651115428},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1564651115428},{"_id":"themes/next/source/images/favicon.ico","hash":"6bfec58ad0950e0d792bc453010291a922ed19dc","modified":1564651115428},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564651115428},{"_id":"themes/next/source/images/linkcard.png","hash":"2be2b2cba11bc738336a86dba759020671e640e6","modified":1567664084903},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1564651115428},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1564651115428},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1564651115428},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1564651115428},{"_id":"themes/next/source/images/scroll.png","hash":"443930af0ee54778babad7724291bfed9b431dd5","modified":1567484575903},{"_id":"themes/next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1564651115428},{"_id":"themes/next/source/images/wechatpay.png","hash":"67383d953fdb28e3673c2c07b660fbe675a4cb0b","modified":1567146895889},{"_id":"themes/next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1564651115429},{"_id":"themes/next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1564651115429},{"_id":"themes/next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1564651115441},{"_id":"themes/next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1564651115442},{"_id":"themes/next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1564651115442},{"_id":"themes/next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1564651115442},{"_id":"themes/next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1564651115442},{"_id":"themes/next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1564651115442},{"_id":"themes/next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1564651115443},{"_id":"themes/next/source/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1564651115443},{"_id":"source/uploads/avatar.jpeg","hash":"08305dc6c226dd9a07870b78dbc1b214a6dad67e","modified":1567138901643},{"_id":"source/uploads/maopao3.png","hash":"a44532d41c1bad865be270de981a8e2f4c497f11","modified":1566527004264},{"_id":"source/uploads/tree4.gif","hash":"732a9ed7b35e02d56a3346e45375d74669b1df51","modified":1564651114779},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115416},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115416},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115417},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115419},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1564651115420},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1564651114976},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"9257da95bd032bb3bd1da670e302fd2c7d5610b6","modified":1564651114976},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1564651114989},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1564651114990},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"773b120aa7947b28be6bfba2511b73eb33591892","modified":1567135263307},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1564651114990},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1564651114990},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1564651114990},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1564651114990},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1564651114999},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1564651115011},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1564651115018},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1564651115069},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1564651115077},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1564651115077},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"d9fe715fee716f78c7976c4e8838da71439ee0e0","modified":1564651115077},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1564651115077},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1564651115078},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1564651115078},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1564651115098},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"b736871e483108dbf1a06a144e2262ce756b98fb","modified":1567662300181},{"_id":"themes/next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1564651115098},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1564651115110},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1564651115118},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1564651115118},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1564651115118},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1564651115118},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1564651115123},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1564651115124},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1564651115124},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"c4803b9f9e4f1493cd1e9c853367b35e231739f2","modified":1567069130038},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1564651115124},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"3d01fa6edc0ad73f81813613f2e8a610777f1852","modified":1564651115124},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1564651115125},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"9fa1ca7059243197d8fbbd35108c36629a254570","modified":1564651115125},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1564651115125},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1564651115167},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"a09d2af2a8470555eeb265b0eb14dc678079e870","modified":1564651115167},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1564651115167},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1564651115167},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1564651115168},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1564651115168},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1a00b1b78c429721d6477c2d8f6f68f005285cc8","modified":1564651115168},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"074a995cd630f56fc4a3135173515c86f2cb34b6","modified":1564651115169},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1564651115222},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"53a59cba82cad49f15a90e1a18007aaac525bddd","modified":1564651115222},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"40bab84a4a7a368fa31f0f8ce49af6ec3e5983c9","modified":1564651115223},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"15a4d60d3ecc59db2f23629477f8e7b8324981ed","modified":1564651115223},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1564651115223},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1564651115223},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1564651115224},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1564651115262},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1564651115262},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1564651115262},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"f58efab2afedd7fc27cd7dd115d47d4e39d0efe7","modified":1567663791060},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1564651115416},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1564651115417},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1564651115416},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1564651115419},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1564651115419},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1564651115420},{"_id":"themes/next/source/dist/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1567661819733},{"_id":"themes/next/source/dist/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1567661819733},{"_id":"themes/next/source/dist/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1567661819733},{"_id":"themes/next/source/dist/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1567661819734},{"_id":"themes/next/source/dist/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1567661819734},{"_id":"themes/next/source/dist/js/jquery.share.min.js","hash":"ff614988a0a4d6b68eb3f0fc95f8f65be745a5b8","modified":1567661819734},{"_id":"themes/next/source/dist/js/social-share.min.js","hash":"efdfa6b695ac6f0dd04cd8153d3e3a1a1edd90c2","modified":1567661819735},{"_id":"themes/next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1564651115442},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1564651115442},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1564651115443},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1564651115443},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1564651115443},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1564651115443},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1564651115443},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1564651115455},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1564651115456},{"_id":"source/uploads/tree3.gif","hash":"3469361ccf75209c8a013d2015004cdb65108c74","modified":1564651114776},{"_id":"themes/next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1564651115420},{"_id":"themes/next/source/dist/APlayer.min.js","hash":"2426b8f854758172890287c03957afa0ec5fc018","modified":1567157150370},{"_id":"themes/next/source/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1567153835176},{"_id":"themes/next/source/lib/jquery/index.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1564651115454},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1564651115456},{"_id":"source/uploads/guibing2.png","hash":"4f98f6d55075c07599015fcac8bdc077ddbc1c88","modified":1567563244375},{"_id":"source/uploads/maopao1.png","hash":"7917d9950334ea0528e45b3838fd4a44c718950a","modified":1566526201842},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1564651115285},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1564651115285},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1564651115285},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1564651115285},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"9d71f34fa13a41b8c8cd2fbdf3fdea608385277c","modified":1564651115286},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1564651115336},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1564651115337},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1564651115415},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1564651115415},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1564651115415},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"9a190ef2f49bdbf69604b48ad1dc7197895ee9b6","modified":1564651115416},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1564651115416},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1564651115416},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1564651115416},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1564651115417},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"239f78140aae393f05757fa785fdab187cf0b838","modified":1564651115419},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1564651115419},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1564651115419},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1564651115419},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1564651115419},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1564651115419},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1564651115444},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1564651115452},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1564651115452},{"_id":"themes/next/source/static/api/css/imgshare.css","hash":"c3624a2dde649ed28b2e5d1f050fd971fbaf71a0","modified":1567152476856},{"_id":"themes/next/source/static/api/css/like.css","hash":"2024d58206df01b858c38f07957f928b44e14cb3","modified":1567152476856},{"_id":"themes/next/source/static/api/css/select_share.css","hash":"d0259abdb410193cf761e42bffaa51e70327a0cd","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_popup.css","hash":"338ba2b30ef8ce0c84cd36b37d7f8482996291dc","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_style0_16.css","hash":"090e77e9e6e9b8ee0d73a233cbe46499de935bdd","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_style0_24.css","hash":"7d1f9f32b80f91001f4f951aa045180cde22d82e","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_style0_32.css","hash":"7c2d12ea532c8a55c102b649bb23ef5bf53b3ed3","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_style1_16.css","hash":"aeb4e9fa96cfa0167481e1f4007079dc3f3c6c27","modified":1567152476856},{"_id":"themes/next/source/static/api/css/share_style1_24.css","hash":"3ee5f745c863b4f68299fe5dc125f913ca619c07","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style1_32.css","hash":"626d67a4c0bb72a152e90d25dbf281c0c35a2140","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style2.css","hash":"1ad451187cde8a74843fd398b924ca0ac911e9be","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style2_16.css","hash":"572c8e856988e463eb865f38d33ba003cc20d083","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style2_24.css","hash":"917d963d3be111064cbb1d122963da91ee3724a0","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style2_32.css","hash":"3657bbc4b5bbc66ebca4906ee0a1cbf9f98be883","modified":1567152476857},{"_id":"themes/next/source/static/api/css/share_style4.css","hash":"0a9e2ed712a5ef5c4699c038cd001a0d688a0fdf","modified":1567152476857},{"_id":"themes/next/source/static/api/css/slide_share.css","hash":"3898feaf45559b039f885bee8f9e831f48adb20c","modified":1567152476857},{"_id":"themes/next/source/static/api/css/weixin_popup.css","hash":"5e6c5084bfd16051de5776c2e136a5462b08a32c","modified":1567152476857},{"_id":"source/uploads/guibing3.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1567563759112},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1564651115454},{"_id":"themes/next/source/static/api/js/trans/data.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567152476867},{"_id":"themes/next/source/static/api/js/trans/logger.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567152476867},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1564651115286},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1564651115286},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"6c4990d375b640ee4551e62c48c1cbe4c3d62212","modified":1567067873729},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1564651115286},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"352796ec0a0cbbdb45d2351711d136ae6112b757","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1564651115287},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1564651115288},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"df3c19fd447da6d4a807683345007a41338f9a04","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1564651115289},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"67165cd8836e03c289162b96ef06f8b024afe9af","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1564651115290},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1564651115291},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"2f11354d462e3391f8d4837ffbeef0c763957804","modified":1567154935864},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a3170630d8e085889a4bdc20eb7f09c5a0479c47","modified":1564651115336},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1564651115377},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1564651115377},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1564651115377},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1564651115377},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1564651115413},{"_id":"themes/next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1564651115413},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"6e4400d6704dee076434726b7a03ac464eb7bcb4","modified":1564651115413},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1564651115414},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1564651115337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1564651115337},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"ac99213aef58c39ff899cf1ddfba80a5a4a9f24b","modified":1567130087640},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1564651115358},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1564651115358},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1564651115358},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1564651115358},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1564651115376},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1564651115376},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1564651115376},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1564651115414},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1564651115414},{"_id":"themes/next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1564651115414},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1564651115414},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1564651115415},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1564651115415},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1564651115415},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"dd44d8ca93ad5d366a96d797a0a8b4f3b46f9a77","modified":1564651115415},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1564651115418},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1564651115419},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1564651115453},{"_id":"themes/next/source/static/api/img/share/icons_0_16.png","hash":"0eec1e81a04664b2032bd389513349e9bd5d5b0f","modified":1567152476858},{"_id":"themes/next/source/static/api/img/share/icons_0_24.png","hash":"a89223f9714c8c4fa169430a327963ca6a1c9a6e","modified":1567152476858},{"_id":"themes/next/source/static/api/img/share/icons_0_32.png","hash":"c20521634fdacef39631031671528713e6ba6081","modified":1567152476858},{"_id":"themes/next/source/static/api/img/share/icons_1_16.png","hash":"3793c3265429ab7b830bfaf18322259cd0b4c4ef","modified":1567152476858},{"_id":"themes/next/source/static/api/img/share/icons_1_24.png","hash":"9f1d472095dbe138ef7aff069b1d18cae6ffa942","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/icons_1_32.png","hash":"09825de5f238c97e4374d545961d6e0d5bbfb3e2","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/icons_2_16.png","hash":"07340442cb61aabb419dd226f4bfb206a7577f52","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/icons_2_24.png","hash":"e47fb87c533f2be89f22901f0864d9b5ef83412d","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/icons_2_32.png","hash":"deba62865245a6b5aafa446787d72165c703b943","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/l0.gif","hash":"738b92632b0a9789a9eb568b8d101eb64f55f6e0","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/l1.gif","hash":"70e1932ca7a622ed3322b683eceb7a590860a55e","modified":1567152476859},{"_id":"themes/next/source/static/api/img/share/l2.gif","hash":"e6a5d6104c226a686d48759e0268e09d762e242e","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l3.gif","hash":"26c0dd37d98df63abb9d3d83e01bb47c34ee3f0f","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l4.gif","hash":"8a9c3cf99766d3f07a9c480cfdffdc3197b9a6b9","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l5.gif","hash":"148706f56b8ef4fd9d8483d0ac3a6730e72fc0ad","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l6.gif","hash":"f4b8e3188f744f13aca46b27b451d55d9e209c48","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l7.gif","hash":"e4f7e5e56c8f4eb026b5cb0affe3bd69c31af261","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/l8.gif","hash":"ec7dbc7703961356e05528d2844b983f225445e4","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/pop_c.gif","hash":"e8b9ece6ddaa47ccb2c15f2396d1cd3020740603","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/r0.gif","hash":"882f255fbafc0136a3917c1dd40db88879c1b1c1","modified":1567152476860},{"_id":"themes/next/source/static/api/img/share/r1.gif","hash":"96064d132ee2477c0e444c2e18162f9d1dc9e9c2","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r2.gif","hash":"67c84a67be3b039892e9cb8c7c29ed29813bf60f","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r3.gif","hash":"ecdd21f1457be54afc96e2d005524eef93d7bf85","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r4.gif","hash":"517435e69a2215a0f003e75a4861154ca963c30e","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r5.gif","hash":"e61b32d1830390303927bdab21823959f8dc7023","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r6.gif","hash":"4bc01e08ef0015fddf5b8c7257c094ec584ca3ee","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r7.gif","hash":"3c596c924910c93cf3e37cc1b2870dbf271151e2","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/r8.gif","hash":"c068ece54a72a3f2428d4f1b5ca7c176f027dd4e","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/sc.png","hash":"e5a2ca56973a3d6608e7e3a48ebd9fa5ebda9991","modified":1567152476861},{"_id":"themes/next/source/static/api/img/share/selectshare_close.png","hash":"6f3666278268890a153c85fb9f04ac848c442561","modified":1567152476862},{"_id":"themes/next/source/static/api/img/share/share-search-icon.png","hash":"0629677a7eb5aa3e8bab3faa310c6d8c467a3287","modified":1567152476862},{"_id":"themes/next/source/static/api/js/base/class.js","hash":"db02960fb51f69a0d50dc9ed626a998be3884706","modified":1567152476862},{"_id":"themes/next/source/static/api/js/component/animate.js","hash":"17a3495543db66e4eb56a81a93edf3e41ca8cc31","modified":1567152476863},{"_id":"themes/next/source/static/api/js/component/anticheat.js","hash":"ee6b11a7ed39ae67c1c2aeeef96b4a0f40f8083c","modified":1567152476863},{"_id":"themes/next/source/static/api/js/component/comm_tools.js","hash":"28d096a61f54e64bdbc32d172ae20e7f6e9656a7","modified":1567152476863},{"_id":"themes/next/source/static/api/js/component/partners.js","hash":"a4c275ffb4d3557280211e6bf0573485b397ffd8","modified":1567152476863},{"_id":"themes/next/source/static/api/js/component/pop_base.js","hash":"eae6e120c149a21caa2883c533ccc40bc07fda51","modified":1567152476863},{"_id":"themes/next/source/static/api/js/component/pop_dialog.js","hash":"4417d2fa9ad8ff6c79a2352ef07e9d10a1313ee0","modified":1567152476864},{"_id":"themes/next/source/static/api/js/component/pop_popup.js","hash":"aface5a8c3f71e9e024bf0df5b361ed8f5452f50","modified":1567152476864},{"_id":"themes/next/source/static/api/js/component/pop_popup_slide.js","hash":"45a72013fba95249ca965fd4d98f3bbde7a7098a","modified":1567152476864},{"_id":"themes/next/source/static/api/js/component/qrcode.js","hash":"2e3cc4cc5545556dd97ab899ff32d3ab7ccee808","modified":1567152476864},{"_id":"themes/next/source/static/api/js/conf/const.js","hash":"7da7df37d0f3d3e1977a8d107c98a3c1ecdb39c2","modified":1567152476864},{"_id":"themes/next/source/static/api/js/conf/define.js","hash":"ee0afad836be1553980501855752ccd79fe1fe0e","modified":1567152476865},{"_id":"themes/next/source/static/api/js/share/api_base.js","hash":"cbacd664451f80955c2ff4caccd4b9110062c714","modified":1567152476865},{"_id":"themes/next/source/static/api/js/share/combine_api.js","hash":"7ad3c5396bf20704e87f98ebe118034ed3cc7b22","modified":1567152476865},{"_id":"themes/next/source/static/api/js/share/image_api.js","hash":"43a93415f2a5dd34760042c2bcd9f4692feecb5d","modified":1567152476865},{"_id":"themes/next/source/static/api/js/share/like_api.js","hash":"4034b10f8f34367c6db47ae092e5b4107c2fb8b4","modified":1567152476866},{"_id":"themes/next/source/static/api/js/share/likeshare.js","hash":"2d14ab97cc3dc294c51c0d6814f4ea45f4b4e312","modified":1567152476866},{"_id":"themes/next/source/static/api/js/share/select_api.js","hash":"bf259a7912ee6124d741dbb5e45cab40bfa45e90","modified":1567152476866},{"_id":"themes/next/source/static/api/js/share/share_api.js","hash":"f7b86d0cc063f692a73a174d04e77cbe3c5facc7","modified":1567152476866},{"_id":"themes/next/source/static/api/js/share/slide_api.js","hash":"c317e3f7fec13d89178e475f26a689bb94e5aa76","modified":1567152476866},{"_id":"themes/next/source/static/api/js/share.js","hash":"73bdb33580128e6c79a726a25f98092c0faa369d","modified":1567405886540},{"_id":"themes/next/source/static/api/js/start/router.js","hash":"27bc546a9c796b15e59442aaf09ae645a2ed4c74","modified":1567152476866},{"_id":"themes/next/source/static/api/js/trans/trans.js","hash":"cb82afecdbede8d5a00b6c5ea9595187b6408376","modified":1567152476867},{"_id":"themes/next/source/static/api/js/trans/trans_bdxc.js","hash":"a512ebfca0319ab38d06b7b0fb74bcdc942dc46e","modified":1567152476867},{"_id":"themes/next/source/static/api/js/trans/trans_bdysc.js","hash":"28bb985a03b6b1da5a89a143331932a12126c9c3","modified":1567152476867},{"_id":"themes/next/source/static/api/js/trans/trans_weixin.js","hash":"e68e9bc91ee6fbcd64ac788463870f01602a8562","modified":1567152476867},{"_id":"themes/next/source/static/api/js/view/image_view.js","hash":"bb66297a5bd2c7dd931b9145f5d4a616876f3373","modified":1567152476868},{"_id":"themes/next/source/static/api/js/view/like_view.js","hash":"c1b6a3f3f89ac734c6da284c1ba1dde2ada4e250","modified":1567152476868},{"_id":"themes/next/source/static/api/js/view/select_view.js","hash":"2611efec1d31d85609feea0c57e14d3f817a6220","modified":1567152476868},{"_id":"themes/next/source/static/api/js/view/share_view.js","hash":"f445ce9cbbcf887da5e248b1cfadc03ab7df76d0","modified":1567152476868},{"_id":"themes/next/source/static/api/js/view/view_base.js","hash":"b3fd7dafde05d63af3dfe9e0a59f9367f81402c5","modified":1567152476868},{"_id":"themes/next/source/static/api/js/view/slide_view.js","hash":"973ded5cd15eb119e79ffd9326af3a44167b26bd","modified":1567152476868},{"_id":"source/uploads/maopao2.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1566526362488},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1564651115453},{"_id":"themes/next/source/static/api/js/base/tangram.js","hash":"e1952e27f6dc3d6339128cec157acef8cc0a775f","modified":1567152476863},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1564651115455},{"_id":"source/uploads/guibing1.png","hash":"9ab881528daa1f0e9c0de65d5ec316c3727e5f50","modified":1567563198277}],"Category":[{"name":"软件调试","_id":"ck07ketda00040vfa5f704cr0"},{"name":"LettCode","_id":"ck07ketdj000b0vfaidgyyo3v"},{"name":"Spring Boot","_id":"ck07ketdx000l0vfauj4s25g2"},{"name":"常见问题","_id":"ck07kete0000t0vfaquydi5h4"},{"name":"java开发","_id":"ck07kete700140vfaorg4zcia"},{"name":"转载","_id":"ck07ketfu003l0vfaag182q77"},{"name":"Mysql","_id":"ck07ketge004a0vfas2qqk5dl"},{"name":"Spring Security","_id":"ck07keth0004k0vfaw3palo1u"},{"name":"算法","_id":"ck07keth4004t0vfatnjamq5y"},{"name":"Hexo","_id":"ck07keth500500vfasnfw70gw"}],"Data":[],"Page":[{"title":"关于","date":"2017-10-19T14:29:44.000Z","_content":"\n\n### 关于我\n\n一只敲代码的程序猿，欢迎分享知识。\n\n### 联系方式\nEmail: 158199521@qq.com","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-10-19 22:29:44\n---\n\n\n### 关于我\n\n一只敲代码的程序猿，欢迎分享知识。\n\n### 联系方式\nEmail: 158199521@qq.com","updated":"2019-08-01T09:18:34.690Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck07ketd400010vfas5ztbggz","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>一只敲代码的程序猿，欢迎分享知识。</p><h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p>Email: 158199521@qq.com</p><!-- rebuild by neat -->","site":{"data":{}},"length":47,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>一只敲代码的程序猿，欢迎分享知识。</p><h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p>Email: 158199521@qq.com</p><!-- rebuild by neat -->"},{"title":"archives","date":"2017-10-19T14:30:04.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2017-10-19 22:30:04\n---\n","updated":"2019-08-01T09:18:34.691Z","path":"archives/index.html","comments":1,"layout":"page","_id":"ck07ketd900030vfammcfiw18","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->","site":{"data":{}},"length":0,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->"},{"title":"分类","date":"2017-10-19T14:28:54.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-10-19 22:28:54\ntype: \"categories\"\n---\n","updated":"2019-08-01T09:18:34.691Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck07ketde00070vfaf55oapog","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->","site":{"data":{}},"length":0,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->"},{"title":"留言","date":"2017-10-19T14:29:44.000Z","_content":"\n> 欢迎大家留言","source":"comment/index.md","raw":"---\ntitle: 留言\ndate: 2017-10-19 22:29:44\n---\n\n> 欢迎大家留言","updated":"2019-08-29T09:06:04.218Z","path":"comment/index.html","comments":1,"layout":"page","_id":"ck07ketdh00090vfamyhnyln5","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>欢迎大家留言</p></blockquote><!-- rebuild by neat -->","site":{"data":{}},"length":6,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>欢迎大家留言</p></blockquote><!-- rebuild by neat -->"},{"title":"标签","date":"2017-10-19T14:26:28.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-10-19 22:26:28\ntype: \"tags\"\n---\n","updated":"2019-08-01T09:18:34.691Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck07ketdj000d0vfav8iw6tu5","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->","site":{"data":{}},"length":0,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><!-- rebuild by neat -->"}],"Post":[{"title":"MyBatisCodeHelper-Pro插件破解版[2.7.1]","abbrlink":"40e63741","date":"2019-07-02T08:56:30.000Z","_content":"\n## **下载地址**\n\n[百度网盘下载](https://pan.baidu.com/s/1CmmRCjBrWa1geP1Pje8z5Q)\n\n提取码：sf6d\n\n","source":"_posts/IDEA-Plugin-Mybatis-Generator-PRO.md","raw":"---\ntitle: 'MyBatisCodeHelper-Pro插件破解版[2.7.1]'\ntags:\n  - 软件调试\n  - IDEA\n  - 插件\ncategories: 软件调试\nabbrlink: '40e63741'\ndate: 2019-07-02 16:56:30\n---\n\n## **下载地址**\n\n[百度网盘下载](https://pan.baidu.com/s/1CmmRCjBrWa1geP1Pje8z5Q)\n\n提取码：sf6d\n\n","slug":"IDEA-Plugin-Mybatis-Generator-PRO","published":1,"updated":"2019-09-03T03:40:46.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketd000000vfavknk96ro","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a><strong>下载地址</strong></h2><p><a href=\"https://pan.baidu.com/s/1CmmRCjBrWa1geP1Pje8z5Q\" target=\"_blank\" rel=\"noopener\">百度网盘下载</a></p><p>提取码：sf6d</p><!-- rebuild by neat -->","site":{"data":{}},"length":18,"excerpt":"","more":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"下载地址\"><a href=\"#下载地址\" class=\"headerlink\" title=\"下载地址\"></a><strong>下载地址</strong></h2><p><a href=\"https://pan.baidu.com/s/1CmmRCjBrWa1geP1Pje8z5Q\" target=\"_blank\" rel=\"noopener\">百度网盘下载</a></p><p>提取码：sf6d</p><!-- rebuild by neat -->"},{"title":"LeetCode - 两数之合","author":"Carlos","abbrlink":"7bc80c4f","date":"2019-09-02T02:06:00.000Z","_content":"## 题目描述\n\n给出一个整数数组，请在数组中找出两个加起来等于目标值的数，\n你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的\n假设给出的数组中只存在唯一解\n例如：\n给出的数组为 {2, 7, 11, 15},目标值为9\n输出 ndex1=1, index2=2\n\n\n## 解题思路\n\n使用HashMap 保存 键为target-每个数的结果 值为下标，每次放入的时候看是否包含 当前值，\n有的话说明当前值和已包含的值下标的那个元素为需要的结果\n\n<!-- more -->\n\n``` java\nimport java.util.Map;\nimport java.util.HashMap;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0; i<nums.length; i++) {\n            if(map.containsKey(nums[i])) {\n                result[0] = map.get(nums[i]);\n                result[1] = i;\n                break;\n            } else {\n                map.put(target - nums[i],i);\n            }\n        }\n        return result;\n    }\n}\n\n```","source":"_posts/LeetCode-两数之合.md","raw":"---\ntitle: LeetCode - 两数之合\nauthor: Carlos\ntags:\n  - LettCode\n  - 哈希\ncategories:\n  - LettCode\nabbrlink: 7bc80c4f\ndate: 2019-09-02 10:06:00\n---\n## 题目描述\n\n给出一个整数数组，请在数组中找出两个加起来等于目标值的数，\n你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的\n假设给出的数组中只存在唯一解\n例如：\n给出的数组为 {2, 7, 11, 15},目标值为9\n输出 ndex1=1, index2=2\n\n\n## 解题思路\n\n使用HashMap 保存 键为target-每个数的结果 值为下标，每次放入的时候看是否包含 当前值，\n有的话说明当前值和已包含的值下标的那个元素为需要的结果\n\n<!-- more -->\n\n``` java\nimport java.util.Map;\nimport java.util.HashMap;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i=0; i<nums.length; i++) {\n            if(map.containsKey(nums[i])) {\n                result[0] = map.get(nums[i]);\n                result[1] = i;\n                break;\n            } else {\n                map.put(target - nums[i],i);\n            }\n        }\n        return result;\n    }\n}\n\n```","slug":"LeetCode-两数之合","published":1,"updated":"2019-09-03T03:40:46.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketd500020vfaonvct7w2","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给出一个整数数组，请在数组中找出两个加起来等于目标值的数，<br>你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的<br>假设给出的数组中只存在唯一解<br>例如：<br>给出的数组为 {2, 7, 11, 15},目标值为9<br>输出 ndex1=1, index2=2</p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>使用HashMap 保存 键为target-每个数的结果 值为下标，每次放入的时候看是否包含 当前值，<br>有的话说明当前值和已包含的值下标的那个元素为需要的结果</p><a id=\"more\"></a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = map.get(nums[i]);</span><br><span class=\"line\">                result[<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(target - nums[i],i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"length":838,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给出一个整数数组，请在数组中找出两个加起来等于目标值的数，<br>你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的<br>假设给出的数组中只存在唯一解<br>例如：<br>给出的数组为 {2, 7, 11, 15},目标值为9<br>输出 ndex1=1, index2=2</p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>使用HashMap 保存 键为target-每个数的结果 值为下标，每次放入的时候看是否包含 当前值，<br>有的话说明当前值和已包含的值下标的那个元素为需要的结果</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        Map&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = map.get(nums[i]);</span><br><span class=\"line\">                result[<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(target - nums[i],i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"LeetCode-无重复字符的最长子串","author":"Carlos","mathjax":true,"abbrlink":"f7eda5e6","date":"2019-09-03T01:43:00.000Z","_content":"> 转载: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/\n\n## 题目描述\n\n 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n \n 示例 1:\n ```java\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n ```\n \n 示例 2:\n ```java\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n ```\n<!-- more -->\n\n示例 3：\n```java\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n## 解题思路\n\n### 方法一：暴力法\n\n#### 思路\n 逐个检查所有的子字符串，看它是否不含有重复的字符。\n \n#### 算法\n假设我们有一个函数 <code>boolean allUnique(String substring)</code> ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 <code>s </code>的所有可能的子字符串并调用函数<code> allUnique</code>。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。\n\n现在让我们填补缺少的部分：\n\n为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 ii 和 jj。那么我们有 0 < i < j < n（这里的结束索引 jj 是按惯例排除的）。因此，使用 i 从 0 到 n - 1 以及 j从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。\n\n要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j <= n; j++)\n                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);\n        return ans;\n    }\n\n    public boolean allUnique(String s, int start, int end) {\n        Set<Character> set = new HashSet<>();\n        for (int i = start; i < end; i++) {\n            Character ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n\n```\n#### 复杂度分析\n+ 时间复杂度：$O(n{}^3)$\n  要验证索引范围在 [i,j) 内的字符是否都是唯一，我们需要检查该范围中的所有字符。因此，它将花费 **O(j-i)** 的时间。对于给定的 i，对于所有 j∈[i+1,n] 所耗费的时间总和为:$$\\sum_{i=1}^NO(j-i)$$。因此，执行所有步骤耗去的时间总和为：\n  $$O\\left(\\sum_{i=0}^{n-1} \\left(\\sum_{j=i+1}^n(j-i)\\right)\\right)=O\\left(\\sum_{i=0} ^{n-1}\\frac{(1+n-i)(n-i)}{2}\\right)=O(n{}^3)$$\n+ 空间复杂度：$O(min(n, m))$，我们需要 $O(k)$ 的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。\n\n### 方法二 滑动窗口\n\n#### 算法\n暴力法非常简单，但它太慢了。那么我们该如何优化它呢？\n\n在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 $i$ 到 $j - 1$之间的子字符串 $s_{ij}$\t\n已经被检查为没有重复字符。我们只需要检查 $s[j]$ 对应的字符是否已经存在于子字符串 $s_{ij}$中。\n\n要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 $O(n^2)$的算法，但我们可以做得更好。\n\n通过使用 HashSet 作为滑动窗口，我们可以用 $O(1)$ 的时间来完成对字符是否在当前的子字符串中的检查。\n\n滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 $[i,j)$（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 $[i,j)$ 向右滑动 1 个元素，则它将变为 $[i+1, j+1)$（左闭，右开）。\n\n回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 $[i,j)$（最初 $j = i$）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 $s[j]$ 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        Set<Character> set = new HashSet<>();\n        int ans = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charAt(j))){\n                set.add(s.charAt(j++));\n                ans = Math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n#### 复杂度分析\n+ 时间复杂度：$O(2n) = O(n)$，在最糟糕的情况下，每个字符将被 $i$ 和 $j$ 访问两次。\n+ 空间复杂度：$O(min(m, n))$，与之前的方法相同。滑动窗口法需要 $O(k)$ 的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小。\n\n### 方法三：优化的滑动窗口\n上述的方法最多需要执行 $2n$ 个步骤。事实上，它可以被进一步优化为仅需要 $n$ 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。\n\n也就是说，如果 $s[j]$ 在 $[i, j)$ 范围内有与 $j′$重复的字符，我们不需要逐渐增加 $i$ 。 我们可以直接跳过 $[i，j']$范围内的所有元素，并将 $i$ 变为 $j′ + 1$。\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        Map<Character, Integer> map = new HashMap<>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            if (map.containsKey(s.charAt(j))) {\n                i = Math.max(map.get(s.charAt(j)), i);\n            }\n            ans = Math.max(ans, j - i + 1);\n            map.put(s.charAt(j), j + 1);\n        }\n        return ans;\n    }\n}\n\n```\n\nJava（假设字符集为 ASCII 128）\n\n以前的我们都没有对字符串 s 所使用的字符集进行假设。\n\n当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。\n\n常用的表如下所示：\n\n  int<code> [26] </code> 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’\n  int<code> [128] </code>用于ASCII码\n  int<code>[256] </code> 用于扩展ASCII码\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n\n```\n\n#### 复杂度分析\n+ 时间复杂度：$O(n)$，索引 $j$ 将会迭代 $n$ 次。\n+ 空间复杂度（HashMap）：$O(min(m, n))$，与之前的方法相同。\n+ 空间复杂度（Table）：$O(m)$，$m$ 是字符集的大小。","source":"_posts/LeetCode-无重复字符的最长子串.md","raw":"title: LeetCode-无重复字符的最长子串\nauthor: Carlos\ntags:\n  - LettCode\n  - 动态规划\ncategories:\n  - LettCode\nmathjax: true\nabbrlink: f7eda5e6\ndate: 2019-09-03 09:43:00\n---\n> 转载: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/\n\n## 题目描述\n\n 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n \n 示例 1:\n ```java\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n ```\n \n 示例 2:\n ```java\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n ```\n<!-- more -->\n\n示例 3：\n```java\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n## 解题思路\n\n### 方法一：暴力法\n\n#### 思路\n 逐个检查所有的子字符串，看它是否不含有重复的字符。\n \n#### 算法\n假设我们有一个函数 <code>boolean allUnique(String substring)</code> ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 <code>s </code>的所有可能的子字符串并调用函数<code> allUnique</code>。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。\n\n现在让我们填补缺少的部分：\n\n为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 ii 和 jj。那么我们有 0 < i < j < n（这里的结束索引 jj 是按惯例排除的）。因此，使用 i 从 0 到 n - 1 以及 j从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。\n\n要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j <= n; j++)\n                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);\n        return ans;\n    }\n\n    public boolean allUnique(String s, int start, int end) {\n        Set<Character> set = new HashSet<>();\n        for (int i = start; i < end; i++) {\n            Character ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n\n```\n#### 复杂度分析\n+ 时间复杂度：$O(n{}^3)$\n  要验证索引范围在 [i,j) 内的字符是否都是唯一，我们需要检查该范围中的所有字符。因此，它将花费 **O(j-i)** 的时间。对于给定的 i，对于所有 j∈[i+1,n] 所耗费的时间总和为:$$\\sum_{i=1}^NO(j-i)$$。因此，执行所有步骤耗去的时间总和为：\n  $$O\\left(\\sum_{i=0}^{n-1} \\left(\\sum_{j=i+1}^n(j-i)\\right)\\right)=O\\left(\\sum_{i=0} ^{n-1}\\frac{(1+n-i)(n-i)}{2}\\right)=O(n{}^3)$$\n+ 空间复杂度：$O(min(n, m))$，我们需要 $O(k)$ 的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。\n\n### 方法二 滑动窗口\n\n#### 算法\n暴力法非常简单，但它太慢了。那么我们该如何优化它呢？\n\n在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 $i$ 到 $j - 1$之间的子字符串 $s_{ij}$\t\n已经被检查为没有重复字符。我们只需要检查 $s[j]$ 对应的字符是否已经存在于子字符串 $s_{ij}$中。\n\n要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 $O(n^2)$的算法，但我们可以做得更好。\n\n通过使用 HashSet 作为滑动窗口，我们可以用 $O(1)$ 的时间来完成对字符是否在当前的子字符串中的检查。\n\n滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 $[i,j)$（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 $[i,j)$ 向右滑动 1 个元素，则它将变为 $[i+1, j+1)$（左闭，右开）。\n\n回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 $[i,j)$（最初 $j = i$）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 $s[j]$ 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        Set<Character> set = new HashSet<>();\n        int ans = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charAt(j))){\n                set.add(s.charAt(j++));\n                ans = Math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n#### 复杂度分析\n+ 时间复杂度：$O(2n) = O(n)$，在最糟糕的情况下，每个字符将被 $i$ 和 $j$ 访问两次。\n+ 空间复杂度：$O(min(m, n))$，与之前的方法相同。滑动窗口法需要 $O(k)$ 的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小。\n\n### 方法三：优化的滑动窗口\n上述的方法最多需要执行 $2n$ 个步骤。事实上，它可以被进一步优化为仅需要 $n$ 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。\n\n也就是说，如果 $s[j]$ 在 $[i, j)$ 范围内有与 $j′$重复的字符，我们不需要逐渐增加 $i$ 。 我们可以直接跳过 $[i，j']$范围内的所有元素，并将 $i$ 变为 $j′ + 1$。\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        Map<Character, Integer> map = new HashMap<>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            if (map.containsKey(s.charAt(j))) {\n                i = Math.max(map.get(s.charAt(j)), i);\n            }\n            ans = Math.max(ans, j - i + 1);\n            map.put(s.charAt(j), j + 1);\n        }\n        return ans;\n    }\n}\n\n```\n\nJava（假设字符集为 ASCII 128）\n\n以前的我们都没有对字符串 s 所使用的字符集进行假设。\n\n当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。\n\n常用的表如下所示：\n\n  int<code> [26] </code> 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’\n  int<code> [128] </code>用于ASCII码\n  int<code>[256] </code> 用于扩展ASCII码\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n\n```\n\n#### 复杂度分析\n+ 时间复杂度：$O(n)$，索引 $j$ 将会迭代 $n$ 次。\n+ 空间复杂度（HashMap）：$O(min(m, n))$，与之前的方法相同。\n+ 空间复杂度（Table）：$O(m)$，$m$ 是字符集的大小。","slug":"LeetCode-无重复字符的最长子串","published":1,"updated":"2019-09-04T02:29:42.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdd00060vfa3u2apjsl","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载: <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/</a></p></blockquote><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"abcabcbb\"</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"abc\"</span>，所以其长度为 <span class=\"number\">3</span>。</span><br></pre></td></tr></table></figure><p></p><p>示例 2:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"bbbbb\"</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"b\"</span>，所以其长度为 <span class=\"number\">1</span>。</span><br></pre></td></tr></table></figure><p></p><a id=\"more\"></a><p>示例 3：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"pwwkew\"</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"wke\"</span>，所以其长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，<span class=\"string\">\"pwke\"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p></p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"方法一：暴力法\"><a href=\"#方法一：暴力法\" class=\"headerlink\" title=\"方法一：暴力法\"></a>方法一：暴力法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>逐个检查所有的子字符串，看它是否不含有重复的字符。</p><h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>假设我们有一个函数 <code>boolean allUnique(String substring)</code> ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 <code>s</code>的所有可能的子字符串并调用函数<code>allUnique</code>。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。</p><p>现在让我们填补缺少的部分：</p><p>为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 ii 和 jj。那么我们有 0 &lt; i &lt; j &lt; n（这里的结束索引 jj 是按惯例排除的）。因此，使用 i 从 0 到 n - 1 以及 j从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。</p><p>要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allUnique</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            Character ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set.contains(ch)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            set.add(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n{}^3)$<br>要验证索引范围在 [i,j) 内的字符是否都是唯一，我们需要检查该范围中的所有字符。因此，它将花费 <strong>O(j-i)</strong> 的时间。对于给定的 i，对于所有 j∈[i+1,n] 所耗费的时间总和为:<script type=\"math/tex\">\\sum_{i=1}^NO(j-i)</script>。因此，执行所有步骤耗去的时间总和为：<script type=\"math/tex;mode=display\">O\\left(\\sum_{i=0}^{n-1} \\left(\\sum_{j=i+1}^n(j-i)\\right)\\right)=O\\left(\\sum_{i=0} ^{n-1}\\frac{(1+n-i)(n-i)}{2}\\right)=O(n{}^3)</script></li><li>空间复杂度：$O(min(n, m))$，我们需要 $O(k)$ 的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</li></ul><h3 id=\"方法二-滑动窗口\"><a href=\"#方法二-滑动窗口\" class=\"headerlink\" title=\"方法二 滑动窗口\"></a>方法二 滑动窗口</h3><h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>暴力法非常简单，但它太慢了。那么我们该如何优化它呢？</p><p>在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 $i$ 到 $j - 1$之间的子字符串 $s_{ij}$<br>已经被检查为没有重复字符。我们只需要检查 $s[j]$ 对应的字符是否已经存在于子字符串 $s_{ij}$中。</p><p>要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 $O(n^2)$的算法，但我们可以做得更好。</p><p>通过使用 HashSet 作为滑动窗口，我们可以用 $O(1)$ 的时间来完成对字符是否在当前的子字符串中的检查。</p><p>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 $[i,j)$（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 $[i,j)$ 向右滑动 1 个元素，则它将变为 $[i+1, j+1)$（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 $[i,j)$（最初 $j = i$）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 $s[j]$ 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class=\"line\">                set.add(s.charAt(j++));</span><br><span class=\"line\">                ans = Math.max(ans, j - i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set.remove(s.charAt(i++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(2n) = O(n)$，在最糟糕的情况下，每个字符将被 $i$ 和 $j$ 访问两次。</li><li>空间复杂度：$O(min(m, n))$，与之前的方法相同。滑动窗口法需要 $O(k)$ 的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小。</li></ul><h3 id=\"方法三：优化的滑动窗口\"><a href=\"#方法三：优化的滑动窗口\" class=\"headerlink\" title=\"方法三：优化的滑动窗口\"></a>方法三：优化的滑动窗口</h3><p>上述的方法最多需要执行 $2n$ 个步骤。事实上，它可以被进一步优化为仅需要 $n$ 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><p>也就是说，如果 $s[j]$ 在 $[i, j)$ 范围内有与 $j′$重复的字符，我们不需要逐渐增加 $i$ 。 我们可以直接跳过 $[i，j’]$范围内的所有元素，并将 $i$ 变为 $j′ + 1$。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// current index of character</span></span><br><span class=\"line\">        <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class=\"line\">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = Math.max(ans, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            map.put(s.charAt(j), j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>Java（假设字符集为 ASCII 128）</p><p>以前的我们都没有对字符串 s 所使用的字符集进行假设。</p><p>当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。</p><p>常用的表如下所示：</p><p>int<code>[26]</code> 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’<br>int<code>[128]</code>用于ASCII码<br>int<code>[256]</code> 用于扩展ASCII码</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] index = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>]; <span class=\"comment\">// current index of character</span></span><br><span class=\"line\">        <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            i = Math.max(index[s.charAt(j)], i);</span><br><span class=\"line\">            ans = Math.max(ans, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            index[s.charAt(j)] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n)$，索引 $j$ 将会迭代 $n$ 次。</li><li>空间复杂度（HashMap）：$O(min(m, n))$，与之前的方法相同。</li><li>空间复杂度（Table）：$O(m)$，$m$ 是字符集的大小。</li></ul><!-- rebuild by neat -->","site":{"data":{}},"length":4886,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载: <a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/</a></p></blockquote><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"abcabcbb\"</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span> </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"abc\"</span>，所以其长度为 <span class=\"number\">3</span>。</span><br></pre></td></tr></table></figure><p></p><p>示例 2:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"bbbbb\"</span></span><br><span class=\"line\">输出: <span class=\"number\">1</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"b\"</span>，所以其长度为 <span class=\"number\">1</span>。</span><br></pre></td></tr></table></figure><p></p>","more":"<p>示例 3：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: <span class=\"string\">\"pwwkew\"</span></span><br><span class=\"line\">输出: <span class=\"number\">3</span></span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 <span class=\"string\">\"wke\"</span>，所以其长度为 <span class=\"number\">3</span>。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，<span class=\"string\">\"pwke\"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p></p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"方法一：暴力法\"><a href=\"#方法一：暴力法\" class=\"headerlink\" title=\"方法一：暴力法\"></a>方法一：暴力法</h3><h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>逐个检查所有的子字符串，看它是否不含有重复的字符。</p><h4 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>假设我们有一个函数 <code>boolean allUnique(String substring)</code> ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 <code>s</code>的所有可能的子字符串并调用函数<code>allUnique</code>。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。</p><p>现在让我们填补缺少的部分：</p><p>为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 ii 和 jj。那么我们有 0 &lt; i &lt; j &lt; n（这里的结束索引 jj 是按惯例排除的）。因此，使用 i 从 0 到 n - 1 以及 j从 i+1 到 n 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。</p><p>要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">allUnique</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            Character ch = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set.contains(ch)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            set.add(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n{}^3)$<br>要验证索引范围在 [i,j) 内的字符是否都是唯一，我们需要检查该范围中的所有字符。因此，它将花费 <strong>O(j-i)</strong> 的时间。对于给定的 i，对于所有 j∈[i+1,n] 所耗费的时间总和为:<script type=\"math/tex\">\\sum_{i=1}^NO(j-i)</script>。因此，执行所有步骤耗去的时间总和为：<script type=\"math/tex;mode=display\">O\\left(\\sum_{i=0}^{n-1} \\left(\\sum_{j=i+1}^n(j-i)\\right)\\right)=O\\left(\\sum_{i=0} ^{n-1}\\frac{(1+n-i)(n-i)}{2}\\right)=O(n{}^3)</script></li><li>空间复杂度：$O(min(n, m))$，我们需要 $O(k)$ 的空间来检查子字符串中是否有重复字符，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集/字母 m 的大小。</li></ul><h3 id=\"方法二-滑动窗口\"><a href=\"#方法二-滑动窗口\" class=\"headerlink\" title=\"方法二 滑动窗口\"></a>方法二 滑动窗口</h3><h4 id=\"算法-1\"><a href=\"#算法-1\" class=\"headerlink\" title=\"算法\"></a>算法</h4><p>暴力法非常简单，但它太慢了。那么我们该如何优化它呢？</p><p>在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 $i$ 到 $j - 1$之间的子字符串 $s_{ij}$<br>已经被检查为没有重复字符。我们只需要检查 $s[j]$ 对应的字符是否已经存在于子字符串 $s_{ij}$中。</p><p>要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 $O(n^2)$的算法，但我们可以做得更好。</p><p>通过使用 HashSet 作为滑动窗口，我们可以用 $O(1)$ 的时间来完成对字符是否在当前的子字符串中的检查。</p><p>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 $[i,j)$（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 $[i,j)$ 向右滑动 1 个元素，则它将变为 $[i+1, j+1)$（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 $[i,j)$（最初 $j = i$）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 $s[j]$ 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        Set&lt;Character&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class=\"line\">                set.add(s.charAt(j++));</span><br><span class=\"line\">                ans = Math.max(ans, j - i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set.remove(s.charAt(i++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"复杂度分析-1\"><a href=\"#复杂度分析-1\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(2n) = O(n)$，在最糟糕的情况下，每个字符将被 $i$ 和 $j$ 访问两次。</li><li>空间复杂度：$O(min(m, n))$，与之前的方法相同。滑动窗口法需要 $O(k)$ 的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n 的大小以及字符集 / 字母 m 的大小。</li></ul><h3 id=\"方法三：优化的滑动窗口\"><a href=\"#方法三：优化的滑动窗口\" class=\"headerlink\" title=\"方法三：优化的滑动窗口\"></a>方法三：优化的滑动窗口</h3><p>上述的方法最多需要执行 $2n$ 个步骤。事实上，它可以被进一步优化为仅需要 $n$ 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><p>也就是说，如果 $s[j]$ 在 $[i, j)$ 范围内有与 $j′$重复的字符，我们不需要逐渐增加 $i$ 。 我们可以直接跳过 $[i，j’]$范围内的所有元素，并将 $i$ 变为 $j′ + 1$。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(); <span class=\"comment\">// current index of character</span></span><br><span class=\"line\">        <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class=\"line\">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = Math.max(ans, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            map.put(s.charAt(j), j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>Java（假设字符集为 ASCII 128）</p><p>以前的我们都没有对字符串 s 所使用的字符集进行假设。</p><p>当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。</p><p>常用的表如下所示：</p><p>int<code>[26]</code> 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’<br>int<code>[128]</code>用于ASCII码<br>int<code>[256]</code> 用于扩展ASCII码</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] index = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">128</span>]; <span class=\"comment\">// current index of character</span></span><br><span class=\"line\">        <span class=\"comment\">// try to extend the range [i, j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">            i = Math.max(index[s.charAt(j)], i);</span><br><span class=\"line\">            ans = Math.max(ans, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            index[s.charAt(j)] = j + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"复杂度分析-2\"><a href=\"#复杂度分析-2\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h4><ul><li>时间复杂度：$O(n)$，索引 $j$ 将会迭代 $n$ 次。</li><li>空间复杂度（HashMap）：$O(min(m, n))$，与之前的方法相同。</li><li>空间复杂度（Table）：$O(m)$，$m$ 是字符集的大小。</li></ul><!-- rebuild by neat -->"},{"title":"LettCode-厄拉多塞筛法求质数","author":"Carlos","abbrlink":"d432b74b","date":"2019-09-05T05:10:00.000Z","_content":"<a href=\"https://leetcode-cn.com/problems/count-primes/\" class=\"LinkCard\">LeetCode(204)- 计数质数</a>\n## 题目描述\n\n统计所有小于非负整数 n 的质数的数量。\n\n\n## 解题思路\n如求10之内的质数，首先列出2~N-1的所有数，如果当前数为质数，则其倍数就是质数，如\n+ 第一个质数为2，在2上画圈，其倍数4/6/8不是质数，划掉4/6/8，继续遍历\n+ 下一个质数为3，在3上画圈，其倍数6/9不是质数，划掉6/9，继续遍历\n+ 下一个质数为5，在5上画圈，没有倍数，继续遍历\n+ 下一个质数为7，在7上画圈，没有倍数，继续遍历。\n<!-- more -->\n最后再次遍历整个数组，画圈的数字就是质数，即2,3,5,7\n转换为代码就是如果需要求<n的所有质数个数，则创建一个长度为n的整数数组，所有元素值变为1，1表示对应的索引值为质数，0表示对应的索引值为非质数。从2开始遍历，如果当前数字值为1，则获取其所有倍数，将元素值变为0（标记为非质数）。遍历完成后再次遍历数组，从2开始，记录元素为1的个数，即为对应的质数个数。\n\n## 代码实现\n\n```java\nclass Solution {\n    public int countPrimes(int n) {\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = 1;\n        }\n\n        for (int i = 2; i < n; i++) {\n        \t//如果当前数为质数\n            if (nums[i] == 1) {\n            \t//将对应数的倍数变为0\n                for (int j = 2; i * j < n; j++) {\n                    nums[i * j] = 0;\n                }\n            }\n        }\n\n        int res = 0;\n        //遍历数组，统计值为1的元素个数\n        for (int i = 2; i < n; i++) {\n            if (nums[i] == 1) {\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```","source":"_posts/LettCode-求质数.md","raw":"title: LettCode-厄拉多塞筛法求质数\nauthor: Carlos\nabbrlink: d432b74b\ntags:\n  - LettCode\ncategories: []\ndate: 2019-09-05 13:10:00\n---\n<a href=\"https://leetcode-cn.com/problems/count-primes/\" class=\"LinkCard\">LeetCode(204)- 计数质数</a>\n## 题目描述\n\n统计所有小于非负整数 n 的质数的数量。\n\n\n## 解题思路\n如求10之内的质数，首先列出2~N-1的所有数，如果当前数为质数，则其倍数就是质数，如\n+ 第一个质数为2，在2上画圈，其倍数4/6/8不是质数，划掉4/6/8，继续遍历\n+ 下一个质数为3，在3上画圈，其倍数6/9不是质数，划掉6/9，继续遍历\n+ 下一个质数为5，在5上画圈，没有倍数，继续遍历\n+ 下一个质数为7，在7上画圈，没有倍数，继续遍历。\n<!-- more -->\n最后再次遍历整个数组，画圈的数字就是质数，即2,3,5,7\n转换为代码就是如果需要求<n的所有质数个数，则创建一个长度为n的整数数组，所有元素值变为1，1表示对应的索引值为质数，0表示对应的索引值为非质数。从2开始遍历，如果当前数字值为1，则获取其所有倍数，将元素值变为0（标记为非质数）。遍历完成后再次遍历数组，从2开始，记录元素为1的个数，即为对应的质数个数。\n\n## 代码实现\n\n```java\nclass Solution {\n    public int countPrimes(int n) {\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = 1;\n        }\n\n        for (int i = 2; i < n; i++) {\n        \t//如果当前数为质数\n            if (nums[i] == 1) {\n            \t//将对应数的倍数变为0\n                for (int j = 2; i * j < n; j++) {\n                    nums[i * j] = 0;\n                }\n            }\n        }\n\n        int res = 0;\n        //遍历数组，统计值为1的元素个数\n        for (int i = 2; i < n; i++) {\n            if (nums[i] == 1) {\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n```","slug":"LettCode-求质数","published":1,"updated":"2019-09-05T06:40:49.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdf00080vfaliaatc5j","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p><a href=\"https://leetcode-cn.com/problems/count-primes/\" class=\"LinkCard\" target=\"_blank\" rel=\"noopener\">LeetCode(204)- 计数质数</a></p><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如求10之内的质数，首先列出2~N-1的所有数，如果当前数为质数，则其倍数就是质数，如</p><ul><li>第一个质数为2，在2上画圈，其倍数4/6/8不是质数，划掉4/6/8，继续遍历</li><li>下一个质数为3，在3上画圈，其倍数6/9不是质数，划掉6/9，继续遍历</li><li>下一个质数为5，在5上画圈，没有倍数，继续遍历</li><li>下一个质数为7，在7上画圈，没有倍数，继续遍历。<a id=\"more\"></a> 最后再次遍历整个数组，画圈的数字就是质数，即2,3,5,7<br>转换为代码就是如果需要求&lt;n的所有质数个数，则创建一个长度为n的整数数组，所有元素值变为1，1表示对应的索引值为质数，0表示对应的索引值为非质数。从2开始遍历，如果当前数字值为1，则获取其所有倍数，将元素值变为0（标记为非质数）。遍历完成后再次遍历数组，从2开始，记录元素为1的个数，即为对应的质数个数。</li></ul><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countPrimes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            nums[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//如果当前数为质数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">//将对应数的倍数变为0</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>; i * j &lt; n; j++) &#123;</span><br><span class=\"line\">                    nums[i * j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//遍历数组，统计值为1的元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"length":1110,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p><a href=\"https://leetcode-cn.com/problems/count-primes/\" class=\"LinkCard\" target=\"_blank\" rel=\"noopener\">LeetCode(204)- 计数质数</a></p><h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如求10之内的质数，首先列出2~N-1的所有数，如果当前数为质数，则其倍数就是质数，如</p><ul><li>第一个质数为2，在2上画圈，其倍数4/6/8不是质数，划掉4/6/8，继续遍历</li><li>下一个质数为3，在3上画圈，其倍数6/9不是质数，划掉6/9，继续遍历</li><li>下一个质数为5，在5上画圈，没有倍数，继续遍历</li><li>下一个质数为7，在7上画圈，没有倍数，继续遍历。","more":"最后再次遍历整个数组，画圈的数字就是质数，即2,3,5,7<br>转换为代码就是如果需要求&lt;n的所有质数个数，则创建一个长度为n的整数数组，所有元素值变为1，1表示对应的索引值为质数，0表示对应的索引值为非质数。从2开始遍历，如果当前数字值为1，则获取其所有倍数，将元素值变为0（标记为非质数）。遍历完成后再次遍历数组，从2开始，记录元素为1的个数，即为对应的质数个数。</li></ul><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countPrimes</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            nums[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">//如果当前数为质数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            \t<span class=\"comment\">//将对应数的倍数变为0</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>; i * j &lt; n; j++) &#123;</span><br><span class=\"line\">                    nums[i * j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//遍历数组，统计值为1的元素个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"Spring Boot读写分离配置","author":"Carlos","abbrlink":"85578cb1","date":"2019-08-20T09:29:00.000Z","_content":"数据源配置\n\n```java\n## 数据库连接池\nspring:\n  dynamic:\n    master:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      jdbc-url: jdbc:mysql://192.168.1.117:3306/boot\n      username: root\n      password: 123456\n    slave:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      jdbc-url: jdbc:mysql://192.168.1.118:3306/boot\n      username: root\n      password: 123456\n\n```\n\n项目结构：\n\n![项目结构](/uploads/zhucong1.png)\n\n首先创建 DataSourceContants 数据源枚举类：\n<!-- more -->\n\n```java\n@Getter\n@AllArgsConstructor\npublic enum DataSourceContants {\n\n    /**\n     * 主库\n     */\n    MASTER(\"master\", \"主库\"),\n\n    /**\n     * 从库\n     */\n    SLAVE(\"slave\", \"从库\");\n\n    public String value;\n\n    public String description;\n\n}\n\n```\n\n创建存储当前数据源的类DynamicDataSourceContextHolder，和用于切换数据源的DynamicDataSource\n```java\n/**\n *  根据当前线程来选择具体的数据源\n * @author carlos\n */\n@UtilityClass\npublic class DynamicDataSourceContextHolder {\n\n    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();\n\n    public static void add(String dataSourceName) {\n        CONTEXT_HOLDER.set(dataSourceName);\n    }\n\n    public static String get() {\n        return CONTEXT_HOLDER.get();\n    }\n\n    public static void clear(){\n        CONTEXT_HOLDER.remove();\n    }\n\n}\n```\n\n```java\n@Slf4j\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        String dataSourceName = DynamicDataSourceContextHolder.get();\n        logger.info(\"当前数据源是：\" + dataSourceName);\n        return DynamicDataSourceContextHolder.get();\n    }\n}\n\n```\n配置多数据源：\n```java\n@Slf4j\n@Configuration\n@AllArgsConstructor\n@AutoConfigureBefore(DataSourceAutoConfiguration.class)\npublic class DynamicDataSourceAutoConfiguration{\n    private final Map<Object, Object> dataSourceMap = new HashMap<>(8);\n\n    /**\n     * 主库\n     * @return\n     */\n    @Bean\n    @ConfigurationProperties(\"spring.dynamic.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 从库\n     * @return\n     */\n    @Bean\n    @ConfigurationProperties(\"spring.dynamic.slave\")\n    public DataSource slaveDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源\n     * @return\n     */\n    @Bean\n    @Primary\n    public DataSource dynamicDataSource() {\n        dataSourceMap.put(DataSourceContants.MASTER.getValue(), masterDataSource());\n        dataSourceMap.put(DataSourceContants.SLAVE.getValue(), slaveDataSource());\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());\n        dynamicDataSource.setTargetDataSources(dataSourceMap);\n\n        return dynamicDataSource;\n    }\n\n}\n\n```\n\n\n我们这里基于mybatis的插件来实现数据源切换条件判断。\n实现自定义mybatis插件MasterSlaveAutoRoutingPlugin。\n```java\n@Intercepts({\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class,\n                RowBounds.class, ResultHandler.class}),\n        @Signature(type = Executor.class, method = \"update\", args = {MappedStatement.class, Object.class})\n})\n@Slf4j\npublic class MasterSlaveAutoRoutingPlugin implements Interceptor {\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        Object[] args = invocation.getArgs();\n        MappedStatement ms = (MappedStatement) args[0];\n        try {\n            DynamicDataSourceContextHolder.add(ms.getSqlCommandType().equals(SqlCommandType.SELECT) \n            ? DataSourceContants.SLAVE.getValue()\n            : DataSourceContants.MASTER.getValue());\n            return invocation.proceed();\n        } finally {\n            DynamicDataSourceContextHolder.clear();\n        }\n    }\n\n    @Override\n    public Object plugin(Object target) {\n        return target instanceof Executor ? Plugin.wrap(target, this) : target;\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n\n    }\n}\n```\n注册MasterSlaveAutoRoutingPlugin插件\n```java\n /**\n     * 数据源切换Mybatis插件\n     * @return\n     */\n    @Bean\n    public MasterSlaveAutoRoutingPlugin masterSlaveAutoRoutingPlugin(){\n        return new MasterSlaveAutoRoutingPlugin();\n    }\n}\n```","source":"_posts/Spring-Boot配置动态数据源.md","raw":"---\ntitle: Spring Boot读写分离配置\nauthor: Carlos\ntags:\n  - Spring Boot\ncategories:\n  - Spring Boot\nabbrlink: 85578cb1\ndate: 2019-08-20 17:29:00\n---\n数据源配置\n\n```java\n## 数据库连接池\nspring:\n  dynamic:\n    master:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      jdbc-url: jdbc:mysql://192.168.1.117:3306/boot\n      username: root\n      password: 123456\n    slave:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      jdbc-url: jdbc:mysql://192.168.1.118:3306/boot\n      username: root\n      password: 123456\n\n```\n\n项目结构：\n\n![项目结构](/uploads/zhucong1.png)\n\n首先创建 DataSourceContants 数据源枚举类：\n<!-- more -->\n\n```java\n@Getter\n@AllArgsConstructor\npublic enum DataSourceContants {\n\n    /**\n     * 主库\n     */\n    MASTER(\"master\", \"主库\"),\n\n    /**\n     * 从库\n     */\n    SLAVE(\"slave\", \"从库\");\n\n    public String value;\n\n    public String description;\n\n}\n\n```\n\n创建存储当前数据源的类DynamicDataSourceContextHolder，和用于切换数据源的DynamicDataSource\n```java\n/**\n *  根据当前线程来选择具体的数据源\n * @author carlos\n */\n@UtilityClass\npublic class DynamicDataSourceContextHolder {\n\n    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();\n\n    public static void add(String dataSourceName) {\n        CONTEXT_HOLDER.set(dataSourceName);\n    }\n\n    public static String get() {\n        return CONTEXT_HOLDER.get();\n    }\n\n    public static void clear(){\n        CONTEXT_HOLDER.remove();\n    }\n\n}\n```\n\n```java\n@Slf4j\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        String dataSourceName = DynamicDataSourceContextHolder.get();\n        logger.info(\"当前数据源是：\" + dataSourceName);\n        return DynamicDataSourceContextHolder.get();\n    }\n}\n\n```\n配置多数据源：\n```java\n@Slf4j\n@Configuration\n@AllArgsConstructor\n@AutoConfigureBefore(DataSourceAutoConfiguration.class)\npublic class DynamicDataSourceAutoConfiguration{\n    private final Map<Object, Object> dataSourceMap = new HashMap<>(8);\n\n    /**\n     * 主库\n     * @return\n     */\n    @Bean\n    @ConfigurationProperties(\"spring.dynamic.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 从库\n     * @return\n     */\n    @Bean\n    @ConfigurationProperties(\"spring.dynamic.slave\")\n    public DataSource slaveDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源\n     * @return\n     */\n    @Bean\n    @Primary\n    public DataSource dynamicDataSource() {\n        dataSourceMap.put(DataSourceContants.MASTER.getValue(), masterDataSource());\n        dataSourceMap.put(DataSourceContants.SLAVE.getValue(), slaveDataSource());\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());\n        dynamicDataSource.setTargetDataSources(dataSourceMap);\n\n        return dynamicDataSource;\n    }\n\n}\n\n```\n\n\n我们这里基于mybatis的插件来实现数据源切换条件判断。\n实现自定义mybatis插件MasterSlaveAutoRoutingPlugin。\n```java\n@Intercepts({\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class,\n                RowBounds.class, ResultHandler.class}),\n        @Signature(type = Executor.class, method = \"update\", args = {MappedStatement.class, Object.class})\n})\n@Slf4j\npublic class MasterSlaveAutoRoutingPlugin implements Interceptor {\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        Object[] args = invocation.getArgs();\n        MappedStatement ms = (MappedStatement) args[0];\n        try {\n            DynamicDataSourceContextHolder.add(ms.getSqlCommandType().equals(SqlCommandType.SELECT) \n            ? DataSourceContants.SLAVE.getValue()\n            : DataSourceContants.MASTER.getValue());\n            return invocation.proceed();\n        } finally {\n            DynamicDataSourceContextHolder.clear();\n        }\n    }\n\n    @Override\n    public Object plugin(Object target) {\n        return target instanceof Executor ? Plugin.wrap(target, this) : target;\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n\n    }\n}\n```\n注册MasterSlaveAutoRoutingPlugin插件\n```java\n /**\n     * 数据源切换Mybatis插件\n     * @return\n     */\n    @Bean\n    public MasterSlaveAutoRoutingPlugin masterSlaveAutoRoutingPlugin(){\n        return new MasterSlaveAutoRoutingPlugin();\n    }\n}\n```","slug":"Spring-Boot配置动态数据源","published":1,"updated":"2019-09-03T03:40:46.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdh000a0vfapq5nbcuw","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>数据源配置</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数据库连接池</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  dynamic:</span><br><span class=\"line\">    master:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      jdbc-url: jdbc:mysql:<span class=\"comment\">//192.168.1.117:3306/boot</span></span><br><span class=\"line\">      username: root</span><br><span class=\"line\">      password: <span class=\"number\">123456</span></span><br><span class=\"line\">    slave:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      jdbc-url: jdbc:mysql:<span class=\"comment\">//192.168.1.118:3306/boot</span></span><br><span class=\"line\">      username: root</span><br><span class=\"line\">      password: <span class=\"number\">123456</span></span><br></pre></td></tr></table></figure><p>项目结构：</p><p><img src=\"/uploads/zhucong1.png\" alt=\"项目结构\"></p><p>首先创建 DataSourceContants 数据源枚举类：<br><a id=\"more\"></a></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> DataSourceContants &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 主库</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MASTER(<span class=\"string\">\"master\"</span>, <span class=\"string\">\"主库\"</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从库</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SLAVE(<span class=\"string\">\"slave\"</span>, <span class=\"string\">\"从库\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String description;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>创建存储当前数据源的类DynamicDataSourceContextHolder，和用于切换数据源的DynamicDataSource<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据当前线程来选择具体的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> carlos</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UtilityClass</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(String dataSourceName)</span> </span>&#123;</span><br><span class=\"line\">        CONTEXT_HOLDER.set(dataSourceName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CONTEXT_HOLDER.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        CONTEXT_HOLDER.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSource</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String dataSourceName = DynamicDataSourceContextHolder.get();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"当前数据源是：\"</span> + dataSourceName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicDataSourceContextHolder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>配置多数据源：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureBefore</span>(DataSourceAutoConfiguration.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceAutoConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Object, Object&gt; dataSourceMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 主库</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties</span>(<span class=\"string\">\"spring.dynamic.master\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">masterDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从库</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties</span>(<span class=\"string\">\"spring.dynamic.slave\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">slaveDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 动态数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dynamicDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        dataSourceMap.put(DataSourceContants.MASTER.getValue(), masterDataSource());</span><br><span class=\"line\">        dataSourceMap.put(DataSourceContants.SLAVE.getValue(), slaveDataSource());</span><br><span class=\"line\">        DynamicDataSource dynamicDataSource = <span class=\"keyword\">new</span> DynamicDataSource();</span><br><span class=\"line\">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());</span><br><span class=\"line\">        dynamicDataSource.setTargetDataSources(dataSourceMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dynamicDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们这里基于mybatis的插件来实现数据源切换条件判断。<br>实现自定义mybatis插件MasterSlaveAutoRoutingPlugin。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Intercepts</span>(&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Signature</span>(type = Executor.class, method = <span class=\"string\">\"query\"</span>, args = &#123;MappedStatement.class, Object.class,</span><br><span class=\"line\">                RowBounds.class, ResultHandler.class&#125;),</span><br><span class=\"line\">        <span class=\"meta\">@Signature</span>(type = Executor.class, method = <span class=\"string\">\"update\"</span>, args = &#123;MappedStatement.class, Object.class&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MasterSlaveAutoRoutingPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object[] args = invocation.getArgs();</span><br><span class=\"line\">        MappedStatement ms = (MappedStatement) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DynamicDataSourceContextHolder.add(ms.getSqlCommandType().equals(SqlCommandType.SELECT) </span><br><span class=\"line\">            ? DataSourceContants.SLAVE.getValue()</span><br><span class=\"line\">            : DataSourceContants.MASTER.getValue());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            DynamicDataSourceContextHolder.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">plugin</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target <span class=\"keyword\">instanceof</span> Executor ? Plugin.wrap(target, <span class=\"keyword\">this</span>) : target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProperties</span><span class=\"params\">(Properties properties)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注册MasterSlaveAutoRoutingPlugin插件<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数据源切换Mybatis插件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MasterSlaveAutoRoutingPlugin <span class=\"title\">masterSlaveAutoRoutingPlugin</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MasterSlaveAutoRoutingPlugin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":4411,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>数据源配置</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数据库连接池</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  dynamic:</span><br><span class=\"line\">    master:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      jdbc-url: jdbc:mysql:<span class=\"comment\">//192.168.1.117:3306/boot</span></span><br><span class=\"line\">      username: root</span><br><span class=\"line\">      password: <span class=\"number\">123456</span></span><br><span class=\"line\">    slave:</span><br><span class=\"line\">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">      jdbc-url: jdbc:mysql:<span class=\"comment\">//192.168.1.118:3306/boot</span></span><br><span class=\"line\">      username: root</span><br><span class=\"line\">      password: <span class=\"number\">123456</span></span><br></pre></td></tr></table></figure><p>项目结构：</p><p><img src=\"/uploads/zhucong1.png\" alt=\"项目结构\"></p><p>首先创建 DataSourceContants 数据源枚举类：<br>","more":"</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> DataSourceContants &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 主库</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    MASTER(<span class=\"string\">\"master\"</span>, <span class=\"string\">\"主库\"</span>),</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从库</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    SLAVE(<span class=\"string\">\"slave\"</span>, <span class=\"string\">\"从库\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String description;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>创建存储当前数据源的类DynamicDataSourceContextHolder，和用于切换数据源的DynamicDataSource<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据当前线程来选择具体的数据源</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> carlos</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@UtilityClass</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceContextHolder</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(String dataSourceName)</span> </span>&#123;</span><br><span class=\"line\">        CONTEXT_HOLDER.set(dataSourceName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> CONTEXT_HOLDER.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        CONTEXT_HOLDER.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSource</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String dataSourceName = DynamicDataSourceContextHolder.get();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"当前数据源是：\"</span> + dataSourceName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DynamicDataSourceContextHolder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>配置多数据源：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureBefore</span>(DataSourceAutoConfiguration.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSourceAutoConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Object, Object&gt; dataSourceMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 主库</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties</span>(<span class=\"string\">\"spring.dynamic.master\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">masterDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从库</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties</span>(<span class=\"string\">\"spring.dynamic.slave\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">slaveDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DataSourceBuilder.create().type(HikariDataSource.class).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 动态数据源</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">dynamicDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        dataSourceMap.put(DataSourceContants.MASTER.getValue(), masterDataSource());</span><br><span class=\"line\">        dataSourceMap.put(DataSourceContants.SLAVE.getValue(), slaveDataSource());</span><br><span class=\"line\">        DynamicDataSource dynamicDataSource = <span class=\"keyword\">new</span> DynamicDataSource();</span><br><span class=\"line\">        dynamicDataSource.setDefaultTargetDataSource(masterDataSource());</span><br><span class=\"line\">        dynamicDataSource.setTargetDataSources(dataSourceMap);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dynamicDataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们这里基于mybatis的插件来实现数据源切换条件判断。<br>实现自定义mybatis插件MasterSlaveAutoRoutingPlugin。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Intercepts</span>(&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Signature</span>(type = Executor.class, method = <span class=\"string\">\"query\"</span>, args = &#123;MappedStatement.class, Object.class,</span><br><span class=\"line\">                RowBounds.class, ResultHandler.class&#125;),</span><br><span class=\"line\">        <span class=\"meta\">@Signature</span>(type = Executor.class, method = <span class=\"string\">\"update\"</span>, args = &#123;MappedStatement.class, Object.class&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MasterSlaveAutoRoutingPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Interceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object[] args = invocation.getArgs();</span><br><span class=\"line\">        MappedStatement ms = (MappedStatement) args[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            DynamicDataSourceContextHolder.add(ms.getSqlCommandType().equals(SqlCommandType.SELECT) </span><br><span class=\"line\">            ? DataSourceContants.SLAVE.getValue()</span><br><span class=\"line\">            : DataSourceContants.MASTER.getValue());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            DynamicDataSourceContextHolder.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">plugin</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target <span class=\"keyword\">instanceof</span> Executor ? Plugin.wrap(target, <span class=\"keyword\">this</span>) : target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProperties</span><span class=\"params\">(Properties properties)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注册MasterSlaveAutoRoutingPlugin插件<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数据源切换Mybatis插件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MasterSlaveAutoRoutingPlugin <span class=\"title\">masterSlaveAutoRoutingPlugin</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MasterSlaveAutoRoutingPlugin();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"Intellij IDEA运行报Command line is too long错误","abbrlink":"7107112b","date":"2019-06-29T08:23:53.000Z","_content":"\nIDEA 运行springBoot Application 出现 command line is too long错误\n\n解决办法：\n修改项目中的 .idea\\workspace.xml:\n\n```java\n  <component name=\"PropertiesComponent\">\n    <property name=\"dynamic.classpath\" value=\"true\" />\n  </component>\n\n```\n\n<!-- more -->","source":"_posts/bug-idea-commands-too-long.md","raw":"---\ntitle: Intellij IDEA运行报Command line is too long错误\ncategories: 常见问题\nabbrlink: 7107112b\ndate: 2019-06-29 16:23:53\ntags:\n---\n\nIDEA 运行springBoot Application 出现 command line is too long错误\n\n解决办法：\n修改项目中的 .idea\\workspace.xml:\n\n```java\n  <component name=\"PropertiesComponent\">\n    <property name=\"dynamic.classpath\" value=\"true\" />\n  </component>\n\n```\n\n<!-- more -->","slug":"bug-idea-commands-too-long","published":1,"updated":"2019-09-03T03:40:46.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdl000e0vfae57us6n9","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>IDEA 运行springBoot Application 出现 command line is too long错误</p><p>解决办法：<br>修改项目中的 .idea\\workspace.xml:</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component name=<span class=\"string\">\"PropertiesComponent\"</span>&gt;</span><br><span class=\"line\">  &lt;property name=<span class=\"string\">\"dynamic.classpath\"</span> value=<span class=\"string\">\"true\"</span> /&gt;</span><br><span class=\"line\">&lt;/component&gt;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><!-- rebuild by neat -->","site":{"data":{}},"length":214,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>IDEA 运行springBoot Application 出现 command line is too long错误</p><p>解决办法：<br>修改项目中的 .idea\\workspace.xml:</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component name=<span class=\"string\">\"PropertiesComponent\"</span>&gt;</span><br><span class=\"line\">  &lt;property name=<span class=\"string\">\"dynamic.classpath\"</span> value=<span class=\"string\">\"true\"</span> /&gt;</span><br><span class=\"line\">&lt;/component&gt;</span><br></pre></td></tr></table></figure>","more":"<!-- rebuild by neat -->"},{"title":"Spring Boot 整合 Druid数据源","abbrlink":"ce2b196c","date":"2019-08-16T05:28:46.000Z","_content":"\n\n首先引入maven配置：\n\n``` java\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.1.18</version>\n    </dependency>\n\n```\n\n\n更改配置bootstrap.yml:\n<!-- more -->\n\n``` java\nspring:\n    datasource:\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        url: jdbc:mysql://boot-mysql:3306/boot?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=false&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2B8&allowMultiQueries=true\n        username: root\n        password: 123456\n        type: com.alibaba.druid.pool.DruidDataSource\n        druid:\n        #初始化大小\n        initial-size: 8\n        #连接池最小值\n        min-idle: 8\n        #连接池最大值\n        max-active: 12\n        #配置获取连接等待超时的时间(单位：毫秒)\n        max-wait: 60000\n        #配置间隔多久才进行一次检测，检测需要关闭的空闲连接(单位：毫秒)\n        time-between-eviction-runs-millis: 2000\n        #配置一个连接在池中（含空闲）最小生存的时间(单位：毫秒)\n        min-evictable-idle-time-millis: 60000\n        #配置一个连接在池中空闲最大生存的时间(单位：毫秒)\n        max-evictable-idle-time-millis: 90000\n        #检测连接是否有效的测试语句\n        validation-query: select 1\n        #申请连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低\n        test-on-borrow: false\n        #申请连接的时候，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效\n        test-while-idle: true\n        #归还连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低\n        test-on-return: false\n        #打开后，增强timeBetweenEvictionRunsMillis的周期性连接检查，minIdle内的空闲连接，每次检查强制验证连接有效性.\n        keep-alive: true\n        #是否缓存preparedStatement（也就是PSCache），PSCache对支持游标的数据库性能提升巨大，如：oracle，在mysql下建议关闭。\n        pool-prepared-statements: false\n        #检查连接泄露依据（超时时间）\n        remove-abandoned-timeout-millis: 300000\n        #abanded连接时输出错误日志，方便出现连接泄露时可以通过错误日志定位忘记关闭连接的位置\n        log-abandoned: true\n        filters: stat,wall\n        connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n        ######Druid监控配置######\n        web-stat-filter:\n            enabled: true\n            session-stat-enable: false\n            session-stat-max-count: 1000\n            principal-cookie-name: admin\n            principal-session-name: admin\n            profile-enable: true\n            # 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html\n            # http://loacalhsot:8081/druid\n        stat-view-servlet:\n            enabled: true\n            # 允许清空统计数据\n            reset-enable: true\n            login-username: admin\n            login-password: 123456\n            allow:\n            deny:\n\n```\n\n配置文件中已经配置了Monitor，所以我们可以直接访问Druid monitor\n\n\n","source":"_posts/druid-monitor.md","raw":"---\ntitle: Spring Boot 整合 Druid数据源\ntags: 数据库\nabbrlink: ce2b196c\ndate: 2019-08-16 13:28:46\n---\n\n\n首先引入maven配置：\n\n``` java\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.1.18</version>\n    </dependency>\n\n```\n\n\n更改配置bootstrap.yml:\n<!-- more -->\n\n``` java\nspring:\n    datasource:\n        driver-class-name: com.mysql.cj.jdbc.Driver\n        url: jdbc:mysql://boot-mysql:3306/boot?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=false&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=GMT%2B8&allowMultiQueries=true\n        username: root\n        password: 123456\n        type: com.alibaba.druid.pool.DruidDataSource\n        druid:\n        #初始化大小\n        initial-size: 8\n        #连接池最小值\n        min-idle: 8\n        #连接池最大值\n        max-active: 12\n        #配置获取连接等待超时的时间(单位：毫秒)\n        max-wait: 60000\n        #配置间隔多久才进行一次检测，检测需要关闭的空闲连接(单位：毫秒)\n        time-between-eviction-runs-millis: 2000\n        #配置一个连接在池中（含空闲）最小生存的时间(单位：毫秒)\n        min-evictable-idle-time-millis: 60000\n        #配置一个连接在池中空闲最大生存的时间(单位：毫秒)\n        max-evictable-idle-time-millis: 90000\n        #检测连接是否有效的测试语句\n        validation-query: select 1\n        #申请连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低\n        test-on-borrow: false\n        #申请连接的时候，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效\n        test-while-idle: true\n        #归还连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低\n        test-on-return: false\n        #打开后，增强timeBetweenEvictionRunsMillis的周期性连接检查，minIdle内的空闲连接，每次检查强制验证连接有效性.\n        keep-alive: true\n        #是否缓存preparedStatement（也就是PSCache），PSCache对支持游标的数据库性能提升巨大，如：oracle，在mysql下建议关闭。\n        pool-prepared-statements: false\n        #检查连接泄露依据（超时时间）\n        remove-abandoned-timeout-millis: 300000\n        #abanded连接时输出错误日志，方便出现连接泄露时可以通过错误日志定位忘记关闭连接的位置\n        log-abandoned: true\n        filters: stat,wall\n        connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n        ######Druid监控配置######\n        web-stat-filter:\n            enabled: true\n            session-stat-enable: false\n            session-stat-max-count: 1000\n            principal-cookie-name: admin\n            principal-session-name: admin\n            profile-enable: true\n            # 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html\n            # http://loacalhsot:8081/druid\n        stat-view-servlet:\n            enabled: true\n            # 允许清空统计数据\n            reset-enable: true\n            login-username: admin\n            login-password: 123456\n            allow:\n            deny:\n\n```\n\n配置文件中已经配置了Monitor，所以我们可以直接访问Druid monitor\n\n\n","slug":"druid-monitor","published":1,"updated":"2019-09-03T03:40:46.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdo000f0vfaload3se9","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>首先引入maven配置：</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.18&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>更改配置bootstrap.yml:<br><a id=\"more\"></a></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">    datasource:</span><br><span class=\"line\">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">        url: jdbc:mysql:<span class=\"comment\">//boot-mysql:3306/boot?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=true</span></span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: <span class=\"number\">123456</span></span><br><span class=\"line\">        type: com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">        druid:</span><br><span class=\"line\">        #初始化大小</span><br><span class=\"line\">        initial-size: <span class=\"number\">8</span></span><br><span class=\"line\">        #连接池最小值</span><br><span class=\"line\">        min-idle: <span class=\"number\">8</span></span><br><span class=\"line\">        #连接池最大值</span><br><span class=\"line\">        max-active: <span class=\"number\">12</span></span><br><span class=\"line\">        #配置获取连接等待超时的时间(单位：毫秒)</span><br><span class=\"line\">        max-wait: <span class=\"number\">60000</span></span><br><span class=\"line\">        #配置间隔多久才进行一次检测，检测需要关闭的空闲连接(单位：毫秒)</span><br><span class=\"line\">        time-between-eviction-runs-millis: <span class=\"number\">2000</span></span><br><span class=\"line\">        #配置一个连接在池中（含空闲）最小生存的时间(单位：毫秒)</span><br><span class=\"line\">        min-evictable-idle-time-millis: <span class=\"number\">60000</span></span><br><span class=\"line\">        #配置一个连接在池中空闲最大生存的时间(单位：毫秒)</span><br><span class=\"line\">        max-evictable-idle-time-millis: <span class=\"number\">90000</span></span><br><span class=\"line\">        #检测连接是否有效的测试语句</span><br><span class=\"line\">        validation-query: select <span class=\"number\">1</span></span><br><span class=\"line\">        #申请连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低</span><br><span class=\"line\">        test-on-borrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #申请连接的时候，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效</span><br><span class=\"line\">        test-<span class=\"keyword\">while</span>-idle: <span class=\"keyword\">true</span></span><br><span class=\"line\">        #归还连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低</span><br><span class=\"line\">        test-on-<span class=\"keyword\">return</span>: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #打开后，增强timeBetweenEvictionRunsMillis的周期性连接检查，minIdle内的空闲连接，每次检查强制验证连接有效性.</span><br><span class=\"line\">        keep-alive: <span class=\"keyword\">true</span></span><br><span class=\"line\">        #是否缓存preparedStatement（也就是PSCache），PSCache对支持游标的数据库性能提升巨大，如：oracle，在mysql下建议关闭。</span><br><span class=\"line\">        pool-prepared-statements: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #检查连接泄露依据（超时时间）</span><br><span class=\"line\">        remove-abandoned-timeout-millis: <span class=\"number\">300000</span></span><br><span class=\"line\">        #abanded连接时输出错误日志，方便出现连接泄露时可以通过错误日志定位忘记关闭连接的位置</span><br><span class=\"line\">        log-abandoned: <span class=\"keyword\">true</span></span><br><span class=\"line\">        filters: stat,wall</span><br><span class=\"line\">        connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">        ######Druid监控配置######</span><br><span class=\"line\">        web-stat-filter:</span><br><span class=\"line\">            enabled: <span class=\"keyword\">true</span></span><br><span class=\"line\">            session-stat-enable: <span class=\"keyword\">false</span></span><br><span class=\"line\">            session-stat-max-count: <span class=\"number\">1000</span></span><br><span class=\"line\">            principal-cookie-name: admin</span><br><span class=\"line\">            principal-session-name: admin</span><br><span class=\"line\">            profile-enable: <span class=\"keyword\">true</span></span><br><span class=\"line\">            # 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html</span><br><span class=\"line\">            # http://loacalhsot:8081/druid</span><br><span class=\"line\">        stat-view-servlet:</span><br><span class=\"line\">            enabled: <span class=\"keyword\">true</span></span><br><span class=\"line\">            # 允许清空统计数据</span><br><span class=\"line\">            reset-enable: <span class=\"keyword\">true</span></span><br><span class=\"line\">            login-username: admin</span><br><span class=\"line\">            login-password: <span class=\"number\">123456</span></span><br><span class=\"line\">            allow:</span><br><span class=\"line\">            deny:</span><br></pre></td></tr></table></figure><p>配置文件中已经配置了Monitor，所以我们可以直接访问Druid monitor</p><!-- rebuild by neat -->","site":{"data":{}},"length":2629,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>首先引入maven配置：</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.18&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>更改配置bootstrap.yml:<br>","more":"</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">    datasource:</span><br><span class=\"line\">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class=\"line\">        url: jdbc:mysql:<span class=\"comment\">//boot-mysql:3306/boot?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2B8&amp;allowMultiQueries=true</span></span><br><span class=\"line\">        username: root</span><br><span class=\"line\">        password: <span class=\"number\">123456</span></span><br><span class=\"line\">        type: com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\">        druid:</span><br><span class=\"line\">        #初始化大小</span><br><span class=\"line\">        initial-size: <span class=\"number\">8</span></span><br><span class=\"line\">        #连接池最小值</span><br><span class=\"line\">        min-idle: <span class=\"number\">8</span></span><br><span class=\"line\">        #连接池最大值</span><br><span class=\"line\">        max-active: <span class=\"number\">12</span></span><br><span class=\"line\">        #配置获取连接等待超时的时间(单位：毫秒)</span><br><span class=\"line\">        max-wait: <span class=\"number\">60000</span></span><br><span class=\"line\">        #配置间隔多久才进行一次检测，检测需要关闭的空闲连接(单位：毫秒)</span><br><span class=\"line\">        time-between-eviction-runs-millis: <span class=\"number\">2000</span></span><br><span class=\"line\">        #配置一个连接在池中（含空闲）最小生存的时间(单位：毫秒)</span><br><span class=\"line\">        min-evictable-idle-time-millis: <span class=\"number\">60000</span></span><br><span class=\"line\">        #配置一个连接在池中空闲最大生存的时间(单位：毫秒)</span><br><span class=\"line\">        max-evictable-idle-time-millis: <span class=\"number\">90000</span></span><br><span class=\"line\">        #检测连接是否有效的测试语句</span><br><span class=\"line\">        validation-query: select <span class=\"number\">1</span></span><br><span class=\"line\">        #申请连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低</span><br><span class=\"line\">        test-on-borrow: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #申请连接的时候，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效</span><br><span class=\"line\">        test-<span class=\"keyword\">while</span>-idle: <span class=\"keyword\">true</span></span><br><span class=\"line\">        #归还连接时执行validationQuery检测连接是否有效。此配置会造成一定性能降低</span><br><span class=\"line\">        test-on-<span class=\"keyword\">return</span>: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #打开后，增强timeBetweenEvictionRunsMillis的周期性连接检查，minIdle内的空闲连接，每次检查强制验证连接有效性.</span><br><span class=\"line\">        keep-alive: <span class=\"keyword\">true</span></span><br><span class=\"line\">        #是否缓存preparedStatement（也就是PSCache），PSCache对支持游标的数据库性能提升巨大，如：oracle，在mysql下建议关闭。</span><br><span class=\"line\">        pool-prepared-statements: <span class=\"keyword\">false</span></span><br><span class=\"line\">        #检查连接泄露依据（超时时间）</span><br><span class=\"line\">        remove-abandoned-timeout-millis: <span class=\"number\">300000</span></span><br><span class=\"line\">        #abanded连接时输出错误日志，方便出现连接泄露时可以通过错误日志定位忘记关闭连接的位置</span><br><span class=\"line\">        log-abandoned: <span class=\"keyword\">true</span></span><br><span class=\"line\">        filters: stat,wall</span><br><span class=\"line\">        connectionProperties: druid.stat.mergeSql=<span class=\"keyword\">true</span>;druid.stat.slowSqlMillis=<span class=\"number\">5000</span></span><br><span class=\"line\">        ######Druid监控配置######</span><br><span class=\"line\">        web-stat-filter:</span><br><span class=\"line\">            enabled: <span class=\"keyword\">true</span></span><br><span class=\"line\">            session-stat-enable: <span class=\"keyword\">false</span></span><br><span class=\"line\">            session-stat-max-count: <span class=\"number\">1000</span></span><br><span class=\"line\">            principal-cookie-name: admin</span><br><span class=\"line\">            principal-session-name: admin</span><br><span class=\"line\">            profile-enable: <span class=\"keyword\">true</span></span><br><span class=\"line\">            # 根据配置中的url-pattern来访问内置监控页面，如果是上面的配置，内置监控页面的首页是/druid/index.html</span><br><span class=\"line\">            # http://loacalhsot:8081/druid</span><br><span class=\"line\">        stat-view-servlet:</span><br><span class=\"line\">            enabled: <span class=\"keyword\">true</span></span><br><span class=\"line\">            # 允许清空统计数据</span><br><span class=\"line\">            reset-enable: <span class=\"keyword\">true</span></span><br><span class=\"line\">            login-username: admin</span><br><span class=\"line\">            login-password: <span class=\"number\">123456</span></span><br><span class=\"line\">            allow:</span><br><span class=\"line\">            deny:</span><br></pre></td></tr></table></figure><p>配置文件中已经配置了Monitor，所以我们可以直接访问Druid monitor</p><!-- rebuild by neat -->"},{"title":"IDEA 显示 RunDashboard","abbrlink":"2fc130b3","date":"2019-06-29T08:30:25.000Z","_content":"\n关于IDEA 启动多个服务时，不自动提示RunDashboard\n\n解决办法：\n修改项目中的 .idea\\workspace.xml:\n\n```java\n  <component name=\"RunDashboard\">\n    <option name=\"configurationTypes\">\n      <set>\n        <option value=\"SpringBootApplicationConfigurationType\" />\n      </set>\n    </option>\n   </component>\n\n```\n\n<!-- more -->","source":"_posts/idea-rundashboard.md","raw":"---\ntitle: IDEA 显示 RunDashboard\ncategories: 常见问题\nabbrlink: 2fc130b3\ndate: 2019-06-29 16:30:25\ntags:\n---\n\n关于IDEA 启动多个服务时，不自动提示RunDashboard\n\n解决办法：\n修改项目中的 .idea\\workspace.xml:\n\n```java\n  <component name=\"RunDashboard\">\n    <option name=\"configurationTypes\">\n      <set>\n        <option value=\"SpringBootApplicationConfigurationType\" />\n      </set>\n    </option>\n   </component>\n\n```\n\n<!-- more -->","slug":"idea-rundashboard","published":1,"updated":"2019-09-03T03:40:46.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdu000j0vfav2dl0z5j","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>关于IDEA 启动多个服务时，不自动提示RunDashboard</p><p>解决办法：<br>修改项目中的 .idea\\workspace.xml:</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component name=<span class=\"string\">\"RunDashboard\"</span>&gt;</span><br><span class=\"line\">  &lt;option name=<span class=\"string\">\"configurationTypes\"</span>&gt;</span><br><span class=\"line\">    &lt;set&gt;</span><br><span class=\"line\">      &lt;option value=<span class=\"string\">\"SpringBootApplicationConfigurationType\"</span> /&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">  &lt;/option&gt;</span><br><span class=\"line\"> &lt;/component&gt;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><!-- rebuild by neat -->","site":{"data":{}},"length":286,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>关于IDEA 启动多个服务时，不自动提示RunDashboard</p><p>解决办法：<br>修改项目中的 .idea\\workspace.xml:</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component name=<span class=\"string\">\"RunDashboard\"</span>&gt;</span><br><span class=\"line\">  &lt;option name=<span class=\"string\">\"configurationTypes\"</span>&gt;</span><br><span class=\"line\">    &lt;set&gt;</span><br><span class=\"line\">      &lt;option value=<span class=\"string\">\"SpringBootApplicationConfigurationType\"</span> /&gt;</span><br><span class=\"line\">    &lt;/set&gt;</span><br><span class=\"line\">  &lt;/option&gt;</span><br><span class=\"line\"> &lt;/component&gt;</span><br></pre></td></tr></table></figure>","more":"<!-- rebuild by neat -->"},{"title":"java提高篇-----详解java的四舍五入与保留位","abbrlink":"54d31add","date":"2017-10-20T15:34:10.000Z","_content":"\n> 转载：[http://blog.csdn.net/chenssy/article/details/12719811](http://blog.csdn.net/chenssy/article/details/12719811)\n\n四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。\n在讲解之前，我们先看一个经典的案例：\n\n```java\n    public static void main(String[] args){\n        System.out.println(\"12.5的四舍五入值：\"+Math.round(12.5));\n          System.out.println(\"-12.5的四舍五入值：\" + Math.round(-12.5));  \n    }  \n    Output:  \n    12.5的四舍五入值：13  \n    -12.5的四舍五入值：-12  \n```\n<!-- more -->\n\n这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。\n      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：\n      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。\n      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。\n      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：\n      舍去位的数值小于5时，直接舍去。\n      舍去位的数值大于5时，进位后舍去。\n      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。\n      对于上面的规则我们举例说明\n         11.556 = 11.56 ------六入\n         11.554 = 11.55 -----四舍\n         11.5551 = 11.56 -----五后有数进位\n         11.545 = 11.54 -----五后无数，若前位为偶数应舍去\n         11.555 = 11.56 -----五后无数，若前位为奇数应进位\n      下面实例是使用银行家舍入法：\n\n```java\n    public static void main(String[] args) {  \n        BigDecimal d = new BigDecimal(100000);      //存款  \n        BigDecimal r = new BigDecimal(0.001875*3);   //利息  \n        //使用银行家算法   \n        BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN);\n        \n        System.out.println(\"季利息是：\"+i);  \n        }  \nOutput:  \n季利息是：562.50  \n```\n在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：\n         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。\n         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。\n         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。\n         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。\n         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。\n         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。\n         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。\n      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。\n\n## 保留位\n\n### 方法一：四舍五入 \n```java\n    double   f   =   111231.5585;  \n    BigDecimal   b   =   new   BigDecimal(f);  \n    double   f1   =   b.setScale(2,   RoundingMode.HALF_UP).doubleValue();\n```\n在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。\n\n### 方法二：\n```java\n    java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  \n    df.format(你要格式化的数字);  \n```\n例：new java.text.DecimalFormat(”#.00″).format(3.1415926)\n      #.00 表示两位小数 #.0000四位小数 以此类推…\n\n### 方法三：\n\n```java\n    double d = 3.1415926;  \n  \n    String result = String .format(”%.2f”);  \n  \n    %.2f %. 表示 小数点前任意位数   2 表示两位小数 格式后的结果为f 表示浮点型。\n```\n\n### 方法四：\n\n此外如果使用struts标签做输出的话，有个format属性,设置为format=\"0.00\"就是保留两位小数\n      例如：\n```java\n    <bean:write name=\"entity\" property=\"dkhAFSumPl\"  format=\"0.00\" />  \n    \n    或者  \n    \n    <fmt:formatNumber type=\"number\" value=\"${10000.22/100}\" \n                                maxFractionDigits=\"0\"/>  \n    \n    maxFractionDigits表示保留的位数  \n\n```","source":"_posts/java-toup1.md","raw":"---\ntitle: java提高篇-----详解java的四舍五入与保留位\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 54d31add\ndate: 2017-10-20 23:34:10\n---\n\n> 转载：[http://blog.csdn.net/chenssy/article/details/12719811](http://blog.csdn.net/chenssy/article/details/12719811)\n\n四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。\n在讲解之前，我们先看一个经典的案例：\n\n```java\n    public static void main(String[] args){\n        System.out.println(\"12.5的四舍五入值：\"+Math.round(12.5));\n          System.out.println(\"-12.5的四舍五入值：\" + Math.round(-12.5));  \n    }  \n    Output:  \n    12.5的四舍五入值：13  \n    -12.5的四舍五入值：-12  \n```\n<!-- more -->\n\n这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。\n      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：\n      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。\n      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。\n      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：\n      舍去位的数值小于5时，直接舍去。\n      舍去位的数值大于5时，进位后舍去。\n      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。\n      对于上面的规则我们举例说明\n         11.556 = 11.56 ------六入\n         11.554 = 11.55 -----四舍\n         11.5551 = 11.56 -----五后有数进位\n         11.545 = 11.54 -----五后无数，若前位为偶数应舍去\n         11.555 = 11.56 -----五后无数，若前位为奇数应进位\n      下面实例是使用银行家舍入法：\n\n```java\n    public static void main(String[] args) {  \n        BigDecimal d = new BigDecimal(100000);      //存款  \n        BigDecimal r = new BigDecimal(0.001875*3);   //利息  \n        //使用银行家算法   \n        BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN);\n        \n        System.out.println(\"季利息是：\"+i);  \n        }  \nOutput:  \n季利息是：562.50  \n```\n在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：\n         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。\n         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。\n         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。\n         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。\n         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。\n         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。\n         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。\n      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。\n\n## 保留位\n\n### 方法一：四舍五入 \n```java\n    double   f   =   111231.5585;  \n    BigDecimal   b   =   new   BigDecimal(f);  \n    double   f1   =   b.setScale(2,   RoundingMode.HALF_UP).doubleValue();\n```\n在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。\n\n### 方法二：\n```java\n    java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  \n    df.format(你要格式化的数字);  \n```\n例：new java.text.DecimalFormat(”#.00″).format(3.1415926)\n      #.00 表示两位小数 #.0000四位小数 以此类推…\n\n### 方法三：\n\n```java\n    double d = 3.1415926;  \n  \n    String result = String .format(”%.2f”);  \n  \n    %.2f %. 表示 小数点前任意位数   2 表示两位小数 格式后的结果为f 表示浮点型。\n```\n\n### 方法四：\n\n此外如果使用struts标签做输出的话，有个format属性,设置为format=\"0.00\"就是保留两位小数\n      例如：\n```java\n    <bean:write name=\"entity\" property=\"dkhAFSumPl\"  format=\"0.00\" />  \n    \n    或者  \n    \n    <fmt:formatNumber type=\"number\" value=\"${10000.22/100}\" \n                                maxFractionDigits=\"0\"/>  \n    \n    maxFractionDigits表示保留的位数  \n\n```","slug":"java-toup1","published":1,"updated":"2019-09-03T03:40:46.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdw000k0vfayg713jnw","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/12719811\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12719811</a></p></blockquote><p>四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。<br>在讲解之前，我们先看一个经典的案例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"12.5的四舍五入值：\"</span>+Math.round(<span class=\"number\">12.5</span>));</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"-12.5的四舍五入值：\"</span> + Math.round(-<span class=\"number\">12.5</span>));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\"><span class=\"number\">12.5</span>的四舍五入值：<span class=\"number\">13</span>  </span><br><span class=\"line\">-<span class=\"number\">12.5</span>的四舍五入值：-<span class=\"number\">12</span></span><br></pre></td></tr></table></figure><a id=\"more\"></a><p>这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。<br>四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：<br>四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。<br>五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。<br>所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：<br>舍去位的数值小于5时，直接舍去。<br>舍去位的数值大于5时，进位后舍去。<br>当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。<br>对于上面的规则我们举例说明<br>11.556 = 11.56 ———六入<br>11.554 = 11.55 ——-四舍<br>11.5551 = 11.56 ——-五后有数进位<br>11.545 = 11.54 ——-五后无数，若前位为偶数应舍去<br>11.555 = 11.56 ——-五后无数，若前位为奇数应进位<br>下面实例是使用银行家舍入法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        BigDecimal d = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>);      <span class=\"comment\">//存款  </span></span><br><span class=\"line\">        BigDecimal r = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">0.001875</span>*<span class=\"number\">3</span>);   <span class=\"comment\">//利息  </span></span><br><span class=\"line\">        <span class=\"comment\">//使用银行家算法   </span></span><br><span class=\"line\">        BigDecimal i = d.multiply(r).setScale(<span class=\"number\">2</span>,RoundingMode.HALF_EVEN);</span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"季利息是：\"</span>+i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">季利息是：<span class=\"number\">562.50</span></span><br></pre></td></tr></table></figure><p>在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：<br><font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。<br><font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。<br><font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。<br><font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。<br><font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。<br><font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。<br><font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。<br>提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。</p><h2 id=\"保留位\"><a href=\"#保留位\" class=\"headerlink\" title=\"保留位\"></a>保留位</h2><h3 id=\"方法一：四舍五入\"><a href=\"#方法一：四舍五入\" class=\"headerlink\" title=\"方法一：四舍五入\"></a>方法一：四舍五入</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span>   f   =   <span class=\"number\">111231.5585</span>;  </span><br><span class=\"line\">BigDecimal   b   =   <span class=\"keyword\">new</span>   BigDecimal(f);  </span><br><span class=\"line\"><span class=\"keyword\">double</span>   f1   =   b.setScale(<span class=\"number\">2</span>,   RoundingMode.HALF_UP).doubleValue();</span><br></pre></td></tr></table></figure><p>在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。</p><h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  </span><br><span class=\"line\">df.format(你要格式化的数字);</span><br></pre></td></tr></table></figure><p>例：new java.text.DecimalFormat(”#.00″).format(3.1415926)</p><pre><code>  #.00 表示两位小数 #.0000四位小数 以此类推…\n</code></pre><h3 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> d = <span class=\"number\">3.1415926</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">String result = String .format(”%.<span class=\"number\">2f</span>”);  </span><br><span class=\"line\">  </span><br><span class=\"line\">%.<span class=\"number\">2f</span> %. 表示 小数点前任意位数   <span class=\"number\">2</span> 表示两位小数 格式后的结果为f 表示浮点型。</span><br></pre></td></tr></table></figure><h3 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h3><p>此外如果使用struts标签做输出的话，有个format属性,设置为format=”0.00”就是保留两位小数<br>例如：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean:write name=<span class=\"string\">\"entity\"</span> property=<span class=\"string\">\"dkhAFSumPl\"</span>  format=<span class=\"string\">\"0.00\"</span> /&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">或者  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;fmt:formatNumber type=<span class=\"string\">\"number\"</span> value=<span class=\"string\">\"$&#123;10000.22/100&#125;\"</span> </span><br><span class=\"line\">                            maxFractionDigits=<span class=\"string\">\"0\"</span>/&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">maxFractionDigits表示保留的位数</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":2824,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/12719811\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12719811</a></p></blockquote><p>四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。<br>在讲解之前，我们先看一个经典的案例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"12.5的四舍五入值：\"</span>+Math.round(<span class=\"number\">12.5</span>));</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"-12.5的四舍五入值：\"</span> + Math.round(-<span class=\"number\">12.5</span>));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\"><span class=\"number\">12.5</span>的四舍五入值：<span class=\"number\">13</span>  </span><br><span class=\"line\">-<span class=\"number\">12.5</span>的四舍五入值：-<span class=\"number\">12</span></span><br></pre></td></tr></table></figure>","more":"<p>这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。<br>四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：<br>四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。<br>五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。<br>所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：<br>舍去位的数值小于5时，直接舍去。<br>舍去位的数值大于5时，进位后舍去。<br>当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。<br>对于上面的规则我们举例说明<br>11.556 = 11.56 ———六入<br>11.554 = 11.55 ——-四舍<br>11.5551 = 11.56 ——-五后有数进位<br>11.545 = 11.54 ——-五后无数，若前位为偶数应舍去<br>11.555 = 11.56 ——-五后无数，若前位为奇数应进位<br>下面实例是使用银行家舍入法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        BigDecimal d = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>);      <span class=\"comment\">//存款  </span></span><br><span class=\"line\">        BigDecimal r = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">0.001875</span>*<span class=\"number\">3</span>);   <span class=\"comment\">//利息  </span></span><br><span class=\"line\">        <span class=\"comment\">//使用银行家算法   </span></span><br><span class=\"line\">        BigDecimal i = d.multiply(r).setScale(<span class=\"number\">2</span>,RoundingMode.HALF_EVEN);</span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"季利息是：\"</span>+i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">季利息是：<span class=\"number\">562.50</span></span><br></pre></td></tr></table></figure><p>在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：<br><font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。<br><font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。<br><font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。<br><font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。<br><font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。<br><font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。<br><font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。<br>提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。</p><h2 id=\"保留位\"><a href=\"#保留位\" class=\"headerlink\" title=\"保留位\"></a>保留位</h2><h3 id=\"方法一：四舍五入\"><a href=\"#方法一：四舍五入\" class=\"headerlink\" title=\"方法一：四舍五入\"></a>方法一：四舍五入</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span>   f   =   <span class=\"number\">111231.5585</span>;  </span><br><span class=\"line\">BigDecimal   b   =   <span class=\"keyword\">new</span>   BigDecimal(f);  </span><br><span class=\"line\"><span class=\"keyword\">double</span>   f1   =   b.setScale(<span class=\"number\">2</span>,   RoundingMode.HALF_UP).doubleValue();</span><br></pre></td></tr></table></figure><p>在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。</p><h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  </span><br><span class=\"line\">df.format(你要格式化的数字);</span><br></pre></td></tr></table></figure><p>例：new java.text.DecimalFormat(”#.00″).format(3.1415926)</p><pre><code>  #.00 表示两位小数 #.0000四位小数 以此类推…\n</code></pre><h3 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> d = <span class=\"number\">3.1415926</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">String result = String .format(”%.<span class=\"number\">2f</span>”);  </span><br><span class=\"line\">  </span><br><span class=\"line\">%.<span class=\"number\">2f</span> %. 表示 小数点前任意位数   <span class=\"number\">2</span> 表示两位小数 格式后的结果为f 表示浮点型。</span><br></pre></td></tr></table></figure><h3 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h3><p>此外如果使用struts标签做输出的话，有个format属性,设置为format=”0.00”就是保留两位小数<br>例如：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean:write name=<span class=\"string\">\"entity\"</span> property=<span class=\"string\">\"dkhAFSumPl\"</span>  format=<span class=\"string\">\"0.00\"</span> /&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">或者  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;fmt:formatNumber type=<span class=\"string\">\"number\"</span> value=<span class=\"string\">\"$&#123;10000.22/100&#125;\"</span> </span><br><span class=\"line\">                            maxFractionDigits=<span class=\"string\">\"0\"</span>/&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">maxFractionDigits表示保留的位数</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"java提高篇（九）-----详解匿名内部类","abbrlink":"ea538890","date":"2017-10-23T05:38:35.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/13170015\n\n在java提高篇-----详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。\n\n## 使用匿名内部类内部类\n匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：\n```java\n    new 父类构造器（参数列表）|实现接口（）    \n        {    \n        //匿名内部类的类体部分    \n        }  \n```\n<!-- more -->\n在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。\n```java\n    public abstract class Bird {  \n        private String name;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n        \n        public abstract int fly();  \n    }  \n    \n    public class Test {  \n        \n        public void test(Bird bird){  \n            System.out.println(bird.getName() + \"能够飞 \" + bird.fly() + \"米\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Test test = new Test();  \n            test.test(new Bird() {  \n                \n                public int fly() {  \n                    return 10000;  \n                }  \n                \n                public String getName() {  \n                    return \"大雁\";  \n                }  \n            });  \n        }  \n    }  \n    ------------------  \n    Output：  \n    大雁能够飞 10000米  \n```\n在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。\n由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。\n对于这段匿名内部类代码其实是可以拆分为如下形式：\n```java\n    public class WildGoose extends Bird{  \n        public int fly() {  \n            return 10000;  \n        }  \n        \n        public String getName() {  \n            return \"大雁\";  \n        }  \n    }  \n    \n    WildGoose wildGoose = new WildGoose();  \n    test.test(wildGoose);  \n\n```\n在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。\n对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。\n\n## 注意事项\n在使用匿名内部类的过程中，我们需要注意如下几点：\n\n      1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n      2、匿名内部类中是不能定义构造函数的。\n      3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n      5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n\n## 使用的形参为何要为final\n参考文件：http://android.blog.51cto.com/268543/384844\n我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：**当所在的方法的形参需要被内部类里面使用时，该形参必须为final**。\n\n为什么必须要为final呢？\n首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：\n```java\n    public class OuterClass {  \n        public void display(final String name,String age){  \n            class InnerClass{  \n                void display(){  \n                    System.out.println(name);  \n                }  \n            }  \n        }  \n    }  \n```\n从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：\n\n```java\n    public class OuterClass$InnerClass {  \n        public InnerClass(String name,String age){  \n            this.InnerClass$name = name;  \n            this.InnerClass$age = age;  \n        }  \n        \n        \n        public void display(){  \n            System.out.println(this.InnerClass$name + \"----\" + this.InnerClass$age );  \n        }  \n    }  \n```\n所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。\n直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。\n\n<font color=\"#3366ff\">**简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的**</font>。\n\n## 匿名内部类初始化\n我们一般都是利用构造器来完成某个实例的``初始化``工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。\n\n```java\n    public class OutClass {  \n        public InnerClass getInnerClass(final int age,final String name){  \n            return new InnerClass() {  \n                int age_ ;  \n                String name_;  \n                //构造代码块完成初始化工作  \n                {  \n                    if(0 < age && age < 200){  \n                        age_ = age;  \n                        name_ = name;  \n                    }  \n                }  \n                public String getName() {  \n                    return name_;  \n                }  \n                \n                public int getAge() {  \n                    return age_;  \n                }  \n            };  \n        }  \n        \n        public static void main(String[] args) {  \n            OutClass out = new OutClass();  \n            \n            InnerClass inner_1 = out.getInnerClass(201, \"chenssy\");  \n            System.out.println(inner_1.getName());  \n            \n            InnerClass inner_2 = out.getInnerClass(23, \"chenssy\");  \n            System.out.println(inner_2.getName());  \n        }  \n    }  \n\n```","source":"_posts/java-toup10.md","raw":"---\ntitle: java提高篇（九）-----详解匿名内部类\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: ea538890\ndate: 2017-10-23 13:38:35\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/13170015\n\n在java提高篇-----详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。\n\n## 使用匿名内部类内部类\n匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：\n```java\n    new 父类构造器（参数列表）|实现接口（）    \n        {    \n        //匿名内部类的类体部分    \n        }  \n```\n<!-- more -->\n在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。\n```java\n    public abstract class Bird {  \n        private String name;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n        \n        public abstract int fly();  \n    }  \n    \n    public class Test {  \n        \n        public void test(Bird bird){  \n            System.out.println(bird.getName() + \"能够飞 \" + bird.fly() + \"米\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Test test = new Test();  \n            test.test(new Bird() {  \n                \n                public int fly() {  \n                    return 10000;  \n                }  \n                \n                public String getName() {  \n                    return \"大雁\";  \n                }  \n            });  \n        }  \n    }  \n    ------------------  \n    Output：  \n    大雁能够飞 10000米  \n```\n在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。\n由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。\n对于这段匿名内部类代码其实是可以拆分为如下形式：\n```java\n    public class WildGoose extends Bird{  \n        public int fly() {  \n            return 10000;  \n        }  \n        \n        public String getName() {  \n            return \"大雁\";  \n        }  \n    }  \n    \n    WildGoose wildGoose = new WildGoose();  \n    test.test(wildGoose);  \n\n```\n在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。\n对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。\n\n## 注意事项\n在使用匿名内部类的过程中，我们需要注意如下几点：\n\n      1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n      2、匿名内部类中是不能定义构造函数的。\n      3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n      5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n\n## 使用的形参为何要为final\n参考文件：http://android.blog.51cto.com/268543/384844\n我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：**当所在的方法的形参需要被内部类里面使用时，该形参必须为final**。\n\n为什么必须要为final呢？\n首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：\n```java\n    public class OuterClass {  \n        public void display(final String name,String age){  \n            class InnerClass{  \n                void display(){  \n                    System.out.println(name);  \n                }  \n            }  \n        }  \n    }  \n```\n从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：\n\n```java\n    public class OuterClass$InnerClass {  \n        public InnerClass(String name,String age){  \n            this.InnerClass$name = name;  \n            this.InnerClass$age = age;  \n        }  \n        \n        \n        public void display(){  \n            System.out.println(this.InnerClass$name + \"----\" + this.InnerClass$age );  \n        }  \n    }  \n```\n所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。\n直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。\n\n<font color=\"#3366ff\">**简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的**</font>。\n\n## 匿名内部类初始化\n我们一般都是利用构造器来完成某个实例的``初始化``工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。\n\n```java\n    public class OutClass {  \n        public InnerClass getInnerClass(final int age,final String name){  \n            return new InnerClass() {  \n                int age_ ;  \n                String name_;  \n                //构造代码块完成初始化工作  \n                {  \n                    if(0 < age && age < 200){  \n                        age_ = age;  \n                        name_ = name;  \n                    }  \n                }  \n                public String getName() {  \n                    return name_;  \n                }  \n                \n                public int getAge() {  \n                    return age_;  \n                }  \n            };  \n        }  \n        \n        public static void main(String[] args) {  \n            OutClass out = new OutClass();  \n            \n            InnerClass inner_1 = out.getInnerClass(201, \"chenssy\");  \n            System.out.println(inner_1.getName());  \n            \n            InnerClass inner_2 = out.getInnerClass(23, \"chenssy\");  \n            System.out.println(inner_2.getName());  \n        }  \n    }  \n\n```","slug":"java-toup10","published":1,"updated":"2019-09-03T03:40:46.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdx000o0vfap2v3aefg","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13170015\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13170015</a></p></blockquote><p>在java提高篇——-详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。</p><h2 id=\"使用匿名内部类内部类\"><a href=\"#使用匿名内部类内部类\" class=\"headerlink\" title=\"使用匿名内部类内部类\"></a>使用匿名内部类内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 父类构造器（参数列表）|实现接口（）    </span><br><span class=\"line\">    &#123;    </span><br><span class=\"line\">    <span class=\"comment\">//匿名内部类的类体部分    </span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><a id=\"more\"></a><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Bird bird)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(bird.getName() + <span class=\"string\">\"能够飞 \"</span> + bird.fly() + <span class=\"string\">\"米\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        test.test(<span class=\"keyword\">new</span> Bird() &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">------------------  </span><br><span class=\"line\">Output：  </span><br><span class=\"line\">大雁能够飞 <span class=\"number\">10000</span>米</span><br></pre></td></tr></table></figure><p></p><p>在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。<br>由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。<br>对于这段匿名内部类代码其实是可以拆分为如下形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildGoose</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">WildGoose wildGoose = <span class=\"keyword\">new</span> WildGoose();  </span><br><span class=\"line\">test.test(wildGoose);</span><br></pre></td></tr></table></figure><p></p><p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><pre><code>  1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n  2、匿名内部类中是不能定义构造函数的。\n  3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n  4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n  5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n</code></pre><h2 id=\"使用的形参为何要为final\"><a href=\"#使用的形参为何要为final\" class=\"headerlink\" title=\"使用的形参为何要为final\"></a>使用的形参为何要为final</h2><p>参考文件：<a href=\"http://android.blog.51cto.com/268543/384844\" target=\"_blank\" rel=\"noopener\">http://android.blog.51cto.com/268543/384844</a><br>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：<strong>当所在的方法的形参需要被内部类里面使用时，该形参必须为final</strong>。</p><p>为什么必须要为final呢？<br>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">final</span> String name,String age)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                System.out.println(name);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span>$<span class=\"title\">InnerClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">(String name,String age)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$name = name;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.InnerClass$name + <span class=\"string\">\"----\"</span> + <span class=\"keyword\">this</span>.InnerClass$age );  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p><p><font color=\"#3366ff\"><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的</strong></font>。</p><h2 id=\"匿名内部类初始化\"><a href=\"#匿名内部类初始化\" class=\"headerlink\" title=\"匿名内部类初始化\"></a>匿名内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的<code>初始化</code>工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age,<span class=\"keyword\">final</span> String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass() &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> age_ ;  </span><br><span class=\"line\">            String name_;  </span><br><span class=\"line\">            <span class=\"comment\">//构造代码块完成初始化工作  </span></span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt; age &amp;&amp; age &lt; <span class=\"number\">200</span>)&#123;  </span><br><span class=\"line\">                    age_ = age;  </span><br><span class=\"line\">                    name_ = name;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> name_;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> age_;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OutClass out = <span class=\"keyword\">new</span> OutClass();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        InnerClass inner_1 = out.getInnerClass(<span class=\"number\">201</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner_1.getName());  </span><br><span class=\"line\">        </span><br><span class=\"line\">        InnerClass inner_2 = out.getInnerClass(<span class=\"number\">23</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner_2.getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"length":4616,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13170015\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13170015</a></p></blockquote><p>在java提高篇——-详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。</p><h2 id=\"使用匿名内部类内部类\"><a href=\"#使用匿名内部类内部类\" class=\"headerlink\" title=\"使用匿名内部类内部类\"></a>使用匿名内部类内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 父类构造器（参数列表）|实现接口（）    </span><br><span class=\"line\">    &#123;    </span><br><span class=\"line\">    <span class=\"comment\">//匿名内部类的类体部分    </span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p>","more":"<p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Bird bird)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(bird.getName() + <span class=\"string\">\"能够飞 \"</span> + bird.fly() + <span class=\"string\">\"米\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        test.test(<span class=\"keyword\">new</span> Bird() &#123;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">------------------  </span><br><span class=\"line\">Output：  </span><br><span class=\"line\">大雁能够飞 <span class=\"number\">10000</span>米</span><br></pre></td></tr></table></figure><p></p><p>在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。<br>由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。<br>对于这段匿名内部类代码其实是可以拆分为如下形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildGoose</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">WildGoose wildGoose = <span class=\"keyword\">new</span> WildGoose();  </span><br><span class=\"line\">test.test(wildGoose);</span><br></pre></td></tr></table></figure><p></p><p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><pre><code>  1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n  2、匿名内部类中是不能定义构造函数的。\n  3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n  4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n  5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n</code></pre><h2 id=\"使用的形参为何要为final\"><a href=\"#使用的形参为何要为final\" class=\"headerlink\" title=\"使用的形参为何要为final\"></a>使用的形参为何要为final</h2><p>参考文件：<a href=\"http://android.blog.51cto.com/268543/384844\" target=\"_blank\" rel=\"noopener\">http://android.blog.51cto.com/268543/384844</a><br>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：<strong>当所在的方法的形参需要被内部类里面使用时，该形参必须为final</strong>。</p><p>为什么必须要为final呢？<br>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">final</span> String name,String age)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                System.out.println(name);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span>$<span class=\"title\">InnerClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">(String name,String age)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$name = name;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.InnerClass$name + <span class=\"string\">\"----\"</span> + <span class=\"keyword\">this</span>.InnerClass$age );  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p><p><font color=\"#3366ff\"><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的</strong></font>。</p><h2 id=\"匿名内部类初始化\"><a href=\"#匿名内部类初始化\" class=\"headerlink\" title=\"匿名内部类初始化\"></a>匿名内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的<code>初始化</code>工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age,<span class=\"keyword\">final</span> String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass() &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> age_ ;  </span><br><span class=\"line\">            String name_;  </span><br><span class=\"line\">            <span class=\"comment\">//构造代码块完成初始化工作  </span></span><br><span class=\"line\">            &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt; age &amp;&amp; age &lt; <span class=\"number\">200</span>)&#123;  </span><br><span class=\"line\">                    age_ = age;  </span><br><span class=\"line\">                    name_ = name;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> name_;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> age_;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OutClass out = <span class=\"keyword\">new</span> OutClass();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        InnerClass inner_1 = out.getInnerClass(<span class=\"number\">201</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner_1.getName());  </span><br><span class=\"line\">        </span><br><span class=\"line\">        InnerClass inner_2 = out.getInnerClass(<span class=\"number\">23</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner_2.getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"java提高篇（十）-----强制类型转换","abbrlink":"74443e7b","date":"2017-10-23T14:38:15.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14111307\n\n\n在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。\n在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。\n当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。\n<!-- more -->\n举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：\nFather father = new Son();\n在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！\nSon son = (Son)father;\n这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。\n前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？\n当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：\nFather father = new Father();\nSon son = (Son) father;\n这个系统会抛出ClassCastException异常信息。\n所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。\n所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。\n","source":"_posts/java-toup11.md","raw":"---\ntitle: java提高篇（十）-----强制类型转换\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 74443e7b\ndate: 2017-10-23 22:38:15\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14111307\n\n\n在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。\n在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。\n当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。\n<!-- more -->\n举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：\nFather father = new Son();\n在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！\nSon son = (Son)father;\n这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。\n前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？\n当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：\nFather father = new Father();\nSon son = (Son) father;\n这个系统会抛出ClassCastException异常信息。\n所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。\n所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。\n","slug":"java-toup11","published":1,"updated":"2019-09-03T03:40:46.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketdy000q0vfa2hrmtjye","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14111307\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14111307</a></p></blockquote><p>在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。<br>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。<br>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。<br><a id=\"more\"></a><br>举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：<br>Father father = new Son();<br>在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！<br>Son son = (Son)father;<br>这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。<br>前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？<br>当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：<br>Father father = new Father();<br>Son son = (Son) father;<br>这个系统会抛出ClassCastException异常信息。<br>所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。<br>所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。</p><!-- rebuild by neat -->","site":{"data":{}},"length":977,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14111307\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14111307</a></p></blockquote><p>在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。<br>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。<br>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。<br>","more":"<br>举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：<br>Father father = new Son();<br>在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！<br>Son son = (Son)father;<br>这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。<br>前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？<br>当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：<br>Father father = new Father();<br>Son son = (Son) father;<br>这个系统会抛出ClassCastException异常信息。<br>所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。<br>所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。</p><!-- rebuild by neat -->"},{"title":"java提高篇（十一）-----代码块","abbrlink":"ed0f4534","date":"2017-10-23T14:38:24.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14486833\n\n\n在编程过程中我们可能会遇到如下这种形式的程序：\n```java\npublic class Test {  \n    {  \n        ////  \n    }  \n}  \n```\n这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：\n<!-- more -->\n## 普通代码块\n普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。\n```java\npublic class Test {  \n    public void test(){  \n        System.out.println(\"普通代码块\");  \n    }  \n}  \n```\n## 静态代码块\n想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。\n```java\npublic class Test {  \n    static{  \n        System.out.println(\"静态代码块\");  \n    }  \n}  \n```\n## 同步代码块\n使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。\n## 构造代码块\n在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：\n```java\n    public class Test {  \n        /** \n        * 构造代码 \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    }  \n```\n上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：\n```java\n    public class Test {  \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    \n    }  \n    \n        运行结果  \n    \n    public static void main(String[] args) {  \n            new Test();  \n            System.out.println(\"----------------\");  \n            new Test(\"1\");  \n        }  \n    ------------  \n    Output:  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```\n从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：\n1、 初始化实例变量\n如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。\n2、 初始化实例环境\n一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。\n上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。\n五、 静态代码块、构造代码块、构造函数执行顺序\n从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。\n1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。\n2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。\n3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。\n通过上面的分析，他们三者的执行顺序应该为：静态代码块 > 构造代码块 > 构造函数。\n```java\n    public class Test {  \n        /**  \n        * 静态代码块  \n        */  \n        static{  \n            System.out.println(\"执行静态代码块...\");  \n        }  \n        \n        /**  \n        * 构造代码块  \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /**  \n        * 无参构造函数  \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /**  \n        * 有参构造函数  \n        * @param id  \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            System.out.println(\"----------------------\");  \n            new Test();  \n            System.out.println(\"----------------------\");  \n            new Test(\"1\");  \n        }  \n    }  \n    -----------  \n    Output:  \n    执行静态代码块...  \n    ----------------------  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```","source":"_posts/java-toup12.md","raw":"---\ntitle: java提高篇（十一）-----代码块\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: ed0f4534\ndate: 2017-10-23 22:38:24\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14486833\n\n\n在编程过程中我们可能会遇到如下这种形式的程序：\n```java\npublic class Test {  \n    {  \n        ////  \n    }  \n}  \n```\n这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：\n<!-- more -->\n## 普通代码块\n普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。\n```java\npublic class Test {  \n    public void test(){  \n        System.out.println(\"普通代码块\");  \n    }  \n}  \n```\n## 静态代码块\n想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。\n```java\npublic class Test {  \n    static{  \n        System.out.println(\"静态代码块\");  \n    }  \n}  \n```\n## 同步代码块\n使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。\n## 构造代码块\n在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：\n```java\n    public class Test {  \n        /** \n        * 构造代码 \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    }  \n```\n上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：\n```java\n    public class Test {  \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    \n    }  \n    \n        运行结果  \n    \n    public static void main(String[] args) {  \n            new Test();  \n            System.out.println(\"----------------\");  \n            new Test(\"1\");  \n        }  \n    ------------  \n    Output:  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```\n从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：\n1、 初始化实例变量\n如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。\n2、 初始化实例环境\n一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。\n上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。\n五、 静态代码块、构造代码块、构造函数执行顺序\n从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。\n1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。\n2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。\n3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。\n通过上面的分析，他们三者的执行顺序应该为：静态代码块 > 构造代码块 > 构造函数。\n```java\n    public class Test {  \n        /**  \n        * 静态代码块  \n        */  \n        static{  \n            System.out.println(\"执行静态代码块...\");  \n        }  \n        \n        /**  \n        * 构造代码块  \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /**  \n        * 无参构造函数  \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /**  \n        * 有参构造函数  \n        * @param id  \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            System.out.println(\"----------------------\");  \n            new Test();  \n            System.out.println(\"----------------------\");  \n            new Test(\"1\");  \n        }  \n    }  \n    -----------  \n    Output:  \n    执行静态代码块...  \n    ----------------------  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```","slug":"java-toup12","published":1,"updated":"2019-09-03T03:40:46.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07kete0000v0vfa7uk0zkdj","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14486833\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14486833</a></p></blockquote><p>在编程过程中我们可能会遇到如下这种形式的程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">////  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：<br><a id=\"more\"></a></p><h2 id=\"普通代码块\"><a href=\"#普通代码块\" class=\"headerlink\" title=\"普通代码块\"></a>普通代码块</h2><p>普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"普通代码块\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><p>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p><h2 id=\"构造代码块\"><a href=\"#构造代码块\" class=\"headerlink\" title=\"构造代码块\"></a>构造代码块</h2><p>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 构造代码 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    运行结果  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行无参构造函数...  </span><br><span class=\"line\">----------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行有参构造函数...</span><br></pre></td></tr></table></figure><p></p><p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：<br>1、 初始化实例变量<br>如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。<br>2、 初始化实例环境<br>一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。<br>上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。<br>五、 静态代码块、构造代码块、构造函数执行顺序<br>从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。<br>1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。<br>2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。<br>3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。<br>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 静态代码块  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行静态代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 构造代码块  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数  </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">执行静态代码块...  </span><br><span class=\"line\">----------------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行无参构造函数...  </span><br><span class=\"line\">----------------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行有参构造函数...</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":3876,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14486833\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14486833</a></p></blockquote><p>在编程过程中我们可能会遇到如下这种形式的程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"comment\">////  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：<br>","more":"</p><h2 id=\"普通代码块\"><a href=\"#普通代码块\" class=\"headerlink\" title=\"普通代码块\"></a>普通代码块</h2><p>普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"普通代码块\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><p>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p><h2 id=\"构造代码块\"><a href=\"#构造代码块\" class=\"headerlink\" title=\"构造代码块\"></a>构造代码块</h2><p>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 构造代码 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    运行结果  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行无参构造函数...  </span><br><span class=\"line\">----------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行有参构造函数...</span><br></pre></td></tr></table></figure><p></p><p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：<br>1、 初始化实例变量<br>如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。<br>2、 初始化实例环境<br>一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。<br>上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。<br>五、 静态代码块、构造代码块、构造函数执行顺序<br>从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。<br>1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。<br>2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。<br>3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。<br>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 静态代码块  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行静态代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 构造代码块  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 无参构造函数  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">    * 有参构造函数  </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">执行静态代码块...  </span><br><span class=\"line\">----------------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行无参构造函数...  </span><br><span class=\"line\">----------------------  </span><br><span class=\"line\">执行构造代码块...  </span><br><span class=\"line\">执行有参构造函数...</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"java提高篇（十二）-----equals()","abbrlink":"1ddeb0f4","date":"2017-10-23T14:38:32.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14963073\n\n equals()\n       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：\n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n    }  \n```\n我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：\n<!-- more -->\n```java\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String)anObject;  \n        int n = count;  \n        if (n == anotherString.count) {  \n        char v1[] = value;  \n        char v2[] = anotherString.value;  \n        int i = offset;  \n        int j = anotherString.offset;  \n        while (n-- != 0) {  \n            if (v1[i++] != v2[j++])  \n            return false;  \n        }  \n        return true;  \n        }  \n    }  \n    return false;  \n    }  \n```\n对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。\n在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：\nequals 方法在非空对象引用上实现相等关系：\n      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。\n       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。\n       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：\n      1) 对象域，使用equals方法 。 \n       2) 类型安全的枚举，使用equals或== 。\n       3) 可能为null的对象域 : 使用 == 和 equals 。\n       4) 数组域 : 使用 Arrays.equals 。\n       5) 除float和double外的原始数据类型 : 使用 == 。\n       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。\n       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。\n       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：\n```java\npublic boolean equals(Object obj) {  \n    return (obj instanceof Float)  \n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  \n    }  \n```\n原因嘛，里面提到了两点：\n```java\nHowever, there are two exceptions:  \nIf f1 and f2 both represent  \nFloat.NaN, then the equals method returns  \ntrue, even though Float.NaN==Float.NaN  \nhas the value false.  \nIf <code>f1 represents +0.0f while  \nf2 represents -0.0f, or vice  \nversa, the equal test has the value  \nfalse, even though 0.0f==-0.0f  \nhas the value true.  \n```\n在equals()中使用getClass进行类型判断\n我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。\n父类：Person\n```java\npublic class Person {  \n    protected String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n      \n    public Person(String name){  \n        this.name = name;  \n    }  \n      \n    public boolean equals(Object object){  \n        if(object instanceof Person){  \n            Person p = (Person) object;  \n            if(p.getName() == null || name == null){  \n                return false;  \n            }  \n            else{  \n                return name.equalsIgnoreCase(p.getName());  \n            }  \n        }  \n        return false;  \n    }  \n} \n```\n子类：Employee\n```java\npublic class Employee extends Person{  \n    private int id;  \n      \n    public int getId() {  \n        return id;  \n    }  \n  \n    public void setId(int id) {  \n        this.id = id;  \n    }  \n  \n    public Employee(String name,int id){  \n        super(name);  \n        this.id = id;  \n    }  \n      \n    /** \n     * 重写equals()方法 \n     */  \n    public boolean equals(Object object){  \n        if(object instanceof Employee){  \n            Employee e = (Employee) object;  \n            return super.equals(object) && e.getId() == id;  \n        }  \n        return false;  \n    }  \n}  \n```\n上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        Employee e1 = new Employee(\"chenssy\", 23);  \n        Employee e2 = new Employee(\"chenssy\", 24);  \n        Person p1 = new Person(\"chenssy\");  \n          \n        System.out.println(p1.equals(e1));  \n        System.out.println(p1.equals(e2));  \n        System.out.println(e1.equals(e2));  \n    }  \n}  \n```\n上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。\n对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。\n所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。","source":"_posts/java-toup13.md","raw":"---\ntitle: java提高篇（十二）-----equals()\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 1ddeb0f4\ndate: 2017-10-23 22:38:32\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14963073\n\n equals()\n       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：\n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n    }  \n```\n我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：\n<!-- more -->\n```java\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String)anObject;  \n        int n = count;  \n        if (n == anotherString.count) {  \n        char v1[] = value;  \n        char v2[] = anotherString.value;  \n        int i = offset;  \n        int j = anotherString.offset;  \n        while (n-- != 0) {  \n            if (v1[i++] != v2[j++])  \n            return false;  \n        }  \n        return true;  \n        }  \n    }  \n    return false;  \n    }  \n```\n对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。\n在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：\nequals 方法在非空对象引用上实现相等关系：\n      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。\n       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。\n       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：\n      1) 对象域，使用equals方法 。 \n       2) 类型安全的枚举，使用equals或== 。\n       3) 可能为null的对象域 : 使用 == 和 equals 。\n       4) 数组域 : 使用 Arrays.equals 。\n       5) 除float和double外的原始数据类型 : 使用 == 。\n       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。\n       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。\n       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：\n```java\npublic boolean equals(Object obj) {  \n    return (obj instanceof Float)  \n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  \n    }  \n```\n原因嘛，里面提到了两点：\n```java\nHowever, there are two exceptions:  \nIf f1 and f2 both represent  \nFloat.NaN, then the equals method returns  \ntrue, even though Float.NaN==Float.NaN  \nhas the value false.  \nIf <code>f1 represents +0.0f while  \nf2 represents -0.0f, or vice  \nversa, the equal test has the value  \nfalse, even though 0.0f==-0.0f  \nhas the value true.  \n```\n在equals()中使用getClass进行类型判断\n我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。\n父类：Person\n```java\npublic class Person {  \n    protected String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n      \n    public Person(String name){  \n        this.name = name;  \n    }  \n      \n    public boolean equals(Object object){  \n        if(object instanceof Person){  \n            Person p = (Person) object;  \n            if(p.getName() == null || name == null){  \n                return false;  \n            }  \n            else{  \n                return name.equalsIgnoreCase(p.getName());  \n            }  \n        }  \n        return false;  \n    }  \n} \n```\n子类：Employee\n```java\npublic class Employee extends Person{  \n    private int id;  \n      \n    public int getId() {  \n        return id;  \n    }  \n  \n    public void setId(int id) {  \n        this.id = id;  \n    }  \n  \n    public Employee(String name,int id){  \n        super(name);  \n        this.id = id;  \n    }  \n      \n    /** \n     * 重写equals()方法 \n     */  \n    public boolean equals(Object object){  \n        if(object instanceof Employee){  \n            Employee e = (Employee) object;  \n            return super.equals(object) && e.getId() == id;  \n        }  \n        return false;  \n    }  \n}  \n```\n上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        Employee e1 = new Employee(\"chenssy\", 23);  \n        Employee e2 = new Employee(\"chenssy\", 24);  \n        Person p1 = new Person(\"chenssy\");  \n          \n        System.out.println(p1.equals(e1));  \n        System.out.println(p1.equals(e2));  \n        System.out.println(e1.equals(e2));  \n    }  \n}  \n```\n上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。\n对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。\n所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。","slug":"java-toup13","published":1,"updated":"2019-09-03T03:40:46.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07kete2000x0vfa8tt34ter","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14963073\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14963073</a></p></blockquote><p>equals()<br>超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;  </span><br><span class=\"line\">    return (this == obj);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;  </span><br><span class=\"line\">        String anotherString = (String)anObject;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = count;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.count) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;  </span><br><span class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = offset;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = anotherString.offset;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1[i++] != v2[j++])  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。<br>在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：<br>equals 方法在非空对象引用上实现相等关系：<br>1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。<br>对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。<br>在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：<br>1) 对象域，使用equals方法 。<br>2) 类型安全的枚举，使用equals或== 。<br>3) 可能为null的对象域 : 使用 == 和 equals 。<br>4) 数组域 : 使用 Arrays.equals 。<br>5) 除float和double外的原始数据类型 : 使用 == 。<br>6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。<br>7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。<br>至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)  </span><br><span class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>原因嘛，里面提到了两点：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">However, there are two exceptions:  </span><br><span class=\"line\">If f1 and f2 both represent  </span><br><span class=\"line\">Float.NaN, then the equals method returns  </span><br><span class=\"line\"><span class=\"keyword\">true</span>, even though Float.NaN==Float.NaN  </span><br><span class=\"line\">has the value <span class=\"keyword\">false</span>.  </span><br><span class=\"line\">If &lt;code&gt;f1 represents +<span class=\"number\">0.0f</span> <span class=\"keyword\">while</span>  </span><br><span class=\"line\">f2 represents -<span class=\"number\">0.0f</span>, or vice  </span><br><span class=\"line\">versa, the equal test has the value  </span><br><span class=\"line\"><span class=\"keyword\">false</span>, even though <span class=\"number\">0.0f</span>==-<span class=\"number\">0.0f</span>  </span><br><span class=\"line\">has the value <span class=\"keyword\">true</span>.</span><br></pre></td></tr></table></figure><p></p><p>在equals()中使用getClass进行类型判断<br>我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。<br>父类：Person<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Person)&#123;  </span><br><span class=\"line\">            Person p = (Person) object;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.getName() == <span class=\"keyword\">null</span> || name == <span class=\"keyword\">null</span>)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> name.equalsIgnoreCase(p.getName());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>子类：Employee<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> id)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 重写equals()方法 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Employee)&#123;  </span><br><span class=\"line\">            Employee e = (Employee) object;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(object) &amp;&amp; e.getId() == id;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Employee e1 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">23</span>);  </span><br><span class=\"line\">        Employee e2 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">24</span>);  </span><br><span class=\"line\">        Person p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(p1.equals(e1));  </span><br><span class=\"line\">        System.out.println(p1.equals(e2));  </span><br><span class=\"line\">        System.out.println(e1.equals(e2));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。<br>对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。<br>所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。</p><!-- rebuild by neat -->","site":{"data":{}},"length":5098,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14963073\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/14963073</a></p></blockquote><p>equals()<br>超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean equals(Object obj) &#123;  </span><br><span class=\"line\">    return (this == obj);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;  </span><br><span class=\"line\">        String anotherString = (String)anObject;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = count;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.count) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;  </span><br><span class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = offset;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = anotherString.offset;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1[i++] != v2[j++])  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。<br>在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：<br>equals 方法在非空对象引用上实现相等关系：<br>1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。<br>对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。<br>在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：<br>1) 对象域，使用equals方法 。<br>2) 类型安全的枚举，使用equals或== 。<br>3) 可能为null的对象域 : 使用 == 和 equals 。<br>4) 数组域 : 使用 Arrays.equals 。<br>5) 除float和double外的原始数据类型 : 使用 == 。<br>6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。<br>7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。<br>至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)  </span><br><span class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>原因嘛，里面提到了两点：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">However, there are two exceptions:  </span><br><span class=\"line\">If f1 and f2 both represent  </span><br><span class=\"line\">Float.NaN, then the equals method returns  </span><br><span class=\"line\"><span class=\"keyword\">true</span>, even though Float.NaN==Float.NaN  </span><br><span class=\"line\">has the value <span class=\"keyword\">false</span>.  </span><br><span class=\"line\">If &lt;code&gt;f1 represents +<span class=\"number\">0.0f</span> <span class=\"keyword\">while</span>  </span><br><span class=\"line\">f2 represents -<span class=\"number\">0.0f</span>, or vice  </span><br><span class=\"line\">versa, the equal test has the value  </span><br><span class=\"line\"><span class=\"keyword\">false</span>, even though <span class=\"number\">0.0f</span>==-<span class=\"number\">0.0f</span>  </span><br><span class=\"line\">has the value <span class=\"keyword\">true</span>.</span><br></pre></td></tr></table></figure><p></p><p>在equals()中使用getClass进行类型判断<br>我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。<br>父类：Person<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Person)&#123;  </span><br><span class=\"line\">            Person p = (Person) object;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p.getName() == <span class=\"keyword\">null</span> || name == <span class=\"keyword\">null</span>)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> name.equalsIgnoreCase(p.getName());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>子类：Employee<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> id)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 重写equals()方法 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Employee)&#123;  </span><br><span class=\"line\">            Employee e = (Employee) object;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(object) &amp;&amp; e.getId() == id;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Employee e1 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">23</span>);  </span><br><span class=\"line\">        Employee e2 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">24</span>);  </span><br><span class=\"line\">        Person p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(p1.equals(e1));  </span><br><span class=\"line\">        System.out.println(p1.equals(e2));  </span><br><span class=\"line\">        System.out.println(e1.equals(e2));  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。<br>对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。<br>所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。</p><!-- rebuild by neat -->"},{"title":"java提高篇（十三）-----字符串","abbrlink":"beafe466","date":"2017-10-23T14:38:36.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17591363\n\n可以证明，字符串操作是计算机程序设计中最常见的行为。\n\n## String\n首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。\n字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与\" \"、new String()的区别就象真空与空气一样。\n<!-- more -->\n在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。\n对于字符串的使用无非就是这几个方面：\n ### 字符串比较\n         equals() ------判断内容是否相同。\n         compareTo() ------判断字符串的大小关系。\n         compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n         == ------判断内容与地址是否相同。\n         equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n         reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n### 字符串查找\n         charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n         indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n         indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n         lastIndexOf(String str)------查找最后一次出现的位置。\n         lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n         starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n         starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n         endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n### 字符串截取\n        ------返回一个新的字符串，它是此字符串的一个子字符串。\n        public String subString(int beginIndex)\n        ------返回的字符串是从beginIndex开始到endIndex-1的串。\n        public String subString(int beginIndex，int endIndex)\n### 字符串替换\n         public String replace(char oldChar，char newChar)。\n         public String replace(CharSequence target，CharSequence replacement)\n         ------把原来的etarget子序列替换为replacement序列，返回新串。\n         public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n         注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n### 更多方法请参考API\n\n## StringBuffer\nStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。\n其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。\n同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。\n在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：\n\n      1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n      2、insert：该类方法主要是在StringBuffer对象中插入内容。\n      3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n\n## StringBuilder\nStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。\n上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。\n\n## 正确使用String、StringBuffer、StringBuilder\n我们先看如下表格：\n    ![](/uploads/string.png)\n\n这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。\n      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。\n      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：\n      String name = ”I ” + ”am ” + ”chenssy ” ;\n      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);\n      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。\n      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：\n         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。\n         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。\n         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。\n      更多有关于他们之间区别，请参考：http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\n## 字符串拼接方式\n对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：\n\n```java\n    public class StringTest {  \n        \n        /** \n        * @desc 使用+、concat()、append()方法循环10W次 \n        * @author chenssy \n        * @data 2013-11-16 \n        * @param args \n        * @return void \n        */  \n        public static void main(String[] args) {  \n            //+  \n            long start_01 = System.currentTimeMillis();  \n            String a = \"a\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                a += \"b\";  \n            }  \n            long end_01 = System.currentTimeMillis();  \n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");  \n            \n            //concat()  \n            long start_02 = System.currentTimeMillis();  \n            String c = \"c\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                c = c.concat(\"d\");  \n            }  \n            long end_02 = System.currentTimeMillis();  \n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");  \n            \n            //append  \n            long start_03 = System.currentTimeMillis();  \n            StringBuffer e = new StringBuffer(\"e\");  \n            for(int i = 0 ; i < 100000 ; i++){  \n                e.append(\"d\");  \n            }  \n            long end_03 = System.currentTimeMillis();  \n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");  \n        }  \n    }  \n    \n    ------------  \n    Output:  \n    +   所消耗的时间：19080毫米  \n    concat所消耗的时间：9089毫米  \n    append所消耗的时间：10毫米 \n```\n\n```java\n    public class StringTest {\n        \n        /**\n        * @desc 使用+、concat()、append()方法循环10W次\n        * @author chenssy\n        * @data 2013-11-16\n        * @param args\n        * @return void\n        */\n        public static void main(String[] args) {\n            //+\n            long start_01 = System.currentTimeMillis();\n            String a = \"a\";\n            for(int i = 0 ; i < 100000 ; i++){\n                a += \"b\";\n            }\n            long end_01 = System.currentTimeMillis();\n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");\n            \n            //concat()\n            long start_02 = System.currentTimeMillis();\n            String c = \"c\";\n            for(int i = 0 ; i < 100000 ; i++){\n                c = c.concat(\"d\");\n            }\n            long end_02 = System.currentTimeMillis();\n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");\n            \n            //append\n            long start_03 = System.currentTimeMillis();\n            StringBuffer e = new StringBuffer(\"e\");\n            for(int i = 0 ; i < 100000 ; i++){\n                e.append(\"d\");\n            }\n            long end_03 = System.currentTimeMillis();\n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");\n        }\n    }\n\n    ------------\n    Output:\n    +   所消耗的时间：19080毫米\n    concat所消耗的时间：9089毫米\n    append所消耗的时间：10毫米\n```\n从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:\n\n### +方式拼接字符串\n在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于\nstr = new StringBuilder(str).append(\"b\").toString();\n它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？\n### concat()方法拼接字符串\n```java\n    public String concat(String str) {  \n        int otherLen = str.length();  \n        if (otherLen == 0) {  \n            return this;  \n        }  \n        char buf[] = new char[count + otherLen];  \n        getChars(0, count, buf, 0);  \n        str.getChars(0, otherLen, buf, count);  \n        return new String(0, count + otherLen, buf);  \n    }  \n```\n 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。\n\n ### append()方法拼接字符串\n ```java\n    public synchronized StringBuffer append(String str) {\n        super.append(str);\n        return this;\n    }\n\n ```\nStringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：\n```java\n    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = \"null\";  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount > value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    } \n``` \n与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。","source":"_posts/java-toup14.md","raw":"---\ntitle: java提高篇（十三）-----字符串\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: beafe466\ndate: 2017-10-23 22:38:36\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17591363\n\n可以证明，字符串操作是计算机程序设计中最常见的行为。\n\n## String\n首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。\n字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与\" \"、new String()的区别就象真空与空气一样。\n<!-- more -->\n在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。\n对于字符串的使用无非就是这几个方面：\n ### 字符串比较\n         equals() ------判断内容是否相同。\n         compareTo() ------判断字符串的大小关系。\n         compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n         == ------判断内容与地址是否相同。\n         equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n         reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n### 字符串查找\n         charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n         indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n         indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n         lastIndexOf(String str)------查找最后一次出现的位置。\n         lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n         starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n         starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n         endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n### 字符串截取\n        ------返回一个新的字符串，它是此字符串的一个子字符串。\n        public String subString(int beginIndex)\n        ------返回的字符串是从beginIndex开始到endIndex-1的串。\n        public String subString(int beginIndex，int endIndex)\n### 字符串替换\n         public String replace(char oldChar，char newChar)。\n         public String replace(CharSequence target，CharSequence replacement)\n         ------把原来的etarget子序列替换为replacement序列，返回新串。\n         public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n         注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n### 更多方法请参考API\n\n## StringBuffer\nStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。\n其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。\n同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。\n在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：\n\n      1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n      2、insert：该类方法主要是在StringBuffer对象中插入内容。\n      3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n\n## StringBuilder\nStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。\n上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。\n\n## 正确使用String、StringBuffer、StringBuilder\n我们先看如下表格：\n    ![](/uploads/string.png)\n\n这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。\n      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。\n      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：\n      String name = ”I ” + ”am ” + ”chenssy ” ;\n      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);\n      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。\n      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：\n         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。\n         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。\n         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。\n      更多有关于他们之间区别，请参考：http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\n## 字符串拼接方式\n对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：\n\n```java\n    public class StringTest {  \n        \n        /** \n        * @desc 使用+、concat()、append()方法循环10W次 \n        * @author chenssy \n        * @data 2013-11-16 \n        * @param args \n        * @return void \n        */  \n        public static void main(String[] args) {  \n            //+  \n            long start_01 = System.currentTimeMillis();  \n            String a = \"a\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                a += \"b\";  \n            }  \n            long end_01 = System.currentTimeMillis();  \n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");  \n            \n            //concat()  \n            long start_02 = System.currentTimeMillis();  \n            String c = \"c\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                c = c.concat(\"d\");  \n            }  \n            long end_02 = System.currentTimeMillis();  \n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");  \n            \n            //append  \n            long start_03 = System.currentTimeMillis();  \n            StringBuffer e = new StringBuffer(\"e\");  \n            for(int i = 0 ; i < 100000 ; i++){  \n                e.append(\"d\");  \n            }  \n            long end_03 = System.currentTimeMillis();  \n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");  \n        }  \n    }  \n    \n    ------------  \n    Output:  \n    +   所消耗的时间：19080毫米  \n    concat所消耗的时间：9089毫米  \n    append所消耗的时间：10毫米 \n```\n\n```java\n    public class StringTest {\n        \n        /**\n        * @desc 使用+、concat()、append()方法循环10W次\n        * @author chenssy\n        * @data 2013-11-16\n        * @param args\n        * @return void\n        */\n        public static void main(String[] args) {\n            //+\n            long start_01 = System.currentTimeMillis();\n            String a = \"a\";\n            for(int i = 0 ; i < 100000 ; i++){\n                a += \"b\";\n            }\n            long end_01 = System.currentTimeMillis();\n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");\n            \n            //concat()\n            long start_02 = System.currentTimeMillis();\n            String c = \"c\";\n            for(int i = 0 ; i < 100000 ; i++){\n                c = c.concat(\"d\");\n            }\n            long end_02 = System.currentTimeMillis();\n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");\n            \n            //append\n            long start_03 = System.currentTimeMillis();\n            StringBuffer e = new StringBuffer(\"e\");\n            for(int i = 0 ; i < 100000 ; i++){\n                e.append(\"d\");\n            }\n            long end_03 = System.currentTimeMillis();\n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");\n        }\n    }\n\n    ------------\n    Output:\n    +   所消耗的时间：19080毫米\n    concat所消耗的时间：9089毫米\n    append所消耗的时间：10毫米\n```\n从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:\n\n### +方式拼接字符串\n在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于\nstr = new StringBuilder(str).append(\"b\").toString();\n它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？\n### concat()方法拼接字符串\n```java\n    public String concat(String str) {  \n        int otherLen = str.length();  \n        if (otherLen == 0) {  \n            return this;  \n        }  \n        char buf[] = new char[count + otherLen];  \n        getChars(0, count, buf, 0);  \n        str.getChars(0, otherLen, buf, count);  \n        return new String(0, count + otherLen, buf);  \n    }  \n```\n 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。\n\n ### append()方法拼接字符串\n ```java\n    public synchronized StringBuffer append(String str) {\n        super.append(str);\n        return this;\n    }\n\n ```\nStringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：\n```java\n    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = \"null\";  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount > value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    } \n``` \n与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。","slug":"java-toup14","published":1,"updated":"2019-09-03T03:40:46.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07kete300100vfab5t9a5gb","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591363\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17591363</a></p></blockquote><p>可以证明，字符串操作是计算机程序设计中最常见的行为。</p><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。<br>字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。<br><a id=\"more\"></a><br>在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。<br>对于字符串的使用无非就是这几个方面：</p><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><pre><code>     equals() ------判断内容是否相同。\n     compareTo() ------判断字符串的大小关系。\n     compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n     == ------判断内容与地址是否相同。\n     equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n     reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n</code></pre><h3 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h3><pre><code>     charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n     indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n     indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n     lastIndexOf(String str)------查找最后一次出现的位置。\n     lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n     starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n     starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n     endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n</code></pre><h3 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h3><pre><code>    ------返回一个新的字符串，它是此字符串的一个子字符串。\n    public String subString(int beginIndex)\n    ------返回的字符串是从beginIndex开始到endIndex-1的串。\n    public String subString(int beginIndex，int endIndex)\n</code></pre><h3 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h3><pre><code>     public String replace(char oldChar，char newChar)。\n     public String replace(CharSequence target，CharSequence replacement)\n     ------把原来的etarget子序列替换为replacement序列，返回新串。\n     public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n     注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n</code></pre><h3 id=\"更多方法请参考API\"><a href=\"#更多方法请参考API\" class=\"headerlink\" title=\"更多方法请参考API\"></a>更多方法请参考API</h3><h2 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h2><p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。<br>其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。<br>同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。<br>在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：</p><pre><code>  1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n  2、insert：该类方法主要是在StringBuffer对象中插入内容。\n  3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n</code></pre><h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。<br>上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。</p><h2 id=\"正确使用String、StringBuffer、StringBuilder\"><a href=\"#正确使用String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"正确使用String、StringBuffer、StringBuilder\"></a>正确使用String、StringBuffer、StringBuilder</h2><p>我们先看如下表格：<br><img src=\"/uploads/string.png\" alt></p><p>这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。<br>在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。<br>但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：<br>String name = ”I ” + ”am ” + ”chenssy ” ;<br>StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);<br>对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。<br>对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：<br>1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。<br>2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。<br>3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。<br>更多有关于他们之间区别，请参考：<a href=\"http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。</a></p><h2 id=\"字符串拼接方式\"><a href=\"#字符串拼接方式\" class=\"headerlink\" title=\"字符串拼接方式\"></a>字符串拼接方式</h2><p>对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//+  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();  </span><br><span class=\"line\">        String a = <span class=\"string\">\"a\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            a += <span class=\"string\">\"b\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//concat()  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();  </span><br><span class=\"line\">        String c = <span class=\"string\">\"c\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//append  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();  </span><br><span class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米  </span><br><span class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米  </span><br><span class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//+</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();</span><br><span class=\"line\">        String a = <span class=\"string\">\"a\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            a += <span class=\"string\">\"b\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//concat()</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();</span><br><span class=\"line\">        String c = <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//append</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();</span><br><span class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">Output:</span><br><span class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米</span><br><span class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米</span><br><span class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</span><br></pre></td></tr></table></figure><p>从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:</p><h3 id=\"方式拼接字符串\"><a href=\"#方式拼接字符串\" class=\"headerlink\" title=\"+方式拼接字符串\"></a>+方式拼接字符串</h3><p>在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<br>str = new StringBuilder(str).append(“b”).toString();<br>它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？</p><h3 id=\"concat-方法拼接字符串\"><a href=\"#concat-方法拼接字符串\" class=\"headerlink\" title=\"concat()方法拼接字符串\"></a>concat()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> otherLen = str.length();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[count + otherLen];  </span><br><span class=\"line\">    getChars(<span class=\"number\">0</span>, count, buf, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    str.getChars(<span class=\"number\">0</span>, otherLen, buf, count);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(<span class=\"number\">0</span>, count + otherLen, buf);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。</p><h3 id=\"append-方法拼接字符串\"><a href=\"#append-方法拼接字符串\" class=\"headerlink\" title=\"append()方法拼接字符串\"></a>append()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：</p><pre><code class=\"lang-java\">    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = &quot;null&quot;;  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount &gt; value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    }\n</code></pre><p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。</p><!-- rebuild by neat -->","site":{"data":{}},"length":8271,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591363\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17591363</a></p></blockquote><p>可以证明，字符串操作是计算机程序设计中最常见的行为。</p><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。<br>字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。<br>","more":"<br>在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。<br>对于字符串的使用无非就是这几个方面：</p><h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><pre><code>     equals() ------判断内容是否相同。\n     compareTo() ------判断字符串的大小关系。\n     compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n     == ------判断内容与地址是否相同。\n     equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n     reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n</code></pre><h3 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h3><pre><code>     charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n     indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n     indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n     lastIndexOf(String str)------查找最后一次出现的位置。\n     lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n     starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n     starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n     endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n</code></pre><h3 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h3><pre><code>    ------返回一个新的字符串，它是此字符串的一个子字符串。\n    public String subString(int beginIndex)\n    ------返回的字符串是从beginIndex开始到endIndex-1的串。\n    public String subString(int beginIndex，int endIndex)\n</code></pre><h3 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h3><pre><code>     public String replace(char oldChar，char newChar)。\n     public String replace(CharSequence target，CharSequence replacement)\n     ------把原来的etarget子序列替换为replacement序列，返回新串。\n     public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n     注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n</code></pre><h3 id=\"更多方法请参考API\"><a href=\"#更多方法请参考API\" class=\"headerlink\" title=\"更多方法请参考API\"></a>更多方法请参考API</h3><h2 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h2><p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。<br>其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。<br>同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。<br>在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：</p><pre><code>  1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n  2、insert：该类方法主要是在StringBuffer对象中插入内容。\n  3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n</code></pre><h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。<br>上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。</p><h2 id=\"正确使用String、StringBuffer、StringBuilder\"><a href=\"#正确使用String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"正确使用String、StringBuffer、StringBuilder\"></a>正确使用String、StringBuffer、StringBuilder</h2><p>我们先看如下表格：<br><img src=\"/uploads/string.png\" alt></p><p>这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。<br>在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。<br>但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：<br>String name = ”I ” + ”am ” + ”chenssy ” ;<br>StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);<br>对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。<br>对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：<br>1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。<br>2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。<br>3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。<br>更多有关于他们之间区别，请参考：<a href=\"http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。</a></p><h2 id=\"字符串拼接方式\"><a href=\"#字符串拼接方式\" class=\"headerlink\" title=\"字符串拼接方式\"></a>字符串拼接方式</h2><p>对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//+  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();  </span><br><span class=\"line\">        String a = <span class=\"string\">\"a\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            a += <span class=\"string\">\"b\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//concat()  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();  </span><br><span class=\"line\">        String c = <span class=\"string\">\"c\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//append  </span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();  </span><br><span class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </span><br><span class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米  </span><br><span class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米  </span><br><span class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//+</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();</span><br><span class=\"line\">        String a = <span class=\"string\">\"a\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            a += <span class=\"string\">\"b\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//concat()</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();</span><br><span class=\"line\">        String c = <span class=\"string\">\"c\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//append</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();</span><br><span class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</span><br><span class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">------------</span><br><span class=\"line\">Output:</span><br><span class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米</span><br><span class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米</span><br><span class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</span><br></pre></td></tr></table></figure><p>从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:</p><h3 id=\"方式拼接字符串\"><a href=\"#方式拼接字符串\" class=\"headerlink\" title=\"+方式拼接字符串\"></a>+方式拼接字符串</h3><p>在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<br>str = new StringBuilder(str).append(“b”).toString();<br>它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？</p><h3 id=\"concat-方法拼接字符串\"><a href=\"#concat-方法拼接字符串\" class=\"headerlink\" title=\"concat()方法拼接字符串\"></a>concat()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> otherLen = str.length();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[count + otherLen];  </span><br><span class=\"line\">    getChars(<span class=\"number\">0</span>, count, buf, <span class=\"number\">0</span>);  </span><br><span class=\"line\">    str.getChars(<span class=\"number\">0</span>, otherLen, buf, count);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(<span class=\"number\">0</span>, count + otherLen, buf);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。</p><h3 id=\"append-方法拼接字符串\"><a href=\"#append-方法拼接字符串\" class=\"headerlink\" title=\"append()方法拼接字符串\"></a>append()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.append(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：</p><pre><code class=\"lang-java\">    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = &quot;null&quot;;  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount &gt; value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    }\n</code></pre><p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。</p><!-- rebuild by neat -->"},{"title":"java提高篇（十四）-----关键字final","abbrlink":"2a921769","date":"2017-10-23T14:38:39.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17591563\n\n在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候final就有用武之地了。final是java的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到final的有三种情况：数据、方法、类。\n\n## final数据\n有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：\n1、编译期常量，永远不可改变。\n2、运行期初始化时，我们希望它不会被改变。\n<!-- more -->\n对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。\n有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。\n```java\npublic class Person {  \n    private String name;  \n  \n    Person(String name){  \n        this.name = name;  \n    }  \n      \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n}  \n  \npublic class FinalTest {  \n    private final String final_01 = \"chenssy\";    //编译期常量，必须要进行初始化，且不可更改  \n    private final String final_02;                //构造器常量，在实例化一个对象时被初始化  \n      \n    private static Random random = new Random();  \n    private final int final_03 = random.nextInt(50);    //使用随机数来进行初始化  \n      \n    //引用  \n    public final Person final_04 = new Person(\"chen_ssy\");    //final指向引用数据类型  \n      \n    FinalTest(String final_02){  \n        this.final_02 = final_02;  \n    }  \n      \n    public String toString(){  \n        return \"final_01 = \" + final_01 +\"   final_02 = \" + final_02 + \"   final_03 = \" + final_03 +  \n               \"   final_04 = \" + final_04.getName();  \n    }  \n      \n    public static void main(String[] args) {  \n        System.out.println(\"------------第一次创建对象------------\");  \n        FinalTest final1 = new FinalTest(\"cm\");  \n        System.out.println(final1);  \n        System.out.println(\"------------第二次创建对象------------\");  \n        FinalTest final2 = new FinalTest(\"zj\");  \n        System.out.println(final2);  \n        System.out.println(\"------------修改引用对象--------------\");  \n        final2.final_04.setName(\"chenssy\");  \n        System.out.println(final2);  \n    }  \n}  \n  \n------------------  \nOutput:  \n------------第一次创建对象------------  \nfinal_01 = chenssy   final_02 = cm   final_03 = 34   final_04 = chen_ssy  \n------------第二次创建对象------------  \nfinal_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chen_ssy  \n------------修改引用对象--------------  \nfinal_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chenssy  \n```\n\n这里只阐述一点就是：不要以为某些数据是final就可以在编译期知道其值，通过final_03我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。\n## final方法\n所有被final标注的方法都是不能被继承、更改的，所以对于final方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：在java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。\n对这段话理解我不是很懂就照搬了，那位java牛人可以解释解释下！！\n父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。\n```java\npublic class Custom extends Person{  \n    public void method1(){  \n        System.out.println(\"Person's  method1....\");  \n    }  \n      \n//    Cannot override the final method from person：子类不能覆盖父类的final方法  \n//    public void method2(){  \n//        System.out.println(\"Person's method2...\");  \n//    }  \n}  \n```\n\n## final类\n如果某个类用final修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用final来修饰该类了。\n对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。\n## final参数\n在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。\n如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。\n```java\npublic class Custom {  \n    public void test(final int i){  \n      //i++;     ---final参数不可改变  \n        System.out.println(i);  \n    }  \n      \n    public void test(final Person p){  \n     //p = new Person();    --final参数不可变  \n     p.setName(\"chenssy\");  \n    }  \n}  \n```\n同final修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为final。详情参看：http://www.cnblogs.com/chenssy/p/3390871.html\n## final与static\nfinal和static在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。\n对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。\n对于成员方法，则是不可继承和改变。可以通过类名直接访问。","source":"_posts/java-toup15.md","raw":"---\ntitle: java提高篇（十四）-----关键字final\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 2a921769\ndate: 2017-10-23 22:38:39\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17591563\n\n在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候final就有用武之地了。final是java的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到final的有三种情况：数据、方法、类。\n\n## final数据\n有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：\n1、编译期常量，永远不可改变。\n2、运行期初始化时，我们希望它不会被改变。\n<!-- more -->\n对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。\n有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。\n```java\npublic class Person {  \n    private String name;  \n  \n    Person(String name){  \n        this.name = name;  \n    }  \n      \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n}  \n  \npublic class FinalTest {  \n    private final String final_01 = \"chenssy\";    //编译期常量，必须要进行初始化，且不可更改  \n    private final String final_02;                //构造器常量，在实例化一个对象时被初始化  \n      \n    private static Random random = new Random();  \n    private final int final_03 = random.nextInt(50);    //使用随机数来进行初始化  \n      \n    //引用  \n    public final Person final_04 = new Person(\"chen_ssy\");    //final指向引用数据类型  \n      \n    FinalTest(String final_02){  \n        this.final_02 = final_02;  \n    }  \n      \n    public String toString(){  \n        return \"final_01 = \" + final_01 +\"   final_02 = \" + final_02 + \"   final_03 = \" + final_03 +  \n               \"   final_04 = \" + final_04.getName();  \n    }  \n      \n    public static void main(String[] args) {  \n        System.out.println(\"------------第一次创建对象------------\");  \n        FinalTest final1 = new FinalTest(\"cm\");  \n        System.out.println(final1);  \n        System.out.println(\"------------第二次创建对象------------\");  \n        FinalTest final2 = new FinalTest(\"zj\");  \n        System.out.println(final2);  \n        System.out.println(\"------------修改引用对象--------------\");  \n        final2.final_04.setName(\"chenssy\");  \n        System.out.println(final2);  \n    }  \n}  \n  \n------------------  \nOutput:  \n------------第一次创建对象------------  \nfinal_01 = chenssy   final_02 = cm   final_03 = 34   final_04 = chen_ssy  \n------------第二次创建对象------------  \nfinal_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chen_ssy  \n------------修改引用对象--------------  \nfinal_01 = chenssy   final_02 = zj   final_03 = 46   final_04 = chenssy  \n```\n\n这里只阐述一点就是：不要以为某些数据是final就可以在编译期知道其值，通过final_03我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。\n## final方法\n所有被final标注的方法都是不能被继承、更改的，所以对于final方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：在java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。\n对这段话理解我不是很懂就照搬了，那位java牛人可以解释解释下！！\n父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。\n```java\npublic class Custom extends Person{  \n    public void method1(){  \n        System.out.println(\"Person's  method1....\");  \n    }  \n      \n//    Cannot override the final method from person：子类不能覆盖父类的final方法  \n//    public void method2(){  \n//        System.out.println(\"Person's method2...\");  \n//    }  \n}  \n```\n\n## final类\n如果某个类用final修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用final来修饰该类了。\n对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。\n## final参数\n在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。\n如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。\n```java\npublic class Custom {  \n    public void test(final int i){  \n      //i++;     ---final参数不可改变  \n        System.out.println(i);  \n    }  \n      \n    public void test(final Person p){  \n     //p = new Person();    --final参数不可变  \n     p.setName(\"chenssy\");  \n    }  \n}  \n```\n同final修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为final。详情参看：http://www.cnblogs.com/chenssy/p/3390871.html\n## final与static\nfinal和static在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。\n对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。\n对于成员方法，则是不可继承和改变。可以通过类名直接访问。","slug":"java-toup15","published":1,"updated":"2019-09-03T03:40:46.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07kete600130vfabvoq11le","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591563\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17591563</a></p></blockquote><p>在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候final就有用武之地了。final是java的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到final的有三种情况：数据、方法、类。</p><h2 id=\"final数据\"><a href=\"#final数据\" class=\"headerlink\" title=\"final数据\"></a>final数据</h2><p>有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：<br>1、编译期常量，永远不可改变。<br>2、运行期初始化时，我们希望它不会被改变。<br><a id=\"more\"></a><br>对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。<br>有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Person(String name)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String final_01 = <span class=\"string\">\"chenssy\"</span>;    <span class=\"comment\">//编译期常量，必须要进行初始化，且不可更改  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String final_02;                <span class=\"comment\">//构造器常量，在实例化一个对象时被初始化  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> final_03 = random.nextInt(<span class=\"number\">50</span>);    <span class=\"comment\">//使用随机数来进行初始化  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//引用  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Person final_04 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chen_ssy\"</span>);    <span class=\"comment\">//final指向引用数据类型  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    FinalTest(String final_02)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.final_02 = final_02;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"final_01 = \"</span> + final_01 +<span class=\"string\">\"   final_02 = \"</span> + final_02 + <span class=\"string\">\"   final_03 = \"</span> + final_03 +  </span><br><span class=\"line\">               <span class=\"string\">\"   final_04 = \"</span> + final_04.getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------第一次创建对象------------\"</span>);  </span><br><span class=\"line\">        FinalTest final1 = <span class=\"keyword\">new</span> FinalTest(<span class=\"string\">\"cm\"</span>);  </span><br><span class=\"line\">        System.out.println(final1);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------第二次创建对象------------\"</span>);  </span><br><span class=\"line\">        FinalTest final2 = <span class=\"keyword\">new</span> FinalTest(<span class=\"string\">\"zj\"</span>);  </span><br><span class=\"line\">        System.out.println(final2);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------修改引用对象--------------\"</span>);  </span><br><span class=\"line\">        final2.final_04.setName(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(final2);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">------------第一次创建对象------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = cm   final_03 = <span class=\"number\">34</span>   final_04 = chen_ssy  </span><br><span class=\"line\">------------第二次创建对象------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = zj   final_03 = <span class=\"number\">46</span>   final_04 = chen_ssy  </span><br><span class=\"line\">------------修改引用对象--------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = zj   final_03 = <span class=\"number\">46</span>   final_04 = chenssy</span><br></pre></td></tr></table></figure><p></p><p>这里只阐述一点就是：不要以为某些数据是final就可以在编译期知道其值，通过final_03我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。</p><h2 id=\"final方法\"><a href=\"#final方法\" class=\"headerlink\" title=\"final方法\"></a>final方法</h2><p>所有被final标注的方法都是不能被继承、更改的，所以对于final方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：在java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。<br>对这段话理解我不是很懂就照搬了，那位java牛人可以解释解释下！！<br>父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Custom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Person's  method1....\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"comment\">//    Cannot override the final method from person：子类不能覆盖父类的final方法  </span></span><br><span class=\"line\"><span class=\"comment\">//    public void method2()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"Person's method2...\");  </span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"final类\"><a href=\"#final类\" class=\"headerlink\" title=\"final类\"></a>final类</h2><p>如果某个类用final修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用final来修饰该类了。<br>对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。</p><h2 id=\"final参数\"><a href=\"#final参数\" class=\"headerlink\" title=\"final参数\"></a>final参数</h2><p>在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。<br>如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Custom</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i)</span></span>&#123;  </span><br><span class=\"line\">      <span class=\"comment\">//i++;     ---final参数不可改变  </span></span><br><span class=\"line\">        System.out.println(i);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">final</span> Person p)</span></span>&#123;  </span><br><span class=\"line\">     <span class=\"comment\">//p = new Person();    --final参数不可变  </span></span><br><span class=\"line\">     p.setName(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同final修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为final。详情参看：<a href=\"http://www.cnblogs.com/chenssy/p/3390871.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/chenssy/p/3390871.html</a></p><h2 id=\"final与static\"><a href=\"#final与static\" class=\"headerlink\" title=\"final与static\"></a>final与static</h2><p>final和static在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。<br>对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。<br>对于成员方法，则是不可继承和改变。可以通过类名直接访问。</p><!-- rebuild by neat -->","site":{"data":{}},"length":4340,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591563\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17591563</a></p></blockquote><p>在程序设计中，我们有时可能希望某些数据是不能够改变的，这个时候final就有用武之地了。final是java的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到final的有三种情况：数据、方法、类。</p><h2 id=\"final数据\"><a href=\"#final数据\" class=\"headerlink\" title=\"final数据\"></a>final数据</h2><p>有时候数据的恒定不变是很有用的，它能够减轻系统运行时的负担。对于这些恒定不变的数据我可以叫做“常量”。“常量”主要应用与以下两个地方：<br>1、编译期常量，永远不可改变。<br>2、运行期初始化时，我们希望它不会被改变。<br>","more":"<br>对于编译期常量，它在类加载的过程就已经完成了初始化，所以当类加载完成后是不可更改的，编译期可以将它代入到任何用到它的计算式中，也就是说可以在编译期执行计算式。当然对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化。<br>有些变量，我们希望它可以根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。对于运行期常量，它既可是基本数据类型，也可是引用数据类型。基本数据类型不可变的是其内容，而引用数据类型不可变的是其引用，引用所指定的对象内容是可变的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    Person(String name)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinalTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String final_01 = <span class=\"string\">\"chenssy\"</span>;    <span class=\"comment\">//编译期常量，必须要进行初始化，且不可更改  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String final_02;                <span class=\"comment\">//构造器常量，在实例化一个对象时被初始化  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> final_03 = random.nextInt(<span class=\"number\">50</span>);    <span class=\"comment\">//使用随机数来进行初始化  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//引用  </span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Person final_04 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chen_ssy\"</span>);    <span class=\"comment\">//final指向引用数据类型  </span></span><br><span class=\"line\">      </span><br><span class=\"line\">    FinalTest(String final_02)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.final_02 = final_02;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"final_01 = \"</span> + final_01 +<span class=\"string\">\"   final_02 = \"</span> + final_02 + <span class=\"string\">\"   final_03 = \"</span> + final_03 +  </span><br><span class=\"line\">               <span class=\"string\">\"   final_04 = \"</span> + final_04.getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------第一次创建对象------------\"</span>);  </span><br><span class=\"line\">        FinalTest final1 = <span class=\"keyword\">new</span> FinalTest(<span class=\"string\">\"cm\"</span>);  </span><br><span class=\"line\">        System.out.println(final1);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------第二次创建对象------------\"</span>);  </span><br><span class=\"line\">        FinalTest final2 = <span class=\"keyword\">new</span> FinalTest(<span class=\"string\">\"zj\"</span>);  </span><br><span class=\"line\">        System.out.println(final2);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------修改引用对象--------------\"</span>);  </span><br><span class=\"line\">        final2.final_04.setName(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(final2);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">------------第一次创建对象------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = cm   final_03 = <span class=\"number\">34</span>   final_04 = chen_ssy  </span><br><span class=\"line\">------------第二次创建对象------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = zj   final_03 = <span class=\"number\">46</span>   final_04 = chen_ssy  </span><br><span class=\"line\">------------修改引用对象--------------  </span><br><span class=\"line\">final_01 = chenssy   final_02 = zj   final_03 = <span class=\"number\">46</span>   final_04 = chenssy</span><br></pre></td></tr></table></figure><p></p><p>这里只阐述一点就是：不要以为某些数据是final就可以在编译期知道其值，通过final_03我们就知道了，在这里是使用随机数其进行初始化，他要在运行期才能知道其值。</p><h2 id=\"final方法\"><a href=\"#final方法\" class=\"headerlink\" title=\"final方法\"></a>final方法</h2><p>所有被final标注的方法都是不能被继承、更改的，所以对于final方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：在java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。<br>对这段话理解我不是很懂就照搬了，那位java牛人可以解释解释下！！<br>父类的final方法是不能被子类所覆盖的，也就是说子类是不能够存在和父类一模一样的方法的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Custom</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Person's  method1....\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\"><span class=\"comment\">//    Cannot override the final method from person：子类不能覆盖父类的final方法  </span></span><br><span class=\"line\"><span class=\"comment\">//    public void method2()&#123;  </span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"Person's method2...\");  </span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"final类\"><a href=\"#final类\" class=\"headerlink\" title=\"final类\"></a>final类</h2><p>如果某个类用final修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用final来修饰该类了。<br>对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。</p><h2 id=\"final参数\"><a href=\"#final参数\" class=\"headerlink\" title=\"final参数\"></a>final参数</h2><p>在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。<br>如果在方法中我们修改了该参数，则编译器会提示你：The final local variable i cannot be assigned. It must be blank and not using a compound assignment。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Custom</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> i)</span></span>&#123;  </span><br><span class=\"line\">      <span class=\"comment\">//i++;     ---final参数不可改变  </span></span><br><span class=\"line\">        System.out.println(i);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">final</span> Person p)</span></span>&#123;  </span><br><span class=\"line\">     <span class=\"comment\">//p = new Person();    --final参数不可变  </span></span><br><span class=\"line\">     p.setName(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同final修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为final。详情参看：<a href=\"http://www.cnblogs.com/chenssy/p/3390871.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/chenssy/p/3390871.html</a></p><h2 id=\"final与static\"><a href=\"#final与static\" class=\"headerlink\" title=\"final与static\"></a>final与static</h2><p>final和static在一起使用就会发生神奇的化学反应，他们同时使用时即可修饰成员变量，也可修饰成员方法。<br>对于成员变量，该变量一旦赋值就不能改变，我们称它为“全局常量”。可以通过类名直接访问。<br>对于成员方法，则是不可继承和改变。可以通过类名直接访问。</p><!-- rebuild by neat -->"},{"title":"java提高篇(十六)-----异常（一）","abbrlink":"fe7fe614","date":"2017-10-23T14:38:43.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17651909\n\n**Java的基本理念是“结构不佳的代码不能运行”！！！！！**\n大成若缺，其用不弊。\n大盈若冲，其用不穷。\n在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。\n## 为什么要使用异常\n<!-- more -->\n首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。有异常就说明程序存在问题，有助于我们及时改正。在我们的程序设计当做，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：\n\n       1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？\n       2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。\n       3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。\n在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。\n在初学时，总是听老师说把有可能出错的地方记得加异常处理，刚刚开始还不明白，有时候还觉得只是多此一举，现在随着自己的不断深入，代码编写多了，渐渐明白了异常是非常重要的。\n## 基本定义\n在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！\n那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态恢复，以使程序要么换一种方法执行，要么继续执行下去。\n总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。\n## 异常体系\njava为我们提供了非常完美的异常处理机制，使得我们可以更加专心于我们的程序，在使用异常之前我们需要了解它的体系结构：如下（该图摘自：http://blog.csdn.net/zhangerqing/article/details/8248186 ）。\n![](/uploads/exception.png)\n从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。\n其中Error为错误，是程序无法处理的，如OutOfMemoryError、ThreadDeath等，出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。\n而Exception是程序可以处理的异常。它又分为两种CheckedException（受捡异常），一种是UncheckedException（不受检异常）。其中CheckException发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。而UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。\n所以：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。\njava的异常类实在是太多了，产生的原因也千变万化，所以下篇博文我将会整理，统计java中经常出现的异常，望各位关注！！\n## 异常使用\n在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch，（鄙人刚刚接触时也是这么认为的，碰到异常就是try…catch）。个人感觉try…catch确实是用的最多也是最实用的。\n在异常中try快包含着可能出现异常的代码块，catch块捕获异常后对异常进行处理。先看如下实例：\n```java\npublic class ExceptionTest {  \n    public static void main(String[] args) {  \n        String file = \"D:\\\\exceptionTest.txt\";  \n        FileReader reader;  \n        try {  \n            reader = new FileReader(file);  \n            Scanner in = new Scanner(reader);    \n            String string = in.next();    \n            System.out.println(string + \"不知道我有幸能够执行到不.....\");  \n        } catch (FileNotFoundException e) {  \n            e.printStackTrace();  \n            System.out.println(\"对不起,你执行不到...\");  \n        }    \n        finally{  \n            System.out.println(\"finally 在执行...\");  \n        }  \n    }  \n}  \n```\n这是段非常简单的程序，用于读取D盘目录下的exceptionText.txt文件，同时读取其中的内容、输出。首先D盘没有该文件，运行程序结果如下：\n```java\njava.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  \n    at java.io.FileInputStream.open(Native Method)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:106)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:66)  \n    at java.io.FileReader.<init>(FileReader.java:41)  \n    at com.test9.ExceptionTest.main(ExceptionTest.java:19)  \n对不起,你执行不到...  \nfinally 在执行...  \n```\n从这个结果我们可以看出这些：\n1、当程序遇到异常时会终止程序的运行（即后面的代码不在执行），控制权交由异常处理机制处理。\n2、catch捕捉异常后，执行里面的函数。\n当我们在D盘目录下新建一个exceptionTest.txt文件后，运行程序结果如下：\n```java\n1111不知道我有幸能够执行到不.....  \nfinally 在执行...  \n```\n11111是该文件中的内容。从这个运行结果可以得出这个结果：不论程序是否发生异常，finally代码块总是会执行。所以finally一般用来关闭资源。\n在这里我们在看如下程序：\n```java\npublic class ExceptionTest {  \n    public static void main(String[] args) {  \n        int[] a = {1,2,3,4};  \n        System.out.println(a[4]);  \n        System.out.println(\"我执行了吗???\");  \n    }  \n} \n```\n程序运行结果：\n```java\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4  \n    at com.test9.ExceptionTest.main(ExceptionTest.java:14)  \n```\n各位请注意这个异常信息和上面的异常信息错误，为了看得更加清楚，我将他们列在一起：\n```java\njava.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  \n        Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4  \n```\n在这里我们发现两个异常之间存在如下区别：第二个异常信息多了Exception in thread \"main\"，这显示了出现异常信息的位置。在这里可以得到如下结论：若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处。","source":"_posts/java-toup16.md","raw":"---\ntitle: java提高篇(十六)-----异常（一）\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: fe7fe614\ndate: 2017-10-23 22:38:43\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17651909\n\n**Java的基本理念是“结构不佳的代码不能运行”！！！！！**\n大成若缺，其用不弊。\n大盈若冲，其用不穷。\n在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。\n## 为什么要使用异常\n<!-- more -->\n首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。有异常就说明程序存在问题，有助于我们及时改正。在我们的程序设计当做，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：\n\n       1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？\n       2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。\n       3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。\n在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。\n在初学时，总是听老师说把有可能出错的地方记得加异常处理，刚刚开始还不明白，有时候还觉得只是多此一举，现在随着自己的不断深入，代码编写多了，渐渐明白了异常是非常重要的。\n## 基本定义\n在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！\n那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态恢复，以使程序要么换一种方法执行，要么继续执行下去。\n总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。\n## 异常体系\njava为我们提供了非常完美的异常处理机制，使得我们可以更加专心于我们的程序，在使用异常之前我们需要了解它的体系结构：如下（该图摘自：http://blog.csdn.net/zhangerqing/article/details/8248186 ）。\n![](/uploads/exception.png)\n从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。\n其中Error为错误，是程序无法处理的，如OutOfMemoryError、ThreadDeath等，出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。\n而Exception是程序可以处理的异常。它又分为两种CheckedException（受捡异常），一种是UncheckedException（不受检异常）。其中CheckException发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。而UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。\n所以：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。\njava的异常类实在是太多了，产生的原因也千变万化，所以下篇博文我将会整理，统计java中经常出现的异常，望各位关注！！\n## 异常使用\n在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch，（鄙人刚刚接触时也是这么认为的，碰到异常就是try…catch）。个人感觉try…catch确实是用的最多也是最实用的。\n在异常中try快包含着可能出现异常的代码块，catch块捕获异常后对异常进行处理。先看如下实例：\n```java\npublic class ExceptionTest {  \n    public static void main(String[] args) {  \n        String file = \"D:\\\\exceptionTest.txt\";  \n        FileReader reader;  \n        try {  \n            reader = new FileReader(file);  \n            Scanner in = new Scanner(reader);    \n            String string = in.next();    \n            System.out.println(string + \"不知道我有幸能够执行到不.....\");  \n        } catch (FileNotFoundException e) {  \n            e.printStackTrace();  \n            System.out.println(\"对不起,你执行不到...\");  \n        }    \n        finally{  \n            System.out.println(\"finally 在执行...\");  \n        }  \n    }  \n}  \n```\n这是段非常简单的程序，用于读取D盘目录下的exceptionText.txt文件，同时读取其中的内容、输出。首先D盘没有该文件，运行程序结果如下：\n```java\njava.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  \n    at java.io.FileInputStream.open(Native Method)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:106)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:66)  \n    at java.io.FileReader.<init>(FileReader.java:41)  \n    at com.test9.ExceptionTest.main(ExceptionTest.java:19)  \n对不起,你执行不到...  \nfinally 在执行...  \n```\n从这个结果我们可以看出这些：\n1、当程序遇到异常时会终止程序的运行（即后面的代码不在执行），控制权交由异常处理机制处理。\n2、catch捕捉异常后，执行里面的函数。\n当我们在D盘目录下新建一个exceptionTest.txt文件后，运行程序结果如下：\n```java\n1111不知道我有幸能够执行到不.....  \nfinally 在执行...  \n```\n11111是该文件中的内容。从这个运行结果可以得出这个结果：不论程序是否发生异常，finally代码块总是会执行。所以finally一般用来关闭资源。\n在这里我们在看如下程序：\n```java\npublic class ExceptionTest {  \n    public static void main(String[] args) {  \n        int[] a = {1,2,3,4};  \n        System.out.println(a[4]);  \n        System.out.println(\"我执行了吗???\");  \n    }  \n} \n```\n程序运行结果：\n```java\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4  \n    at com.test9.ExceptionTest.main(ExceptionTest.java:14)  \n```\n各位请注意这个异常信息和上面的异常信息错误，为了看得更加清楚，我将他们列在一起：\n```java\njava.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  \n        Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4  \n```\n在这里我们发现两个异常之间存在如下区别：第二个异常信息多了Exception in thread \"main\"，这显示了出现异常信息的位置。在这里可以得到如下结论：若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处。","slug":"java-toup16","published":1,"updated":"2019-09-03T03:40:46.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07kete800170vfa6buh7kws","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17651909\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17651909</a></p></blockquote><p><strong>Java的基本理念是“结构不佳的代码不能运行”！！！！！</strong><br>大成若缺，其用不弊。<br>大盈若冲，其用不穷。<br>在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。</p><h2 id=\"为什么要使用异常\"><a href=\"#为什么要使用异常\" class=\"headerlink\" title=\"为什么要使用异常\"></a>为什么要使用异常</h2><a id=\"more\"></a><p>首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。有异常就说明程序存在问题，有助于我们及时改正。在我们的程序设计当做，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p><pre><code>   1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？\n   2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。\n   3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。\n</code></pre><p>在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。<br>在初学时，总是听老师说把有可能出错的地方记得加异常处理，刚刚开始还不明白，有时候还觉得只是多此一举，现在随着自己的不断深入，代码编写多了，渐渐明白了异常是非常重要的。</p><h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h2><p>在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！<br>那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态恢复，以使程序要么换一种方法执行，要么继续执行下去。<br>总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p><h2 id=\"异常体系\"><a href=\"#异常体系\" class=\"headerlink\" title=\"异常体系\"></a>异常体系</h2><p>java为我们提供了非常完美的异常处理机制，使得我们可以更加专心于我们的程序，在使用异常之前我们需要了解它的体系结构：如下（该图摘自：<a href=\"http://blog.csdn.net/zhangerqing/article/details/8248186\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zhangerqing/article/details/8248186</a> ）。<br><img src=\"/uploads/exception.png\" alt><br>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。<br>其中Error为错误，是程序无法处理的，如OutOfMemoryError、ThreadDeath等，出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。<br>而Exception是程序可以处理的异常。它又分为两种CheckedException（受捡异常），一种是UncheckedException（不受检异常）。其中CheckException发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。而UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。<br>所以：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。<br>java的异常类实在是太多了，产生的原因也千变万化，所以下篇博文我将会整理，统计java中经常出现的异常，望各位关注！！</p><h2 id=\"异常使用\"><a href=\"#异常使用\" class=\"headerlink\" title=\"异常使用\"></a>异常使用</h2><p>在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch，（鄙人刚刚接触时也是这么认为的，碰到异常就是try…catch）。个人感觉try…catch确实是用的最多也是最实用的。<br>在异常中try快包含着可能出现异常的代码块，catch块捕获异常后对异常进行处理。先看如下实例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        String file = <span class=\"string\">\"D:\\\\exceptionTest.txt\"</span>;  </span><br><span class=\"line\">        FileReader reader;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            reader = <span class=\"keyword\">new</span> FileReader(file);  </span><br><span class=\"line\">            Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">            String string = in.next();    </span><br><span class=\"line\">            System.out.println(string + <span class=\"string\">\"不知道我有幸能够执行到不.....\"</span>);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"对不起,你执行不到...\"</span>);  </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        <span class=\"keyword\">finally</span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"finally 在执行...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是段非常简单的程序，用于读取D盘目录下的exceptionText.txt文件，同时读取其中的内容、输出。首先D盘没有该文件，运行程序结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  </span><br><span class=\"line\">    at java.io.FileInputStream.open(Native Method)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">106</span>)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">66</span>)  </span><br><span class=\"line\">    at java.io.FileReader.&lt;init&gt;(FileReader.java:<span class=\"number\">41</span>)  </span><br><span class=\"line\">    at com.test9.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">19</span>)  </span><br><span class=\"line\">对不起,你执行不到...  </span><br><span class=\"line\"><span class=\"keyword\">finally</span> 在执行...</span><br></pre></td></tr></table></figure><p></p><p>从这个结果我们可以看出这些：<br>1、当程序遇到异常时会终止程序的运行（即后面的代码不在执行），控制权交由异常处理机制处理。<br>2、catch捕捉异常后，执行里面的函数。<br>当我们在D盘目录下新建一个exceptionTest.txt文件后，运行程序结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1111</span>不知道我有幸能够执行到不.....  </span><br><span class=\"line\"><span class=\"keyword\">finally</span> 在执行...</span><br></pre></td></tr></table></figure><p></p><p>11111是该文件中的内容。从这个运行结果可以得出这个结果：不论程序是否发生异常，finally代码块总是会执行。所以finally一般用来关闭资源。<br>在这里我们在看如下程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;  </span><br><span class=\"line\">        System.out.println(a[<span class=\"number\">4</span>]);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我执行了吗???\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序运行结果：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.ArrayIndexOutOfBoundsException: <span class=\"number\">4</span>  </span><br><span class=\"line\">    at com.test9.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">14</span>)</span><br></pre></td></tr></table></figure><p></p><p>各位请注意这个异常信息和上面的异常信息错误，为了看得更加清楚，我将他们列在一起：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  </span><br><span class=\"line\">        Exception in thread <span class=\"string\">\"main\"</span> java.lang.ArrayIndexOutOfBoundsException: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><p></p><p>在这里我们发现两个异常之间存在如下区别：第二个异常信息多了Exception in thread “main”，这显示了出现异常信息的位置。在这里可以得到如下结论：若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处。</p><!-- rebuild by neat -->","site":{"data":{}},"length":4442,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17651909\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17651909</a></p></blockquote><p><strong>Java的基本理念是“结构不佳的代码不能运行”！！！！！</strong><br>大成若缺，其用不弊。<br>大盈若冲，其用不穷。<br>在这个世界不可能存在完美的东西，不管完美的思维有多么缜密，细心，我们都不可能考虑所有的因素，这就是所谓的智者千虑必有一失。同样的道理，计算机的世界也是不完美的，异常情况随时都会发生，我们所需要做的就是避免那些能够避免的异常，处理那些不能避免的异常。这里我将记录如何利用异常还程序一个“完美世界”。</p><h2 id=\"为什么要使用异常\"><a href=\"#为什么要使用异常\" class=\"headerlink\" title=\"为什么要使用异常\"></a>为什么要使用异常</h2>","more":"<p>首先我们可以明确一点就是异常的处理机制可以确保我们程序的健壮性，提高系统可用率。虽然我们不是特别喜欢看到它，但是我们不能不承认它的地位，作用。有异常就说明程序存在问题，有助于我们及时改正。在我们的程序设计当做，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：</p><pre><code>   1、 容易混淆。如果约定返回值为-11111时表示出现异常，那么当程序最后的计算结果真的为-1111呢？\n   2、 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。\n   3、 由调用函数来分析异常，这要求程序员对库函数有很深的了解。\n</code></pre><p>在OO中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。<br>在初学时，总是听老师说把有可能出错的地方记得加异常处理，刚刚开始还不明白，有时候还觉得只是多此一举，现在随着自己的不断深入，代码编写多了，渐渐明白了异常是非常重要的。</p><h2 id=\"基本定义\"><a href=\"#基本定义\" class=\"headerlink\" title=\"基本定义\"></a>基本定义</h2><p>在《Think in java》中是这样定义异常的：异常情形是指阻止当前方法或者作用域继续执行的问题。在这里一定要明确一点：异常代码某种程度的错误，尽管Java有异常处理机制，但是我们不能以“正常”的眼光来看待异常，异常处理机制的原因就是告诉你：这里可能会或者已经产生了错误，您的程序出现了不正常的情况，可能会导致程序失败！<br>那么什么时候才会出现异常呢？只有在你当前的环境下程序无法正常运行下去，也就是说程序已经无法来正确解决问题了，这时它所就会从当前环境中跳出，并抛出异常。抛出异常后，它首先会做几件事。首先，它会使用new创建一个异常对象，然后在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用，这时。异常处理机制就会接管程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态恢复，以使程序要么换一种方法执行，要么继续执行下去。<br>总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。</p><h2 id=\"异常体系\"><a href=\"#异常体系\" class=\"headerlink\" title=\"异常体系\"></a>异常体系</h2><p>java为我们提供了非常完美的异常处理机制，使得我们可以更加专心于我们的程序，在使用异常之前我们需要了解它的体系结构：如下（该图摘自：<a href=\"http://blog.csdn.net/zhangerqing/article/details/8248186\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zhangerqing/article/details/8248186</a> ）。<br><img src=\"/uploads/exception.png\" alt><br>从上面这幅图可以看出，Throwable是java语言中所有错误和异常的超类（万物即可抛）。它有两个子类：Error、Exception。<br>其中Error为错误，是程序无法处理的，如OutOfMemoryError、ThreadDeath等，出现这种情况你唯一能做的就是听之任之，交由JVM来处理，不过JVM在大多数情况下会选择终止线程。<br>而Exception是程序可以处理的异常。它又分为两种CheckedException（受捡异常），一种是UncheckedException（不受检异常）。其中CheckException发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。而UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的，难以排查，我们一般都需要纵观全局才能够发现这类的异常错误，所以在程序设计中我们需要认真考虑，好好写代码，尽量处理异常，即使产生了异常，也能尽量保证程序朝着有利方向发展。<br>所以：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。<br>java的异常类实在是太多了，产生的原因也千变万化，所以下篇博文我将会整理，统计java中经常出现的异常，望各位关注！！</p><h2 id=\"异常使用\"><a href=\"#异常使用\" class=\"headerlink\" title=\"异常使用\"></a>异常使用</h2><p>在网上看了这样一个搞笑的话：世界上最真情的相依，是你在try我在catch。无论你发神马脾气，我都默默承受，静静处理。对于初学者来说异常就是try…catch，（鄙人刚刚接触时也是这么认为的，碰到异常就是try…catch）。个人感觉try…catch确实是用的最多也是最实用的。<br>在异常中try快包含着可能出现异常的代码块，catch块捕获异常后对异常进行处理。先看如下实例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        String file = <span class=\"string\">\"D:\\\\exceptionTest.txt\"</span>;  </span><br><span class=\"line\">        FileReader reader;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            reader = <span class=\"keyword\">new</span> FileReader(file);  </span><br><span class=\"line\">            Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">            String string = in.next();    </span><br><span class=\"line\">            System.out.println(string + <span class=\"string\">\"不知道我有幸能够执行到不.....\"</span>);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"对不起,你执行不到...\"</span>);  </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        <span class=\"keyword\">finally</span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"finally 在执行...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是段非常简单的程序，用于读取D盘目录下的exceptionText.txt文件，同时读取其中的内容、输出。首先D盘没有该文件，运行程序结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  </span><br><span class=\"line\">    at java.io.FileInputStream.open(Native Method)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">106</span>)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">66</span>)  </span><br><span class=\"line\">    at java.io.FileReader.&lt;init&gt;(FileReader.java:<span class=\"number\">41</span>)  </span><br><span class=\"line\">    at com.test9.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">19</span>)  </span><br><span class=\"line\">对不起,你执行不到...  </span><br><span class=\"line\"><span class=\"keyword\">finally</span> 在执行...</span><br></pre></td></tr></table></figure><p></p><p>从这个结果我们可以看出这些：<br>1、当程序遇到异常时会终止程序的运行（即后面的代码不在执行），控制权交由异常处理机制处理。<br>2、catch捕捉异常后，执行里面的函数。<br>当我们在D盘目录下新建一个exceptionTest.txt文件后，运行程序结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1111</span>不知道我有幸能够执行到不.....  </span><br><span class=\"line\"><span class=\"keyword\">finally</span> 在执行...</span><br></pre></td></tr></table></figure><p></p><p>11111是该文件中的内容。从这个运行结果可以得出这个结果：不论程序是否发生异常，finally代码块总是会执行。所以finally一般用来关闭资源。<br>在这里我们在看如下程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExceptionTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] a = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;  </span><br><span class=\"line\">        System.out.println(a[<span class=\"number\">4</span>]);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我执行了吗???\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序运行结果：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.ArrayIndexOutOfBoundsException: <span class=\"number\">4</span>  </span><br><span class=\"line\">    at com.test9.ExceptionTest.main(ExceptionTest.java:<span class=\"number\">14</span>)</span><br></pre></td></tr></table></figure><p></p><p>各位请注意这个异常信息和上面的异常信息错误，为了看得更加清楚，我将他们列在一起：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.FileNotFoundException: D:\\exceptionTest.txt (系统找不到指定的文件。)  </span><br><span class=\"line\">        Exception in thread <span class=\"string\">\"main\"</span> java.lang.ArrayIndexOutOfBoundsException: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><p></p><p>在这里我们发现两个异常之间存在如下区别：第二个异常信息多了Exception in thread “main”，这显示了出现异常信息的位置。在这里可以得到如下结论：若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处。</p><!-- rebuild by neat -->"},{"title":"java提高篇(十七)-----异常(二)","abbrlink":"13bda316","date":"2017-10-23T14:38:47.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17651971\n\n## 自定义异常\nJava确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误，所以Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。\nJava自定义异常的使用要经历如下四个步骤：\n1、定义一个类继承Throwable或其子类。\n2、添加构造方法(当然也可以不用添加，使用默认构造方法)。\n3、在某个方法类抛出该异常。\n4、捕捉该异常。 \n  <!-- more -->\n```java\n/** 自定义异常 继承Exception类 **/  \npublic class MyException extends Exception{  \n    public MyException(){  \n          \n    }  \n      \n    public MyException(String message){  \n        super(message);  \n    }  \n}  \n\npublic class Test {  \n    public void display(int i) throws MyException{  \n        if(i == 0){  \n            throw new MyException(\"该值不能为0.......\");  \n        }  \n        else{  \n            System.out.println( i / 2);  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        Test test = new Test();  \n        try {  \n            test.display(0);  \n            System.out.println(\"---------------------\");  \n        } catch (MyException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n```\n运行结果：\n![](/uploads/exception2.png)\n## 异常链\n在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。\n我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。\n诚然在应用程序中，我们有时候不仅仅只需要封装异常，更需要传递。怎么传递？throws!！binge，正确！！但是如果仅仅只用throws抛出异常，那么你的封装类，怎么办？？\n我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。\n在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n语法：\n```java\npublic void test() throws XxxException{  \n        try {  \n            //do something:可能抛出异常信息的代码块  \n        } catch (Exception e) {  \n            throw new XxxException(e);  \n        }  \n    }  \n```\n示例：\n```java\npublic class Test {  \n    public void f() throws MyException{  \n         try {  \n            FileReader reader = new FileReader(\"G:\\\\myfile\\\\struts.txt\");    \n             Scanner in = new Scanner(reader);    \n             System.out.println(in.next());  \n        } catch (FileNotFoundException e) {  \n            //e 保存异常信息  \n            throw new MyException(\"文件没有找到--01\",e);  \n        }    \n    }  \n      \n    public void g() throws MyException{  \n        try {  \n            f();  \n        } catch (MyException e) {  \n            //e 保存异常信息  \n            throw new MyException(\"文件没有找到--02\",e);  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        Test t = new Test();  \n        try {  \n            t.g();  \n        } catch (MyException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n```\n运行结果:\n```java\ncom.test9.MyException: 文件没有找到--02  \n    at com.test9.Test.g(Test.java:31)  \n    at com.test9.Test.main(Test.java:38)  \nCaused by: com.test9.MyException: 文件没有找到--01  \n    at com.test9.Test.f(Test.java:22)  \n    at com.test9.Test.g(Test.java:28)  \n    ... 1 more  \nCaused by: java.io.FileNotFoundException: G:\\myfile\\struts.txt (系统找不到指定的路径。)  \n    at java.io.FileInputStream.open(Native Method)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:106)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:66)  \n    at java.io.FileReader.<init>(FileReader.java:41)  \n    at com.test9.Test.f(Test.java:17)  \n    ... 2 more  \n```\n如果在程序中,去掉e，也就是：throw new MyException(\"文件没有找到--02\");\n那么异常信息就保存不了，运行结果如下：\n```java\ncom.test9.MyException: 文件没有找到--02  \n    at com.test9.Test.g(Test.java:31)  \n    at com.test9.Test.main(Test.java:38)  \n```\n       PS:其实对于异常链鄙人使用的也不是很多，理解的不是很清楚，望各位指正！！！！\n## 异常的使用误区\n首先我们先看如下示例：该实例能够反映java异常的不正确使用（其实这也是我刚刚学Java时写的代码）！！\n```java\n    OutputStreamWriter out = null;  \n        java.sql.Connection conn = null;  \n        try {            //   ---------1  \n            Statement stat = conn.createStatement();  \n            ResultSet rs = stat.executeQuery(\"select *from user\");  \n            while (rs.next()){  \n                out.println(\"name:\" + rs.getString(\"name\") + \"sex:\"  \n                        + rs.getString(\"sex\"));  \n            }  \n            conn.close();         //------2  \n            out.close();  \n        }   \n        catch (Exception ex){    //------3  \n            ex.printStackTrace();    //------4  \n        }  \n```\n\n1、-----------1\n对于这个try…catch块，我想他的真正目的是捕获SQL的异常，但是这个try块是不是包含了太多的信息了。这是我们为了偷懒而养成的代码坏习惯。有些人喜欢将一大块的代码全部包含在一个try块里面，因为这样省事，反正有异常它就会抛出，而不愿意花时间来分析这个大代码块有那几块会产生异常，产生什么类型的异常，反正就是一篓子全部搞定。这就想我们出去旅游将所有的东西全部装进一个箱子里面，而不是分类来装，虽不知装进去容易，找出来难啊！！！所有对于一个异常块，我们应该仔细分清楚每块的抛出异常，因为一个大代码块有太多的地方会出现异常了。\n结论一：尽可能的减小try块！！！\n2、--------2\n在这里你发现了什么？异常改变了运行流程！！不错就是异常改变了程序运行流程。如果该程序发生了异常那么conn.close(); out.close();是不可能执行得到的，这样势必会导致资源不能释放掉。所以如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，我们也要确保能够正确释放占用的资源。这里finally就有用武之地了：不管是否出现了异常，finally总是有机会运行的，所以finally用于释放资源是再适合不过了。\n结论二：保证所有资源都被正确释放。充分运用finally关键词。\n3、----------3\n对于这个代码我想大部分人都是这样处理的，（LZ也是尴尬）。使用这样代码的人都有这样一个心理，一个catch解决所有异常，这样是可以，但是不推荐！为什么！首先我们需要明白catch块所表示是它预期会出现何种异常，并且需要做何种处理，而使用Exception就表示他要处理所有的异常信息，但是这样做有什么意义呢？\n这里我们再来看看上面的程序实例，很显然它可能需要抛出两个异常信息，SQLException和IOException。所以一个catch处理两个截然不同的Exception明显的不合适。如果用两个catch，一个处理SQLException、一个处理IOException就好多了。所以：\n结论三：catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。\n4、----------4\n这个就问题多多了，我敢保证几乎所有的人都这么使用过。这里涉及到了两个问题，一是，捕获了异常不做处理，二是异常信息不够明确。\n4.1、捕获异常不做处理，就是我们所谓的丢弃异常。我们都知道异常意味着程序出现了不可预期的问题，程序它希望我们能够做出处理来拯救它，但是你呢？一句ex.printStackTrace()搞定，这是多么的不负责任对程序的异常情况不理不顾。虽然这样在调试可能会有一定的帮助，但是调试阶段结束后呢？不是一句ex.printStackTrace()就可以搞定所有的事情的！\n那么怎么改进呢？有四种选择：\n1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.\n2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！\n3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。\n4、不要捕获异常。\n4.2、异常信息不明确。我想对于这样的：java.io.FileNotFoundException: ………信息除了我们IT人没有几个人看得懂和想看吧！所以在出现异常后，我们最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。起码我公司是需要将异常信息所在的类、方法、何种异常都需要记录在日志文件中的。\n所以：\n结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。\n结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。\n对于异常还有以下几个注意地方：\n六、不要在finally块中处理返回值。\n七、不要在构造函数中抛出异常。\n八、try…catch、throw、throws\n在这里主要是区分throw和throws。\nthrows是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！\n而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。\n```java\n//使用throws抛出异常  \n    public void f() throws MyException{  \n         try {  \n            FileReader reader = new FileReader(\"G:\\\\myfile\\\\struts.txt\");    \n             Scanner in = new Scanner(reader);    \n             System.out.println(in.next());  \n        } catch (FileNotFoundException e) {  \n            throw new MyException(\"文件没有找到\", e);    //throw  \n        }    \n          \n    }  \n```\n## 总结\n其实对于异常使用的优缺点现在确实存在很多的讨论。例如：http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html 。 这篇博文对于是否需要使用异常进行了比较深刻的讨论。LZ实乃菜鸟一枚，不能理解异常深奥之处。但是有一点LZ可以肯定，那就是异常必定会影响系统的性能。\n异常使用指南（摘自：Think in java）\n应该在下列情况下使用异常。\n\n    1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。\n    2、解决问题并且重新调用产生异常的方法。\n    3、进行少许修补，然后绕过异常发生的地方继续执行。\n    4、用别的数据进行计算，以代替方法预计会返回的值。\n    5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。\n    6、终止程序。\n    7、进行简化。\n    8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）\n","source":"_posts/java-toup17.md","raw":"---\ntitle: java提高篇(十七)-----异常(二)\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 13bda316\ndate: 2017-10-23 22:38:47\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17651971\n\n## 自定义异常\nJava确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误，所以Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。\nJava自定义异常的使用要经历如下四个步骤：\n1、定义一个类继承Throwable或其子类。\n2、添加构造方法(当然也可以不用添加，使用默认构造方法)。\n3、在某个方法类抛出该异常。\n4、捕捉该异常。 \n  <!-- more -->\n```java\n/** 自定义异常 继承Exception类 **/  \npublic class MyException extends Exception{  \n    public MyException(){  \n          \n    }  \n      \n    public MyException(String message){  \n        super(message);  \n    }  \n}  \n\npublic class Test {  \n    public void display(int i) throws MyException{  \n        if(i == 0){  \n            throw new MyException(\"该值不能为0.......\");  \n        }  \n        else{  \n            System.out.println( i / 2);  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        Test test = new Test();  \n        try {  \n            test.display(0);  \n            System.out.println(\"---------------------\");  \n        } catch (MyException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n```\n运行结果：\n![](/uploads/exception2.png)\n## 异常链\n在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。\n我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。\n诚然在应用程序中，我们有时候不仅仅只需要封装异常，更需要传递。怎么传递？throws!！binge，正确！！但是如果仅仅只用throws抛出异常，那么你的封装类，怎么办？？\n我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。\n在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。\n语法：\n```java\npublic void test() throws XxxException{  \n        try {  \n            //do something:可能抛出异常信息的代码块  \n        } catch (Exception e) {  \n            throw new XxxException(e);  \n        }  \n    }  \n```\n示例：\n```java\npublic class Test {  \n    public void f() throws MyException{  \n         try {  \n            FileReader reader = new FileReader(\"G:\\\\myfile\\\\struts.txt\");    \n             Scanner in = new Scanner(reader);    \n             System.out.println(in.next());  \n        } catch (FileNotFoundException e) {  \n            //e 保存异常信息  \n            throw new MyException(\"文件没有找到--01\",e);  \n        }    \n    }  \n      \n    public void g() throws MyException{  \n        try {  \n            f();  \n        } catch (MyException e) {  \n            //e 保存异常信息  \n            throw new MyException(\"文件没有找到--02\",e);  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        Test t = new Test();  \n        try {  \n            t.g();  \n        } catch (MyException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n}  \n```\n运行结果:\n```java\ncom.test9.MyException: 文件没有找到--02  \n    at com.test9.Test.g(Test.java:31)  \n    at com.test9.Test.main(Test.java:38)  \nCaused by: com.test9.MyException: 文件没有找到--01  \n    at com.test9.Test.f(Test.java:22)  \n    at com.test9.Test.g(Test.java:28)  \n    ... 1 more  \nCaused by: java.io.FileNotFoundException: G:\\myfile\\struts.txt (系统找不到指定的路径。)  \n    at java.io.FileInputStream.open(Native Method)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:106)  \n    at java.io.FileInputStream.<init>(FileInputStream.java:66)  \n    at java.io.FileReader.<init>(FileReader.java:41)  \n    at com.test9.Test.f(Test.java:17)  \n    ... 2 more  \n```\n如果在程序中,去掉e，也就是：throw new MyException(\"文件没有找到--02\");\n那么异常信息就保存不了，运行结果如下：\n```java\ncom.test9.MyException: 文件没有找到--02  \n    at com.test9.Test.g(Test.java:31)  \n    at com.test9.Test.main(Test.java:38)  \n```\n       PS:其实对于异常链鄙人使用的也不是很多，理解的不是很清楚，望各位指正！！！！\n## 异常的使用误区\n首先我们先看如下示例：该实例能够反映java异常的不正确使用（其实这也是我刚刚学Java时写的代码）！！\n```java\n    OutputStreamWriter out = null;  \n        java.sql.Connection conn = null;  \n        try {            //   ---------1  \n            Statement stat = conn.createStatement();  \n            ResultSet rs = stat.executeQuery(\"select *from user\");  \n            while (rs.next()){  \n                out.println(\"name:\" + rs.getString(\"name\") + \"sex:\"  \n                        + rs.getString(\"sex\"));  \n            }  \n            conn.close();         //------2  \n            out.close();  \n        }   \n        catch (Exception ex){    //------3  \n            ex.printStackTrace();    //------4  \n        }  \n```\n\n1、-----------1\n对于这个try…catch块，我想他的真正目的是捕获SQL的异常，但是这个try块是不是包含了太多的信息了。这是我们为了偷懒而养成的代码坏习惯。有些人喜欢将一大块的代码全部包含在一个try块里面，因为这样省事，反正有异常它就会抛出，而不愿意花时间来分析这个大代码块有那几块会产生异常，产生什么类型的异常，反正就是一篓子全部搞定。这就想我们出去旅游将所有的东西全部装进一个箱子里面，而不是分类来装，虽不知装进去容易，找出来难啊！！！所有对于一个异常块，我们应该仔细分清楚每块的抛出异常，因为一个大代码块有太多的地方会出现异常了。\n结论一：尽可能的减小try块！！！\n2、--------2\n在这里你发现了什么？异常改变了运行流程！！不错就是异常改变了程序运行流程。如果该程序发生了异常那么conn.close(); out.close();是不可能执行得到的，这样势必会导致资源不能释放掉。所以如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，我们也要确保能够正确释放占用的资源。这里finally就有用武之地了：不管是否出现了异常，finally总是有机会运行的，所以finally用于释放资源是再适合不过了。\n结论二：保证所有资源都被正确释放。充分运用finally关键词。\n3、----------3\n对于这个代码我想大部分人都是这样处理的，（LZ也是尴尬）。使用这样代码的人都有这样一个心理，一个catch解决所有异常，这样是可以，但是不推荐！为什么！首先我们需要明白catch块所表示是它预期会出现何种异常，并且需要做何种处理，而使用Exception就表示他要处理所有的异常信息，但是这样做有什么意义呢？\n这里我们再来看看上面的程序实例，很显然它可能需要抛出两个异常信息，SQLException和IOException。所以一个catch处理两个截然不同的Exception明显的不合适。如果用两个catch，一个处理SQLException、一个处理IOException就好多了。所以：\n结论三：catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。\n4、----------4\n这个就问题多多了，我敢保证几乎所有的人都这么使用过。这里涉及到了两个问题，一是，捕获了异常不做处理，二是异常信息不够明确。\n4.1、捕获异常不做处理，就是我们所谓的丢弃异常。我们都知道异常意味着程序出现了不可预期的问题，程序它希望我们能够做出处理来拯救它，但是你呢？一句ex.printStackTrace()搞定，这是多么的不负责任对程序的异常情况不理不顾。虽然这样在调试可能会有一定的帮助，但是调试阶段结束后呢？不是一句ex.printStackTrace()就可以搞定所有的事情的！\n那么怎么改进呢？有四种选择：\n1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.\n2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！\n3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。\n4、不要捕获异常。\n4.2、异常信息不明确。我想对于这样的：java.io.FileNotFoundException: ………信息除了我们IT人没有几个人看得懂和想看吧！所以在出现异常后，我们最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。起码我公司是需要将异常信息所在的类、方法、何种异常都需要记录在日志文件中的。\n所以：\n结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。\n结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。\n对于异常还有以下几个注意地方：\n六、不要在finally块中处理返回值。\n七、不要在构造函数中抛出异常。\n八、try…catch、throw、throws\n在这里主要是区分throw和throws。\nthrows是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！\n而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。\n```java\n//使用throws抛出异常  \n    public void f() throws MyException{  \n         try {  \n            FileReader reader = new FileReader(\"G:\\\\myfile\\\\struts.txt\");    \n             Scanner in = new Scanner(reader);    \n             System.out.println(in.next());  \n        } catch (FileNotFoundException e) {  \n            throw new MyException(\"文件没有找到\", e);    //throw  \n        }    \n          \n    }  \n```\n## 总结\n其实对于异常使用的优缺点现在确实存在很多的讨论。例如：http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html 。 这篇博文对于是否需要使用异常进行了比较深刻的讨论。LZ实乃菜鸟一枚，不能理解异常深奥之处。但是有一点LZ可以肯定，那就是异常必定会影响系统的性能。\n异常使用指南（摘自：Think in java）\n应该在下列情况下使用异常。\n\n    1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。\n    2、解决问题并且重新调用产生异常的方法。\n    3、进行少许修补，然后绕过异常发生的地方继续执行。\n    4、用别的数据进行计算，以代替方法预计会返回的值。\n    5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。\n    6、终止程序。\n    7、进行简化。\n    8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）\n","slug":"java-toup17","published":1,"updated":"2019-09-03T03:40:46.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketea00190vfaz6p12m6y","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17651971\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17651971</a></p></blockquote><h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><p>Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误，所以Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。<br>Java自定义异常的使用要经历如下四个步骤：<br>1、定义一个类继承Throwable或其子类。<br>2、添加构造方法(当然也可以不用添加，使用默认构造方法)。<br>3、在某个方法类抛出该异常。<br>4、捕捉该异常。<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 自定义异常 继承Exception类 **/</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">(String message)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"该值不能为0.......\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            System.out.println( i / <span class=\"number\">2</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            test.display(<span class=\"number\">0</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br><img src=\"/uploads/exception2.png\" alt></p><h2 id=\"异常链\"><a href=\"#异常链\" class=\"headerlink\" title=\"异常链\"></a>异常链</h2><p>在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。<br>我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。<br>诚然在应用程序中，我们有时候不仅仅只需要封装异常，更需要传递。怎么传递？throws!！binge，正确！！但是如果仅仅只用throws抛出异常，那么你的封装类，怎么办？？<br>我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。<br>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。<br>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。<br>在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。<br>语法：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> XxxException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//do something:可能抛出异常信息的代码块  </span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> XxxException(e);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            FileReader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"G:\\\\myfile\\\\struts.txt\"</span>);    </span><br><span class=\"line\">             Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">             System.out.println(in.next());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//e 保存异常信息  </span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到--01\"</span>,e);  </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            f();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//e 保存异常信息  </span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到--02\"</span>,e);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test t = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            t.g();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.test9.MyException: 文件没有找到--<span class=\"number\">02</span>  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">31</span>)  </span><br><span class=\"line\">    at com.test9.Test.main(Test.java:<span class=\"number\">38</span>)  </span><br><span class=\"line\">Caused by: com.test9.MyException: 文件没有找到--<span class=\"number\">01</span>  </span><br><span class=\"line\">    at com.test9.Test.f(Test.java:<span class=\"number\">22</span>)  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">28</span>)  </span><br><span class=\"line\">    ... <span class=\"number\">1</span> more  </span><br><span class=\"line\">Caused by: java.io.FileNotFoundException: G:\\myfile\\struts.txt (系统找不到指定的路径。)  </span><br><span class=\"line\">    at java.io.FileInputStream.open(Native Method)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">106</span>)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">66</span>)  </span><br><span class=\"line\">    at java.io.FileReader.&lt;init&gt;(FileReader.java:<span class=\"number\">41</span>)  </span><br><span class=\"line\">    at com.test9.Test.f(Test.java:<span class=\"number\">17</span>)  </span><br><span class=\"line\">    ... <span class=\"number\">2</span> more</span><br></pre></td></tr></table></figure><p></p><p>如果在程序中,去掉e，也就是：throw new MyException(“文件没有找到—02”);<br>那么异常信息就保存不了，运行结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.test9.MyException: 文件没有找到--<span class=\"number\">02</span>  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">31</span>)  </span><br><span class=\"line\">    at com.test9.Test.main(Test.java:<span class=\"number\">38</span>)</span><br></pre></td></tr></table></figure><p></p><pre><code>   PS:其实对于异常链鄙人使用的也不是很多，理解的不是很清楚，望各位指正！！！！\n</code></pre><h2 id=\"异常的使用误区\"><a href=\"#异常的使用误区\" class=\"headerlink\" title=\"异常的使用误区\"></a>异常的使用误区</h2><p>首先我们先看如下示例：该实例能够反映java异常的不正确使用（其实这也是我刚刚学Java时写的代码）！！<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter out = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    java.sql.Connection conn = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;            <span class=\"comment\">//   ---------1  </span></span><br><span class=\"line\">        Statement stat = conn.createStatement();  </span><br><span class=\"line\">        ResultSet rs = stat.executeQuery(<span class=\"string\">\"select *from user\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rs.next())&#123;  </span><br><span class=\"line\">            out.println(<span class=\"string\">\"name:\"</span> + rs.getString(<span class=\"string\">\"name\"</span>) + <span class=\"string\">\"sex:\"</span>  </span><br><span class=\"line\">                    + rs.getString(<span class=\"string\">\"sex\"</span>));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        conn.close();         <span class=\"comment\">//------2  </span></span><br><span class=\"line\">        out.close();  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)&#123;    <span class=\"comment\">//------3  </span></span><br><span class=\"line\">        ex.printStackTrace();    <span class=\"comment\">//------4  </span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>1、—————-1<br>对于这个try…catch块，我想他的真正目的是捕获SQL的异常，但是这个try块是不是包含了太多的信息了。这是我们为了偷懒而养成的代码坏习惯。有些人喜欢将一大块的代码全部包含在一个try块里面，因为这样省事，反正有异常它就会抛出，而不愿意花时间来分析这个大代码块有那几块会产生异常，产生什么类型的异常，反正就是一篓子全部搞定。这就想我们出去旅游将所有的东西全部装进一个箱子里面，而不是分类来装，虽不知装进去容易，找出来难啊！！！所有对于一个异常块，我们应该仔细分清楚每块的抛出异常，因为一个大代码块有太多的地方会出现异常了。<br>结论一：尽可能的减小try块！！！<br>2、————2<br>在这里你发现了什么？异常改变了运行流程！！不错就是异常改变了程序运行流程。如果该程序发生了异常那么conn.close(); out.close();是不可能执行得到的，这样势必会导致资源不能释放掉。所以如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，我们也要确保能够正确释放占用的资源。这里finally就有用武之地了：不管是否出现了异常，finally总是有机会运行的，所以finally用于释放资源是再适合不过了。<br>结论二：保证所有资源都被正确释放。充分运用finally关键词。<br>3、—————3<br>对于这个代码我想大部分人都是这样处理的，（LZ也是尴尬）。使用这样代码的人都有这样一个心理，一个catch解决所有异常，这样是可以，但是不推荐！为什么！首先我们需要明白catch块所表示是它预期会出现何种异常，并且需要做何种处理，而使用Exception就表示他要处理所有的异常信息，但是这样做有什么意义呢？<br>这里我们再来看看上面的程序实例，很显然它可能需要抛出两个异常信息，SQLException和IOException。所以一个catch处理两个截然不同的Exception明显的不合适。如果用两个catch，一个处理SQLException、一个处理IOException就好多了。所以：<br>结论三：catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。<br>4、—————4<br>这个就问题多多了，我敢保证几乎所有的人都这么使用过。这里涉及到了两个问题，一是，捕获了异常不做处理，二是异常信息不够明确。<br>4.1、捕获异常不做处理，就是我们所谓的丢弃异常。我们都知道异常意味着程序出现了不可预期的问题，程序它希望我们能够做出处理来拯救它，但是你呢？一句ex.printStackTrace()搞定，这是多么的不负责任对程序的异常情况不理不顾。虽然这样在调试可能会有一定的帮助，但是调试阶段结束后呢？不是一句ex.printStackTrace()就可以搞定所有的事情的！<br>那么怎么改进呢？有四种选择：<br>1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.<br>2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！<br>3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。<br>4、不要捕获异常。<br>4.2、异常信息不明确。我想对于这样的：java.io.FileNotFoundException: ………信息除了我们IT人没有几个人看得懂和想看吧！所以在出现异常后，我们最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。起码我公司是需要将异常信息所在的类、方法、何种异常都需要记录在日志文件中的。<br>所以：<br>结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。<br>结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。<br>对于异常还有以下几个注意地方：<br>六、不要在finally块中处理返回值。<br>七、不要在构造函数中抛出异常。<br>八、try…catch、throw、throws<br>在这里主要是区分throw和throws。<br>throws是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！<br>而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用throws抛出异常  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            FileReader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"G:\\\\myfile\\\\struts.txt\"</span>);    </span><br><span class=\"line\">             Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">             System.out.println(in.next());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到\"</span>, e);    <span class=\"comment\">//throw  </span></span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实对于异常使用的优缺点现在确实存在很多的讨论。例如：<a href=\"http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html</a> 。 这篇博文对于是否需要使用异常进行了比较深刻的讨论。LZ实乃菜鸟一枚，不能理解异常深奥之处。但是有一点LZ可以肯定，那就是异常必定会影响系统的性能。<br>异常使用指南（摘自：Think in java）<br>应该在下列情况下使用异常。</p><pre><code>1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。\n2、解决问题并且重新调用产生异常的方法。\n3、进行少许修补，然后绕过异常发生的地方继续执行。\n4、用别的数据进行计算，以代替方法预计会返回的值。\n5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。\n6、终止程序。\n7、进行简化。\n8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）\n</code></pre><!-- rebuild by neat -->","site":{"data":{}},"length":7295,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17651971\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17651971</a></p></blockquote><h2 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h2><p>Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误，所以Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。<br>Java自定义异常的使用要经历如下四个步骤：<br>1、定义一个类继承Throwable或其子类。<br>2、添加构造方法(当然也可以不用添加，使用默认构造方法)。<br>3、在某个方法类抛出该异常。<br>4、捕捉该异常。<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 自定义异常 继承Exception类 **/</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">(String message)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"该值不能为0.......\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            System.out.println( i / <span class=\"number\">2</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            test.display(<span class=\"number\">0</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br><img src=\"/uploads/exception2.png\" alt></p><h2 id=\"异常链\"><a href=\"#异常链\" class=\"headerlink\" title=\"异常链\"></a>异常链</h2><p>在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。<br>我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。<br>诚然在应用程序中，我们有时候不仅仅只需要封装异常，更需要传递。怎么传递？throws!！binge，正确！！但是如果仅仅只用throws抛出异常，那么你的封装类，怎么办？？<br>我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。<br>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。<br>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。<br>在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。<br>语法：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> XxxException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//do something:可能抛出异常信息的代码块  </span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> XxxException(e);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>示例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            FileReader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"G:\\\\myfile\\\\struts.txt\"</span>);    </span><br><span class=\"line\">             Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">             System.out.println(in.next());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//e 保存异常信息  </span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到--01\"</span>,e);  </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            f();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//e 保存异常信息  </span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到--02\"</span>,e);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Test t = <span class=\"keyword\">new</span> Test();  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            t.g();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (MyException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.test9.MyException: 文件没有找到--<span class=\"number\">02</span>  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">31</span>)  </span><br><span class=\"line\">    at com.test9.Test.main(Test.java:<span class=\"number\">38</span>)  </span><br><span class=\"line\">Caused by: com.test9.MyException: 文件没有找到--<span class=\"number\">01</span>  </span><br><span class=\"line\">    at com.test9.Test.f(Test.java:<span class=\"number\">22</span>)  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">28</span>)  </span><br><span class=\"line\">    ... <span class=\"number\">1</span> more  </span><br><span class=\"line\">Caused by: java.io.FileNotFoundException: G:\\myfile\\struts.txt (系统找不到指定的路径。)  </span><br><span class=\"line\">    at java.io.FileInputStream.open(Native Method)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">106</span>)  </span><br><span class=\"line\">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:<span class=\"number\">66</span>)  </span><br><span class=\"line\">    at java.io.FileReader.&lt;init&gt;(FileReader.java:<span class=\"number\">41</span>)  </span><br><span class=\"line\">    at com.test9.Test.f(Test.java:<span class=\"number\">17</span>)  </span><br><span class=\"line\">    ... <span class=\"number\">2</span> more</span><br></pre></td></tr></table></figure><p></p><p>如果在程序中,去掉e，也就是：throw new MyException(“文件没有找到—02”);<br>那么异常信息就保存不了，运行结果如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">com.test9.MyException: 文件没有找到--<span class=\"number\">02</span>  </span><br><span class=\"line\">    at com.test9.Test.g(Test.java:<span class=\"number\">31</span>)  </span><br><span class=\"line\">    at com.test9.Test.main(Test.java:<span class=\"number\">38</span>)</span><br></pre></td></tr></table></figure><p></p><pre><code>   PS:其实对于异常链鄙人使用的也不是很多，理解的不是很清楚，望各位指正！！！！\n</code></pre><h2 id=\"异常的使用误区\"><a href=\"#异常的使用误区\" class=\"headerlink\" title=\"异常的使用误区\"></a>异常的使用误区</h2><p>首先我们先看如下示例：该实例能够反映java异常的不正确使用（其实这也是我刚刚学Java时写的代码）！！<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter out = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    java.sql.Connection conn = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;            <span class=\"comment\">//   ---------1  </span></span><br><span class=\"line\">        Statement stat = conn.createStatement();  </span><br><span class=\"line\">        ResultSet rs = stat.executeQuery(<span class=\"string\">\"select *from user\"</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (rs.next())&#123;  </span><br><span class=\"line\">            out.println(<span class=\"string\">\"name:\"</span> + rs.getString(<span class=\"string\">\"name\"</span>) + <span class=\"string\">\"sex:\"</span>  </span><br><span class=\"line\">                    + rs.getString(<span class=\"string\">\"sex\"</span>));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        conn.close();         <span class=\"comment\">//------2  </span></span><br><span class=\"line\">        out.close();  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Exception ex)&#123;    <span class=\"comment\">//------3  </span></span><br><span class=\"line\">        ex.printStackTrace();    <span class=\"comment\">//------4  </span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>1、—————-1<br>对于这个try…catch块，我想他的真正目的是捕获SQL的异常，但是这个try块是不是包含了太多的信息了。这是我们为了偷懒而养成的代码坏习惯。有些人喜欢将一大块的代码全部包含在一个try块里面，因为这样省事，反正有异常它就会抛出，而不愿意花时间来分析这个大代码块有那几块会产生异常，产生什么类型的异常，反正就是一篓子全部搞定。这就想我们出去旅游将所有的东西全部装进一个箱子里面，而不是分类来装，虽不知装进去容易，找出来难啊！！！所有对于一个异常块，我们应该仔细分清楚每块的抛出异常，因为一个大代码块有太多的地方会出现异常了。<br>结论一：尽可能的减小try块！！！<br>2、————2<br>在这里你发现了什么？异常改变了运行流程！！不错就是异常改变了程序运行流程。如果该程序发生了异常那么conn.close(); out.close();是不可能执行得到的，这样势必会导致资源不能释放掉。所以如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，我们也要确保能够正确释放占用的资源。这里finally就有用武之地了：不管是否出现了异常，finally总是有机会运行的，所以finally用于释放资源是再适合不过了。<br>结论二：保证所有资源都被正确释放。充分运用finally关键词。<br>3、—————3<br>对于这个代码我想大部分人都是这样处理的，（LZ也是尴尬）。使用这样代码的人都有这样一个心理，一个catch解决所有异常，这样是可以，但是不推荐！为什么！首先我们需要明白catch块所表示是它预期会出现何种异常，并且需要做何种处理，而使用Exception就表示他要处理所有的异常信息，但是这样做有什么意义呢？<br>这里我们再来看看上面的程序实例，很显然它可能需要抛出两个异常信息，SQLException和IOException。所以一个catch处理两个截然不同的Exception明显的不合适。如果用两个catch，一个处理SQLException、一个处理IOException就好多了。所以：<br>结论三：catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。<br>4、—————4<br>这个就问题多多了，我敢保证几乎所有的人都这么使用过。这里涉及到了两个问题，一是，捕获了异常不做处理，二是异常信息不够明确。<br>4.1、捕获异常不做处理，就是我们所谓的丢弃异常。我们都知道异常意味着程序出现了不可预期的问题，程序它希望我们能够做出处理来拯救它，但是你呢？一句ex.printStackTrace()搞定，这是多么的不负责任对程序的异常情况不理不顾。虽然这样在调试可能会有一定的帮助，但是调试阶段结束后呢？不是一句ex.printStackTrace()就可以搞定所有的事情的！<br>那么怎么改进呢？有四种选择：<br>1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.<br>2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！<br>3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。<br>4、不要捕获异常。<br>4.2、异常信息不明确。我想对于这样的：java.io.FileNotFoundException: ………信息除了我们IT人没有几个人看得懂和想看吧！所以在出现异常后，我们最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。起码我公司是需要将异常信息所在的类、方法、何种异常都需要记录在日志文件中的。<br>所以：<br>结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。<br>结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。<br>对于异常还有以下几个注意地方：<br>六、不要在finally块中处理返回值。<br>七、不要在构造函数中抛出异常。<br>八、try…catch、throw、throws<br>在这里主要是区分throw和throws。<br>throws是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！<br>而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用throws抛出异常  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> MyException</span>&#123;  </span><br><span class=\"line\">         <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            FileReader reader = <span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"G:\\\\myfile\\\\struts.txt\"</span>);    </span><br><span class=\"line\">             Scanner in = <span class=\"keyword\">new</span> Scanner(reader);    </span><br><span class=\"line\">             System.out.println(in.next());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"文件没有找到\"</span>, e);    <span class=\"comment\">//throw  </span></span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实对于异常使用的优缺点现在确实存在很多的讨论。例如：<a href=\"http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html</a> 。 这篇博文对于是否需要使用异常进行了比较深刻的讨论。LZ实乃菜鸟一枚，不能理解异常深奥之处。但是有一点LZ可以肯定，那就是异常必定会影响系统的性能。<br>异常使用指南（摘自：Think in java）<br>应该在下列情况下使用异常。</p><pre><code>1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。\n2、解决问题并且重新调用产生异常的方法。\n3、进行少许修补，然后绕过异常发生的地方继续执行。\n4、用别的数据进行计算，以代替方法预计会返回的值。\n5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。\n6、终止程序。\n7、进行简化。\n8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）\n</code></pre><!-- rebuild by neat -->"},{"title":"java提高篇(十八)-----数组之一：认识JAVA数组","abbrlink":"c15f12bd","date":"2017-10-23T14:38:52.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17732783\n\n\n## 什么是数组\n数组？什么是数组？在我印象中的数组是应该这样的：通过new关键字创建并组装他们，通过使用整形索引值访问它的元素，并且它的尺寸是不可变的！\n但是这只是数组的最表面的东西！深一点？就是这样：数组是一个简单的复合数据类型，它是一系列有序数据的集合，它当中的每一个数据都具有相同的数据类型，我们通过数组名加上一个不会越界下标值来唯一确定数组中的元素。\n还有更深的，那就是数组是一个特殊的对象！！（对于这个LZ理解的不是很好，对JVM也没有看，所以见解有限）。以下参考文献：http://developer.51cto.com/art/201001/176671.htm 、 http://www.blogjava.net/flysky19/articles/92763.html?opt=admin\n不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。\n<!-- more -->\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array = new int[10];  \n        System.out.println(\"array的父类是：\" + array.getClass().getSuperclass());  \n        System.out.println(\"array的类名是：\" + array.getClass().getName());  \n    }  \n}  \n-------Output:  \narray的父类是：class java.lang.Object  \narray的类名是：[I  \n```\n从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个\"[I”都不是一个合法标识符。怎么定义成类啊？所以我认为SUM那帮天才肯定对数组的底层肯定做了特殊的处理。\n我们再看如下示例：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array_00 = new int[10];  \n        System.out.println(\"一维数组：\" + array_00.getClass().getName());  \n        int[][] array_01 = new int[10][10];  \n        System.out.println(\"二维数组：\" + array_01.getClass().getName());  \n          \n        int[][][] array_02 = new int[10][10][10];  \n        System.out.println(\"三维数组：\" + array_02.getClass().getName());  \n    }  \n}  \n-----------------Output:  \n一维数组：[I  \n二维数组：[[I  \n三维数组：[[[I  \n```\n通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个'['和数组元素类型的内部名称组成。不清楚我们再看：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        System.out.println(\"Object[]:\" + Object[].class);  \n        System.out.println(\"Object[][]:\" + Object[][].class);  \n        System.err.println(\"Object[][][]:\" + Object[][][].class);  \n        System.out.println(\"Object:\" + Object.class);  \n    }  \n}  \n---------Output:  \nObject[]:class [Ljava.lang.Object;  \nObject[][]:class [[Ljava.lang.Object;  \nObject[][][]:class [[[Ljava.lang.Object;  \nObject:class java.lang.Object  \n```\n从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。\n我们暂且不论这个[I是什么东东，是由谁来声明的，怎么声明的（这些我现在也不知道！但是有一点可以确认：这个是在运行时确定的）。先看如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array = new int[10];  \n        Class clazz = array.getClass();     \n        System.out.println(clazz.getDeclaredFields().length);     \n        System.out.println(clazz.getDeclaredMethods().length);     \n        System.out.println(clazz.getDeclaredConstructors().length);     \n        System.out.println(clazz.getDeclaredAnnotations().length);     \n        System.out.println(clazz.getDeclaredClasses().length);     \n    }  \n}  \n----------------Output：  \n0  \n0  \n0  \n0  \n0  \n```\n从这个运行结果可以看出，我们亲爱的[I没有生命任何成员变量、成员方法、构造函数、Annotation甚至连length成员变量这个都没有，它就是一个彻彻底底的空类。没有声明length，那么我们array.length时，编译器怎么不会报错呢？确实，数组的length是一个非常特殊的成员变量。我们知道数组的是Object的直接之类，但是Object是没有length这个成员变量的，那么length应该是数组的成员变量，但是从上面的示例中，我们发现数组根本就没有任何成员变量，这两者不是相互矛盾么？\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        int a[] = new int[2];  \n        int i = a.length;  \n    }  \n}  \n```\n打开class文件，得到main方法的字节码：\n```java\n0 iconst_2                   //将int型常量2压入操作数栈    \n    1 newarray 10 (int)          //将2弹出操作数栈，作为长度，创建一个元素类型为int, 维度为1的数组，并将数组的引用压入操作数栈    \n    3 astore_1                   //将数组的引用从操作数栈中弹出，保存在索引为1的局部变量(即a)中    \n    4 aload_1                    //将索引为1的局部变量(即a)压入操作数栈    \n    5 arraylength                //从操作数栈弹出数组引用(即a)，并获取其长度(JVM负责实现如何获取)，并将长度压入操作数栈    \n    6 istore_2                   //将数组长度从操作数栈弹出，保存在索引为2的局部变量(即i)中    \n    7 return                     //main方法返回  \n```\n在这个字节码中我们还是没有看到length这个成员变量，但是看到了这个:arraylength ,这条指令是用来获取数组的长度的，所以说JVM对数组的长度做了特殊的处理，它是通过arraylength这条指令来实现的。\n## 数组的使用方法\n通过上面算是对数组是什么有了一个初步的认识，下面将简单介绍数组的使用方法。\n数组的使用方法无非就是四个步骤：声明数组、分配空间、赋值、处理。\n声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。\n分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10];\n赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式：\n```java\nint a[] = new int[2];    //默认为0,如果是引用数据类型就为null  \n        int b[] = new int[] {1,2,3,4,5};      \n        int c[] = {1,2,3,4,5};  \n```\n处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。\nPS：**由于能力有限，所以“什么是数组”主要是参考这篇博文：http://developer.51cto.com/art/201001/176671.htm 。下篇将更多的介绍数组的一些特性，例如：效率问题、Array的使用、浅拷贝以及与list之间的转换问题。**\n","source":"_posts/java-toup18.md","raw":"---\ntitle: java提高篇(十八)-----数组之一：认识JAVA数组\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: c15f12bd\ndate: 2017-10-23 22:38:52\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17732783\n\n\n## 什么是数组\n数组？什么是数组？在我印象中的数组是应该这样的：通过new关键字创建并组装他们，通过使用整形索引值访问它的元素，并且它的尺寸是不可变的！\n但是这只是数组的最表面的东西！深一点？就是这样：数组是一个简单的复合数据类型，它是一系列有序数据的集合，它当中的每一个数据都具有相同的数据类型，我们通过数组名加上一个不会越界下标值来唯一确定数组中的元素。\n还有更深的，那就是数组是一个特殊的对象！！（对于这个LZ理解的不是很好，对JVM也没有看，所以见解有限）。以下参考文献：http://developer.51cto.com/art/201001/176671.htm 、 http://www.blogjava.net/flysky19/articles/92763.html?opt=admin\n不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。\n<!-- more -->\n\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array = new int[10];  \n        System.out.println(\"array的父类是：\" + array.getClass().getSuperclass());  \n        System.out.println(\"array的类名是：\" + array.getClass().getName());  \n    }  \n}  \n-------Output:  \narray的父类是：class java.lang.Object  \narray的类名是：[I  \n```\n从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个\"[I”都不是一个合法标识符。怎么定义成类啊？所以我认为SUM那帮天才肯定对数组的底层肯定做了特殊的处理。\n我们再看如下示例：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array_00 = new int[10];  \n        System.out.println(\"一维数组：\" + array_00.getClass().getName());  \n        int[][] array_01 = new int[10][10];  \n        System.out.println(\"二维数组：\" + array_01.getClass().getName());  \n          \n        int[][][] array_02 = new int[10][10][10];  \n        System.out.println(\"三维数组：\" + array_02.getClass().getName());  \n    }  \n}  \n-----------------Output:  \n一维数组：[I  \n二维数组：[[I  \n三维数组：[[[I  \n```\n通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个'['和数组元素类型的内部名称组成。不清楚我们再看：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        System.out.println(\"Object[]:\" + Object[].class);  \n        System.out.println(\"Object[][]:\" + Object[][].class);  \n        System.err.println(\"Object[][][]:\" + Object[][][].class);  \n        System.out.println(\"Object:\" + Object.class);  \n    }  \n}  \n---------Output:  \nObject[]:class [Ljava.lang.Object;  \nObject[][]:class [[Ljava.lang.Object;  \nObject[][][]:class [[[Ljava.lang.Object;  \nObject:class java.lang.Object  \n```\n从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。\n我们暂且不论这个[I是什么东东，是由谁来声明的，怎么声明的（这些我现在也不知道！但是有一点可以确认：这个是在运行时确定的）。先看如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        int[] array = new int[10];  \n        Class clazz = array.getClass();     \n        System.out.println(clazz.getDeclaredFields().length);     \n        System.out.println(clazz.getDeclaredMethods().length);     \n        System.out.println(clazz.getDeclaredConstructors().length);     \n        System.out.println(clazz.getDeclaredAnnotations().length);     \n        System.out.println(clazz.getDeclaredClasses().length);     \n    }  \n}  \n----------------Output：  \n0  \n0  \n0  \n0  \n0  \n```\n从这个运行结果可以看出，我们亲爱的[I没有生命任何成员变量、成员方法、构造函数、Annotation甚至连length成员变量这个都没有，它就是一个彻彻底底的空类。没有声明length，那么我们array.length时，编译器怎么不会报错呢？确实，数组的length是一个非常特殊的成员变量。我们知道数组的是Object的直接之类，但是Object是没有length这个成员变量的，那么length应该是数组的成员变量，但是从上面的示例中，我们发现数组根本就没有任何成员变量，这两者不是相互矛盾么？\n```java\npublic class Main {  \n    public static void main(String[] args) {  \n        int a[] = new int[2];  \n        int i = a.length;  \n    }  \n}  \n```\n打开class文件，得到main方法的字节码：\n```java\n0 iconst_2                   //将int型常量2压入操作数栈    \n    1 newarray 10 (int)          //将2弹出操作数栈，作为长度，创建一个元素类型为int, 维度为1的数组，并将数组的引用压入操作数栈    \n    3 astore_1                   //将数组的引用从操作数栈中弹出，保存在索引为1的局部变量(即a)中    \n    4 aload_1                    //将索引为1的局部变量(即a)压入操作数栈    \n    5 arraylength                //从操作数栈弹出数组引用(即a)，并获取其长度(JVM负责实现如何获取)，并将长度压入操作数栈    \n    6 istore_2                   //将数组长度从操作数栈弹出，保存在索引为2的局部变量(即i)中    \n    7 return                     //main方法返回  \n```\n在这个字节码中我们还是没有看到length这个成员变量，但是看到了这个:arraylength ,这条指令是用来获取数组的长度的，所以说JVM对数组的长度做了特殊的处理，它是通过arraylength这条指令来实现的。\n## 数组的使用方法\n通过上面算是对数组是什么有了一个初步的认识，下面将简单介绍数组的使用方法。\n数组的使用方法无非就是四个步骤：声明数组、分配空间、赋值、处理。\n声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。\n分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10];\n赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式：\n```java\nint a[] = new int[2];    //默认为0,如果是引用数据类型就为null  \n        int b[] = new int[] {1,2,3,4,5};      \n        int c[] = {1,2,3,4,5};  \n```\n处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。\nPS：**由于能力有限，所以“什么是数组”主要是参考这篇博文：http://developer.51cto.com/art/201001/176671.htm 。下篇将更多的介绍数组的一些特性，例如：效率问题、Array的使用、浅拷贝以及与list之间的转换问题。**\n","slug":"java-toup18","published":1,"updated":"2019-09-03T03:40:46.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keteb001b0vfaexos2ert","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732783\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732783</a></p></blockquote><h2 id=\"什么是数组\"><a href=\"#什么是数组\" class=\"headerlink\" title=\"什么是数组\"></a>什么是数组</h2><p>数组？什么是数组？在我印象中的数组是应该这样的：通过new关键字创建并组装他们，通过使用整形索引值访问它的元素，并且它的尺寸是不可变的！<br>但是这只是数组的最表面的东西！深一点？就是这样：数组是一个简单的复合数据类型，它是一系列有序数据的集合，它当中的每一个数据都具有相同的数据类型，我们通过数组名加上一个不会越界下标值来唯一确定数组中的元素。<br>还有更深的，那就是数组是一个特殊的对象！！（对于这个LZ理解的不是很好，对JVM也没有看，所以见解有限）。以下参考文献：<a href=\"http://developer.51cto.com/art/201001/176671.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201001/176671.htm</a> 、 <a href=\"http://www.blogjava.net/flysky19/articles/92763.html?opt=admin\" target=\"_blank\" rel=\"noopener\">http://www.blogjava.net/flysky19/articles/92763.html?opt=admin</a><br>不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。<br><a id=\"more\"></a></p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"array的父类是：\"</span> + array.getClass().getSuperclass());  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"array的类名是：\"</span> + array.getClass().getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------Output:  </span><br><span class=\"line\">array的父类是：<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Object</span>  </span></span><br><span class=\"line\">array的类名是：[I</span><br></pre></td></tr></table></figure><p>从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个”[I”都不是一个合法标识符。怎么定义成类啊？所以我认为SUM那帮天才肯定对数组的底层肯定做了特殊的处理。<br>我们再看如下示例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array_00 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"一维数组：\"</span> + array_00.getClass().getName());  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] array_01 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"二维数组：\"</span> + array_01.getClass().getName());  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][][] array_02 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"三维数组：\"</span> + array_02.getClass().getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----------------Output:  </span><br><span class=\"line\">一维数组：[I  </span><br><span class=\"line\">二维数组：[[I  </span><br><span class=\"line\">三维数组：[[[I</span><br></pre></td></tr></table></figure><p></p><p>通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个’[‘和数组元素类型的内部名称组成。不清楚我们再看：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object[]:\"</span> + Object[].class);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object[][]:\"</span> + Object[][].class);  </span><br><span class=\"line\">        System.err.println(<span class=\"string\">\"Object[][][]:\"</span> + Object[][][].class);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object:\"</span> + Object.class);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">---------Output:  </span><br><span class=\"line\">Object[]:class [Ljava.lang.Object;  </span><br><span class=\"line\">Object[][]:class [[Ljava.lang.Object;  </span><br><span class=\"line\">Object[][][]:class [[[Ljava.lang.Object;  </span><br><span class=\"line\">Object:<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Object</span></span></span><br></pre></td></tr></table></figure><p></p><p>从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。<br>我们暂且不论这个[I是什么东东，是由谁来声明的，怎么声明的（这些我现在也不知道！但是有一点可以确认：这个是在运行时确定的）。先看如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        Class clazz = array.getClass();     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredFields().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredMethods().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredConstructors().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredAnnotations().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredClasses().length);     </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------Output：  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p></p><p>从这个运行结果可以看出，我们亲爱的[I没有生命任何成员变量、成员方法、构造函数、Annotation甚至连length成员变量这个都没有，它就是一个彻彻底底的空类。没有声明length，那么我们array.length时，编译器怎么不会报错呢？确实，数组的length是一个非常特殊的成员变量。我们知道数组的是Object的直接之类，但是Object是没有length这个成员变量的，那么length应该是数组的成员变量，但是从上面的示例中，我们发现数组根本就没有任何成员变量，这两者不是相互矛盾么？<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = a.length;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>打开class文件，得到main方法的字节码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> iconst_2                   <span class=\"comment\">//将int型常量2压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">1</span> newarray <span class=\"number\">10</span> (<span class=\"keyword\">int</span>)          <span class=\"comment\">//将2弹出操作数栈，作为长度，创建一个元素类型为int, 维度为1的数组，并将数组的引用压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">3</span> astore_1                   <span class=\"comment\">//将数组的引用从操作数栈中弹出，保存在索引为1的局部变量(即a)中    </span></span><br><span class=\"line\">    <span class=\"number\">4</span> aload_1                    <span class=\"comment\">//将索引为1的局部变量(即a)压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">5</span> arraylength                <span class=\"comment\">//从操作数栈弹出数组引用(即a)，并获取其长度(JVM负责实现如何获取)，并将长度压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">6</span> istore_2                   <span class=\"comment\">//将数组长度从操作数栈弹出，保存在索引为2的局部变量(即i)中    </span></span><br><span class=\"line\">    <span class=\"number\">7</span> <span class=\"keyword\">return</span>                     <span class=\"comment\">//main方法返回</span></span><br></pre></td></tr></table></figure><p></p><p>在这个字节码中我们还是没有看到length这个成员变量，但是看到了这个:arraylength ,这条指令是用来获取数组的长度的，所以说JVM对数组的长度做了特殊的处理，它是通过arraylength这条指令来实现的。</p><h2 id=\"数组的使用方法\"><a href=\"#数组的使用方法\" class=\"headerlink\" title=\"数组的使用方法\"></a>数组的使用方法</h2><p>通过上面算是对数组是什么有了一个初步的认识，下面将简单介绍数组的使用方法。<br>数组的使用方法无非就是四个步骤：声明数组、分配空间、赋值、处理。<br>声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。<br>分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10];<br>赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];    <span class=\"comment\">//默认为0,如果是引用数据类型就为null  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> b[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> c[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br></pre></td></tr></table></figure><p></p><p>处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。<br>PS：<strong>由于能力有限，所以“什么是数组”主要是参考这篇博文：<a href=\"http://developer.51cto.com/art/201001/176671.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201001/176671.htm</a> 。下篇将更多的介绍数组的一些特性，例如：效率问题、Array的使用、浅拷贝以及与list之间的转换问题。</strong></p><!-- rebuild by neat -->","site":{"data":{}},"length":4506,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732783\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732783</a></p></blockquote><h2 id=\"什么是数组\"><a href=\"#什么是数组\" class=\"headerlink\" title=\"什么是数组\"></a>什么是数组</h2><p>数组？什么是数组？在我印象中的数组是应该这样的：通过new关键字创建并组装他们，通过使用整形索引值访问它的元素，并且它的尺寸是不可变的！<br>但是这只是数组的最表面的东西！深一点？就是这样：数组是一个简单的复合数据类型，它是一系列有序数据的集合，它当中的每一个数据都具有相同的数据类型，我们通过数组名加上一个不会越界下标值来唯一确定数组中的元素。<br>还有更深的，那就是数组是一个特殊的对象！！（对于这个LZ理解的不是很好，对JVM也没有看，所以见解有限）。以下参考文献：<a href=\"http://developer.51cto.com/art/201001/176671.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201001/176671.htm</a> 、 <a href=\"http://www.blogjava.net/flysky19/articles/92763.html?opt=admin\" target=\"_blank\" rel=\"noopener\">http://www.blogjava.net/flysky19/articles/92763.html?opt=admin</a><br>不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。<br>","more":"</p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"array的父类是：\"</span> + array.getClass().getSuperclass());  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"array的类名是：\"</span> + array.getClass().getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------Output:  </span><br><span class=\"line\">array的父类是：<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Object</span>  </span></span><br><span class=\"line\">array的类名是：[I</span><br></pre></td></tr></table></figure><p>从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个”[I”都不是一个合法标识符。怎么定义成类啊？所以我认为SUM那帮天才肯定对数组的底层肯定做了特殊的处理。<br>我们再看如下示例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array_00 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"一维数组：\"</span> + array_00.getClass().getName());  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] array_01 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"二维数组：\"</span> + array_01.getClass().getName());  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][][] array_02 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>];  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"三维数组：\"</span> + array_02.getClass().getName());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----------------Output:  </span><br><span class=\"line\">一维数组：[I  </span><br><span class=\"line\">二维数组：[[I  </span><br><span class=\"line\">三维数组：[[[I</span><br></pre></td></tr></table></figure><p></p><p>通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个’[‘和数组元素类型的内部名称组成。不清楚我们再看：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object[]:\"</span> + Object[].class);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object[][]:\"</span> + Object[][].class);  </span><br><span class=\"line\">        System.err.println(<span class=\"string\">\"Object[][][]:\"</span> + Object[][][].class);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Object:\"</span> + Object.class);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">---------Output:  </span><br><span class=\"line\">Object[]:class [Ljava.lang.Object;  </span><br><span class=\"line\">Object[][]:class [[Ljava.lang.Object;  </span><br><span class=\"line\">Object[][][]:class [[[Ljava.lang.Object;  </span><br><span class=\"line\">Object:<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">java</span>.<span class=\"title\">lang</span>.<span class=\"title\">Object</span></span></span><br></pre></td></tr></table></figure><p></p><p>从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。<br>我们暂且不论这个[I是什么东东，是由谁来声明的，怎么声明的（这些我现在也不知道！但是有一点可以确认：这个是在运行时确定的）。先看如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\">        Class clazz = array.getClass();     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredFields().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredMethods().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredConstructors().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredAnnotations().length);     </span><br><span class=\"line\">        System.out.println(clazz.getDeclaredClasses().length);     </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------Output：  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span>  </span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p></p><p>从这个运行结果可以看出，我们亲爱的[I没有生命任何成员变量、成员方法、构造函数、Annotation甚至连length成员变量这个都没有，它就是一个彻彻底底的空类。没有声明length，那么我们array.length时，编译器怎么不会报错呢？确实，数组的length是一个非常特殊的成员变量。我们知道数组的是Object的直接之类，但是Object是没有length这个成员变量的，那么length应该是数组的成员变量，但是从上面的示例中，我们发现数组根本就没有任何成员变量，这两者不是相互矛盾么？<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = a.length;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>打开class文件，得到main方法的字节码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> iconst_2                   <span class=\"comment\">//将int型常量2压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">1</span> newarray <span class=\"number\">10</span> (<span class=\"keyword\">int</span>)          <span class=\"comment\">//将2弹出操作数栈，作为长度，创建一个元素类型为int, 维度为1的数组，并将数组的引用压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">3</span> astore_1                   <span class=\"comment\">//将数组的引用从操作数栈中弹出，保存在索引为1的局部变量(即a)中    </span></span><br><span class=\"line\">    <span class=\"number\">4</span> aload_1                    <span class=\"comment\">//将索引为1的局部变量(即a)压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">5</span> arraylength                <span class=\"comment\">//从操作数栈弹出数组引用(即a)，并获取其长度(JVM负责实现如何获取)，并将长度压入操作数栈    </span></span><br><span class=\"line\">    <span class=\"number\">6</span> istore_2                   <span class=\"comment\">//将数组长度从操作数栈弹出，保存在索引为2的局部变量(即i)中    </span></span><br><span class=\"line\">    <span class=\"number\">7</span> <span class=\"keyword\">return</span>                     <span class=\"comment\">//main方法返回</span></span><br></pre></td></tr></table></figure><p></p><p>在这个字节码中我们还是没有看到length这个成员变量，但是看到了这个:arraylength ,这条指令是用来获取数组的长度的，所以说JVM对数组的长度做了特殊的处理，它是通过arraylength这条指令来实现的。</p><h2 id=\"数组的使用方法\"><a href=\"#数组的使用方法\" class=\"headerlink\" title=\"数组的使用方法\"></a>数组的使用方法</h2><p>通过上面算是对数组是什么有了一个初步的认识，下面将简单介绍数组的使用方法。<br>数组的使用方法无非就是四个步骤：声明数组、分配空间、赋值、处理。<br>声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。<br>分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10];<br>赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];    <span class=\"comment\">//默认为0,如果是引用数据类型就为null  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> b[] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> c[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br></pre></td></tr></table></figure><p></p><p>处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。<br>PS：<strong>由于能力有限，所以“什么是数组”主要是参考这篇博文：<a href=\"http://developer.51cto.com/art/201001/176671.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201001/176671.htm</a> 。下篇将更多的介绍数组的一些特性，例如：效率问题、Array的使用、浅拷贝以及与list之间的转换问题。</strong></p><!-- rebuild by neat -->"},{"title":"java提高篇（十九）-----数组之二","abbrlink":"3338b61","date":"2017-10-23T14:38:55.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17732815\n\n## 性能？请优先考虑数组\n在java中有很多方式来存储一系列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？数组与其他种类的容器之间的区别有三个方面：效率、类型和保存基本类型的能力。在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。\n在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。\n```java\n--------这是ArrayList的add()------  \n    public boolean add(E e) {  \n        ensureCapacity(size + 1);  // Increments modCount!!  \n        elementData[size++] = e;  \n        return true;  \n    }  \n```\n下面利用数组和list来做一些操作比较。\n<!-- more -->\n## 求和\n```java\nLong time1 = System.currentTimeMillis();  \n        for(int i = 0 ; i < 100000000 ;i++){  \n            sum += arrays[i%10];  \n        }  \n        Long time2 = System.currentTimeMillis();  \n        System.out.println(\"数组求和所花费时间：\" + (time2 - time1) + \"毫秒\");  \n        Long time3 = System.currentTimeMillis();  \n        for (int i = 0; i < 100000000; i++) {  \n            sum  += list.get(i%10);  \n        }  \n        Long time4 = System.currentTimeMillis();  \n        System.out.println(\"List求和所花费时间：\" + (time4 - time3) + \"毫秒\");  \n--------------Output:  \n数组求和所花费时间：696毫秒  \nList求和所花费时间：3498毫秒  \n```\n从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。\n所以在性能要求较高的场景中请优先考虑数组。\n## 变长数组？\n数组是定长的，一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。就如java不能实现多重继承一样，我们一样可以利用内部类和接口来实现(请参考：java提高篇(九)-----实现多重继承)。\n那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:\n```java\n    public void ensureCapacity(int minCapacity) {  \n        modCount++;    \n        int oldCapacity = elementData.length;  \n        /** \n         * 若当前需要的长度超过数组长度时进行扩容处理 \n         */  \n        if (minCapacity > oldCapacity) {  \n            Object oldData[] = elementData;      \n            int newCapacity = (oldCapacity * 3) / 2 + 1;    //扩容  \n            if (newCapacity < minCapacity)  \n                newCapacity = minCapacity;  \n            //拷贝数组，生成新的数组  \n            elementData = Arrays.copyOf(elementData, newCapacity);  \n        }  \n    }\n```\n这段代码对我们有用的地方就在于if语句后面。它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：\n```java\npublic class ArrayUtils {  \n    /** \n     * @desc 对数组进行扩容 \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas 原始数组 \n     * @param newLen 扩容大小 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacity(T[] datas,int newLen){  \n        newLen = newLen < 0 ? datas.length :datas.length + newLen;     \n        //生成一个新的数组  \n        return Arrays.copyOf(datas, newLen);  \n    }  \n      \n    /** \n     * @desc 对数组进行扩容处理，1.5倍 \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas  原始数组 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacity(T[] datas){  \n        int newLen = (datas.length * 3) / 2;      //扩容原始数组的1.5倍  \n        //生成一个新的数组  \n        return Arrays.copyOf(datas, newLen);  \n    }  \n      \n    /** \n     * @desc 对数组进行扩容处理， \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas 原始数组 \n     * @param mulitiple 扩容的倍数 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacityMul(T[] datas,int mulitiple){  \n        mulitiple = mulitiple < 0 ? 1 : mulitiple;  \n        int newLen = datas.length * mulitiple;  \n        return Arrays.copyOf(datas,newLen );  \n    }  \n}  \n```\n通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！\n## 数组复制问题\n以前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用\n```java\n    public class Test {  \n        public static void main(String[] args) {  \n            Person person_01 = new Person(\"chenssy_01\");  \n            \n            Person[] persons1 = new Person[]{person_01};  \n            Person[] persons2 = Arrays.copyOf(persons1,persons1.length);  \n            \n            System.out.println(\"数组persons1:\");  \n            display(persons1);  \n            System.out.println(\"---------------------\");  \n            System.out.println(\"数组persons2:\");  \n            display(persons2);  \n            //改变其值  \n            persons2[0].setName(\"chessy_02\");  \n            System.out.println(\"------------改变其值后------------\");  \n            System.out.println(\"数组persons1:\");  \n            display(persons1);  \n            System.out.println(\"---------------------\");  \n            System.out.println(\"数组persons2:\");  \n            display(persons2);  \n        }  \n        public static void display(Person[] persons){  \n            for(Person person : persons){  \n                System.out.println(person.toString());  \n            }  \n        }  \n    }  \n-------------Output:  \n数组persons1:  \n姓名是：chenssy_01  \n---------------------  \n数组persons2:  \n姓名是：chenssy_01  \n------------改变其值后------------  \n数组persons1:  \n姓名是：chessy_02  \n---------------------  \n数组persons2:  \n姓名是：chessy_02  \n```\n从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。\n有关于深浅拷贝的博文，参考：\n渐析java的浅拷贝和深拷贝：http://www.cnblogs.com/chenssy/p/3308489.html 。\n使用序列化实现对象的拷贝：http://blog.csdn.net/chenssy/article/details/12952063\n## 数组转换为List注意地方\n我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：\n```java\npublic static void main(String[] args) {  \n        int[] datas = new int[]{1,2,3,4,5};  \n        List list = Arrays.asList(datas);  \n        System.out.println(list.size());  \n    }  \n------------Output:  \n1 \n```  \n结果是1,是的你没有看错, 结果就是1。但是为什么会是1而不是5呢？先看asList()的源码\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<T>(a);  \n    }\n```\n注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。\n我们在看下面程序：\n```java\n    enum Week{Sum,Mon,Tue,Web,Thu,Fri,Sat}  \n    public static void main(String[] args) {  \n        Week[] weeks = {Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri};  \n        List<Week> list = Arrays.asList(weeks);  \n        list.add(Week.Sat);  \n    }  \n```\n这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException  \n    at java.util.AbstractList.add(AbstractList.java:131)  \n    at java.util.AbstractList.add(AbstractList.java:91)  \n    at com.array.Test.main(Test.java:18)  \n```\n编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<T>(a);  \n    }  \n```\n这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：\n```java\nprivate static class ArrayList<E> extends AbstractList<E>  \n    implements RandomAccess, java.io.Serializable{  \n            private static final long serialVersionUID = -2764017481108945198L;  \n            private final E[] a;  \n            ArrayList(E[] array) {  \n                if (array==null)  \n                    throw new NullPointerException();  \n            a = array;  \n        }  \n        /** 省略方法 **/  \n    } \n```\n但是这个内部类并没有提供add()方法，那么查看父类：\n```java\npublic boolean add(E e) {  \n    add(size(), e);  \n    return true;  \n    }  \n    public void add(int index, E element) {  \n    throw new UnsupportedOperationException();  \n    }  \n```\n这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾\n这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：\n>1、size：元素数量\n>2、toArray：转换为数组，实现了数组的浅拷贝。\n>3、get：获得指定元素。\n>4、contains：是否包含某元素。\n\n所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。\n[参考文献：《编写高质量代码--改善Java程序的151个建议》](http://blog.csdn.net/aishangyutian12/article/details/52699938)","source":"_posts/java-toup19.md","raw":"---\ntitle: java提高篇（十九）-----数组之二\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 3338b61\ndate: 2017-10-23 22:38:55\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17732815\n\n## 性能？请优先考虑数组\n在java中有很多方式来存储一系列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？数组与其他种类的容器之间的区别有三个方面：效率、类型和保存基本类型的能力。在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。\n在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。\n```java\n--------这是ArrayList的add()------  \n    public boolean add(E e) {  \n        ensureCapacity(size + 1);  // Increments modCount!!  \n        elementData[size++] = e;  \n        return true;  \n    }  \n```\n下面利用数组和list来做一些操作比较。\n<!-- more -->\n## 求和\n```java\nLong time1 = System.currentTimeMillis();  \n        for(int i = 0 ; i < 100000000 ;i++){  \n            sum += arrays[i%10];  \n        }  \n        Long time2 = System.currentTimeMillis();  \n        System.out.println(\"数组求和所花费时间：\" + (time2 - time1) + \"毫秒\");  \n        Long time3 = System.currentTimeMillis();  \n        for (int i = 0; i < 100000000; i++) {  \n            sum  += list.get(i%10);  \n        }  \n        Long time4 = System.currentTimeMillis();  \n        System.out.println(\"List求和所花费时间：\" + (time4 - time3) + \"毫秒\");  \n--------------Output:  \n数组求和所花费时间：696毫秒  \nList求和所花费时间：3498毫秒  \n```\n从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。\n所以在性能要求较高的场景中请优先考虑数组。\n## 变长数组？\n数组是定长的，一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。就如java不能实现多重继承一样，我们一样可以利用内部类和接口来实现(请参考：java提高篇(九)-----实现多重继承)。\n那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:\n```java\n    public void ensureCapacity(int minCapacity) {  \n        modCount++;    \n        int oldCapacity = elementData.length;  \n        /** \n         * 若当前需要的长度超过数组长度时进行扩容处理 \n         */  \n        if (minCapacity > oldCapacity) {  \n            Object oldData[] = elementData;      \n            int newCapacity = (oldCapacity * 3) / 2 + 1;    //扩容  \n            if (newCapacity < minCapacity)  \n                newCapacity = minCapacity;  \n            //拷贝数组，生成新的数组  \n            elementData = Arrays.copyOf(elementData, newCapacity);  \n        }  \n    }\n```\n这段代码对我们有用的地方就在于if语句后面。它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：\n```java\npublic class ArrayUtils {  \n    /** \n     * @desc 对数组进行扩容 \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas 原始数组 \n     * @param newLen 扩容大小 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacity(T[] datas,int newLen){  \n        newLen = newLen < 0 ? datas.length :datas.length + newLen;     \n        //生成一个新的数组  \n        return Arrays.copyOf(datas, newLen);  \n    }  \n      \n    /** \n     * @desc 对数组进行扩容处理，1.5倍 \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas  原始数组 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacity(T[] datas){  \n        int newLen = (datas.length * 3) / 2;      //扩容原始数组的1.5倍  \n        //生成一个新的数组  \n        return Arrays.copyOf(datas, newLen);  \n    }  \n      \n    /** \n     * @desc 对数组进行扩容处理， \n     * @author chenssy \n     * @data 2013-12-8 \n     * @param <T> \n     * @param datas 原始数组 \n     * @param mulitiple 扩容的倍数 \n     * @return T[] \n     */  \n    public static <T> T[] expandCapacityMul(T[] datas,int mulitiple){  \n        mulitiple = mulitiple < 0 ? 1 : mulitiple;  \n        int newLen = datas.length * mulitiple;  \n        return Arrays.copyOf(datas,newLen );  \n    }  \n}  \n```\n通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！\n## 数组复制问题\n以前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用\n```java\n    public class Test {  \n        public static void main(String[] args) {  \n            Person person_01 = new Person(\"chenssy_01\");  \n            \n            Person[] persons1 = new Person[]{person_01};  \n            Person[] persons2 = Arrays.copyOf(persons1,persons1.length);  \n            \n            System.out.println(\"数组persons1:\");  \n            display(persons1);  \n            System.out.println(\"---------------------\");  \n            System.out.println(\"数组persons2:\");  \n            display(persons2);  \n            //改变其值  \n            persons2[0].setName(\"chessy_02\");  \n            System.out.println(\"------------改变其值后------------\");  \n            System.out.println(\"数组persons1:\");  \n            display(persons1);  \n            System.out.println(\"---------------------\");  \n            System.out.println(\"数组persons2:\");  \n            display(persons2);  \n        }  \n        public static void display(Person[] persons){  \n            for(Person person : persons){  \n                System.out.println(person.toString());  \n            }  \n        }  \n    }  \n-------------Output:  \n数组persons1:  \n姓名是：chenssy_01  \n---------------------  \n数组persons2:  \n姓名是：chenssy_01  \n------------改变其值后------------  \n数组persons1:  \n姓名是：chessy_02  \n---------------------  \n数组persons2:  \n姓名是：chessy_02  \n```\n从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。\n有关于深浅拷贝的博文，参考：\n渐析java的浅拷贝和深拷贝：http://www.cnblogs.com/chenssy/p/3308489.html 。\n使用序列化实现对象的拷贝：http://blog.csdn.net/chenssy/article/details/12952063\n## 数组转换为List注意地方\n我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：\n```java\npublic static void main(String[] args) {  \n        int[] datas = new int[]{1,2,3,4,5};  \n        List list = Arrays.asList(datas);  \n        System.out.println(list.size());  \n    }  \n------------Output:  \n1 \n```  \n结果是1,是的你没有看错, 结果就是1。但是为什么会是1而不是5呢？先看asList()的源码\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<T>(a);  \n    }\n```\n注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。\n我们在看下面程序：\n```java\n    enum Week{Sum,Mon,Tue,Web,Thu,Fri,Sat}  \n    public static void main(String[] args) {  \n        Week[] weeks = {Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri};  \n        List<Week> list = Arrays.asList(weeks);  \n        list.add(Week.Sat);  \n    }  \n```\n这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException  \n    at java.util.AbstractList.add(AbstractList.java:131)  \n    at java.util.AbstractList.add(AbstractList.java:91)  \n    at com.array.Test.main(Test.java:18)  \n```\n编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<T>(a);  \n    }  \n```\n这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：\n```java\nprivate static class ArrayList<E> extends AbstractList<E>  \n    implements RandomAccess, java.io.Serializable{  \n            private static final long serialVersionUID = -2764017481108945198L;  \n            private final E[] a;  \n            ArrayList(E[] array) {  \n                if (array==null)  \n                    throw new NullPointerException();  \n            a = array;  \n        }  \n        /** 省略方法 **/  \n    } \n```\n但是这个内部类并没有提供add()方法，那么查看父类：\n```java\npublic boolean add(E e) {  \n    add(size(), e);  \n    return true;  \n    }  \n    public void add(int index, E element) {  \n    throw new UnsupportedOperationException();  \n    }  \n```\n这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾\n这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：\n>1、size：元素数量\n>2、toArray：转换为数组，实现了数组的浅拷贝。\n>3、get：获得指定元素。\n>4、contains：是否包含某元素。\n\n所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。\n[参考文献：《编写高质量代码--改善Java程序的151个建议》](http://blog.csdn.net/aishangyutian12/article/details/52699938)","slug":"java-toup19","published":1,"updated":"2019-09-03T03:40:46.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keted001e0vfauzpk2pl0","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732815\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732815</a></p></blockquote><h2 id=\"性能？请优先考虑数组\"><a href=\"#性能？请优先考虑数组\" class=\"headerlink\" title=\"性能？请优先考虑数组\"></a>性能？请优先考虑数组</h2><p>在java中有很多方式来存储一系列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？数组与其他种类的容器之间的区别有三个方面：效率、类型和保存基本类型的能力。在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<br>在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------这是ArrayList的add()------  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">        ensureCapacity(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!  </span></span><br><span class=\"line\">        elementData[size++] = e;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>下面利用数组和list来做一些操作比较。<br><a id=\"more\"></a></p><h2 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long time1 = System.currentTimeMillis();  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000000</span> ;i++)&#123;  </span><br><span class=\"line\">            sum += arrays[i%<span class=\"number\">10</span>];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        Long time2 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"数组求和所花费时间：\"</span> + (time2 - time1) + <span class=\"string\">\"毫秒\"</span>);  </span><br><span class=\"line\">        Long time3 = System.currentTimeMillis();  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000000</span>; i++) &#123;  </span><br><span class=\"line\">            sum  += list.get(i%<span class=\"number\">10</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        Long time4 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"List求和所花费时间：\"</span> + (time4 - time3) + <span class=\"string\">\"毫秒\"</span>);  </span><br><span class=\"line\">--------------Output:  </span><br><span class=\"line\">数组求和所花费时间：<span class=\"number\">696</span>毫秒  </span><br><span class=\"line\">List求和所花费时间：<span class=\"number\">3498</span>毫秒</span><br></pre></td></tr></table></figure><p>从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。<br>所以在性能要求较高的场景中请优先考虑数组。</p><h2 id=\"变长数组？\"><a href=\"#变长数组？\" class=\"headerlink\" title=\"变长数组？\"></a>变长数组？</h2><p>数组是定长的，一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。就如java不能实现多重继承一样，我们一样可以利用内部类和接口来实现(请参考：java提高篇(九)——-实现多重继承)。<br>那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 若当前需要的长度超过数组长度时进行扩容处理 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; oldCapacity) &#123;  </span><br><span class=\"line\">        Object oldData[] = elementData;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>) / <span class=\"number\">2</span> + <span class=\"number\">1</span>;    <span class=\"comment\">//扩容  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity &lt; minCapacity)  </span><br><span class=\"line\">            newCapacity = minCapacity;  </span><br><span class=\"line\">        <span class=\"comment\">//拷贝数组，生成新的数组  </span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码对我们有用的地方就在于if语句后面。它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayUtils</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas 原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newLen 扩容大小 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacity(T[] datas,<span class=\"keyword\">int</span> newLen)&#123;  </span><br><span class=\"line\">        newLen = newLen &lt; <span class=\"number\">0</span> ? datas.length :datas.length + newLen;     </span><br><span class=\"line\">        <span class=\"comment\">//生成一个新的数组  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas, newLen);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容处理，1.5倍 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas  原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacity(T[] datas)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = (datas.length * <span class=\"number\">3</span>) / <span class=\"number\">2</span>;      <span class=\"comment\">//扩容原始数组的1.5倍  </span></span><br><span class=\"line\">        <span class=\"comment\">//生成一个新的数组  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas, newLen);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容处理， </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas 原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> mulitiple 扩容的倍数 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacityMul(T[] datas,<span class=\"keyword\">int</span> mulitiple)&#123;  </span><br><span class=\"line\">        mulitiple = mulitiple &lt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : mulitiple;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = datas.length * mulitiple;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas,newLen );  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！</p><h2 id=\"数组复制问题\"><a href=\"#数组复制问题\" class=\"headerlink\" title=\"数组复制问题\"></a>数组复制问题</h2><p>以前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">            Person person_01 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy_01\"</span>);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            Person[] persons1 = <span class=\"keyword\">new</span> Person[]&#123;person_01&#125;;  </span><br><span class=\"line\">            Person[] persons2 = Arrays.copyOf(persons1,persons1.length);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons1:\"</span>);  </span><br><span class=\"line\">            display(persons1);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons2:\"</span>);  </span><br><span class=\"line\">            display(persons2);  </span><br><span class=\"line\">            <span class=\"comment\">//改变其值  </span></span><br><span class=\"line\">            persons2[<span class=\"number\">0</span>].setName(<span class=\"string\">\"chessy_02\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"------------改变其值后------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons1:\"</span>);  </span><br><span class=\"line\">            display(persons1);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons2:\"</span>);  </span><br><span class=\"line\">            display(persons2);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person[] persons)</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Person person : persons)&#123;  </span><br><span class=\"line\">                System.out.println(person.toString());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">-------------Output:  </span><br><span class=\"line\">数组persons1:  </span><br><span class=\"line\">姓名是：chenssy_01  </span><br><span class=\"line\">---------------------  </span><br><span class=\"line\">数组persons2:  </span><br><span class=\"line\">姓名是：chenssy_01  </span><br><span class=\"line\">------------改变其值后------------  </span><br><span class=\"line\">数组persons1:  </span><br><span class=\"line\">姓名是：chessy_02  </span><br><span class=\"line\">---------------------  </span><br><span class=\"line\">数组persons2:  </span><br><span class=\"line\">姓名是：chessy_02</span><br></pre></td></tr></table></figure><p></p><p>从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。<br>有关于深浅拷贝的博文，参考：<br>渐析java的浅拷贝和深拷贝：<a href=\"http://www.cnblogs.com/chenssy/p/3308489.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/chenssy/p/3308489.html</a> 。<br>使用序列化实现对象的拷贝：<a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12952063</a></p><h2 id=\"数组转换为List注意地方\"><a href=\"#数组转换为List注意地方\" class=\"headerlink\" title=\"数组转换为List注意地方\"></a>数组转换为List注意地方</h2><p>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] datas = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">        List list = Arrays.asList(datas);  </span><br><span class=\"line\">        System.out.println(list.size());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">------------Output:  </span><br><span class=\"line\"><span class=\"number\">1</span> </span><br><span class=\"line\">```  </span><br><span class=\"line\">结果是<span class=\"number\">1</span>,是的你没有看错, 结果就是<span class=\"number\">1</span>。但是为什么会是<span class=\"number\">1</span>而不是<span class=\"number\">5</span>呢？先看asList()的源码</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;T&gt;(a);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。<br>我们在看下面程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Week&#123;Sum,Mon,Tue,Web,Thu,Fri,Sat&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Week[] weeks = &#123;Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri&#125;;  </span><br><span class=\"line\">    List&lt;Week&gt; list = Arrays.asList(weeks);  </span><br><span class=\"line\">    list.add(Week.Sat);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException  </span><br><span class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">131</span>)  </span><br><span class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">91</span>)  </span><br><span class=\"line\">    at com.array.Test.main(Test.java:<span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure><p></p><p>编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;T&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2764017481108945198L</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> E[] a;  </span><br><span class=\"line\">            ArrayList(E[] array) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array==<span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">            a = array;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略方法 **/</span>  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>但是这个内部类并没有提供add()方法，那么查看父类：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    add(size(), e);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾<br>这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：</p><blockquote><p>1、size：元素数量<br>2、toArray：转换为数组，实现了数组的浅拷贝。<br>3、get：获得指定元素。<br>4、contains：是否包含某元素。</p></blockquote><p>所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。<br><a href=\"http://blog.csdn.net/aishangyutian12/article/details/52699938\" target=\"_blank\" rel=\"noopener\">参考文献：《编写高质量代码—改善Java程序的151个建议》</a></p><!-- rebuild by neat -->","site":{"data":{}},"length":7849,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732815\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732815</a></p></blockquote><h2 id=\"性能？请优先考虑数组\"><a href=\"#性能？请优先考虑数组\" class=\"headerlink\" title=\"性能？请优先考虑数组\"></a>性能？请优先考虑数组</h2><p>在java中有很多方式来存储一系列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？数组与其他种类的容器之间的区别有三个方面：效率、类型和保存基本类型的能力。在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<br>在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------这是ArrayList的add()------  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">        ensureCapacity(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!  </span></span><br><span class=\"line\">        elementData[size++] = e;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>下面利用数组和list来做一些操作比较。<br>","more":"</p><h2 id=\"求和\"><a href=\"#求和\" class=\"headerlink\" title=\"求和\"></a>求和</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long time1 = System.currentTimeMillis();  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000000</span> ;i++)&#123;  </span><br><span class=\"line\">            sum += arrays[i%<span class=\"number\">10</span>];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        Long time2 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"数组求和所花费时间：\"</span> + (time2 - time1) + <span class=\"string\">\"毫秒\"</span>);  </span><br><span class=\"line\">        Long time3 = System.currentTimeMillis();  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000000</span>; i++) &#123;  </span><br><span class=\"line\">            sum  += list.get(i%<span class=\"number\">10</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        Long time4 = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"List求和所花费时间：\"</span> + (time4 - time3) + <span class=\"string\">\"毫秒\"</span>);  </span><br><span class=\"line\">--------------Output:  </span><br><span class=\"line\">数组求和所花费时间：<span class=\"number\">696</span>毫秒  </span><br><span class=\"line\">List求和所花费时间：<span class=\"number\">3498</span>毫秒</span><br></pre></td></tr></table></figure><p>从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。<br>所以在性能要求较高的场景中请优先考虑数组。</p><h2 id=\"变长数组？\"><a href=\"#变长数组？\" class=\"headerlink\" title=\"变长数组？\"></a>变长数组？</h2><p>数组是定长的，一旦初始化声明后是不可改变长度的。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。就如java不能实现多重继承一样，我们一样可以利用内部类和接口来实现(请参考：java提高篇(九)——-实现多重继承)。<br>那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 若当前需要的长度超过数组长度时进行扩容处理 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; oldCapacity) &#123;  </span><br><span class=\"line\">        Object oldData[] = elementData;      </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>) / <span class=\"number\">2</span> + <span class=\"number\">1</span>;    <span class=\"comment\">//扩容  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newCapacity &lt; minCapacity)  </span><br><span class=\"line\">            newCapacity = minCapacity;  </span><br><span class=\"line\">        <span class=\"comment\">//拷贝数组，生成新的数组  </span></span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码对我们有用的地方就在于if语句后面。它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayUtils</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas 原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> newLen 扩容大小 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacity(T[] datas,<span class=\"keyword\">int</span> newLen)&#123;  </span><br><span class=\"line\">        newLen = newLen &lt; <span class=\"number\">0</span> ? datas.length :datas.length + newLen;     </span><br><span class=\"line\">        <span class=\"comment\">//生成一个新的数组  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas, newLen);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容处理，1.5倍 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas  原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacity(T[] datas)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = (datas.length * <span class=\"number\">3</span>) / <span class=\"number\">2</span>;      <span class=\"comment\">//扩容原始数组的1.5倍  </span></span><br><span class=\"line\">        <span class=\"comment\">//生成一个新的数组  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas, newLen);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span> 对数组进行扩容处理， </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span> 2013-12-8 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt; </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datas 原始数组 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> mulitiple 扩容的倍数 </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> T[] </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T[] expandCapacityMul(T[] datas,<span class=\"keyword\">int</span> mulitiple)&#123;  </span><br><span class=\"line\">        mulitiple = mulitiple &lt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : mulitiple;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> newLen = datas.length * mulitiple;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOf(datas,newLen );  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！</p><h2 id=\"数组复制问题\"><a href=\"#数组复制问题\" class=\"headerlink\" title=\"数组复制问题\"></a>数组复制问题</h2><p>以前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">            Person person_01 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy_01\"</span>);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            Person[] persons1 = <span class=\"keyword\">new</span> Person[]&#123;person_01&#125;;  </span><br><span class=\"line\">            Person[] persons2 = Arrays.copyOf(persons1,persons1.length);  </span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons1:\"</span>);  </span><br><span class=\"line\">            display(persons1);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons2:\"</span>);  </span><br><span class=\"line\">            display(persons2);  </span><br><span class=\"line\">            <span class=\"comment\">//改变其值  </span></span><br><span class=\"line\">            persons2[<span class=\"number\">0</span>].setName(<span class=\"string\">\"chessy_02\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"------------改变其值后------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons1:\"</span>);  </span><br><span class=\"line\">            display(persons1);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"---------------------\"</span>);  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"数组persons2:\"</span>);  </span><br><span class=\"line\">            display(persons2);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person[] persons)</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(Person person : persons)&#123;  </span><br><span class=\"line\">                System.out.println(person.toString());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">-------------Output:  </span><br><span class=\"line\">数组persons1:  </span><br><span class=\"line\">姓名是：chenssy_01  </span><br><span class=\"line\">---------------------  </span><br><span class=\"line\">数组persons2:  </span><br><span class=\"line\">姓名是：chenssy_01  </span><br><span class=\"line\">------------改变其值后------------  </span><br><span class=\"line\">数组persons1:  </span><br><span class=\"line\">姓名是：chessy_02  </span><br><span class=\"line\">---------------------  </span><br><span class=\"line\">数组persons2:  </span><br><span class=\"line\">姓名是：chessy_02</span><br></pre></td></tr></table></figure><p></p><p>从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。<br>有关于深浅拷贝的博文，参考：<br>渐析java的浅拷贝和深拷贝：<a href=\"http://www.cnblogs.com/chenssy/p/3308489.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/chenssy/p/3308489.html</a> 。<br>使用序列化实现对象的拷贝：<a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12952063</a></p><h2 id=\"数组转换为List注意地方\"><a href=\"#数组转换为List注意地方\" class=\"headerlink\" title=\"数组转换为List注意地方\"></a>数组转换为List注意地方</h2><p>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] datas = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">        List list = Arrays.asList(datas);  </span><br><span class=\"line\">        System.out.println(list.size());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">------------Output:  </span><br><span class=\"line\"><span class=\"number\">1</span> </span><br><span class=\"line\">```  </span><br><span class=\"line\">结果是<span class=\"number\">1</span>,是的你没有看错, 结果就是<span class=\"number\">1</span>。但是为什么会是<span class=\"number\">1</span>而不是<span class=\"number\">5</span>呢？先看asList()的源码</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;T&gt;(a);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。<br>我们在看下面程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Week&#123;Sum,Mon,Tue,Web,Thu,Fri,Sat&#125;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Week[] weeks = &#123;Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri&#125;;  </span><br><span class=\"line\">    List&lt;Week&gt; list = Arrays.asList(weeks);  </span><br><span class=\"line\">    list.add(Week.Sat);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException  </span><br><span class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">131</span>)  </span><br><span class=\"line\">    at java.util.AbstractList.add(AbstractList.java:<span class=\"number\">91</span>)  </span><br><span class=\"line\">    at com.array.Test.main(Test.java:<span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure><p></p><p>编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;T&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2764017481108945198L</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> E[] a;  </span><br><span class=\"line\">            ArrayList(E[] array) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array==<span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">            a = array;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略方法 **/</span>  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>但是这个内部类并没有提供add()方法，那么查看父类：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    add(size(), e);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾<br>这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：</p><blockquote><p>1、size：元素数量<br>2、toArray：转换为数组，实现了数组的浅拷贝。<br>3、get：获得指定元素。<br>4、contains：是否包含某元素。</p></blockquote><p>所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。<br><a href=\"http://blog.csdn.net/aishangyutian12/article/details/52699938\" target=\"_blank\" rel=\"noopener\">参考文献：《编写高质量代码—改善Java程序的151个建议》</a></p><!-- rebuild by neat -->"},{"title":"java提高篇(一)-----理解java的三大特性之封装","abbrlink":"fe3e490","date":"2017-10-20T16:06:18.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12757911](http://blog.csdn.net/chenssy/article/details/12757911)\n\n从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！\n闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始---封装!!!!!!\n\n<!-- more -->\n\n## 三大特性之---封装\n\n封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\n使用封装有三大好处：\n1、良好的封装能够减少耦合。\n2、类内部的结构可以自由修改。\n3、可以对成员进行更精确的控制。\n4、隐藏信息，实现细节。\n首先我们先来看两个类：Husband.java、Wife.java\n\n```java\n    public class Husband {  \n      \n    /* \n     * 对属性的封装 \n     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n     */  \n    private String name ;  \n    private String sex ;  \n    private int age ;  \n    private Wife wife;  \n      \n    /* \n     * setter()、getter()是该对象对外开发的接口 \n     */  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public int getAge() {  \n        return age;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setWife(Wife wife) {  \n        this.wife = wife;  \n    }  \n}  \n\n```\n\n``` java\n    public class Wife {  \n    private String name;  \n    private int age;  \n    private String sex;  \n    private Husband husband;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setHusband(Husband husband) {  \n        this.husband = husband;  \n    }  \n  \n    public Husband getHusband() {  \n        return husband;  \n    }  \n      \n}  \n```\n\n从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。\n所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。\n通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：\n\n```java\n    public class Husband {  \n        public String name ;  \n        public String sex ;  \n        public int age ;  \n        public Wife wife;  \n    }  \n```\n\n我们应该这样来使用它：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 30;  \n    husband.name = \"张三\";  \n    husband.sex = \"男\";    //貌似有点儿多余  \n```\n\n但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。\n\n```java\n    public class Husband {  \n      \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private String age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n        \n        public String getAge() {  \n            return age;  \n        }  \n        \n        public void setAge(int age) {  \n            //转换即可  \n            this.age = String.valueOf(age);  \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n    }\n```\n\n其他的地方依然那样引用(husband.setAge(22))保持不变。\n到了这里我们确实可以看出，**封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。**\n我们在看这个好处：**可以对成员变量进行更精确的控制**。\n\n还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 300;  \n```\n\n也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！\n但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：\n\n```java\n    public class Husband {  \n        \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private int age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            if(age > 120){  \n                //提示錯誤信息  \n                System.out.println(\"ERROR：error age input....\");    \n            }else{  \n                this.age = age;  \n            }  \n            \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n        \n    }  \n```\n\n上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。\n\n```java\n    public String getSexName() {  \n        if(\"0\".equals(sex)){  \n            sexName = \"女\";  \n        }  \n        else if(\"1\".equals(sex)){  \n            sexName = \"男\";  \n        }  \n        else{  \n            sexName = \"人妖???\";  \n        }  \n        return sexName;  \n    }  \n```\n 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。\n\n ```java\n    public String getCzHTML(){  \n        if(\"1\".equals(zt)){  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='qy(\"+id+\")'>启用</a>\";  \n        }  \n        else{  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='jy(\"+id+\")'>禁用</a>\";  \n        }  \n        return czHTML;  \n    } \n ```","source":"_posts/java-toup2.md","raw":"---\ntitle: java提高篇(一)-----理解java的三大特性之封装\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: fe3e490\ndate: 2017-10-21 00:06:18\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12757911](http://blog.csdn.net/chenssy/article/details/12757911)\n\n从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！\n闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始---封装!!!!!!\n\n<!-- more -->\n\n## 三大特性之---封装\n\n封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\n使用封装有三大好处：\n1、良好的封装能够减少耦合。\n2、类内部的结构可以自由修改。\n3、可以对成员进行更精确的控制。\n4、隐藏信息，实现细节。\n首先我们先来看两个类：Husband.java、Wife.java\n\n```java\n    public class Husband {  \n      \n    /* \n     * 对属性的封装 \n     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n     */  \n    private String name ;  \n    private String sex ;  \n    private int age ;  \n    private Wife wife;  \n      \n    /* \n     * setter()、getter()是该对象对外开发的接口 \n     */  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public int getAge() {  \n        return age;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setWife(Wife wife) {  \n        this.wife = wife;  \n    }  \n}  \n\n```\n\n``` java\n    public class Wife {  \n    private String name;  \n    private int age;  \n    private String sex;  \n    private Husband husband;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setHusband(Husband husband) {  \n        this.husband = husband;  \n    }  \n  \n    public Husband getHusband() {  \n        return husband;  \n    }  \n      \n}  \n```\n\n从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。\n所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。\n通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：\n\n```java\n    public class Husband {  \n        public String name ;  \n        public String sex ;  \n        public int age ;  \n        public Wife wife;  \n    }  \n```\n\n我们应该这样来使用它：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 30;  \n    husband.name = \"张三\";  \n    husband.sex = \"男\";    //貌似有点儿多余  \n```\n\n但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。\n\n```java\n    public class Husband {  \n      \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private String age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n        \n        public String getAge() {  \n            return age;  \n        }  \n        \n        public void setAge(int age) {  \n            //转换即可  \n            this.age = String.valueOf(age);  \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n    }\n```\n\n其他的地方依然那样引用(husband.setAge(22))保持不变。\n到了这里我们确实可以看出，**封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。**\n我们在看这个好处：**可以对成员变量进行更精确的控制**。\n\n还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 300;  \n```\n\n也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！\n但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：\n\n```java\n    public class Husband {  \n        \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private int age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            if(age > 120){  \n                //提示錯誤信息  \n                System.out.println(\"ERROR：error age input....\");    \n            }else{  \n                this.age = age;  \n            }  \n            \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n        \n    }  \n```\n\n上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。\n\n```java\n    public String getSexName() {  \n        if(\"0\".equals(sex)){  \n            sexName = \"女\";  \n        }  \n        else if(\"1\".equals(sex)){  \n            sexName = \"男\";  \n        }  \n        else{  \n            sexName = \"人妖???\";  \n        }  \n        return sexName;  \n    }  \n```\n 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。\n\n ```java\n    public String getCzHTML(){  \n        if(\"1\".equals(zt)){  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='qy(\"+id+\")'>启用</a>\";  \n        }  \n        else{  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='jy(\"+id+\")'>禁用</a>\";  \n        }  \n        return czHTML;  \n    } \n ```","slug":"java-toup2","published":1,"updated":"2019-09-03T03:40:46.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketee001g0vfadlxntzr0","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12757911\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12757911</a></p></blockquote><p>从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！<br>闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—-封装!!!!!!</p><a id=\"more\"></a><h2 id=\"三大特性之—-封装\"><a href=\"#三大特性之—-封装\" class=\"headerlink\" title=\"三大特性之—-封装\"></a>三大特性之—-封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。<br>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。<br>使用封装有三大好处：<br>1、良好的封装能够减少耦合。<br>2、类内部的结构可以自由修改。<br>3、可以对成员进行更精确的控制。<br>4、隐藏信息，实现细节。<br>首先我们先来看两个类：Husband.java、Wife.java</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * setter()、getter()是该对象对外开发的接口 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWife</span><span class=\"params\">(Wife wife)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.wife = wife;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wife</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Husband husband;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHusband</span><span class=\"params\">(Husband husband)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.husband = husband;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Husband <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> husband;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。<br>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。<br>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Wife wife;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们应该这样来使用它：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">husband.age = <span class=\"number\">30</span>;  </span><br><span class=\"line\">husband.name = <span class=\"string\">\"张三\"</span>;  </span><br><span class=\"line\">husband.sex = <span class=\"string\">\"男\"</span>;    <span class=\"comment\">//貌似有点儿多余</span></span><br></pre></td></tr></table></figure><p>但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//转换即可  </span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = String.valueOf(age);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>其他的地方依然那样引用(husband.setAge(22))保持不变。<br>到了这里我们确实可以看出，<strong>封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</strong><br>我们在看这个好处：<strong>可以对成员变量进行更精确的控制</strong>。</p><p>还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">husband.age = <span class=\"number\">300</span>;</span><br></pre></td></tr></table></figure><p>也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！<br>但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age &gt; <span class=\"number\">120</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//提示錯誤信息  </span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"ERROR：error age input....\"</span>);    </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"0\"</span>.equals(sex))&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"女\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(sex))&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"男\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"人妖???\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sexName;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCzHTML</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(zt))&#123;  </span><br><span class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></span><br><span class=\"line\">            + <span class=\"string\">\" onclick='qy(\"</span>+id+<span class=\"string\">\")'&gt;启用&lt;/a&gt;\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></span><br><span class=\"line\">            + <span class=\"string\">\" onclick='jy(\"</span>+id+<span class=\"string\">\")'&gt;禁用&lt;/a&gt;\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> czHTML;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"length":5558,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12757911\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12757911</a></p></blockquote><p>从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！<br>闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—-封装!!!!!!</p>","more":"<h2 id=\"三大特性之—-封装\"><a href=\"#三大特性之—-封装\" class=\"headerlink\" title=\"三大特性之—-封装\"></a>三大特性之—-封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。<br>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。<br>使用封装有三大好处：<br>1、良好的封装能够减少耦合。<br>2、类内部的结构可以自由修改。<br>3、可以对成员进行更精确的控制。<br>4、隐藏信息，实现细节。<br>首先我们先来看两个类：Husband.java、Wife.java</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * setter()、getter()是该对象对外开发的接口 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWife</span><span class=\"params\">(Wife wife)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.wife = wife;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wife</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Husband husband;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHusband</span><span class=\"params\">(Husband husband)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.husband = husband;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Husband <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> husband;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。<br>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。<br>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age ;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Wife wife;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们应该这样来使用它：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">husband.age = <span class=\"number\">30</span>;  </span><br><span class=\"line\">husband.name = <span class=\"string\">\"张三\"</span>;  </span><br><span class=\"line\">husband.sex = <span class=\"string\">\"男\"</span>;    <span class=\"comment\">//貌似有点儿多余</span></span><br></pre></td></tr></table></figure><p>但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//转换即可  </span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = String.valueOf(age);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>其他的地方依然那样引用(husband.setAge(22))保持不变。<br>到了这里我们确实可以看出，<strong>封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</strong><br>我们在看这个好处：<strong>可以对成员变量进行更精确的控制</strong>。</p><p>还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">husband.age = <span class=\"number\">300</span>;</span><br></pre></td></tr></table></figure><p>也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！<br>但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></span><br><span class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age &gt; <span class=\"number\">120</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//提示錯誤信息  </span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"ERROR：error age input....\"</span>);    </span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"0\"</span>.equals(sex))&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"女\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(sex))&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"男\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        sexName = <span class=\"string\">\"人妖???\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> sexName;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCzHTML</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(zt))&#123;  </span><br><span class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></span><br><span class=\"line\">            + <span class=\"string\">\" onclick='qy(\"</span>+id+<span class=\"string\">\")'&gt;启用&lt;/a&gt;\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;  </span><br><span class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></span><br><span class=\"line\">            + <span class=\"string\">\" onclick='jy(\"</span>+id+<span class=\"string\">\")'&gt;禁用&lt;/a&gt;\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> czHTML;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"java提高篇（二十）-----集合大家族","abbrlink":"da849b7b","date":"2017-10-23T14:38:59.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17732841\n\n在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！\n![](/uploads/collections.png)\n上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。\n<!-- more -->\n## Collection接口\nCollection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。\n在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。\n## List接口\nList接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。\n2.1、ArrayList\nArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。\nsize、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。\nArrayList擅长于随机访问。同时ArrayList是非同步的。\n2.2、LinkedList\n同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。\n由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。\n与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： \nList list = Collections.synchronizedList(new LinkedList(...));\n2.3、Vector\n与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。\n2.4、Stack\nStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。\n## Set接口\nSet是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。\n3.1、EnumSet\n是枚举的专用Set。所有的元素都是枚举类型。\n3.2、HashSet\nHashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。\n3.3、TreeSet\n基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。\n## Map接口\nMap与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。\n4.1、HashMap\n以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。\n4.2、TreeMap\n键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口\n4.3、HashTable\n也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低\n## Queue\n队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。\n##异同点\n       出处：http://blog.csdn.net/softwave/article/details/4166598\n6.1、Vector和ArrayList\n1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 \n2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。 \n3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。\nArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！\n6.2、Aarraylist和Linkedlist\n1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 \n2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 \n3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 \n这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。\n6.3、HashMap与TreeMap\n1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。\n2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。\n3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。\n6.4、hashtable与hashmap\n1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。\n2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。\n3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。\n## 对集合的选择\n7.1、对List的选择\n1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList\n2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。\n3、对于Vector而已，我们一般都是避免使用。\n4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。\n7.2、对Set的选择\n1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。\n3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。\n7.3、对Map的选择\n1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。\n2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。\n","source":"_posts/java-toup20.md","raw":"---\ntitle: java提高篇（二十）-----集合大家族\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: da849b7b\ndate: 2017-10-23 22:38:59\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17732841\n\n在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！\n![](/uploads/collections.png)\n上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。\n<!-- more -->\n## Collection接口\nCollection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。\n在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。\n## List接口\nList接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。\n2.1、ArrayList\nArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。\nsize、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。\nArrayList擅长于随机访问。同时ArrayList是非同步的。\n2.2、LinkedList\n同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。\n由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。\n与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： \nList list = Collections.synchronizedList(new LinkedList(...));\n2.3、Vector\n与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。\n2.4、Stack\nStack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。\n## Set接口\nSet是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。\n3.1、EnumSet\n是枚举的专用Set。所有的元素都是枚举类型。\n3.2、HashSet\nHashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。\n3.3、TreeSet\n基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。\n## Map接口\nMap与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。\n4.1、HashMap\n以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。\n4.2、TreeMap\n键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口\n4.3、HashTable\n也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低\n## Queue\n队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。\n##异同点\n       出处：http://blog.csdn.net/softwave/article/details/4166598\n6.1、Vector和ArrayList\n1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。 \n2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。 \n3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。\nArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！\n6.2、Aarraylist和Linkedlist\n1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 \n2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 \n3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 \n这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。\n6.3、HashMap与TreeMap\n1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。\n2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。\n3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。\n6.4、hashtable与hashmap\n1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。\n2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。\n3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。\n## 对集合的选择\n7.1、对List的选择\n1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList\n2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。\n3、对于Vector而已，我们一般都是避免使用。\n4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。\n7.2、对Set的选择\n1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。\n3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。\n7.3、对Map的选择\n1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。\n2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。\n","slug":"java-toup20","published":1,"updated":"2019-09-03T03:40:46.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keteg001l0vfag8jb848f","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732841\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732841</a></p></blockquote><p>在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！<br><img src=\"/uploads/collections.png\" alt><br>上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。<br><a id=\"more\"></a></p><h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><p>Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。<br>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h2 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h2><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。<br>2.1、ArrayList<br>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。<br>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。<br>ArrayList擅长于随机访问。同时ArrayList是非同步的。<br>2.2、LinkedList<br>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。<br>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。<br>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>List list = Collections.synchronizedList(new LinkedList(…));<br>2.3、Vector<br>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。<br>2.4、Stack<br>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h2 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h2><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。<br>3.1、EnumSet<br>是枚举的专用Set。所有的元素都是枚举类型。<br>3.2、HashSet<br>HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。<br>3.3、TreeSet<br>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。<br>4.1、HashMap<br>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。<br>4.2、TreeMap<br>键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口<br>4.3、HashTable<br>也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低</p><h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p><h2 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h2><pre><code>   出处：http://blog.csdn.net/softwave/article/details/4166598\n</code></pre><p>6.1、Vector和ArrayList<br>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。<br>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。<br>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。<br>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！<br>6.2、Aarraylist和Linkedlist<br>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。<br>6.3、HashMap与TreeMap<br>1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。<br>2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。<br>3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。<br>6.4、hashtable与hashmap<br>1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。<br>2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。<br>3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。</p><h2 id=\"对集合的选择\"><a href=\"#对集合的选择\" class=\"headerlink\" title=\"对集合的选择\"></a>对集合的选择</h2><p>7.1、对List的选择<br>1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList<br>2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。<br>3、对于Vector而已，我们一般都是避免使用。<br>4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。<br>7.2、对Set的选择<br>1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。<br>3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。<br>7.3、对Map的选择<br>1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。<br>2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</p><!-- rebuild by neat -->","site":{"data":{}},"length":5122,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17732841\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/17732841</a></p></blockquote><p>在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！<br><img src=\"/uploads/collections.png\" alt><br>上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。<br>","more":"</p><h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><p>Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。<br>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h2 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h2><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。<br>2.1、ArrayList<br>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。<br>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。<br>ArrayList擅长于随机访问。同时ArrayList是非同步的。<br>2.2、LinkedList<br>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。<br>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。<br>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>List list = Collections.synchronizedList(new LinkedList(…));<br>2.3、Vector<br>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。<br>2.4、Stack<br>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h2 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h2><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。<br>3.1、EnumSet<br>是枚举的专用Set。所有的元素都是枚举类型。<br>3.2、HashSet<br>HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。<br>3.3、TreeSet<br>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h2 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h2><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。<br>4.1、HashMap<br>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。<br>4.2、TreeMap<br>键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口<br>4.3、HashTable<br>也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低</p><h2 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h2><p>队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p><h2 id=\"异同点\"><a href=\"#异同点\" class=\"headerlink\" title=\"异同点\"></a>异同点</h2><pre><code>   出处：http://blog.csdn.net/softwave/article/details/4166598\n</code></pre><p>6.1、Vector和ArrayList<br>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。<br>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。<br>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。<br>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！<br>6.2、Aarraylist和Linkedlist<br>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。<br>6.3、HashMap与TreeMap<br>1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。<br>2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。<br>3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。<br>6.4、hashtable与hashmap<br>1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。<br>2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。<br>3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。</p><h2 id=\"对集合的选择\"><a href=\"#对集合的选择\" class=\"headerlink\" title=\"对集合的选择\"></a>对集合的选择</h2><p>7.1、对List的选择<br>1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList<br>2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。<br>3、对于Vector而已，我们一般都是避免使用。<br>4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。<br>7.2、对Set的选择<br>1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。<br>3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。<br>7.3、对Map的选择<br>1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。<br>2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</p><!-- rebuild by neat -->"},{"title":"java提高篇（二二）-----LinkedList","abbrlink":"bf33ec17","date":"2017-10-24T05:09:34.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/18099417\n\n## 概述\nLinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。\nLinkedList实现所有可选的列表操作，并允许所有的元素包括null。\n除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。\n此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。\n所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。\n同时，与ArrayList一样此实现不是同步的。\n（以上摘自JDK 6.0 API）。\n<!-- more -->\n## 源码分析\n### 定义\n首先我们先看LinkedList的定义：\n```java\npublic class LinkedList<E>  \n    extends AbstractSequentialList<E>  \n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable  \n```\n从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。\n### 属性\n在LinkedList中提供了两个基本属性size、header。\n```java\nprivate transient Entry<E> header = new Entry<E>(null, null, null);  \nprivate transient int size = 0;  \n```\n其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。\n```java\nprivate static class Entry<E> {  \n        E element;        //元素节点  \n        Entry<E> next;    //下一个元素  \n        Entry<E> previous;  //上一个元素  \n  \n        Entry(E element, Entry<E> next, Entry<E> previous) {  \n            this.element = element;  \n            this.next = next;  \n            this.previous = previous;  \n        }  \n    }  \n```\n上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。\n### 构造方法\nLinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection<? extends E> c)。\n```java\n/** \n     *  构造一个空列表。 \n     */  \n    public LinkedList() {  \n        header.next = header.previous = header;  \n    }  \n      \n    /** \n     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 \n     */  \n    public LinkedList(Collection<? extends E> c) {  \n        this();  \n        addAll(c);  \n    }  \n```\nLinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。\nLinkedList(Collection<? extends E> c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：\n```java\n    /** \n     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 \n     */  \n    public boolean addAll(Collection<? extends E> c) {  \n        return addAll(size, c);  \n    }  \n      \n    /** \n     * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 \n     */  \n    public boolean addAll(int index, Collection<? extends E> c) {  \n        //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常  \n        if (index < 0 || index > size)  \n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);  \n        Object[] a = c.toArray();  \n        int numNew = a.length;    //插入元素的个数  \n        //若插入的元素为空，则返回false  \n        if (numNew == 0)  \n            return false;  \n        //modCount:在AbstractList中定义的，表示从结构上修改列表的次数  \n        modCount++;  \n        //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点  \n        Entry<E> successor = (index == size ? header : entry(index));  \n        //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素  \n        Entry<E> predecessor = successor.previous;  \n        //执行插入动作  \n        for (int i = 0; i < numNew; i++) {  \n            //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用  \n            //  \n            Entry<E> e = new Entry<E>((E) a[i], successor, predecessor);  \n            //将插入位置前一个节点的下一个元素引用指向当前元素  \n            predecessor.next = e;  \n            //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序  \n            predecessor = e;  \n        }  \n        successor.previous = predecessor;  \n        //修改容量大小  \n        size += numNew;  \n        return true;  \n    } \n```\n在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。\n```java\n/** \n     * 返回指定位置(若存在)的节点元素 \n     */  \n    private Entry<E> entry(int index) {  \n        if (index < 0 || index >= size)  \n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"  \n                    + size);  \n        //头部节点  \n        Entry<E> e = header;  \n        //判断遍历的方向  \n        if (index < (size >> 1)) {  \n            for (int i = 0; i <= index; i++)  \n                e = e.next;  \n        } else {  \n            for (int i = size; i > index; i--)  \n                e = e.previous;  \n        }  \n        return e;  \n    } \n```\n从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。\n如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。\n由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。\n### 增加方法\nadd(E e): 将指定元素添加到此列表的结尾。\n```java\n    public boolean add(E e) {  \n        addBefore(e, header);  \n        return true;  \n    }  \n```\n该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。\n```java\nprivate Entry<E> addBefore(E e, Entry<E> entry) {  \n        //利用Entry构造函数构建一个新节点 newEntry，  \n        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);  \n        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的  \n        newEntry.previous.next = newEntry;  \n        newEntry.next.previous = newEntry;  \n        //容量+1  \n        size++;  \n        //修改次数+1  \n        modCount++;  \n        return newEntry;  \n    } \n``` \n在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。\nLinkedList还提供了其他的增加方法：\nadd(int index, E element)：在此列表中指定的位置插入指定的元素。\naddAll(Collection<? extends E> c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。\naddAll(int index, Collection<? extends E> c)：将指定 collection 中的所有元素从指定位置开始插入此列表。\nAddFirst(E e): 将指定元素插入此列表的开头。\naddLast(E e): 将指定元素添加到此列表的结尾。\n### 移除方法\nremove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：\n```java\npublic boolean remove(Object o) {  \n        if (o==null) {  \n            for (Entry<E> e = header.next; e != header; e = e.next) {  \n                if (e.element==null) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        } else {  \n            for (Entry<E> e = header.next; e != header; e = e.next) {  \n                if (o.equals(e.element)) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n``` \n该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<E> e)，remove(Entry<E> e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：\n```java\nprivate E remove(Entry<E> e) {  \n        if (e == header)  \n            throw new NoSuchElementException();  \n  \n        //保留被移除的元素：要返回  \n        E result = e.element;  \n          \n        //将该节点的前一节点的next指向该节点后节点  \n        e.previous.next = e.next;  \n        //将该节点的后一节点的previous指向该节点的前节点  \n        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的  \n        e.next.previous = e.previous;  \n        //将该节点归空  \n        e.next = e.previous = null;  \n        e.element = null;  \n        size--;  \n        modCount++;  \n        return result;  \n    } \n``` \n其他的移除方法：\n\n       clear()： 从此列表中移除所有元素。\n       remove()：获取并移除此列表的头（第一个元素）。\n       remove(int index)：移除此列表中指定位置处的元素。\n       remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。\n       removeFirst()：移除并返回此列表的第一个元素。\n       removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n       removeLast()：移除并返回此列表的最后一个元素。\n       removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n### 查找方法\n对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。\n\n       get(int index)：返回此列表中指定位置处的元素。\n       getFirst()：返回此列表的第一个元素。\n       getLast()：返回此列表的最后一个元素。\n       indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n       lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n","source":"_posts/java-toup21.md","raw":"---\ntitle: java提高篇（二二）-----LinkedList\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: bf33ec17\ndate: 2017-10-24 13:09:34\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/18099417\n\n## 概述\nLinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。\nLinkedList实现所有可选的列表操作，并允许所有的元素包括null。\n除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。\n此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。\n所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。\n同时，与ArrayList一样此实现不是同步的。\n（以上摘自JDK 6.0 API）。\n<!-- more -->\n## 源码分析\n### 定义\n首先我们先看LinkedList的定义：\n```java\npublic class LinkedList<E>  \n    extends AbstractSequentialList<E>  \n    implements List<E>, Deque<E>, Cloneable, java.io.Serializable  \n```\n从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。\n### 属性\n在LinkedList中提供了两个基本属性size、header。\n```java\nprivate transient Entry<E> header = new Entry<E>(null, null, null);  \nprivate transient int size = 0;  \n```\n其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。\n```java\nprivate static class Entry<E> {  \n        E element;        //元素节点  \n        Entry<E> next;    //下一个元素  \n        Entry<E> previous;  //上一个元素  \n  \n        Entry(E element, Entry<E> next, Entry<E> previous) {  \n            this.element = element;  \n            this.next = next;  \n            this.previous = previous;  \n        }  \n    }  \n```\n上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。\n### 构造方法\nLinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection<? extends E> c)。\n```java\n/** \n     *  构造一个空列表。 \n     */  \n    public LinkedList() {  \n        header.next = header.previous = header;  \n    }  \n      \n    /** \n     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 \n     */  \n    public LinkedList(Collection<? extends E> c) {  \n        this();  \n        addAll(c);  \n    }  \n```\nLinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。\nLinkedList(Collection<? extends E> c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：\n```java\n    /** \n     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 \n     */  \n    public boolean addAll(Collection<? extends E> c) {  \n        return addAll(size, c);  \n    }  \n      \n    /** \n     * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 \n     */  \n    public boolean addAll(int index, Collection<? extends E> c) {  \n        //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常  \n        if (index < 0 || index > size)  \n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);  \n        Object[] a = c.toArray();  \n        int numNew = a.length;    //插入元素的个数  \n        //若插入的元素为空，则返回false  \n        if (numNew == 0)  \n            return false;  \n        //modCount:在AbstractList中定义的，表示从结构上修改列表的次数  \n        modCount++;  \n        //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点  \n        Entry<E> successor = (index == size ? header : entry(index));  \n        //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素  \n        Entry<E> predecessor = successor.previous;  \n        //执行插入动作  \n        for (int i = 0; i < numNew; i++) {  \n            //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用  \n            //  \n            Entry<E> e = new Entry<E>((E) a[i], successor, predecessor);  \n            //将插入位置前一个节点的下一个元素引用指向当前元素  \n            predecessor.next = e;  \n            //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序  \n            predecessor = e;  \n        }  \n        successor.previous = predecessor;  \n        //修改容量大小  \n        size += numNew;  \n        return true;  \n    } \n```\n在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。\n```java\n/** \n     * 返回指定位置(若存在)的节点元素 \n     */  \n    private Entry<E> entry(int index) {  \n        if (index < 0 || index >= size)  \n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \"  \n                    + size);  \n        //头部节点  \n        Entry<E> e = header;  \n        //判断遍历的方向  \n        if (index < (size >> 1)) {  \n            for (int i = 0; i <= index; i++)  \n                e = e.next;  \n        } else {  \n            for (int i = size; i > index; i--)  \n                e = e.previous;  \n        }  \n        return e;  \n    } \n```\n从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。\n如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。\n由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。\n### 增加方法\nadd(E e): 将指定元素添加到此列表的结尾。\n```java\n    public boolean add(E e) {  \n        addBefore(e, header);  \n        return true;  \n    }  \n```\n该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。\n```java\nprivate Entry<E> addBefore(E e, Entry<E> entry) {  \n        //利用Entry构造函数构建一个新节点 newEntry，  \n        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);  \n        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的  \n        newEntry.previous.next = newEntry;  \n        newEntry.next.previous = newEntry;  \n        //容量+1  \n        size++;  \n        //修改次数+1  \n        modCount++;  \n        return newEntry;  \n    } \n``` \n在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。\nLinkedList还提供了其他的增加方法：\nadd(int index, E element)：在此列表中指定的位置插入指定的元素。\naddAll(Collection<? extends E> c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。\naddAll(int index, Collection<? extends E> c)：将指定 collection 中的所有元素从指定位置开始插入此列表。\nAddFirst(E e): 将指定元素插入此列表的开头。\naddLast(E e): 将指定元素添加到此列表的结尾。\n### 移除方法\nremove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：\n```java\npublic boolean remove(Object o) {  \n        if (o==null) {  \n            for (Entry<E> e = header.next; e != header; e = e.next) {  \n                if (e.element==null) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        } else {  \n            for (Entry<E> e = header.next; e != header; e = e.next) {  \n                if (o.equals(e.element)) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    } \n``` \n该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<E> e)，remove(Entry<E> e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：\n```java\nprivate E remove(Entry<E> e) {  \n        if (e == header)  \n            throw new NoSuchElementException();  \n  \n        //保留被移除的元素：要返回  \n        E result = e.element;  \n          \n        //将该节点的前一节点的next指向该节点后节点  \n        e.previous.next = e.next;  \n        //将该节点的后一节点的previous指向该节点的前节点  \n        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的  \n        e.next.previous = e.previous;  \n        //将该节点归空  \n        e.next = e.previous = null;  \n        e.element = null;  \n        size--;  \n        modCount++;  \n        return result;  \n    } \n``` \n其他的移除方法：\n\n       clear()： 从此列表中移除所有元素。\n       remove()：获取并移除此列表的头（第一个元素）。\n       remove(int index)：移除此列表中指定位置处的元素。\n       remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。\n       removeFirst()：移除并返回此列表的第一个元素。\n       removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n       removeLast()：移除并返回此列表的最后一个元素。\n       removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n### 查找方法\n对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。\n\n       get(int index)：返回此列表中指定位置处的元素。\n       getFirst()：返回此列表的第一个元素。\n       getLast()：返回此列表的最后一个元素。\n       indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n       lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n","slug":"java-toup21","published":1,"updated":"2019-09-03T03:40:46.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketei001o0vfa6rqmqofn","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/18099417\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/18099417</a></p></blockquote><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。<br>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。<br>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。<br>同时，与ArrayList一样此实现不是同步的。<br>（以上摘自JDK 6.0 API）。<br><a id=\"more\"></a></p><h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>首先我们先看LinkedList的定义：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSequentialList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Deque</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。</p><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>在LinkedList中提供了两个基本属性size、header。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Entry&lt;E&gt; header = <span class=\"keyword\">new</span> Entry&lt;E&gt;(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><p></p><p>其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">        E element;        <span class=\"comment\">//元素节点  </span></span><br><span class=\"line\">        Entry&lt;E&gt; next;    <span class=\"comment\">//下一个元素  </span></span><br><span class=\"line\">        Entry&lt;E&gt; previous;  <span class=\"comment\">//上一个元素  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.element = element;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.previous = previous;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</p><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>LinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection&lt;? extends E&gt; c)。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  构造一个空列表。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        header.next = header.previous = header;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>();  </span><br><span class=\"line\">        addAll(c);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。<br>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span> + index + <span class=\"string\">\", Size: \"</span> + size);  </span><br><span class=\"line\">    Object[] a = c.toArray();  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;    <span class=\"comment\">//插入元素的个数  </span></span><br><span class=\"line\">    <span class=\"comment\">//若插入的元素为空，则返回false  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    <span class=\"comment\">//modCount:在AbstractList中定义的，表示从结构上修改列表的次数  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点  </span></span><br><span class=\"line\">    Entry&lt;E&gt; successor = (index == size ? header : entry(index));  </span><br><span class=\"line\">    <span class=\"comment\">//插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素  </span></span><br><span class=\"line\">    Entry&lt;E&gt; predecessor = successor.previous;  </span><br><span class=\"line\">    <span class=\"comment\">//执行插入动作  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numNew; i++) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用  </span></span><br><span class=\"line\">        <span class=\"comment\">//  </span></span><br><span class=\"line\">        Entry&lt;E&gt; e = <span class=\"keyword\">new</span> Entry&lt;E&gt;((E) a[i], successor, predecessor);  </span><br><span class=\"line\">        <span class=\"comment\">//将插入位置前一个节点的下一个元素引用指向当前元素  </span></span><br><span class=\"line\">        predecessor.next = e;  </span><br><span class=\"line\">        <span class=\"comment\">//修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序  </span></span><br><span class=\"line\">        predecessor = e;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    successor.previous = predecessor;  </span><br><span class=\"line\">    <span class=\"comment\">//修改容量大小  </span></span><br><span class=\"line\">    size += numNew;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 返回指定位置(若存在)的节点元素 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry&lt;E&gt; <span class=\"title\">entry</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span> + index + <span class=\"string\">\", Size: \"</span>  </span><br><span class=\"line\">                    + size);  </span><br><span class=\"line\">        <span class=\"comment\">//头部节点  </span></span><br><span class=\"line\">        Entry&lt;E&gt; e = header;  </span><br><span class=\"line\">        <span class=\"comment\">//判断遍历的方向  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= index; i++)  </span><br><span class=\"line\">                e = e.next;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size; i &gt; index; i--)  </span><br><span class=\"line\">                e = e.previous;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。<br>如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。<br>由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h3 id=\"增加方法\"><a href=\"#增加方法\" class=\"headerlink\" title=\"增加方法\"></a>增加方法</h3><p>add(E e): 将指定元素添加到此列表的结尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    addBefore(e, header);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。</p><pre><code class=\"lang-java\">private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {  \n        //利用Entry构造函数构建一个新节点 newEntry，  \n        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);  \n        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的  \n        newEntry.previous.next = newEntry;  \n        newEntry.next.previous = newEntry;  \n        //容量+1  \n        size++;  \n        //修改次数+1  \n        modCount++;  \n        return newEntry;  \n    }\n</code></pre><p>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。<br>LinkedList还提供了其他的增加方法：<br>add(int index, E element)：在此列表中指定的位置插入指定的元素。<br>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。<br>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。<br>AddFirst(E e): 将指定元素插入此列表的开头。<br>addLast(E e): 将指定元素添加到此列表的结尾。</p><h3 id=\"移除方法\"><a href=\"#移除方法\" class=\"headerlink\" title=\"移除方法\"></a>移除方法</h3><p>remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：</p><pre><code class=\"lang-java\">public boolean remove(Object o) {  \n        if (o==null) {  \n            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {  \n                if (e.element==null) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        } else {  \n            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {  \n                if (o.equals(e.element)) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    }\n</code></pre><p>该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<e>e)，remove(Entry<e>e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</e></e></p><pre><code class=\"lang-java\">private E remove(Entry&lt;E&gt; e) {  \n        if (e == header)  \n            throw new NoSuchElementException();  \n\n        //保留被移除的元素：要返回  \n        E result = e.element;  \n\n        //将该节点的前一节点的next指向该节点后节点  \n        e.previous.next = e.next;  \n        //将该节点的后一节点的previous指向该节点的前节点  \n        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的  \n        e.next.previous = e.previous;  \n        //将该节点归空  \n        e.next = e.previous = null;  \n        e.element = null;  \n        size--;  \n        modCount++;  \n        return result;  \n    }\n</code></pre><p>其他的移除方法：</p><pre><code>   clear()： 从此列表中移除所有元素。\n   remove()：获取并移除此列表的头（第一个元素）。\n   remove(int index)：移除此列表中指定位置处的元素。\n   remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。\n   removeFirst()：移除并返回此列表的第一个元素。\n   removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n   removeLast()：移除并返回此列表的最后一个元素。\n   removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n</code></pre><h3 id=\"查找方法\"><a href=\"#查找方法\" class=\"headerlink\" title=\"查找方法\"></a>查找方法</h3><p>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</p><pre><code>   get(int index)：返回此列表中指定位置处的元素。\n   getFirst()：返回此列表的第一个元素。\n   getLast()：返回此列表的最后一个元素。\n   indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n   lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n</code></pre><!-- rebuild by neat -->","site":{"data":{}},"length":7370,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/18099417\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/18099417</a></p></blockquote><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。<br>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。<br>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。<br>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。<br>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。<br>同时，与ArrayList一样此实现不是同步的。<br>（以上摘自JDK 6.0 API）。<br>","more":"</p><h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>首先我们先看LinkedList的定义：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSequentialList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Deque</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。</p><h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>在LinkedList中提供了两个基本属性size、header。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Entry&lt;E&gt; header = <span class=\"keyword\">new</span> Entry&lt;E&gt;(<span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><p></p><p>其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">        E element;        <span class=\"comment\">//元素节点  </span></span><br><span class=\"line\">        Entry&lt;E&gt; next;    <span class=\"comment\">//下一个元素  </span></span><br><span class=\"line\">        Entry&lt;E&gt; previous;  <span class=\"comment\">//上一个元素  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.element = element;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.next = next;  </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.previous = previous;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</p><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>LinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection&lt;? extends E&gt; c)。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  构造一个空列表。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        header.next = header.previous = header;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>();  </span><br><span class=\"line\">        addAll(c);  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。<br>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> addAll(size, c);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt; size)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span> + index + <span class=\"string\">\", Size: \"</span> + size);  </span><br><span class=\"line\">    Object[] a = c.toArray();  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;    <span class=\"comment\">//插入元素的个数  </span></span><br><span class=\"line\">    <span class=\"comment\">//若插入的元素为空，则返回false  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numNew == <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">    <span class=\"comment\">//modCount:在AbstractList中定义的，表示从结构上修改列表的次数  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点  </span></span><br><span class=\"line\">    Entry&lt;E&gt; successor = (index == size ? header : entry(index));  </span><br><span class=\"line\">    <span class=\"comment\">//插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素  </span></span><br><span class=\"line\">    Entry&lt;E&gt; predecessor = successor.previous;  </span><br><span class=\"line\">    <span class=\"comment\">//执行插入动作  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numNew; i++) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用  </span></span><br><span class=\"line\">        <span class=\"comment\">//  </span></span><br><span class=\"line\">        Entry&lt;E&gt; e = <span class=\"keyword\">new</span> Entry&lt;E&gt;((E) a[i], successor, predecessor);  </span><br><span class=\"line\">        <span class=\"comment\">//将插入位置前一个节点的下一个元素引用指向当前元素  </span></span><br><span class=\"line\">        predecessor.next = e;  </span><br><span class=\"line\">        <span class=\"comment\">//修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序  </span></span><br><span class=\"line\">        predecessor = e;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    successor.previous = predecessor;  </span><br><span class=\"line\">    <span class=\"comment\">//修改容量大小  </span></span><br><span class=\"line\">    size += numNew;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * 返回指定位置(若存在)的节点元素 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Entry&lt;E&gt; <span class=\"title\">entry</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(<span class=\"string\">\"Index: \"</span> + index + <span class=\"string\">\", Size: \"</span>  </span><br><span class=\"line\">                    + size);  </span><br><span class=\"line\">        <span class=\"comment\">//头部节点  </span></span><br><span class=\"line\">        Entry&lt;E&gt; e = header;  </span><br><span class=\"line\">        <span class=\"comment\">//判断遍历的方向  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= index; i++)  </span><br><span class=\"line\">                e = e.next;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size; i &gt; index; i--)  </span><br><span class=\"line\">                e = e.previous;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。<br>如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。<br>由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h3 id=\"增加方法\"><a href=\"#增加方法\" class=\"headerlink\" title=\"增加方法\"></a>增加方法</h3><p>add(E e): 将指定元素添加到此列表的结尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    addBefore(e, header);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。</p><pre><code class=\"lang-java\">private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {  \n        //利用Entry构造函数构建一个新节点 newEntry，  \n        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);  \n        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的  \n        newEntry.previous.next = newEntry;  \n        newEntry.next.previous = newEntry;  \n        //容量+1  \n        size++;  \n        //修改次数+1  \n        modCount++;  \n        return newEntry;  \n    }\n</code></pre><p>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。<br>LinkedList还提供了其他的增加方法：<br>add(int index, E element)：在此列表中指定的位置插入指定的元素。<br>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。<br>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。<br>AddFirst(E e): 将指定元素插入此列表的开头。<br>addLast(E e): 将指定元素添加到此列表的结尾。</p><h3 id=\"移除方法\"><a href=\"#移除方法\" class=\"headerlink\" title=\"移除方法\"></a>移除方法</h3><p>remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：</p><pre><code class=\"lang-java\">public boolean remove(Object o) {  \n        if (o==null) {  \n            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {  \n                if (e.element==null) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        } else {  \n            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {  \n                if (o.equals(e.element)) {  \n                    remove(e);  \n                    return true;  \n                }  \n            }  \n        }  \n        return false;  \n    }\n</code></pre><p>该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<e>e)，remove(Entry<e>e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</e></e></p><pre><code class=\"lang-java\">private E remove(Entry&lt;E&gt; e) {  \n        if (e == header)  \n            throw new NoSuchElementException();  \n\n        //保留被移除的元素：要返回  \n        E result = e.element;  \n\n        //将该节点的前一节点的next指向该节点后节点  \n        e.previous.next = e.next;  \n        //将该节点的后一节点的previous指向该节点的前节点  \n        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的  \n        e.next.previous = e.previous;  \n        //将该节点归空  \n        e.next = e.previous = null;  \n        e.element = null;  \n        size--;  \n        modCount++;  \n        return result;  \n    }\n</code></pre><p>其他的移除方法：</p><pre><code>   clear()： 从此列表中移除所有元素。\n   remove()：获取并移除此列表的头（第一个元素）。\n   remove(int index)：移除此列表中指定位置处的元素。\n   remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。\n   removeFirst()：移除并返回此列表的第一个元素。\n   removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。\n   removeLast()：移除并返回此列表的最后一个元素。\n   removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。\n</code></pre><h3 id=\"查找方法\"><a href=\"#查找方法\" class=\"headerlink\" title=\"查找方法\"></a>查找方法</h3><p>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</p><pre><code>   get(int index)：返回此列表中指定位置处的元素。\n   getFirst()：返回此列表的第一个元素。\n   getLast()：返回此列表的最后一个元素。\n   indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n   lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。\n</code></pre><!-- rebuild by neat -->"},{"title":"java提高篇（二三）-----HashMap","abbrlink":"1f86fd","date":"2017-10-24T05:09:37.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/18323767\n\nHashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。\n## 定义\nHashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！\n```java\n public class HashMap<K,V>  \n    extends AbstractMap<K,V>  \n    implements Map<K,V>, Cloneable, Serializable  \n```\n## 构造函数\nHashMap提供了三个构造函数：\n<!-- more -->\n\n> HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。\nHashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。\nHashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。\n在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。\nHashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。\n\n## 数据结构\n我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：\n\n从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：\n```java\n    public HashMap(int initialCapacity, float loadFactor) {  \n        //初始容量不能<0  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \"  \n                    + initialCapacity);  \n        //初始容量不能 > 最大容量值，HashMap的最大容量值为2^30  \n        if (initialCapacity > MAXIMUM_CAPACITY)  \n            initialCapacity = MAXIMUM_CAPACITY;  \n        //负载因子不能 < 0  \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))  \n            throw new IllegalArgumentException(\"Illegal load factor: \"  \n                    + loadFactor);  \n  \n        // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。  \n        int capacity = 1;  \n        while (capacity < initialCapacity)  \n            capacity <<= 1;  \n          \n        this.loadFactor = loadFactor;  \n        //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作  \n        threshold = (int) (capacity * loadFactor);  \n        //初始化table数组  \n        table = new Entry[capacity];  \n        init();  \n    }  \n```\n从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。\n```java\n    static class Entry<K,V> implements Map.Entry<K,V> {  \n        final K key;  \n        V value;  \n        Entry<K,V> next;  \n        final int hash;  \n  \n        /** \n         * Creates new entry. \n         */  \n        Entry(int h, K k, V v, Entry<K,V> n) {  \n            value = v;  \n            next = n;  \n            key = k;  \n            hash = h;  \n        }  \n        .......  \n    }\n\n```\n其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。\n上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。\n## 存储实现：put(key,vlaue)\n首先我们先看源码\n```java\n    public V put(K key, V value) {  \n        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  \n        if (key == null)  \n            return putForNullKey(value);  \n        //计算key的hash值  \n        int hash = hash(key.hashCode());                  ------(1)  \n        //计算key hash 值在 table 数组中的位置  \n        int i = indexFor(hash, table.length);             ------(2)  \n        //从i出开始迭代 e,找到 key 保存的位置  \n        for (Entry<K, V> e = table[i]; e != null; e = e.next) {  \n            Object k;  \n            //判断该条链上是否有hash值相同的(key相同)  \n            //若存在相同，则直接覆盖value，返回旧value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n                V oldValue = e.value;    //旧值 = 新值  \n                e.value = value;  \n                e.recordAccess(this);  \n                return oldValue;     //返回旧值  \n            }  \n        }  \n        //修改次数增加1  \n        modCount++;  \n        //将key、value添加至i位置处  \n        addEntry(hash, key, value, i);  \n        return null;  \n    }  \n```\n通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：\n1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。\n2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。\n```java\n    static int hash(int h) {  \n        h ^= (h >>> 20) ^ (h >>> 12);  \n        return h ^ (h >>> 7) ^ (h >>> 4);  \n    }  \n```\n我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。\n```java\n    static int indexFor(int h, int length) {  \n        return h & (length-1);  \n    }  \n```\nHashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity <<= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。\n我们回到indexFor方法，该方法仅有一条语句：h&(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。\n这里我们假设length为16(2^n)和15，h为5、6、7。\n\n当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。\n\n从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。\n这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash && ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：\n```java\n    void addEntry(int hash, K key, V value, int bucketIndex) {  \n        //获取bucketIndex处的Entry  \n        Entry<K, V> e = table[bucketIndex];  \n        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry   \n        table[bucketIndex] = new Entry<K, V>(hash, key, value, e);  \n        //若HashMap中元素的个数超过极限了，则容量扩大两倍  \n        if (size++ >= threshold)  \n            resize(2 * table.length);  \n    }  \n```\n这个方法中有两点需要注意：\n一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。\n## 扩容问题。\n随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。\n## 读取实现：get(key)\n相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。\n```java\n    public V get(Object key) {  \n        // 若为null，调用getForNullKey方法返回相对应的value  \n        if (key == null)  \n            return getForNullKey();  \n        // 根据该 key 的 hashCode 值计算它的 hash 码    \n        int hash = hash(key.hashCode());  \n        // 取出 table 数组中指定索引处的值  \n        for (Entry<K, V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {  \n            Object k;  \n            //若搜索的key与查找的key相同，则返回相对应的value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k)))  \n                return e.value;  \n        }  \n        return null;  \n    }  \n```\n在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。\n","source":"_posts/java-toup22.md","raw":"---\ntitle: java提高篇（二三）-----HashMap\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 1f86fd\ndate: 2017-10-24 13:09:37\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/18323767\n\nHashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。\n## 定义\nHashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！\n```java\n public class HashMap<K,V>  \n    extends AbstractMap<K,V>  \n    implements Map<K,V>, Cloneable, Serializable  \n```\n## 构造函数\nHashMap提供了三个构造函数：\n<!-- more -->\n\n> HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。\nHashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。\nHashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。\n在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。\nHashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。\n\n## 数据结构\n我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：\n\n从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：\n```java\n    public HashMap(int initialCapacity, float loadFactor) {  \n        //初始容量不能<0  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal initial capacity: \"  \n                    + initialCapacity);  \n        //初始容量不能 > 最大容量值，HashMap的最大容量值为2^30  \n        if (initialCapacity > MAXIMUM_CAPACITY)  \n            initialCapacity = MAXIMUM_CAPACITY;  \n        //负载因子不能 < 0  \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))  \n            throw new IllegalArgumentException(\"Illegal load factor: \"  \n                    + loadFactor);  \n  \n        // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。  \n        int capacity = 1;  \n        while (capacity < initialCapacity)  \n            capacity <<= 1;  \n          \n        this.loadFactor = loadFactor;  \n        //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作  \n        threshold = (int) (capacity * loadFactor);  \n        //初始化table数组  \n        table = new Entry[capacity];  \n        init();  \n    }  \n```\n从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。\n```java\n    static class Entry<K,V> implements Map.Entry<K,V> {  \n        final K key;  \n        V value;  \n        Entry<K,V> next;  \n        final int hash;  \n  \n        /** \n         * Creates new entry. \n         */  \n        Entry(int h, K k, V v, Entry<K,V> n) {  \n            value = v;  \n            next = n;  \n            key = k;  \n            hash = h;  \n        }  \n        .......  \n    }\n\n```\n其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。\n上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。\n## 存储实现：put(key,vlaue)\n首先我们先看源码\n```java\n    public V put(K key, V value) {  \n        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  \n        if (key == null)  \n            return putForNullKey(value);  \n        //计算key的hash值  \n        int hash = hash(key.hashCode());                  ------(1)  \n        //计算key hash 值在 table 数组中的位置  \n        int i = indexFor(hash, table.length);             ------(2)  \n        //从i出开始迭代 e,找到 key 保存的位置  \n        for (Entry<K, V> e = table[i]; e != null; e = e.next) {  \n            Object k;  \n            //判断该条链上是否有hash值相同的(key相同)  \n            //若存在相同，则直接覆盖value，返回旧value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n                V oldValue = e.value;    //旧值 = 新值  \n                e.value = value;  \n                e.recordAccess(this);  \n                return oldValue;     //返回旧值  \n            }  \n        }  \n        //修改次数增加1  \n        modCount++;  \n        //将key、value添加至i位置处  \n        addEntry(hash, key, value, i);  \n        return null;  \n    }  \n```\n通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：\n1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。\n2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。\n```java\n    static int hash(int h) {  \n        h ^= (h >>> 20) ^ (h >>> 12);  \n        return h ^ (h >>> 7) ^ (h >>> 4);  \n    }  \n```\n我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。\n```java\n    static int indexFor(int h, int length) {  \n        return h & (length-1);  \n    }  \n```\nHashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity <<= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。\n我们回到indexFor方法，该方法仅有一条语句：h&(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。\n这里我们假设length为16(2^n)和15，h为5、6、7。\n\n当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。\n\n从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。\n这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash && ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：\n```java\n    void addEntry(int hash, K key, V value, int bucketIndex) {  \n        //获取bucketIndex处的Entry  \n        Entry<K, V> e = table[bucketIndex];  \n        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry   \n        table[bucketIndex] = new Entry<K, V>(hash, key, value, e);  \n        //若HashMap中元素的个数超过极限了，则容量扩大两倍  \n        if (size++ >= threshold)  \n            resize(2 * table.length);  \n    }  \n```\n这个方法中有两点需要注意：\n一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。\n## 扩容问题。\n随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。\n## 读取实现：get(key)\n相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。\n```java\n    public V get(Object key) {  \n        // 若为null，调用getForNullKey方法返回相对应的value  \n        if (key == null)  \n            return getForNullKey();  \n        // 根据该 key 的 hashCode 值计算它的 hash 码    \n        int hash = hash(key.hashCode());  \n        // 取出 table 数组中指定索引处的值  \n        for (Entry<K, V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {  \n            Object k;  \n            //若搜索的key与查找的key相同，则返回相对应的value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k)))  \n                return e.value;  \n        }  \n        return null;  \n    }  \n```\n在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。\n","slug":"java-toup22","published":1,"updated":"2019-09-03T03:40:46.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keten001s0vfaqckc43r1","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/18323767\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/18323767</a></p></blockquote><p>HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">   <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">   <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>HashMap提供了三个构造函数：<br><a id=\"more\"></a></p><blockquote><p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。<br>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。<br>HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</p></blockquote><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：</p><p>从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//初始容量不能&lt;0  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span>  </span><br><span class=\"line\">                + initialCapacity);  </span><br><span class=\"line\">    <span class=\"comment\">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class=\"line\">    <span class=\"comment\">//负载因子不能 &lt; 0  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span>  </span><br><span class=\"line\">                + loadFactor);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算出大于 initialCapacity 的最小的 2 的 n 次方值。  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)  </span><br><span class=\"line\">        capacity &lt;&lt;= <span class=\"number\">1</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;  </span><br><span class=\"line\">    <span class=\"comment\">//设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>) (capacity * loadFactor);  </span><br><span class=\"line\">    <span class=\"comment\">//初始化table数组  </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[capacity];  </span><br><span class=\"line\">    init();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;  </span><br><span class=\"line\">    V value;  </span><br><span class=\"line\">    Entry&lt;K,V&gt; next;  </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * Creates new entry. </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </span><br><span class=\"line\">        value = v;  </span><br><span class=\"line\">        next = n;  </span><br><span class=\"line\">        key = k;  </span><br><span class=\"line\">        hash = h;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。<br>上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。</p><h2 id=\"存储实现：put-key-vlaue\"><a href=\"#存储实现：put-key-vlaue\" class=\"headerlink\" title=\"存储实现：put(key,vlaue)\"></a>存储实现：put(key,vlaue)</h2><p>首先我们先看源码<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());                  ------(<span class=\"number\">1</span>)  </span><br><span class=\"line\">    <span class=\"comment\">//计算key hash 值在 table 数组中的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);             ------(<span class=\"number\">2</span>)  </span><br><span class=\"line\">    <span class=\"comment\">//从i出开始迭代 e,找到 key 保存的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//判断该条链上是否有hash值相同的(key相同)  </span></span><br><span class=\"line\">        <span class=\"comment\">//若存在相同，则直接覆盖value，返回旧value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            V oldValue = e.value;    <span class=\"comment\">//旧值 = 新值  </span></span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;     <span class=\"comment\">//返回旧值  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//修改次数增加1  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//将key、value添加至i位置处  </span></span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：<br>1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。<br>2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;  </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。<br>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。<br>这里我们假设length为16(2^n)和15，h为5、6、7。</p><p>当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p><p>从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。<br>这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//获取bucketIndex处的Entry  </span></span><br><span class=\"line\">    Entry&lt;K, V&gt; e = table[bucketIndex];  </span><br><span class=\"line\">    <span class=\"comment\">//将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry   </span></span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;K, V&gt;(hash, key, value, e);  </span><br><span class=\"line\">    <span class=\"comment\">//若HashMap中元素的个数超过极限了，则容量扩大两倍  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size++ &gt;= threshold)  </span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法中有两点需要注意：<br>一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。</p><h2 id=\"扩容问题。\"><a href=\"#扩容问题。\" class=\"headerlink\" title=\"扩容问题。\"></a>扩容问题。</h2><p>随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h2 id=\"读取实现：get-key\"><a href=\"#读取实现：get-key\" class=\"headerlink\" title=\"读取实现：get(key)\"></a>读取实现：get(key)</h2><p>相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 若为null，调用getForNullKey方法返回相对应的value  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> getForNullKey();  </span><br><span class=\"line\">    <span class=\"comment\">// 根据该 key 的 hashCode 值计算它的 hash 码    </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());  </span><br><span class=\"line\">    <span class=\"comment\">// 取出 table 数组中指定索引处的值  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//若搜索的key与查找的key相同，则返回相对应的value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</p><!-- rebuild by neat -->","site":{"data":{}},"length":7263,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/18323767\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/18323767</a></p></blockquote><p>HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">   <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">   <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>HashMap提供了三个构造函数：<br>","more":"</p><blockquote><p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。<br>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。<br>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。<br>HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</p></blockquote><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：</p><p>从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//初始容量不能&lt;0  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span>  </span><br><span class=\"line\">                + initialCapacity);  </span><br><span class=\"line\">    <span class=\"comment\">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class=\"line\">    <span class=\"comment\">//负载因子不能 &lt; 0  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span>  </span><br><span class=\"line\">                + loadFactor);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算出大于 initialCapacity 的最小的 2 的 n 次方值。  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)  </span><br><span class=\"line\">        capacity &lt;&lt;= <span class=\"number\">1</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;  </span><br><span class=\"line\">    <span class=\"comment\">//设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>) (capacity * loadFactor);  </span><br><span class=\"line\">    <span class=\"comment\">//初始化table数组  </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[capacity];  </span><br><span class=\"line\">    init();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;  </span><br><span class=\"line\">    V value;  </span><br><span class=\"line\">    Entry&lt;K,V&gt; next;  </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * Creates new entry. </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;  </span><br><span class=\"line\">        value = v;  </span><br><span class=\"line\">        next = n;  </span><br><span class=\"line\">        key = k;  </span><br><span class=\"line\">        hash = h;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    .......  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。<br>上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。</p><h2 id=\"存储实现：put-key-vlaue\"><a href=\"#存储实现：put-key-vlaue\" class=\"headerlink\" title=\"存储实现：put(key,vlaue)\"></a>存储实现：put(key,vlaue)</h2><p>首先我们先看源码<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());                  ------(<span class=\"number\">1</span>)  </span><br><span class=\"line\">    <span class=\"comment\">//计算key hash 值在 table 数组中的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);             ------(<span class=\"number\">2</span>)  </span><br><span class=\"line\">    <span class=\"comment\">//从i出开始迭代 e,找到 key 保存的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//判断该条链上是否有hash值相同的(key相同)  </span></span><br><span class=\"line\">        <span class=\"comment\">//若存在相同，则直接覆盖value，返回旧value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            V oldValue = e.value;    <span class=\"comment\">//旧值 = 新值  </span></span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;     <span class=\"comment\">//返回旧值  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//修改次数增加1  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//将key、value添加至i位置处  </span></span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：<br>1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。<br>2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;  </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。<br>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。<br>这里我们假设length为16(2^n)和15，h为5、6、7。</p><p>当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</p><p>从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。<br>这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//获取bucketIndex处的Entry  </span></span><br><span class=\"line\">    Entry&lt;K, V&gt; e = table[bucketIndex];  </span><br><span class=\"line\">    <span class=\"comment\">//将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry   </span></span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;K, V&gt;(hash, key, value, e);  </span><br><span class=\"line\">    <span class=\"comment\">//若HashMap中元素的个数超过极限了，则容量扩大两倍  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size++ &gt;= threshold)  </span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法中有两点需要注意：<br>一是链的产生。这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。</p><h2 id=\"扩容问题。\"><a href=\"#扩容问题。\" class=\"headerlink\" title=\"扩容问题。\"></a>扩容问题。</h2><p>随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h2 id=\"读取实现：get-key\"><a href=\"#读取实现：get-key\" class=\"headerlink\" title=\"读取实现：get(key)\"></a>读取实现：get(key)</h2><p>相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 若为null，调用getForNullKey方法返回相对应的value  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> getForNullKey();  </span><br><span class=\"line\">    <span class=\"comment\">// 根据该 key 的 hashCode 值计算它的 hash 码    </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());  </span><br><span class=\"line\">    <span class=\"comment\">// 取出 table 数组中指定索引处的值  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//若搜索的key与查找的key相同，则返回相对应的value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</p><!-- rebuild by neat -->"},{"title":"java提高篇（二四）-----HashSet","abbrlink":"864acdf8","date":"2017-10-24T05:09:42.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/21988605\n\n在前篇博文中（java提高篇（二三）-----HashMap）详细讲解了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so easy!!\n## 定义\n```java\n    public class HashSet<E>  \n        extends AbstractSet<E>  \n        implements Set<E>, Cloneable, java.io.Serializable  \n```\nHashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。\n基本属性\n<!-- more -->\n```java\n    //基于HashMap实现，底层使用HashMap保存所有元素  \n    private transient HashMap<E,Object> map;  \n    \n    //定义一个Object对象作为HashMap的value  \n    private static final Object PRESENT = new Object();  \n```\n构造函数\n```java\n        /** \n         * 默认构造函数 \n         * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \n         */  \n        public HashSet() {  \n            map = new HashMap<>();  \n        }  \n          \n        /** \n         * 构造一个包含指定 collection 中的元素的新 set。 \n         */  \n        public HashSet(Collection<? extends E> c) {  \n            map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));  \n            addAll(c);  \n        }  \n          \n        /** \n         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子 \n         */  \n        public HashSet(int initialCapacity, float loadFactor) {  \n            map = new HashMap<>(initialCapacity, loadFactor);  \n        }  \n             \n        /** \n         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 \n         */  \n        public HashSet(int initialCapacity) {  \n           map = new HashMap<>(initialCapacity);  \n        }  \n             \n        /** \n         * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的） \n         * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n         * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用 \n         */  \n        HashSet(int initialCapacity, float loadFactor, boolean dummy) {  \n           map = new LinkedHashMap<>(initialCapacity, loadFactor);  \n        }  \n```\n从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。\n## 方法\n既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。\n```java\n    public Iterator<E> iterator() {  \n        return map.keySet().iterator();  \n    }  \n```\niterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。\n```java\n    public int size() {  \n        return map.size();  \n    } \n``` \nsize()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。\n```java\n    public boolean isEmpty() {  \n        return map.isEmpty();  \n    }  \n```\nisEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。\n```java\n    public boolean contains(Object o) {  \n        return map.containsKey(o);  \n    } \n```\n\ncontains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。\n```java\n    public boolean add(E e) {  \n        return map.put(e, PRESENT)==null;  \n    }  \n```\nadd()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。\n```java\n    public boolean remove(Object o) {  \n        return map.remove(o)==PRESENT;  \n    }  \n```\nremove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。\n```java\n    public void clear() {  \n        map.clear();  \n    }  \n```\nclear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。\n```java\n    public Object clone() {  \n        try {  \n            HashSet<E> newSet = (HashSet<E>) super.clone();  \n            newSet.map = (HashMap<E, Object>) map.clone();  \n            return newSet;  \n        } catch (CloneNotSupportedException e) {  \n            throw new InternalError();  \n        }  \n    } \n``` \nclone返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。\n后记：\n由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。","source":"_posts/java-toup23.md","raw":"---\ntitle: java提高篇（二四）-----HashSet\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 864acdf8\ndate: 2017-10-24 13:09:42\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/21988605\n\n在前篇博文中（java提高篇（二三）-----HashMap）详细讲解了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so easy!!\n## 定义\n```java\n    public class HashSet<E>  \n        extends AbstractSet<E>  \n        implements Set<E>, Cloneable, java.io.Serializable  \n```\nHashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。\n基本属性\n<!-- more -->\n```java\n    //基于HashMap实现，底层使用HashMap保存所有元素  \n    private transient HashMap<E,Object> map;  \n    \n    //定义一个Object对象作为HashMap的value  \n    private static final Object PRESENT = new Object();  \n```\n构造函数\n```java\n        /** \n         * 默认构造函数 \n         * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \n         */  \n        public HashSet() {  \n            map = new HashMap<>();  \n        }  \n          \n        /** \n         * 构造一个包含指定 collection 中的元素的新 set。 \n         */  \n        public HashSet(Collection<? extends E> c) {  \n            map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));  \n            addAll(c);  \n        }  \n          \n        /** \n         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子 \n         */  \n        public HashSet(int initialCapacity, float loadFactor) {  \n            map = new HashMap<>(initialCapacity, loadFactor);  \n        }  \n             \n        /** \n         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 \n         */  \n        public HashSet(int initialCapacity) {  \n           map = new HashMap<>(initialCapacity);  \n        }  \n             \n        /** \n         * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的） \n         * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n         * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用 \n         */  \n        HashSet(int initialCapacity, float loadFactor, boolean dummy) {  \n           map = new LinkedHashMap<>(initialCapacity, loadFactor);  \n        }  \n```\n从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。\n## 方法\n既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。\n```java\n    public Iterator<E> iterator() {  \n        return map.keySet().iterator();  \n    }  \n```\niterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。\n```java\n    public int size() {  \n        return map.size();  \n    } \n``` \nsize()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。\n```java\n    public boolean isEmpty() {  \n        return map.isEmpty();  \n    }  \n```\nisEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。\n```java\n    public boolean contains(Object o) {  \n        return map.containsKey(o);  \n    } \n```\n\ncontains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。\n```java\n    public boolean add(E e) {  \n        return map.put(e, PRESENT)==null;  \n    }  \n```\nadd()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。\n```java\n    public boolean remove(Object o) {  \n        return map.remove(o)==PRESENT;  \n    }  \n```\nremove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。\n```java\n    public void clear() {  \n        map.clear();  \n    }  \n```\nclear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。\n```java\n    public Object clone() {  \n        try {  \n            HashSet<E> newSet = (HashSet<E>) super.clone();  \n            newSet.map = (HashMap<E, Object>) map.clone();  \n            return newSet;  \n        } catch (CloneNotSupportedException e) {  \n            throw new InternalError();  \n        }  \n    } \n``` \nclone返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。\n后记：\n由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。","slug":"java-toup23","published":1,"updated":"2019-09-03T03:40:46.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketep001v0vfa0885y3h5","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/21988605\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/21988605</a></p></blockquote><p>在前篇博文中（java提高篇（二三）——-HashMap）详细讲解了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so easy!!</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashSet</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Set</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。<br>基本属性<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于HashMap实现，底层使用HashMap保存所有元素  </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个Object对象作为HashMap的value  </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure><p></p><p>构造函数<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 默认构造函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个包含指定 collection 中的元素的新 set。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(Math.max((<span class=\"keyword\">int</span>) (c.size()/.<span class=\"number\">75f</span>) + <span class=\"number\">1</span>, <span class=\"number\">16</span>));  </span><br><span class=\"line\">    addAll(c);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">   map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的） </span></span><br><span class=\"line\"><span class=\"comment\"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span></span><br><span class=\"line\"><span class=\"comment\"> * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">HashSet(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> dummy) &#123;  </span><br><span class=\"line\">   map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。</p><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.keySet().iterator();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>iterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.size();  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">``` </span><br><span class=\"line\">size()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.isEmpty();  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>isEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.containsKey(o);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.remove(o)==PRESENT;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>remove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    map.clear();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>clear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。</p><pre><code class=\"lang-java\">    public Object clone() {  \n        try {  \n            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  \n            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  \n            return newSet;  \n        } catch (CloneNotSupportedException e) {  \n            throw new InternalError();  \n        }  \n    }\n</code></pre><p>clone返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。<br>后记：<br>由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。</p><!-- rebuild by neat -->","site":{"data":{}},"length":3677,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/21988605\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/21988605</a></p></blockquote><p>在前篇博文中（java提高篇（二三）——-HashMap）详细讲解了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so easy!!</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashSet</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Set</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。<br>基本属性<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基于HashMap实现，底层使用HashMap保存所有元素  </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义一个Object对象作为HashMap的value  </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure><p></p><p>构造函数<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 默认构造函数 </span></span><br><span class=\"line\"><span class=\"comment\"> * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个包含指定 collection 中的元素的新 set。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(Math.max((<span class=\"keyword\">int</span>) (c.size()/.<span class=\"number\">75f</span>) + <span class=\"number\">1</span>, <span class=\"number\">16</span>));  </span><br><span class=\"line\">    addAll(c);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashSet</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">   map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(initialCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的） </span></span><br><span class=\"line\"><span class=\"comment\"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span></span><br><span class=\"line\"><span class=\"comment\"> * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">HashSet(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor, <span class=\"keyword\">boolean</span> dummy) &#123;  </span><br><span class=\"line\">   map = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。</p><h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.keySet().iterator();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>iterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.size();  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">``` </span><br><span class=\"line\">size()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.isEmpty();  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>isEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.containsKey(o);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.put(e, PRESENT)==<span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> map.remove(o)==PRESENT;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>remove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    map.clear();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>clear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。</p><pre><code class=\"lang-java\">    public Object clone() {  \n        try {  \n            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();  \n            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  \n            return newSet;  \n        } catch (CloneNotSupportedException e) {  \n            throw new InternalError();  \n        }  \n    }\n</code></pre><p>clone返回此 HashSet 实例的浅表副本：并没有复制这些元素本身。<br>后记：<br>由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。</p><!-- rebuild by neat -->"},{"title":"java提高篇（二五）-----HashTable","abbrlink":"cb6e0d96","date":"2017-10-24T05:09:45.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/22896871\n\n\n有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。\n## 定义\nHashTable在Java中的定义如下：\n```java\n    public class Hashtable<K,V>  \n        extends Dictionary<K,V>  \n        implements Map<K,V>, Cloneable, java.io.Serializable \n```\n\n从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是\"key-value键值对\"接口。\n<!-- more -->\nHashTable采用\"拉链法\"实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。\ntable：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的\"key-value键值对\"都是存储在Entry数组中的。\ncount：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。\nthreshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=\"容量*加载因子\"。\nloadFactor：加载因子。\nmodCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。\n\n## 构造方法\n在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。\n```java\n    public Hashtable() {  \n        this(11, 0.75f);  \n    }  \n```\n\n默认构造函数，容量为11，加载因子为0.75。\n```java\n    public Hashtable(int initialCapacity) {  \n        this(initialCapacity, 0.75f);  \n    } \n```\n\n用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。\n```java\n    public Hashtable(int initialCapacity, float loadFactor) {  \n        //验证初始容量  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+  \n                                               initialCapacity);  \n        //验证加载因子  \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))  \n            throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);  \n  \n        if (initialCapacity==0)  \n            initialCapacity = 1;  \n          \n        this.loadFactor = loadFactor;  \n          \n        //初始化table，获得大小为initialCapacity的table数组  \n        table = new Entry[initialCapacity];  \n        //计算阀值  \n        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  \n        //初始化HashSeed值  \n        initHashSeedAsNeeded(initialCapacity);  \n    }  \n```\n\n用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。\n\n```java\n    private int hash(Object k) {  \n        return hashSeed ^ k.hashCode();  \n    } \n```\n\n构造一个与给定的 Map 具有相同映射关系的新哈希表。\n```java\n    public Hashtable(Map<? extends K, ? extends V> t) {  \n        //设置table容器大小，其值==t.size * 2 + 1  \n        this(Math.max(2*t.size(), 11), 0.75f);  \n        putAll(t);  \n    }  \n```\n## 主要方法\nHashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。\n首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。\n```java\n    public synchronized V put(K key, V value) {  \n        // 确保value不为null  \n        if (value == null) {  \n            throw new NullPointerException();  \n        }  \n  \n        /* \n         * 确保key在table[]是不重复的 \n         * 处理过程： \n         * 1、计算key的hash值，确认在table[]中的索引位置 \n         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 \n         */  \n        Entry tab[] = table;  \n        int hash = hash(key);    //计算key的hash值  \n        int index = (hash & 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  \n        //迭代，寻找该key，替换  \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  \n            if ((e.hash == hash) && e.key.equals(key)) {  \n                V old = e.value;  \n                e.value = value;  \n                return old;  \n            }  \n        }  \n  \n        modCount++;  \n        if (count >= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作  \n            rehash();  \n            tab = table;  \n            hash = hash(key);  \n            index = (hash & 0x7FFFFFFF) % tab.length;  \n        }  \n  \n        // 在索引位置处插入一个新的节点  \n        Entry<K,V> e = tab[index];  \n        tab[index] = new Entry<>(hash, key, value, e);  \n        //容器中元素+1  \n        count++;  \n        return null;  \n    } \n```\n\nput方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：\n首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：\n![](/uploads/hashmap1.png)\n\n然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。\n![](/uploads/hashmap2.png)\n在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。\n![](/uploads/hashmap3.png)\n在HashTabled的put方法中有两个地方需要注意：\n1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:\n```java\n    protected void rehash() {  \n        int oldCapacity = table.length;  \n        //元素  \n        Entry<K,V>[] oldMap = table;  \n  \n        //新容量=旧容量 * 2 + 1  \n        int newCapacity = (oldCapacity << 1) + 1;  \n        if (newCapacity - MAX_ARRAY_SIZE > 0) {  \n            if (oldCapacity == MAX_ARRAY_SIZE)  \n                return;  \n            newCapacity = MAX_ARRAY_SIZE;  \n        }  \n          \n        //新建一个size = newCapacity 的HashTable  \n        Entry<K,V>[] newMap = new Entry[];  \n  \n        modCount++;  \n        //重新计算阀值  \n        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  \n        //重新计算hashSeed  \n        boolean rehash = initHashSeedAsNeeded(newCapacity);  \n  \n        table = newMap;  \n        //将原来的元素拷贝到新的HashTable中  \n        for (int i = oldCapacity ; i-- > 0 ;) {  \n            for (Entry<K,V> old = oldMap[i] ; old != null ; ) {  \n                Entry<K,V> e = old;  \n                old = old.next;  \n  \n                if (rehash) {  \n                    e.hash = hash(e.key);  \n                }  \n                int index = (e.hash & 0x7FFFFFFF) % newCapacity;  \n                e.next = newMap[index];  \n                newMap[index] = e;  \n            }  \n        }  \n    }  \n```\n在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 * 2 + 1 =17，而阀值threshold=17*0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。\n2、其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash & 0x7FFFFFFF），为什么需要做一步操作，这么做有什么好处？如果哪位知道，望指导，LZ不胜感激！！下面是计算key的hash值，这里hashSeed发挥了作用。\n```java\n    private int hash(Object k) {  \n        return hashSeed ^ k.hashCode();  \n    }  \n相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。\n```java\n    public synchronized V get(Object key) {  \n        Entry tab[] = table;  \n        int hash = hash(key);  \n        int index = (hash & 0x7FFFFFFF) % tab.length;  \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  \n            if ((e.hash == hash) && e.key.equals(key)) {  \n                return e.value;  \n            }  \n        }  \n        return null;  \n    }  \n```\n## HashTable与HashMap的区别\nHashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。\n第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。\n第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：\n当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。\n```java\n    if (key == null)  \n         return putForNullKey(value);  \n```\n而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。\n```java\n    if (value == null) {  \n        throw new NullPointerException();  \n    }  \n```\n第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？","source":"_posts/java-toup24.md","raw":"---\ntitle: java提高篇（二五）-----HashTable\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: cb6e0d96\ndate: 2017-10-24 13:09:45\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/22896871\n\n\n有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。\n## 定义\nHashTable在Java中的定义如下：\n```java\n    public class Hashtable<K,V>  \n        extends Dictionary<K,V>  \n        implements Map<K,V>, Cloneable, java.io.Serializable \n```\n\n从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是\"key-value键值对\"接口。\n<!-- more -->\nHashTable采用\"拉链法\"实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。\ntable：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的\"key-value键值对\"都是存储在Entry数组中的。\ncount：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。\nthreshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=\"容量*加载因子\"。\nloadFactor：加载因子。\nmodCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。\n\n## 构造方法\n在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。\n```java\n    public Hashtable() {  \n        this(11, 0.75f);  \n    }  \n```\n\n默认构造函数，容量为11，加载因子为0.75。\n```java\n    public Hashtable(int initialCapacity) {  \n        this(initialCapacity, 0.75f);  \n    } \n```\n\n用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。\n```java\n    public Hashtable(int initialCapacity, float loadFactor) {  \n        //验证初始容量  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+  \n                                               initialCapacity);  \n        //验证加载因子  \n        if (loadFactor <= 0 || Float.isNaN(loadFactor))  \n            throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);  \n  \n        if (initialCapacity==0)  \n            initialCapacity = 1;  \n          \n        this.loadFactor = loadFactor;  \n          \n        //初始化table，获得大小为initialCapacity的table数组  \n        table = new Entry[initialCapacity];  \n        //计算阀值  \n        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  \n        //初始化HashSeed值  \n        initHashSeedAsNeeded(initialCapacity);  \n    }  \n```\n\n用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。\n\n```java\n    private int hash(Object k) {  \n        return hashSeed ^ k.hashCode();  \n    } \n```\n\n构造一个与给定的 Map 具有相同映射关系的新哈希表。\n```java\n    public Hashtable(Map<? extends K, ? extends V> t) {  \n        //设置table容器大小，其值==t.size * 2 + 1  \n        this(Math.max(2*t.size(), 11), 0.75f);  \n        putAll(t);  \n    }  \n```\n## 主要方法\nHashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。\n首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。\n```java\n    public synchronized V put(K key, V value) {  \n        // 确保value不为null  \n        if (value == null) {  \n            throw new NullPointerException();  \n        }  \n  \n        /* \n         * 确保key在table[]是不重复的 \n         * 处理过程： \n         * 1、计算key的hash值，确认在table[]中的索引位置 \n         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 \n         */  \n        Entry tab[] = table;  \n        int hash = hash(key);    //计算key的hash值  \n        int index = (hash & 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  \n        //迭代，寻找该key，替换  \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  \n            if ((e.hash == hash) && e.key.equals(key)) {  \n                V old = e.value;  \n                e.value = value;  \n                return old;  \n            }  \n        }  \n  \n        modCount++;  \n        if (count >= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作  \n            rehash();  \n            tab = table;  \n            hash = hash(key);  \n            index = (hash & 0x7FFFFFFF) % tab.length;  \n        }  \n  \n        // 在索引位置处插入一个新的节点  \n        Entry<K,V> e = tab[index];  \n        tab[index] = new Entry<>(hash, key, value, e);  \n        //容器中元素+1  \n        count++;  \n        return null;  \n    } \n```\n\nput方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：\n首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：\n![](/uploads/hashmap1.png)\n\n然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。\n![](/uploads/hashmap2.png)\n在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。\n![](/uploads/hashmap3.png)\n在HashTabled的put方法中有两个地方需要注意：\n1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:\n```java\n    protected void rehash() {  \n        int oldCapacity = table.length;  \n        //元素  \n        Entry<K,V>[] oldMap = table;  \n  \n        //新容量=旧容量 * 2 + 1  \n        int newCapacity = (oldCapacity << 1) + 1;  \n        if (newCapacity - MAX_ARRAY_SIZE > 0) {  \n            if (oldCapacity == MAX_ARRAY_SIZE)  \n                return;  \n            newCapacity = MAX_ARRAY_SIZE;  \n        }  \n          \n        //新建一个size = newCapacity 的HashTable  \n        Entry<K,V>[] newMap = new Entry[];  \n  \n        modCount++;  \n        //重新计算阀值  \n        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  \n        //重新计算hashSeed  \n        boolean rehash = initHashSeedAsNeeded(newCapacity);  \n  \n        table = newMap;  \n        //将原来的元素拷贝到新的HashTable中  \n        for (int i = oldCapacity ; i-- > 0 ;) {  \n            for (Entry<K,V> old = oldMap[i] ; old != null ; ) {  \n                Entry<K,V> e = old;  \n                old = old.next;  \n  \n                if (rehash) {  \n                    e.hash = hash(e.key);  \n                }  \n                int index = (e.hash & 0x7FFFFFFF) % newCapacity;  \n                e.next = newMap[index];  \n                newMap[index] = e;  \n            }  \n        }  \n    }  \n```\n在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 * 2 + 1 =17，而阀值threshold=17*0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。\n2、其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash & 0x7FFFFFFF），为什么需要做一步操作，这么做有什么好处？如果哪位知道，望指导，LZ不胜感激！！下面是计算key的hash值，这里hashSeed发挥了作用。\n```java\n    private int hash(Object k) {  \n        return hashSeed ^ k.hashCode();  \n    }  \n相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。\n```java\n    public synchronized V get(Object key) {  \n        Entry tab[] = table;  \n        int hash = hash(key);  \n        int index = (hash & 0x7FFFFFFF) % tab.length;  \n        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  \n            if ((e.hash == hash) && e.key.equals(key)) {  \n                return e.value;  \n            }  \n        }  \n        return null;  \n    }  \n```\n## HashTable与HashMap的区别\nHashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。\n第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。\n第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：\n当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。\n```java\n    if (key == null)  \n         return putForNullKey(value);  \n```\n而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。\n```java\n    if (value == null) {  \n        throw new NullPointerException();  \n    }  \n```\n第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？","slug":"java-toup24","published":1,"updated":"2019-09-03T03:40:46.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketes001z0vfasr9c7ii3","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/22896871\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/22896871</a></p></blockquote><p>有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>HashTable在Java中的定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hashtable</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">Dictionary</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。<br><a id=\"more\"></a><br>HashTable采用”拉链法”实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。<br>table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的”key-value键值对”都是存储在Entry数组中的。<br>count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。<br>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。<br>loadFactor：加载因子。<br>modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</p><h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>默认构造函数，容量为11，加载因子为0.75。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//验证初始容量  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+  </span><br><span class=\"line\">                                           initialCapacity);  </span><br><span class=\"line\">    <span class=\"comment\">//验证加载因子  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load: \"</span>+loadFactor);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity==<span class=\"number\">0</span>)  </span><br><span class=\"line\">        initialCapacity = <span class=\"number\">1</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//初始化table，获得大小为initialCapacity的table数组  </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[initialCapacity];  </span><br><span class=\"line\">    <span class=\"comment\">//计算阀值  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">//初始化HashSeed值  </span></span><br><span class=\"line\">    initHashSeedAsNeeded(initialCapacity);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> hashSeed ^ k.hashCode();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>构造一个与给定的 Map 具有相同映射关系的新哈希表。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//设置table容器大小，其值==t.size * 2 + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max(<span class=\"number\">2</span>*t.size(), <span class=\"number\">11</span>), <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">    putAll(t);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><p>HashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。<br>首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 确保value不为null  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 确保key在table[]是不重复的 </span></span><br><span class=\"line\"><span class=\"comment\">     * 处理过程： </span></span><br><span class=\"line\"><span class=\"comment\">     * 1、计算key的hash值，确认在table[]中的索引位置 </span></span><br><span class=\"line\"><span class=\"comment\">     * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    Entry tab[] = table;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;     <span class=\"comment\">//确认该key的索引位置  </span></span><br><span class=\"line\">    <span class=\"comment\">//迭代，寻找该key，替换  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class=\"line\">            V old = e.value;  </span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> old;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt;= threshold) &#123;  <span class=\"comment\">//如果容器中的元素数量已经达到阀值，则进行扩容操作  </span></span><br><span class=\"line\">        rehash();  </span><br><span class=\"line\">        tab = table;  </span><br><span class=\"line\">        hash = hash(key);  </span><br><span class=\"line\">        index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 在索引位置处插入一个新的节点  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];  </span><br><span class=\"line\">    tab[index] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);  </span><br><span class=\"line\">    <span class=\"comment\">//容器中元素+1  </span></span><br><span class=\"line\">    count++;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：<br>首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：<br><img src=\"/uploads/hashmap1.png\" alt></p><p>然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。<br><img src=\"/uploads/hashmap2.png\" alt><br>在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。<br><img src=\"/uploads/hashmap3.png\" alt><br>在HashTabled的put方法中有两个地方需要注意：<br>1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = table.length;  </span><br><span class=\"line\">    <span class=\"comment\">//元素  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] oldMap = table;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//新容量=旧容量 * 2 + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = (oldCapacity &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCapacity == MAX_ARRAY_SIZE)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        newCapacity = MAX_ARRAY_SIZE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//新建一个size = newCapacity 的HashTable  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] newMap = <span class=\"keyword\">new</span> Entry[];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//重新计算阀值  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">//重新计算hashSeed  </span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    table = newMap;  </span><br><span class=\"line\">    <span class=\"comment\">//将原来的元素拷贝到新的HashTable中  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = oldCapacity ; i-- &gt; <span class=\"number\">0</span> ;) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class=\"keyword\">null</span> ; ) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; e = old;  </span><br><span class=\"line\">            old = old.next;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;  </span><br><span class=\"line\">                e.hash = hash(e.key);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = (e.hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % newCapacity;  </span><br><span class=\"line\">            e.next = newMap[index];  </span><br><span class=\"line\">            newMap[index] = e;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 <em>2 + 1 =17，而阀值threshold=17</em>0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。<br>2、其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash &amp; 0x7FFFFFFF），为什么需要做一步操作，这么做有什么好处？如果哪位知道，望指导，LZ不胜感激！！下面是计算key的hash值，这里hashSeed发挥了作用。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hashSeed ^ k.hashCode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回<span class=\"keyword\">null</span>。</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;  </span><br><span class=\"line\">        Entry tab[] = table;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.value;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"HashTable与HashMap的区别\"><a href=\"#HashTable与HashMap的区别\" class=\"headerlink\" title=\"HashTable与HashMap的区别\"></a>HashTable与HashMap的区别</h2><p>HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。<br>第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。<br>第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：<br>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">     <span class=\"keyword\">return</span> putForNullKey(value);</span><br></pre></td></tr></table></figure><p></p><p>而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？</p><!-- rebuild by neat -->","site":{"data":{}},"length":7421,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/22896871\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/22896871</a></p></blockquote><p>有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。</p><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>HashTable在Java中的定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hashtable</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">Dictionary</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。<br>","more":"<br>HashTable采用”拉链法”实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。<br>table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的”key-value键值对”都是存储在Entry数组中的。<br>count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。<br>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。<br>loadFactor：加载因子。<br>modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</p><h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>默认构造函数，容量为11，加载因子为0.75。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//验证初始容量  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+  </span><br><span class=\"line\">                                           initialCapacity);  </span><br><span class=\"line\">    <span class=\"comment\">//验证加载因子  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load: \"</span>+loadFactor);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity==<span class=\"number\">0</span>)  </span><br><span class=\"line\">        initialCapacity = <span class=\"number\">1</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//初始化table，获得大小为initialCapacity的table数组  </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[initialCapacity];  </span><br><span class=\"line\">    <span class=\"comment\">//计算阀值  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">//初始化HashSeed值  </span></span><br><span class=\"line\">    initHashSeedAsNeeded(initialCapacity);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> hashSeed ^ k.hashCode();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>构造一个与给定的 Map 具有相同映射关系的新哈希表。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//设置table容器大小，其值==t.size * 2 + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(Math.max(<span class=\"number\">2</span>*t.size(), <span class=\"number\">11</span>), <span class=\"number\">0.75f</span>);  </span><br><span class=\"line\">    putAll(t);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h2><p>HashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。<br>首先我们先看put方法：将指定 key 映射到此哈希表中的指定 value。注意这里键key和值value都不可为空。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 确保value不为null  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 确保key在table[]是不重复的 </span></span><br><span class=\"line\"><span class=\"comment\">     * 处理过程： </span></span><br><span class=\"line\"><span class=\"comment\">     * 1、计算key的hash值，确认在table[]中的索引位置 </span></span><br><span class=\"line\"><span class=\"comment\">     * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    Entry tab[] = table;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key);    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;     <span class=\"comment\">//确认该key的索引位置  </span></span><br><span class=\"line\">    <span class=\"comment\">//迭代，寻找该key，替换  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class=\"line\">            V old = e.value;  </span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> old;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &gt;= threshold) &#123;  <span class=\"comment\">//如果容器中的元素数量已经达到阀值，则进行扩容操作  </span></span><br><span class=\"line\">        rehash();  </span><br><span class=\"line\">        tab = table;  </span><br><span class=\"line\">        hash = hash(key);  </span><br><span class=\"line\">        index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 在索引位置处插入一个新的节点  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];  </span><br><span class=\"line\">    tab[index] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);  </span><br><span class=\"line\">    <span class=\"comment\">//容器中元素+1  </span></span><br><span class=\"line\">    count++;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：<br>首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：<br><img src=\"/uploads/hashmap1.png\" alt></p><p>然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。<br><img src=\"/uploads/hashmap2.png\" alt><br>在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。<br><img src=\"/uploads/hashmap3.png\" alt><br>在HashTabled的put方法中有两个地方需要注意：<br>1、HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">rehash</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = table.length;  </span><br><span class=\"line\">    <span class=\"comment\">//元素  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] oldMap = table;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//新容量=旧容量 * 2 + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = (oldCapacity &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCapacity == MAX_ARRAY_SIZE)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        newCapacity = MAX_ARRAY_SIZE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//新建一个size = newCapacity 的HashTable  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt;[] newMap = <span class=\"keyword\">new</span> Entry[];  </span><br><span class=\"line\">  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//重新计算阀值  </span></span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">//重新计算hashSeed  </span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> rehash = initHashSeedAsNeeded(newCapacity);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    table = newMap;  </span><br><span class=\"line\">    <span class=\"comment\">//将原来的元素拷贝到新的HashTable中  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = oldCapacity ; i-- &gt; <span class=\"number\">0</span> ;) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class=\"keyword\">null</span> ; ) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; e = old;  </span><br><span class=\"line\">            old = old.next;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;  </span><br><span class=\"line\">                e.hash = hash(e.key);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = (e.hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % newCapacity;  </span><br><span class=\"line\">            e.next = newMap[index];  </span><br><span class=\"line\">            newMap[index] = e;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 <em>2 + 1 =17，而阀值threshold=17</em>0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。<br>2、其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash &amp; 0x7FFFFFFF），为什么需要做一步操作，这么做有什么好处？如果哪位知道，望指导，LZ不胜感激！！下面是计算key的hash值，这里hashSeed发挥了作用。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object k)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> hashSeed ^ k.hashCode();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回<span class=\"keyword\">null</span>。</span><br><span class=\"line\">```java</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;  </span><br><span class=\"line\">        Entry tab[] = table;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash = hash(key);  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.value;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"HashTable与HashMap的区别\"><a href=\"#HashTable与HashMap的区别\" class=\"headerlink\" title=\"HashTable与HashMap的区别\"></a>HashTable与HashMap的区别</h2><p>HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。<br>第一：我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。<br>第二：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：<br>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">     <span class=\"keyword\">return</span> putForNullKey(value);</span><br></pre></td></tr></table></figure><p></p><p>而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第三：Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？</p><!-- rebuild by neat -->"},{"title":"Java提高篇（二六）------hashCode","abbrlink":"adbc4ff","date":"2017-10-24T05:09:49.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/23299963\n\n\n ## hashCode的作用\n要想了解一个方法的内在原理，我们首先需要明白它是干什么的，也就是这个方法的作用。在讲解数组时（java提高篇（十八）------数组），我们提到数组是java中效率最高的数据结构，但是“最高”是有前提的。第一我们需要知道所查询数据的所在位置。第二：如果我们进行迭代查找时，数据量一定要小，对于大数据量而言一般推荐集合。\n在Java集合中有两类，一类是List，一类是Set他们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知（当然我们可以利用算法进行优化）。比如我们向HashSet插入1000数据，难道我们真的要迭代1000次，调用1000次equals()方法吗？hashCode提供了解决方案。怎么实现？我们先看hashCode的源码(Object)。\n<!-- more -->\n```java\npublic native int hashCode();  \n```\n它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）-----HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。\n所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。\nhashCode对于一个对象的重要性\nhashCode重要么？不重要，对于List集合、数组而言，他就是一个累赘，但是对于HashMap、HashSet、HashTable而言，它变得异常重要。所以在使用HashMap、HashSet、HashTable时一定要注意hashCode。对于一个对象而言，其hashCode过程就是一个简单的Hash算法的实现，其实现过程对你实现对象的存取过程起到非常重要的作用。\n在前面LZ提到了HashMap和HashTable两种数据结构，虽然他们存在若干个区别，但是他们的实现原理是相同的，这里我以HashTable为例阐述hashCode对于一个对象的重要性。\n一个对象势必会存在若干个属性，如何选择属性来进行散列考验着一个人的设计能力。如果我们将所有属性进行散列，这必定会是一个糟糕的设计，因为对象的hashCode方法无时无刻不是在被调用，如果太多的属性参与散列，那么需要的操作数时间将会大大增加，这将严重影响程序的性能。但是如果较少属相参与散列，散列的多样性会削弱，会产生大量的散列“冲突”，除了不能够很好的利用空间外，在某种程度也会影响对象的查询效率。其实这两者是一个矛盾体，散列的多样性会带来性能的降低。\n那么如何对对象的hashCode进行设计，LZ也没有经验。从网上查到了这样一种解决方案：设置一个缓存标识来缓存当前的散列码，只有当参与散列的对象改变时才会重新计算，否则调用缓存的hashCode，这样就可以从很大程度上提高性能。\n在HashTable计算某个对象在table[]数组中的索引位置，其代码如下：\n```java\nint index = (hash & 0x7FFFFFFF) % tab.length;  \n```\n为什么要&0x7FFFFFFF？因为某些对象的hashCode可能会为负值，与0x7FFFFFFF进行与运算可以确保index为一个正数。通过这步我可以直接定位某个对象的位置，所以从理论上来说我们是完全可以利用hashCode直接定位对象的散列表中的位置，但是为什么会存在一个key-value的键值对，利用key的hashCode来存入数据而不是直接存放value呢？这就关系HashTable性能问题的最重要的问题:Hash冲突！\n我们知道冲突的产生是由于不同的对象产生了相同的散列码，假如我们设计对象的散列码可以确保99.999999999%的不重复，但是有一种绝对且几乎不可能遇到的冲突你是绝对避免不了的。我们知道hashcode返回的是int，它的值只可能在int范围内。如果我们存放的数据超过了int的范围呢？这样就必定会产生两个相同的index，这时在index位置处会存储两个对象，我们就可以利用key本身来进行判断。所以具有相索引的对象，在该index位置处存在多个对象，我们必须依靠key的hashCode和key本身来进行区分。\nhashCode与equals\n在Java中hashCode的实现总是伴随着equals，他们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。\n对于equals，我们必须遵循如下规则：\n对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。\n反射性：x.equals(x)必须返回是“true”。\n类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。\n一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。\n任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。\n对于hashCode，我们应该遵循如下规则：\n1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。\n2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。\n3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。\n至于两者之间的关联关系，我们只需要记住如下即可：\n如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。\n如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。\n理清了上面的关系我们就知道他们两者是如何配合起来工作的。先看下图：\n![](/uploads/hashcode.png)\n整个处理流程是：\n1、判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals。\n2、若两个对象的equals不等，则可以认为两个对象不等，否则认为他们相等。\n实例：\n```java\n    public class Person {  \n        private int age;  \n        private int sex;    //0：男，1：女  \n        private String name;  \n        \n        private final int PRIME = 37;  \n        \n        Person(int age ,int sex ,String name){  \n            this.age = age;  \n            this.sex = sex;  \n            this.name = name;  \n        }  \n    \n        /** 省略getter、setter方法 **/  \n        \n        @Override  \n        public int hashCode() {  \n            System.out.println(\"调用hashCode方法...........\");  \n    \n            int hashResult = 1;  \n            hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME;  \n            hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode());   \n            System.out.println(\"name:\"+name +\" hashCode:\" + hashResult);  \n            \n            return hashResult;  \n        }  \n    \n        /** \n        * 重写hashCode() \n        */  \n        public boolean equals(Object obj) {  \n            System.out.println(\"调用equals方法...........\");  \n            \n            if(obj == null){  \n                return false;  \n            }  \n            if(obj.getClass() != this.getClass()){  \n                return false;  \n            }  \n            if(this == obj){  \n                return true;  \n            }  \n    \n            Person person = (Person) obj;  \n            \n            if(getAge() != person.getAge() || getSex()!= person.getSex()){  \n                return false;  \n            }  \n            \n            if(getName() != null){  \n                if(!getName().equals(person.getName())){  \n                    return false;  \n                }  \n            }  \n            else if(person != null){  \n                return false;  \n            }  \n            return true;  \n        }  \n    } \n``` \n该Bean为一个标准的Java Bean，重新实现了hashCode方法和equals方法。\n ```java\n    public class Main extends JPanel {  \n    \n        public static void main(String[] args) {  \n            Set<Person> set = new HashSet<Person>();  \n            \n            Person p1 = new Person(11, 1, \"张三\");  \n            Person p2 = new Person(12, 1, \"李四\");  \n            Person p3 = new Person(11, 1, \"张三\");  \n            Person p4 = new Person(11, 1, \"李四\");  \n            \n            //只验证p1、p3  \n            System.out.println(\"p1 == p3? :\" + (p1 == p3));  \n            System.out.println(\"p1.equals(p3)?:\"+p1.equals(p3));  \n            System.out.println(\"-----------------------分割线--------------------------\");  \n            set.add(p1);  \n            set.add(p2);  \n            set.add(p3);  \n            set.add(p4);  \n            System.out.println(\"set.size()=\"+set.size());  \n        }  \n    } \n``` \n运行结果如下：\n![](/uploads/hashcode2.png)\n从上图可以看出，程序调用四次hashCode方法，一次equals方法，其set的长度只有3。add方法运行流程完全符合他们两者之间的处理流程。","source":"_posts/java-toup25.md","raw":"---\ntitle: Java提高篇（二六）------hashCode\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: adbc4ff\ndate: 2017-10-24 13:09:49\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/23299963\n\n\n ## hashCode的作用\n要想了解一个方法的内在原理，我们首先需要明白它是干什么的，也就是这个方法的作用。在讲解数组时（java提高篇（十八）------数组），我们提到数组是java中效率最高的数据结构，但是“最高”是有前提的。第一我们需要知道所查询数据的所在位置。第二：如果我们进行迭代查找时，数据量一定要小，对于大数据量而言一般推荐集合。\n在Java集合中有两类，一类是List，一类是Set他们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知（当然我们可以利用算法进行优化）。比如我们向HashSet插入1000数据，难道我们真的要迭代1000次，调用1000次equals()方法吗？hashCode提供了解决方案。怎么实现？我们先看hashCode的源码(Object)。\n<!-- more -->\n```java\npublic native int hashCode();  \n```\n它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）-----HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。\n所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。\nhashCode对于一个对象的重要性\nhashCode重要么？不重要，对于List集合、数组而言，他就是一个累赘，但是对于HashMap、HashSet、HashTable而言，它变得异常重要。所以在使用HashMap、HashSet、HashTable时一定要注意hashCode。对于一个对象而言，其hashCode过程就是一个简单的Hash算法的实现，其实现过程对你实现对象的存取过程起到非常重要的作用。\n在前面LZ提到了HashMap和HashTable两种数据结构，虽然他们存在若干个区别，但是他们的实现原理是相同的，这里我以HashTable为例阐述hashCode对于一个对象的重要性。\n一个对象势必会存在若干个属性，如何选择属性来进行散列考验着一个人的设计能力。如果我们将所有属性进行散列，这必定会是一个糟糕的设计，因为对象的hashCode方法无时无刻不是在被调用，如果太多的属性参与散列，那么需要的操作数时间将会大大增加，这将严重影响程序的性能。但是如果较少属相参与散列，散列的多样性会削弱，会产生大量的散列“冲突”，除了不能够很好的利用空间外，在某种程度也会影响对象的查询效率。其实这两者是一个矛盾体，散列的多样性会带来性能的降低。\n那么如何对对象的hashCode进行设计，LZ也没有经验。从网上查到了这样一种解决方案：设置一个缓存标识来缓存当前的散列码，只有当参与散列的对象改变时才会重新计算，否则调用缓存的hashCode，这样就可以从很大程度上提高性能。\n在HashTable计算某个对象在table[]数组中的索引位置，其代码如下：\n```java\nint index = (hash & 0x7FFFFFFF) % tab.length;  \n```\n为什么要&0x7FFFFFFF？因为某些对象的hashCode可能会为负值，与0x7FFFFFFF进行与运算可以确保index为一个正数。通过这步我可以直接定位某个对象的位置，所以从理论上来说我们是完全可以利用hashCode直接定位对象的散列表中的位置，但是为什么会存在一个key-value的键值对，利用key的hashCode来存入数据而不是直接存放value呢？这就关系HashTable性能问题的最重要的问题:Hash冲突！\n我们知道冲突的产生是由于不同的对象产生了相同的散列码，假如我们设计对象的散列码可以确保99.999999999%的不重复，但是有一种绝对且几乎不可能遇到的冲突你是绝对避免不了的。我们知道hashcode返回的是int，它的值只可能在int范围内。如果我们存放的数据超过了int的范围呢？这样就必定会产生两个相同的index，这时在index位置处会存储两个对象，我们就可以利用key本身来进行判断。所以具有相索引的对象，在该index位置处存在多个对象，我们必须依靠key的hashCode和key本身来进行区分。\nhashCode与equals\n在Java中hashCode的实现总是伴随着equals，他们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。\n对于equals，我们必须遵循如下规则：\n对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。\n反射性：x.equals(x)必须返回是“true”。\n类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。\n一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。\n任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。\n对于hashCode，我们应该遵循如下规则：\n1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。\n2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。\n3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。\n至于两者之间的关联关系，我们只需要记住如下即可：\n如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。\n如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。\n理清了上面的关系我们就知道他们两者是如何配合起来工作的。先看下图：\n![](/uploads/hashcode.png)\n整个处理流程是：\n1、判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals。\n2、若两个对象的equals不等，则可以认为两个对象不等，否则认为他们相等。\n实例：\n```java\n    public class Person {  \n        private int age;  \n        private int sex;    //0：男，1：女  \n        private String name;  \n        \n        private final int PRIME = 37;  \n        \n        Person(int age ,int sex ,String name){  \n            this.age = age;  \n            this.sex = sex;  \n            this.name = name;  \n        }  \n    \n        /** 省略getter、setter方法 **/  \n        \n        @Override  \n        public int hashCode() {  \n            System.out.println(\"调用hashCode方法...........\");  \n    \n            int hashResult = 1;  \n            hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME;  \n            hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode());   \n            System.out.println(\"name:\"+name +\" hashCode:\" + hashResult);  \n            \n            return hashResult;  \n        }  \n    \n        /** \n        * 重写hashCode() \n        */  \n        public boolean equals(Object obj) {  \n            System.out.println(\"调用equals方法...........\");  \n            \n            if(obj == null){  \n                return false;  \n            }  \n            if(obj.getClass() != this.getClass()){  \n                return false;  \n            }  \n            if(this == obj){  \n                return true;  \n            }  \n    \n            Person person = (Person) obj;  \n            \n            if(getAge() != person.getAge() || getSex()!= person.getSex()){  \n                return false;  \n            }  \n            \n            if(getName() != null){  \n                if(!getName().equals(person.getName())){  \n                    return false;  \n                }  \n            }  \n            else if(person != null){  \n                return false;  \n            }  \n            return true;  \n        }  \n    } \n``` \n该Bean为一个标准的Java Bean，重新实现了hashCode方法和equals方法。\n ```java\n    public class Main extends JPanel {  \n    \n        public static void main(String[] args) {  \n            Set<Person> set = new HashSet<Person>();  \n            \n            Person p1 = new Person(11, 1, \"张三\");  \n            Person p2 = new Person(12, 1, \"李四\");  \n            Person p3 = new Person(11, 1, \"张三\");  \n            Person p4 = new Person(11, 1, \"李四\");  \n            \n            //只验证p1、p3  \n            System.out.println(\"p1 == p3? :\" + (p1 == p3));  \n            System.out.println(\"p1.equals(p3)?:\"+p1.equals(p3));  \n            System.out.println(\"-----------------------分割线--------------------------\");  \n            set.add(p1);  \n            set.add(p2);  \n            set.add(p3);  \n            set.add(p4);  \n            System.out.println(\"set.size()=\"+set.size());  \n        }  \n    } \n``` \n运行结果如下：\n![](/uploads/hashcode2.png)\n从上图可以看出，程序调用四次hashCode方法，一次equals方法，其set的长度只有3。add方法运行流程完全符合他们两者之间的处理流程。","slug":"java-toup25","published":1,"updated":"2019-09-03T03:40:46.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketet00220vfaxalzdmrv","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/23299963\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/23299963</a></p></blockquote><h2 id=\"hashCode的作用\"><a href=\"#hashCode的作用\" class=\"headerlink\" title=\"hashCode的作用\"></a>hashCode的作用</h2><p>要想了解一个方法的内在原理，我们首先需要明白它是干什么的，也就是这个方法的作用。在讲解数组时（java提高篇（十八）———数组），我们提到数组是java中效率最高的数据结构，但是“最高”是有前提的。第一我们需要知道所查询数据的所在位置。第二：如果我们进行迭代查找时，数据量一定要小，对于大数据量而言一般推荐集合。<br>在Java集合中有两类，一类是List，一类是Set他们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知（当然我们可以利用算法进行优化）。比如我们向HashSet插入1000数据，难道我们真的要迭代1000次，调用1000次equals()方法吗？hashCode提供了解决方案。怎么实现？我们先看hashCode的源码(Object)。<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）——-HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。<br>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。<br>hashCode对于一个对象的重要性<br>hashCode重要么？不重要，对于List集合、数组而言，他就是一个累赘，但是对于HashMap、HashSet、HashTable而言，它变得异常重要。所以在使用HashMap、HashSet、HashTable时一定要注意hashCode。对于一个对象而言，其hashCode过程就是一个简单的Hash算法的实现，其实现过程对你实现对象的存取过程起到非常重要的作用。<br>在前面LZ提到了HashMap和HashTable两种数据结构，虽然他们存在若干个区别，但是他们的实现原理是相同的，这里我以HashTable为例阐述hashCode对于一个对象的重要性。<br>一个对象势必会存在若干个属性，如何选择属性来进行散列考验着一个人的设计能力。如果我们将所有属性进行散列，这必定会是一个糟糕的设计，因为对象的hashCode方法无时无刻不是在被调用，如果太多的属性参与散列，那么需要的操作数时间将会大大增加，这将严重影响程序的性能。但是如果较少属相参与散列，散列的多样性会削弱，会产生大量的散列“冲突”，除了不能够很好的利用空间外，在某种程度也会影响对象的查询效率。其实这两者是一个矛盾体，散列的多样性会带来性能的降低。<br>那么如何对对象的hashCode进行设计，LZ也没有经验。从网上查到了这样一种解决方案：设置一个缓存标识来缓存当前的散列码，只有当参与散列的对象改变时才会重新计算，否则调用缓存的hashCode，这样就可以从很大程度上提高性能。<br>在HashTable计算某个对象在table[]数组中的索引位置，其代码如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure><p></p><p>为什么要&amp;0x7FFFFFFF？因为某些对象的hashCode可能会为负值，与0x7FFFFFFF进行与运算可以确保index为一个正数。通过这步我可以直接定位某个对象的位置，所以从理论上来说我们是完全可以利用hashCode直接定位对象的散列表中的位置，但是为什么会存在一个key-value的键值对，利用key的hashCode来存入数据而不是直接存放value呢？这就关系HashTable性能问题的最重要的问题:Hash冲突！<br>我们知道冲突的产生是由于不同的对象产生了相同的散列码，假如我们设计对象的散列码可以确保99.999999999%的不重复，但是有一种绝对且几乎不可能遇到的冲突你是绝对避免不了的。我们知道hashcode返回的是int，它的值只可能在int范围内。如果我们存放的数据超过了int的范围呢？这样就必定会产生两个相同的index，这时在index位置处会存储两个对象，我们就可以利用key本身来进行判断。所以具有相索引的对象，在该index位置处存在多个对象，我们必须依靠key的hashCode和key本身来进行区分。<br>hashCode与equals<br>在Java中hashCode的实现总是伴随着equals，他们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。<br>对于equals，我们必须遵循如下规则：<br>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br>反射性：x.equals(x)必须返回是“true”。<br>类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br>任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。<br>对于hashCode，我们应该遵循如下规则：</p><ol><li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。</li><li><p>如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。<br>至于两者之间的关联关系，我们只需要记住如下即可：<br>如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。<br>如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。<br>理清了上面的关系我们就知道他们两者是如何配合起来工作的。先看下图：<br><img src=\"/uploads/hashcode.png\" alt><br>整个处理流程是：<br>1、判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals。<br>2、若两个对象的equals不等，则可以认为两个对象不等，否则认为他们相等。<br>实例：</p><pre><code class=\"lang-java\"> public class Person {  \n     private int age;  \n     private int sex;    //0：男，1：女  \n     private String name;  \n\n     private final int PRIME = 37;  \n\n     Person(int age ,int sex ,String name){  \n         this.age = age;  \n         this.sex = sex;  \n         this.name = name;  \n     }  \n\n     /** 省略getter、setter方法 **/  \n\n     @Override  \n     public int hashCode() {  \n         System.out.println(&quot;调用hashCode方法...........&quot;);  \n\n         int hashResult = 1;  \n         hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME;  \n         hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode());   \n         System.out.println(&quot;name:&quot;+name +&quot; hashCode:&quot; + hashResult);  \n\n         return hashResult;  \n     }  \n\n     /** \n     * 重写hashCode() \n     */  \n     public boolean equals(Object obj) {  \n         System.out.println(&quot;调用equals方法...........&quot;);  \n\n         if(obj == null){  \n             return false;  \n         }  \n         if(obj.getClass() != this.getClass()){  \n             return false;  \n         }  \n         if(this == obj){  \n             return true;  \n         }  \n\n         Person person = (Person) obj;  \n\n         if(getAge() != person.getAge() || getSex()!= person.getSex()){  \n             return false;  \n         }  \n\n         if(getName() != null){  \n             if(!getName().equals(person.getName())){  \n                 return false;  \n             }  \n         }  \n         else if(person != null){  \n             return false;  \n         }  \n         return true;  \n     }  \n }\n</code></pre><p>该Bean为一个标准的Java Bean，重新实现了hashCode方法和equals方法。</p><pre><code class=\"lang-java\"> public class Main extends JPanel {  \n\n     public static void main(String[] args) {  \n         Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();  \n\n         Person p1 = new Person(11, 1, &quot;张三&quot;);  \n         Person p2 = new Person(12, 1, &quot;李四&quot;);  \n         Person p3 = new Person(11, 1, &quot;张三&quot;);  \n         Person p4 = new Person(11, 1, &quot;李四&quot;);  \n\n         //只验证p1、p3  \n         System.out.println(&quot;p1 == p3? :&quot; + (p1 == p3));  \n         System.out.println(&quot;p1.equals(p3)?:&quot;+p1.equals(p3));  \n         System.out.println(&quot;-----------------------分割线--------------------------&quot;);  \n         set.add(p1);  \n         set.add(p2);  \n         set.add(p3);  \n         set.add(p4);  \n         System.out.println(&quot;set.size()=&quot;+set.size());  \n     }  \n }\n</code></pre><p>运行结果如下：<br><img src=\"/uploads/hashcode2.png\" alt><br>从上图可以看出，程序调用四次hashCode方法，一次equals方法，其set的长度只有3。add方法运行流程完全符合他们两者之间的处理流程。</p></li></ol><!-- rebuild by neat -->","site":{"data":{}},"length":5601,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/23299963\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/23299963</a></p></blockquote><h2 id=\"hashCode的作用\"><a href=\"#hashCode的作用\" class=\"headerlink\" title=\"hashCode的作用\"></a>hashCode的作用</h2><p>要想了解一个方法的内在原理，我们首先需要明白它是干什么的，也就是这个方法的作用。在讲解数组时（java提高篇（十八）———数组），我们提到数组是java中效率最高的数据结构，但是“最高”是有前提的。第一我们需要知道所查询数据的所在位置。第二：如果我们进行迭代查找时，数据量一定要小，对于大数据量而言一般推荐集合。<br>在Java集合中有两类，一类是List，一类是Set他们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知（当然我们可以利用算法进行优化）。比如我们向HashSet插入1000数据，难道我们真的要迭代1000次，调用1000次equals()方法吗？hashCode提供了解决方案。怎么实现？我们先看hashCode的源码(Object)。<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）——-HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。<br>所以hashCode在上面扮演的角色为寻域（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。<br>hashCode对于一个对象的重要性<br>hashCode重要么？不重要，对于List集合、数组而言，他就是一个累赘，但是对于HashMap、HashSet、HashTable而言，它变得异常重要。所以在使用HashMap、HashSet、HashTable时一定要注意hashCode。对于一个对象而言，其hashCode过程就是一个简单的Hash算法的实现，其实现过程对你实现对象的存取过程起到非常重要的作用。<br>在前面LZ提到了HashMap和HashTable两种数据结构，虽然他们存在若干个区别，但是他们的实现原理是相同的，这里我以HashTable为例阐述hashCode对于一个对象的重要性。<br>一个对象势必会存在若干个属性，如何选择属性来进行散列考验着一个人的设计能力。如果我们将所有属性进行散列，这必定会是一个糟糕的设计，因为对象的hashCode方法无时无刻不是在被调用，如果太多的属性参与散列，那么需要的操作数时间将会大大增加，这将严重影响程序的性能。但是如果较少属相参与散列，散列的多样性会削弱，会产生大量的散列“冲突”，除了不能够很好的利用空间外，在某种程度也会影响对象的查询效率。其实这两者是一个矛盾体，散列的多样性会带来性能的降低。<br>那么如何对对象的hashCode进行设计，LZ也没有经验。从网上查到了这样一种解决方案：设置一个缓存标识来缓存当前的散列码，只有当参与散列的对象改变时才会重新计算，否则调用缓存的hashCode，这样就可以从很大程度上提高性能。<br>在HashTable计算某个对象在table[]数组中的索引位置，其代码如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br></pre></td></tr></table></figure><p></p><p>为什么要&amp;0x7FFFFFFF？因为某些对象的hashCode可能会为负值，与0x7FFFFFFF进行与运算可以确保index为一个正数。通过这步我可以直接定位某个对象的位置，所以从理论上来说我们是完全可以利用hashCode直接定位对象的散列表中的位置，但是为什么会存在一个key-value的键值对，利用key的hashCode来存入数据而不是直接存放value呢？这就关系HashTable性能问题的最重要的问题:Hash冲突！<br>我们知道冲突的产生是由于不同的对象产生了相同的散列码，假如我们设计对象的散列码可以确保99.999999999%的不重复，但是有一种绝对且几乎不可能遇到的冲突你是绝对避免不了的。我们知道hashcode返回的是int，它的值只可能在int范围内。如果我们存放的数据超过了int的范围呢？这样就必定会产生两个相同的index，这时在index位置处会存储两个对象，我们就可以利用key本身来进行判断。所以具有相索引的对象，在该index位置处存在多个对象，我们必须依靠key的hashCode和key本身来进行区分。<br>hashCode与equals<br>在Java中hashCode的实现总是伴随着equals，他们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。<br>对于equals，我们必须遵循如下规则：<br>对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br>反射性：x.equals(x)必须返回是“true”。<br>类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br>一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br>任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。<br>对于hashCode，我们应该遵循如下规则：</p><ol><li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。</li><li><p>如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。<br>至于两者之间的关联关系，我们只需要记住如下即可：<br>如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。<br>如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。<br>理清了上面的关系我们就知道他们两者是如何配合起来工作的。先看下图：<br><img src=\"/uploads/hashcode.png\" alt><br>整个处理流程是：<br>1、判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals。<br>2、若两个对象的equals不等，则可以认为两个对象不等，否则认为他们相等。<br>实例：</p><pre><code class=\"lang-java\"> public class Person {  \n     private int age;  \n     private int sex;    //0：男，1：女  \n     private String name;  \n\n     private final int PRIME = 37;  \n\n     Person(int age ,int sex ,String name){  \n         this.age = age;  \n         this.sex = sex;  \n         this.name = name;  \n     }  \n\n     /** 省略getter、setter方法 **/  \n\n     @Override  \n     public int hashCode() {  \n         System.out.println(&quot;调用hashCode方法...........&quot;);  \n\n         int hashResult = 1;  \n         hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME;  \n         hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode());   \n         System.out.println(&quot;name:&quot;+name +&quot; hashCode:&quot; + hashResult);  \n\n         return hashResult;  \n     }  \n\n     /** \n     * 重写hashCode() \n     */  \n     public boolean equals(Object obj) {  \n         System.out.println(&quot;调用equals方法...........&quot;);  \n\n         if(obj == null){  \n             return false;  \n         }  \n         if(obj.getClass() != this.getClass()){  \n             return false;  \n         }  \n         if(this == obj){  \n             return true;  \n         }  \n\n         Person person = (Person) obj;  \n\n         if(getAge() != person.getAge() || getSex()!= person.getSex()){  \n             return false;  \n         }  \n\n         if(getName() != null){  \n             if(!getName().equals(person.getName())){  \n                 return false;  \n             }  \n         }  \n         else if(person != null){  \n             return false;  \n         }  \n         return true;  \n     }  \n }\n</code></pre><p>该Bean为一个标准的Java Bean，重新实现了hashCode方法和equals方法。</p><pre><code class=\"lang-java\"> public class Main extends JPanel {  \n\n     public static void main(String[] args) {  \n         Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();  \n\n         Person p1 = new Person(11, 1, &quot;张三&quot;);  \n         Person p2 = new Person(12, 1, &quot;李四&quot;);  \n         Person p3 = new Person(11, 1, &quot;张三&quot;);  \n         Person p4 = new Person(11, 1, &quot;李四&quot;);  \n\n         //只验证p1、p3  \n         System.out.println(&quot;p1 == p3? :&quot; + (p1 == p3));  \n         System.out.println(&quot;p1.equals(p3)?:&quot;+p1.equals(p3));  \n         System.out.println(&quot;-----------------------分割线--------------------------&quot;);  \n         set.add(p1);  \n         set.add(p2);  \n         set.add(p3);  \n         set.add(p4);  \n         System.out.println(&quot;set.size()=&quot;+set.size());  \n     }  \n }\n</code></pre><p>运行结果如下：<br><img src=\"/uploads/hashcode2.png\" alt><br>从上图可以看出，程序调用四次hashCode方法，一次equals方法，其set的长度只有3。add方法运行流程完全符合他们两者之间的处理流程。</p></li></ol><!-- rebuild by neat -->"},{"title":"Java提高篇（二七）-----TreeMap","abbrlink":"822b9db","date":"2017-10-24T05:09:53.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/23299963\n\nTreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,其实这篇博文的名字叫做：根据红黑树的算法来分析TreeMap的实现，但是为了与Java提高篇系列博文保持一致还是叫做TreeMap比较好。通过这篇博文你可以获得如下知识点：\n\n>1、红黑树的基本概念。\n 2、红黑树增加节点、删除节点的实现过程。\n 3、红黑树左旋转、右旋转的复杂过程。\n 4、Java 中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。\n\n我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。\n<!-- more -->\n## 红黑树简介\n红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。\n我们知道一颗基本的二叉树他们都需要满足一个基本性质--即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。\n平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。\n![](/uploads/tree1.png)\n\n 红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：\n      \n>1、每个节点都只能是红色或者黑色\n 2、根节点是黑色\n 3、每个叶节点（NIL节点，空节点）是黑色的。\n 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log n)。下图为一颗典型的红黑二叉树。\n![](/uploads/tree2.png)\n对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色\n![左旋](/uploads/tree3.gif) ![右旋](/uploads/tree4.gif)\n\n## TreeMap数据结构\n     \nTreeMap的定义如下：\n```java\npublic class TreeMap<K,V>\n    extends AbstractMap<K,V>\n    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n```\nTreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。\nTreeMap中同时也包含了如下几个重要的属性：\n//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制\n```java\n        private final Comparator<? super K> comparator;\n        //TreeMap红-黑节点，为TreeMap的内部类\n        private transient Entry<K,V> root = null;\n        //容器大小\n        private transient int size = 0;\n        //TreeMap修改次数\n        private transient int modCount = 0;\n        //红黑树的节点颜色--红色\n        private static final boolean RED = false;\n        //红黑树的节点颜色--黑色\n        private static final boolean BLACK = true;\n```\n对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：\n```java\n        //键\n        K key;\n        //值\n        V value;\n        //左孩子\n        Entry<K,V> left = null;\n        //右孩子\n        Entry<K,V> right = null;\n        //父亲\n        Entry<K,V> parent;\n        //颜色\n        boolean color = BLACK;\n```\n注：前面只是开胃菜，下面是本篇博文的重中之重，在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。\n## TreeMap put()方法\n在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。\n红黑树增加节点\n红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。\n![](/uploads/tree4.png)\n对于新节点的插入有如下三个关键地方：\n\n       1、插入新节点总是红色节点 。\n       2、如果插入节点的父节点是黑色, 能维持性质 。\n       3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。\n为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：\n\n        1、每个节点都只能是红色或者黑色\n        2、根节点是黑色\n        3、每个叶节点（NIL节点，空节点）是黑色的。\n        4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n        5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n### 为跟节点\n       若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））\n### 父节点为黑色\n这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））\n![](/uploads/tree5.png)\n### 若父节点P和P的兄弟节点U都为红色\n对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。\n![](/uploads/tree6.png)\n\n### 若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\n对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。\n![](/uploads/tree7.png)\n### 父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\n这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。\n![](/uploads/tree8.png)\n上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。\n## TreeMap put()方法实现分析\n在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。\n对于排序二叉树的创建，其添加节点的过程如下：\n1、以根节点为初始节点进行检索。\n2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。\n3、循环递归2步骤知道检索出合适的叶子节点为止。\n4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。\n按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：\n```java\n    public V put(K key, V value) {  \n           //用t表示二叉树的当前节点  \n            Entry<K,V> t = root;  \n            //t为null表示一个空树，即TreeMap中没有任何元素，直接插入  \n            if (t == null) {  \n                //比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？  \n                compare(key, key); // type (and possibly null) check  \n                //将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root  \n                root = new Entry<>(key, value, null);  \n                //容器的size = 1，表示TreeMap集合中存在一个元素  \n                size = 1;  \n                //修改次数 + 1  \n                modCount++;  \n                return null;  \n            }  \n            int cmp;     //cmp表示key排序的返回结果  \n            Entry<K,V> parent;   //父节点  \n            // split comparator and comparable paths  \n            Comparator<? super K> cpr = comparator;    //指定的排序算法  \n            //如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合  \n            if (cpr != null) {  \n                do {  \n                    parent = t;      //parent指向上次循环后的t  \n                    //比较新增节点的key和当前节点key的大小  \n                    cmp = cpr.compare(key, t.key);  \n                    //cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点  \n                    if (cmp < 0)  \n                        t = t.left;  \n                    //cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点  \n                    else if (cmp > 0)  \n                        t = t.right;  \n                    //cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值  \n                    else  \n                        return t.setValue(value);  \n                } while (t != null);  \n            }  \n            //如果cpr为空，则采用默认的排序算法进行创建TreeMap集合  \n            else {  \n                if (key == null)     //key值为空抛出异常  \n                    throw new NullPointerException();  \n                /* 下面处理过程和上面一样 */  \n                Comparable<? super K> k = (Comparable<? super K>) key;  \n                do {  \n                    parent = t;  \n                    cmp = k.compareTo(t.key);  \n                    if (cmp < 0)  \n                        t = t.left;  \n                    else if (cmp > 0)  \n                        t = t.right;  \n                    else  \n                        return t.setValue(value);  \n                } while (t != null);  \n            }  \n            //将新增节点当做parent的子节点  \n            Entry<K,V> e = new Entry<>(key, value, parent);  \n            //如果新增节点的key小于parent的key，则当做左子节点  \n            if (cmp < 0)  \n                parent.left = e;  \n          //如果新增节点的key大于parent的key，则当做右子节点  \n            else  \n                parent.right = e;  \n            /*  \n             *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置  \n             *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况  \n             */  \n            fixAfterInsertion(e);  \n            //TreeMap元素数量 + 1  \n            size++;  \n            //TreeMap容器修改次数 + 1  \n            modCount++;  \n            return null;  \n        }  \n```\n上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下：\n\n```java\n    /** \n     * 新增节点后的修复操作 \n     * x 表示新增节点 \n     */  \n     private void fixAfterInsertion(Entry<K,V> x) {  \n            x.color = RED;    //新增节点的颜色为红色  \n  \n            //循环 直到 x不是根节点，且x的父节点不为红色  \n            while (x != null && x != root && x.parent.color == RED) {  \n                //如果X的父节点（P）是其父节点的父节点（G）的左节点  \n                if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {  \n                    //获取X的叔节点(U)  \n                    Entry<K,V> y = rightOf(parentOf(parentOf(x)));  \n                    //如果X的叔节点（U） 为红色（情况三）  \n                    if (colorOf(y) == RED) {       \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的叔节点（U）设置为黑色  \n                        setColor(y, BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        x = parentOf(parentOf(x));  \n                    }  \n                    //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  \n                    else {     \n                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  \n                        if (x == rightOf(parentOf(x))) {  \n                            //将X的父节点作为X  \n                            x = parentOf(x);  \n                            //右旋转  \n                            rotateLeft(x);  \n                        }  \n                        //（情况五）  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        //以X的父节点的父节点（G）为中心右旋转  \n                        rotateRight(parentOf(parentOf(x)));  \n                    }  \n                }  \n                //如果X的父节点（P）是其父节点的父节点（G）的右节点  \n                else {  \n                    //获取X的叔节点（U）  \n                    Entry<K,V> y = leftOf(parentOf(parentOf(x)));  \n                  //如果X的叔节点（U） 为红色（情况三）  \n                    if (colorOf(y) == RED) {  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的叔节点（U）设置为黑色  \n                        setColor(y, BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        x = parentOf(parentOf(x));  \n                    }  \n                  //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  \n                    else {  \n                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  \n                        if (x == leftOf(parentOf(x))) {  \n                            //将X的父节点作为X  \n                            x = parentOf(x);  \n                           //右旋转  \n                            rotateRight(x);  \n                        }  \n                        //（情况五）  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        //以X的父节点的父节点（G）为中心右旋转  \n                        rotateLeft(parentOf(parentOf(x)));  \n                    }  \n                }  \n            }  \n            //将根节点G强制设置为黑色  \n            root.color = BLACK;  \n        }  \n\n```\n对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。\n左旋：rotateLeft()\n所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left ---> N ,N.left ---> P。\n\n右旋：rotateRight()\n```java\n    private void rotateLeft(Entry<K,V> p) {  \n        if (p != null) {  \n            //获取P的右子节点，其实这里就相当于新增节点N（情况四而言）  \n            Entry<K,V> r = p.right;  \n            //将R的左子树设置为P的右子树  \n            p.right = r.left;  \n            //若R的左子树不为空，则将P设置为R左子树的父亲  \n            if (r.left != null)  \n                r.left.parent = p;  \n            //将P的父亲设置R的父亲  \n            r.parent = p.parent;  \n            //如果P的父亲为空，则将R设置为跟节点  \n            if (p.parent == null)  \n                root = r;  \n            //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树  \n            else if (p.parent.left == p)  \n                p.parent.left = r;  \n            //否则R设置为P的父节点（G）的右子树  \n            else  \n                p.parent.right = r;  \n            //将P设置为R的左子树  \n            r.left = p;  \n            //将R设置为P的父节点  \n            p.parent = r;  \n        }  \n    }  \n```\n\n所谓右旋转即，P.right ---> G、G.parent ---> P。\n```java\n    private void rotateRight(Entry<K,V> p) {  \n        if (p != null) {  \n            //将L设置为P的左子树  \n            Entry<K,V> l = p.left;  \n            //将L的右子树设置为P的左子树  \n            p.left = l.right;  \n            //若L的右子树不为空，则将P设置L的右子树的父节点  \n            if (l.right != null)   \n                l.right.parent = p;  \n            //将P的父节点设置为L的父节点  \n            l.parent = p.parent;  \n            //如果P的父节点为空，则将L设置根节点  \n            if (p.parent == null)  \n                root = l;  \n            //若P为其父节点的右子树，则将L设置为P的父节点的右子树  \n            else if (p.parent.right == p)  \n                p.parent.right = l;  \n            //否则将L设置为P的父节点的左子树  \n            else   \n                p.parent.left = l;  \n            //将P设置为L的右子树  \n            l.right = p;  \n            //将L设置为P的父节点  \n            p.parent = l;  \n        }  \n    }  \n```\n着色：setColor()\n着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。\n\n```java\n    private static <K,V> void setColor(Entry<K,V> p, boolean c) {  \n        if (p != null)  \n            p.color = c;  \n    }  \n```\n## TreeMap delete()方法\n### 红黑树删除节点\n针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。\n![](/uploads/tree9.png)\n 红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。\n红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：\n1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。\n2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。\n3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。\n下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：\n1、每个节点都只能是红色或者黑色\n2、根节点是黑色\n3、每个叶节点（NIL节点，空节点）是黑色的。\n4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n（注：已经讲三遍了，再不记住我就怀疑你是否适合搞IT了 O(∩_∩)O~）\n诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：\n1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。\n2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。\n![](/uploads/tree10.png)\n现在我们就上面提到的三种情况进行分析、处理。\n情况一、无子节点（红色节点）\n这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点-----如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。\n情况二、有一个子节点\n这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）\n情况三、有两个子节点\n这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。\n1、N的兄弟节点W为红色\n2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。\n3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。\n4、N的兄弟w是黑色的，且w的右孩子时红色的。\n情况3.1、N的兄弟节点W为红色\nW为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W、P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1、转变为3.2、3.3、3.4中的一种。如下：\n![](/uploads/tree11.png)\n情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。\n这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下\n![](/uploads/tree12.png)\n将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1、3.3、3.4中的一种。\n情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。\n针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。\n![](/uploads/tree13.png)\n此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.\n情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。\n交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。\n![](/uploads/tree14.png)\n\n总结\n个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。情况3.1，是将W旋转将其转成情况2、3、4情况进行处理。而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。情况3.4、右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。\n通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。\n<font color=\"#3366ff\">**TreeMap deleteEntry()方法实现分析**</font>\n通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点、删除替代节点。\n```java\n    private void deleteEntry(Entry<K,V> p) {  \n        modCount++;      //修改次数 +1  \n        size--;          //元素个数 -1  \n  \n        /* \n         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 \n         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 \n         * ---------------------（1） \n         */  \n        if (p.left != null && p.right != null) {    \n            Entry<K,V> s = successor(p);  \n            p.key = s.key;  \n            p.value = s.value;  \n            p = s;  \n        }  \n  \n        //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代  \n        Entry<K,V> replacement = (p.left != null ? p.left : p.right);  \n  \n        /* \n         * 删除节点，分为上面提到的三种情况 \n         * -----------------------（2） \n         */  \n        //如果替代节点不为空  \n        if (replacement != null) {  \n            replacement.parent = p.parent;  \n            /* \n             *replacement来替代P节点 \n             */  \n            //若P没有父节点，则跟节点直接变成replacement  \n            if (p.parent == null)  \n                root = replacement;  \n            //如果P为左节点，则用replacement来替代为左节点  \n            else if (p == p.parent.left)  \n                p.parent.left  = replacement;  \n          //如果P为右节点，则用replacement来替代为右节点  \n            else  \n                p.parent.right = replacement;  \n  \n            //同时将P节点从这棵树中剔除掉  \n            p.left = p.right = p.parent = null;  \n  \n            /* \n             * 若P为红色直接删除，红黑树保持平衡 \n             * 但是若P为黑色，则需要调整红黑树使其保持平衡 \n             */  \n            if (p.color == BLACK)  \n                fixAfterDeletion(replacement);  \n        } else if (p.parent == null) {     //p没有父节点，表示为P根节点，直接删除即可  \n            root = null;  \n        } else {      //P节点不存在子节点，直接删除即可  \n            if (p.color == BLACK)         //如果P节点的颜色为黑色，对红黑树进行调整  \n                fixAfterDeletion(p);  \n  \n            //删除P节点  \n            if (p.parent != null) {  \n                if (p == p.parent.left)  \n                    p.parent.left = null;  \n                else if (p == p.parent.right)  \n                    p.parent.right = null;  \n                p.parent = null;  \n            }  \n        }  \n    }  \n```\n\n（1）除是寻找替代节点replacement，其实现方法为successor()。如下：\n```java\nstatic <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {  \n        if (t == null)  \n            return null;  \n        /* \n         * 寻找右子树的最左子树 \n         */  \n        else if (t.right != null) {  \n            Entry<K,V> p = t.right;  \n            while (p.left != null)  \n                p = p.left;  \n            return p;  \n        }   \n        /* \n         * 选择左子树的最右子树 \n         */  \n        else {  \n            Entry<K,V> p = t.parent;  \n            Entry<K,V> ch = t;  \n            while (p != null && ch == p.right) {  \n                ch = p;  \n                p = p.parent;  \n            }  \n            return p;  \n        }  \n    } \n```\n\n（2）处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：\n1、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。\n2、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。\n3、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。\n删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。\n```java\n    private void fixAfterDeletion(Entry<K,V> x) {  \n        // 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色  \n        while (x != root && colorOf(x) == BLACK) {  \n            if (x == leftOf(parentOf(x))) {      //若X节点为左节点  \n                //获取其兄弟节点  \n                Entry<K,V> sib = rightOf(parentOf(x));  \n  \n                /* \n                 * 如果兄弟节点为红色----（情况3.1） \n                 * 策略：改变W、P的颜色，然后进行一次左旋转 \n                 */  \n                if (colorOf(sib) == RED) {       \n                    setColor(sib, BLACK);       \n                    setColor(parentOf(x), RED);    \n                    rotateLeft(parentOf(x));  \n                    sib = rightOf(parentOf(x));  \n                }  \n  \n                /* \n                 * 若兄弟节点的两个子节点都为黑色----（情况3.2） \n                 * 策略：将兄弟节点编程红色 \n                 */  \n                if (colorOf(leftOf(sib))  == BLACK &&  \n                    colorOf(rightOf(sib)) == BLACK) {  \n                    setColor(sib, RED);  \n                    x = parentOf(x);  \n                }   \n                else {  \n                    /* \n                     * 如果兄弟节点只有右子树为黑色----（情况3.3） \n                     * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转 \n                     * 这时情况会转变为3.4 \n                     */  \n                    if (colorOf(rightOf(sib)) == BLACK) {  \n                        setColor(leftOf(sib), BLACK);  \n                        setColor(sib, RED);  \n                        rotateRight(sib);  \n                        sib = rightOf(parentOf(x));  \n                    }  \n                    /* \n                     *----情况3.4 \n                     *策略：交换兄弟节点和父节点的颜色， \n                     *同时将兄弟节点右子树设置为黑色，最后左旋转 \n                     */  \n                    setColor(sib, colorOf(parentOf(x)));  \n                    setColor(parentOf(x), BLACK);  \n                    setColor(rightOf(sib), BLACK);  \n                    rotateLeft(parentOf(x));  \n                    x = root;  \n                }  \n            }   \n              \n            /** \n             * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了 \n             */  \n            else {  \n                Entry<K,V> sib = leftOf(parentOf(x));  \n  \n                if (colorOf(sib) == RED) {  \n                    setColor(sib, BLACK);  \n                    setColor(parentOf(x), RED);  \n                    rotateRight(parentOf(x));  \n                    sib = leftOf(parentOf(x));  \n                }  \n  \n                if (colorOf(rightOf(sib)) == BLACK &&  \n                    colorOf(leftOf(sib)) == BLACK) {  \n                    setColor(sib, RED);  \n                    x = parentOf(x);  \n                } else {  \n                    if (colorOf(leftOf(sib)) == BLACK) {  \n                        setColor(rightOf(sib), BLACK);  \n                        setColor(sib, RED);  \n                        rotateLeft(sib);  \n                        sib = leftOf(parentOf(x));  \n                    }  \n                    setColor(sib, colorOf(parentOf(x)));  \n                    setColor(parentOf(x), BLACK);  \n                    setColor(leftOf(sib), BLACK);  \n                    rotateRight(parentOf(x));  \n                    x = root;  \n                }  \n            }  \n        }  \n  \n        setColor(x, BLACK);  \n    }  \n```\n\n这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。\n五、写在最后\n这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。同时这篇博文很大篇幅都在阐述红黑树的实现过程，对Java 的TreeMap聊的比较少，但是我认为如果理解了红黑树的实现过程，对TreeMap那是手到擒来，小菜一碟。\n同时这篇博文我写了四天，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。LZ大二开始学习数据结构，自认为学的不错，现在发现数据结构我还有太多的地方需要学习了，同时也再一次体味了算法的魅力！！！！\n\n参考资料：\n\n1、红黑树数据结构剖析：http://www.cnblogs.com/fanzhidongyzby/p/3187912.html\n2、红黑二叉树详解及理论分析 ：http://blog.csdn.net/kartorz/article/details/8865997\n3、教你透彻了解红黑树 ：http://blog.csdn.net/v_july_v/article/details/6105630\n4、经典算法研究系列：五、红黑树算法的实现与剖析 ：http://blog.csdn.net/v_JULY_v/article/details/6109153\n5、示例，红黑树插入和删除过程：http://saturnman.blog.163.com/blog/static/557611201097221570/\n6、红黑二叉树详解及理论分析 ：http://blog.csdn.net/kartorz/article/details/8865997","source":"_posts/java-toup26.md","raw":"---\ntitle: Java提高篇（二七）-----TreeMap\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 822b9db\ndate: 2017-10-24 13:09:53\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/23299963\n\nTreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,其实这篇博文的名字叫做：根据红黑树的算法来分析TreeMap的实现，但是为了与Java提高篇系列博文保持一致还是叫做TreeMap比较好。通过这篇博文你可以获得如下知识点：\n\n>1、红黑树的基本概念。\n 2、红黑树增加节点、删除节点的实现过程。\n 3、红黑树左旋转、右旋转的复杂过程。\n 4、Java 中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。\n\n我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。\n<!-- more -->\n## 红黑树简介\n红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。\n我们知道一颗基本的二叉树他们都需要满足一个基本性质--即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。\n平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。\n![](/uploads/tree1.png)\n\n 红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：\n      \n>1、每个节点都只能是红色或者黑色\n 2、根节点是黑色\n 3、每个叶节点（NIL节点，空节点）是黑色的。\n 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log n)。下图为一颗典型的红黑二叉树。\n![](/uploads/tree2.png)\n对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色\n![左旋](/uploads/tree3.gif) ![右旋](/uploads/tree4.gif)\n\n## TreeMap数据结构\n     \nTreeMap的定义如下：\n```java\npublic class TreeMap<K,V>\n    extends AbstractMap<K,V>\n    implements NavigableMap<K,V>, Cloneable, java.io.Serializable\n```\nTreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。\nTreeMap中同时也包含了如下几个重要的属性：\n//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制\n```java\n        private final Comparator<? super K> comparator;\n        //TreeMap红-黑节点，为TreeMap的内部类\n        private transient Entry<K,V> root = null;\n        //容器大小\n        private transient int size = 0;\n        //TreeMap修改次数\n        private transient int modCount = 0;\n        //红黑树的节点颜色--红色\n        private static final boolean RED = false;\n        //红黑树的节点颜色--黑色\n        private static final boolean BLACK = true;\n```\n对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：\n```java\n        //键\n        K key;\n        //值\n        V value;\n        //左孩子\n        Entry<K,V> left = null;\n        //右孩子\n        Entry<K,V> right = null;\n        //父亲\n        Entry<K,V> parent;\n        //颜色\n        boolean color = BLACK;\n```\n注：前面只是开胃菜，下面是本篇博文的重中之重，在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。\n## TreeMap put()方法\n在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。\n红黑树增加节点\n红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。\n![](/uploads/tree4.png)\n对于新节点的插入有如下三个关键地方：\n\n       1、插入新节点总是红色节点 。\n       2、如果插入节点的父节点是黑色, 能维持性质 。\n       3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。\n为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：\n\n        1、每个节点都只能是红色或者黑色\n        2、根节点是黑色\n        3、每个叶节点（NIL节点，空节点）是黑色的。\n        4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n        5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n### 为跟节点\n       若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））\n### 父节点为黑色\n这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））\n![](/uploads/tree5.png)\n### 若父节点P和P的兄弟节点U都为红色\n对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。\n![](/uploads/tree6.png)\n\n### 若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\n对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。\n![](/uploads/tree7.png)\n### 父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\n这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。\n![](/uploads/tree8.png)\n上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。\n## TreeMap put()方法实现分析\n在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。\n对于排序二叉树的创建，其添加节点的过程如下：\n1、以根节点为初始节点进行检索。\n2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。\n3、循环递归2步骤知道检索出合适的叶子节点为止。\n4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。\n按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：\n```java\n    public V put(K key, V value) {  \n           //用t表示二叉树的当前节点  \n            Entry<K,V> t = root;  \n            //t为null表示一个空树，即TreeMap中没有任何元素，直接插入  \n            if (t == null) {  \n                //比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？  \n                compare(key, key); // type (and possibly null) check  \n                //将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root  \n                root = new Entry<>(key, value, null);  \n                //容器的size = 1，表示TreeMap集合中存在一个元素  \n                size = 1;  \n                //修改次数 + 1  \n                modCount++;  \n                return null;  \n            }  \n            int cmp;     //cmp表示key排序的返回结果  \n            Entry<K,V> parent;   //父节点  \n            // split comparator and comparable paths  \n            Comparator<? super K> cpr = comparator;    //指定的排序算法  \n            //如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合  \n            if (cpr != null) {  \n                do {  \n                    parent = t;      //parent指向上次循环后的t  \n                    //比较新增节点的key和当前节点key的大小  \n                    cmp = cpr.compare(key, t.key);  \n                    //cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点  \n                    if (cmp < 0)  \n                        t = t.left;  \n                    //cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点  \n                    else if (cmp > 0)  \n                        t = t.right;  \n                    //cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值  \n                    else  \n                        return t.setValue(value);  \n                } while (t != null);  \n            }  \n            //如果cpr为空，则采用默认的排序算法进行创建TreeMap集合  \n            else {  \n                if (key == null)     //key值为空抛出异常  \n                    throw new NullPointerException();  \n                /* 下面处理过程和上面一样 */  \n                Comparable<? super K> k = (Comparable<? super K>) key;  \n                do {  \n                    parent = t;  \n                    cmp = k.compareTo(t.key);  \n                    if (cmp < 0)  \n                        t = t.left;  \n                    else if (cmp > 0)  \n                        t = t.right;  \n                    else  \n                        return t.setValue(value);  \n                } while (t != null);  \n            }  \n            //将新增节点当做parent的子节点  \n            Entry<K,V> e = new Entry<>(key, value, parent);  \n            //如果新增节点的key小于parent的key，则当做左子节点  \n            if (cmp < 0)  \n                parent.left = e;  \n          //如果新增节点的key大于parent的key，则当做右子节点  \n            else  \n                parent.right = e;  \n            /*  \n             *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置  \n             *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况  \n             */  \n            fixAfterInsertion(e);  \n            //TreeMap元素数量 + 1  \n            size++;  \n            //TreeMap容器修改次数 + 1  \n            modCount++;  \n            return null;  \n        }  \n```\n上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下：\n\n```java\n    /** \n     * 新增节点后的修复操作 \n     * x 表示新增节点 \n     */  \n     private void fixAfterInsertion(Entry<K,V> x) {  \n            x.color = RED;    //新增节点的颜色为红色  \n  \n            //循环 直到 x不是根节点，且x的父节点不为红色  \n            while (x != null && x != root && x.parent.color == RED) {  \n                //如果X的父节点（P）是其父节点的父节点（G）的左节点  \n                if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {  \n                    //获取X的叔节点(U)  \n                    Entry<K,V> y = rightOf(parentOf(parentOf(x)));  \n                    //如果X的叔节点（U） 为红色（情况三）  \n                    if (colorOf(y) == RED) {       \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的叔节点（U）设置为黑色  \n                        setColor(y, BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        x = parentOf(parentOf(x));  \n                    }  \n                    //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  \n                    else {     \n                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  \n                        if (x == rightOf(parentOf(x))) {  \n                            //将X的父节点作为X  \n                            x = parentOf(x);  \n                            //右旋转  \n                            rotateLeft(x);  \n                        }  \n                        //（情况五）  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        //以X的父节点的父节点（G）为中心右旋转  \n                        rotateRight(parentOf(parentOf(x)));  \n                    }  \n                }  \n                //如果X的父节点（P）是其父节点的父节点（G）的右节点  \n                else {  \n                    //获取X的叔节点（U）  \n                    Entry<K,V> y = leftOf(parentOf(parentOf(x)));  \n                  //如果X的叔节点（U） 为红色（情况三）  \n                    if (colorOf(y) == RED) {  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的叔节点（U）设置为黑色  \n                        setColor(y, BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        x = parentOf(parentOf(x));  \n                    }  \n                  //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  \n                    else {  \n                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  \n                        if (x == leftOf(parentOf(x))) {  \n                            //将X的父节点作为X  \n                            x = parentOf(x);  \n                           //右旋转  \n                            rotateRight(x);  \n                        }  \n                        //（情况五）  \n                        //将X的父节点（P）设置为黑色  \n                        setColor(parentOf(x), BLACK);  \n                        //将X的父节点的父节点（G）设置红色  \n                        setColor(parentOf(parentOf(x)), RED);  \n                        //以X的父节点的父节点（G）为中心右旋转  \n                        rotateLeft(parentOf(parentOf(x)));  \n                    }  \n                }  \n            }  \n            //将根节点G强制设置为黑色  \n            root.color = BLACK;  \n        }  \n\n```\n对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。\n左旋：rotateLeft()\n所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left ---> N ,N.left ---> P。\n\n右旋：rotateRight()\n```java\n    private void rotateLeft(Entry<K,V> p) {  \n        if (p != null) {  \n            //获取P的右子节点，其实这里就相当于新增节点N（情况四而言）  \n            Entry<K,V> r = p.right;  \n            //将R的左子树设置为P的右子树  \n            p.right = r.left;  \n            //若R的左子树不为空，则将P设置为R左子树的父亲  \n            if (r.left != null)  \n                r.left.parent = p;  \n            //将P的父亲设置R的父亲  \n            r.parent = p.parent;  \n            //如果P的父亲为空，则将R设置为跟节点  \n            if (p.parent == null)  \n                root = r;  \n            //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树  \n            else if (p.parent.left == p)  \n                p.parent.left = r;  \n            //否则R设置为P的父节点（G）的右子树  \n            else  \n                p.parent.right = r;  \n            //将P设置为R的左子树  \n            r.left = p;  \n            //将R设置为P的父节点  \n            p.parent = r;  \n        }  \n    }  \n```\n\n所谓右旋转即，P.right ---> G、G.parent ---> P。\n```java\n    private void rotateRight(Entry<K,V> p) {  \n        if (p != null) {  \n            //将L设置为P的左子树  \n            Entry<K,V> l = p.left;  \n            //将L的右子树设置为P的左子树  \n            p.left = l.right;  \n            //若L的右子树不为空，则将P设置L的右子树的父节点  \n            if (l.right != null)   \n                l.right.parent = p;  \n            //将P的父节点设置为L的父节点  \n            l.parent = p.parent;  \n            //如果P的父节点为空，则将L设置根节点  \n            if (p.parent == null)  \n                root = l;  \n            //若P为其父节点的右子树，则将L设置为P的父节点的右子树  \n            else if (p.parent.right == p)  \n                p.parent.right = l;  \n            //否则将L设置为P的父节点的左子树  \n            else   \n                p.parent.left = l;  \n            //将P设置为L的右子树  \n            l.right = p;  \n            //将L设置为P的父节点  \n            p.parent = l;  \n        }  \n    }  \n```\n着色：setColor()\n着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。\n\n```java\n    private static <K,V> void setColor(Entry<K,V> p, boolean c) {  \n        if (p != null)  \n            p.color = c;  \n    }  \n```\n## TreeMap delete()方法\n### 红黑树删除节点\n针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。\n![](/uploads/tree9.png)\n 红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。\n红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：\n1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。\n2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。\n3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。\n下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：\n1、每个节点都只能是红色或者黑色\n2、根节点是黑色\n3、每个叶节点（NIL节点，空节点）是黑色的。\n4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n（注：已经讲三遍了，再不记住我就怀疑你是否适合搞IT了 O(∩_∩)O~）\n诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：\n1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。\n2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。\n![](/uploads/tree10.png)\n现在我们就上面提到的三种情况进行分析、处理。\n情况一、无子节点（红色节点）\n这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点-----如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。\n情况二、有一个子节点\n这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）\n情况三、有两个子节点\n这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。\n1、N的兄弟节点W为红色\n2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。\n3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。\n4、N的兄弟w是黑色的，且w的右孩子时红色的。\n情况3.1、N的兄弟节点W为红色\nW为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W、P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1、转变为3.2、3.3、3.4中的一种。如下：\n![](/uploads/tree11.png)\n情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。\n这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下\n![](/uploads/tree12.png)\n将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1、3.3、3.4中的一种。\n情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。\n针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。\n![](/uploads/tree13.png)\n此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.\n情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。\n交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。\n![](/uploads/tree14.png)\n\n总结\n个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。情况3.1，是将W旋转将其转成情况2、3、4情况进行处理。而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。情况3.4、右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。\n通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。\n<font color=\"#3366ff\">**TreeMap deleteEntry()方法实现分析**</font>\n通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点、删除替代节点。\n```java\n    private void deleteEntry(Entry<K,V> p) {  \n        modCount++;      //修改次数 +1  \n        size--;          //元素个数 -1  \n  \n        /* \n         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 \n         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 \n         * ---------------------（1） \n         */  \n        if (p.left != null && p.right != null) {    \n            Entry<K,V> s = successor(p);  \n            p.key = s.key;  \n            p.value = s.value;  \n            p = s;  \n        }  \n  \n        //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代  \n        Entry<K,V> replacement = (p.left != null ? p.left : p.right);  \n  \n        /* \n         * 删除节点，分为上面提到的三种情况 \n         * -----------------------（2） \n         */  \n        //如果替代节点不为空  \n        if (replacement != null) {  \n            replacement.parent = p.parent;  \n            /* \n             *replacement来替代P节点 \n             */  \n            //若P没有父节点，则跟节点直接变成replacement  \n            if (p.parent == null)  \n                root = replacement;  \n            //如果P为左节点，则用replacement来替代为左节点  \n            else if (p == p.parent.left)  \n                p.parent.left  = replacement;  \n          //如果P为右节点，则用replacement来替代为右节点  \n            else  \n                p.parent.right = replacement;  \n  \n            //同时将P节点从这棵树中剔除掉  \n            p.left = p.right = p.parent = null;  \n  \n            /* \n             * 若P为红色直接删除，红黑树保持平衡 \n             * 但是若P为黑色，则需要调整红黑树使其保持平衡 \n             */  \n            if (p.color == BLACK)  \n                fixAfterDeletion(replacement);  \n        } else if (p.parent == null) {     //p没有父节点，表示为P根节点，直接删除即可  \n            root = null;  \n        } else {      //P节点不存在子节点，直接删除即可  \n            if (p.color == BLACK)         //如果P节点的颜色为黑色，对红黑树进行调整  \n                fixAfterDeletion(p);  \n  \n            //删除P节点  \n            if (p.parent != null) {  \n                if (p == p.parent.left)  \n                    p.parent.left = null;  \n                else if (p == p.parent.right)  \n                    p.parent.right = null;  \n                p.parent = null;  \n            }  \n        }  \n    }  \n```\n\n（1）除是寻找替代节点replacement，其实现方法为successor()。如下：\n```java\nstatic <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {  \n        if (t == null)  \n            return null;  \n        /* \n         * 寻找右子树的最左子树 \n         */  \n        else if (t.right != null) {  \n            Entry<K,V> p = t.right;  \n            while (p.left != null)  \n                p = p.left;  \n            return p;  \n        }   \n        /* \n         * 选择左子树的最右子树 \n         */  \n        else {  \n            Entry<K,V> p = t.parent;  \n            Entry<K,V> ch = t;  \n            while (p != null && ch == p.right) {  \n                ch = p;  \n                p = p.parent;  \n            }  \n            return p;  \n        }  \n    } \n```\n\n（2）处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：\n1、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。\n2、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。\n3、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。\n删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。\n```java\n    private void fixAfterDeletion(Entry<K,V> x) {  \n        // 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色  \n        while (x != root && colorOf(x) == BLACK) {  \n            if (x == leftOf(parentOf(x))) {      //若X节点为左节点  \n                //获取其兄弟节点  \n                Entry<K,V> sib = rightOf(parentOf(x));  \n  \n                /* \n                 * 如果兄弟节点为红色----（情况3.1） \n                 * 策略：改变W、P的颜色，然后进行一次左旋转 \n                 */  \n                if (colorOf(sib) == RED) {       \n                    setColor(sib, BLACK);       \n                    setColor(parentOf(x), RED);    \n                    rotateLeft(parentOf(x));  \n                    sib = rightOf(parentOf(x));  \n                }  \n  \n                /* \n                 * 若兄弟节点的两个子节点都为黑色----（情况3.2） \n                 * 策略：将兄弟节点编程红色 \n                 */  \n                if (colorOf(leftOf(sib))  == BLACK &&  \n                    colorOf(rightOf(sib)) == BLACK) {  \n                    setColor(sib, RED);  \n                    x = parentOf(x);  \n                }   \n                else {  \n                    /* \n                     * 如果兄弟节点只有右子树为黑色----（情况3.3） \n                     * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转 \n                     * 这时情况会转变为3.4 \n                     */  \n                    if (colorOf(rightOf(sib)) == BLACK) {  \n                        setColor(leftOf(sib), BLACK);  \n                        setColor(sib, RED);  \n                        rotateRight(sib);  \n                        sib = rightOf(parentOf(x));  \n                    }  \n                    /* \n                     *----情况3.4 \n                     *策略：交换兄弟节点和父节点的颜色， \n                     *同时将兄弟节点右子树设置为黑色，最后左旋转 \n                     */  \n                    setColor(sib, colorOf(parentOf(x)));  \n                    setColor(parentOf(x), BLACK);  \n                    setColor(rightOf(sib), BLACK);  \n                    rotateLeft(parentOf(x));  \n                    x = root;  \n                }  \n            }   \n              \n            /** \n             * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了 \n             */  \n            else {  \n                Entry<K,V> sib = leftOf(parentOf(x));  \n  \n                if (colorOf(sib) == RED) {  \n                    setColor(sib, BLACK);  \n                    setColor(parentOf(x), RED);  \n                    rotateRight(parentOf(x));  \n                    sib = leftOf(parentOf(x));  \n                }  \n  \n                if (colorOf(rightOf(sib)) == BLACK &&  \n                    colorOf(leftOf(sib)) == BLACK) {  \n                    setColor(sib, RED);  \n                    x = parentOf(x);  \n                } else {  \n                    if (colorOf(leftOf(sib)) == BLACK) {  \n                        setColor(rightOf(sib), BLACK);  \n                        setColor(sib, RED);  \n                        rotateLeft(sib);  \n                        sib = leftOf(parentOf(x));  \n                    }  \n                    setColor(sib, colorOf(parentOf(x)));  \n                    setColor(parentOf(x), BLACK);  \n                    setColor(leftOf(sib), BLACK);  \n                    rotateRight(parentOf(x));  \n                    x = root;  \n                }  \n            }  \n        }  \n  \n        setColor(x, BLACK);  \n    }  \n```\n\n这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。\n五、写在最后\n这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。同时这篇博文很大篇幅都在阐述红黑树的实现过程，对Java 的TreeMap聊的比较少，但是我认为如果理解了红黑树的实现过程，对TreeMap那是手到擒来，小菜一碟。\n同时这篇博文我写了四天，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。LZ大二开始学习数据结构，自认为学的不错，现在发现数据结构我还有太多的地方需要学习了，同时也再一次体味了算法的魅力！！！！\n\n参考资料：\n\n1、红黑树数据结构剖析：http://www.cnblogs.com/fanzhidongyzby/p/3187912.html\n2、红黑二叉树详解及理论分析 ：http://blog.csdn.net/kartorz/article/details/8865997\n3、教你透彻了解红黑树 ：http://blog.csdn.net/v_july_v/article/details/6105630\n4、经典算法研究系列：五、红黑树算法的实现与剖析 ：http://blog.csdn.net/v_JULY_v/article/details/6109153\n5、示例，红黑树插入和删除过程：http://saturnman.blog.163.com/blog/static/557611201097221570/\n6、红黑二叉树详解及理论分析 ：http://blog.csdn.net/kartorz/article/details/8865997","slug":"java-toup26","published":1,"updated":"2019-09-03T03:40:46.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keteu00250vfav0vjarl1","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/23299963\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/23299963</a></p></blockquote><p>TreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,其实这篇博文的名字叫做：根据红黑树的算法来分析TreeMap的实现，但是为了与Java提高篇系列博文保持一致还是叫做TreeMap比较好。通过这篇博文你可以获得如下知识点：</p><blockquote><p>1、红黑树的基本概念。<br>2、红黑树增加节点、删除节点的实现过程。<br>3、红黑树左旋转、右旋转的复杂过程。<br>4、Java 中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。</p></blockquote><p>我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。<br><a id=\"more\"></a></p><h2 id=\"红黑树简介\"><a href=\"#红黑树简介\" class=\"headerlink\" title=\"红黑树简介\"></a>红黑树简介</h2><p>红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。<br>我们知道一颗基本的二叉树他们都需要满足一个基本性质—即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。<br>平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。<br><img src=\"/uploads/tree1.png\" alt></p><p>红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：</p><blockquote><p>1、每个节点都只能是红色或者黑色<br>2、根节点是黑色<br>3、每个叶节点（NIL节点，空节点）是黑色的。<br>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。<br>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></blockquote><p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log n)。下图为一颗典型的红黑二叉树。<br><img src=\"/uploads/tree2.png\" alt><br>对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色<br><img src=\"/uploads/tree3.gif\" alt=\"左旋\"> <img src=\"/uploads/tree4.gif\" alt=\"右旋\"></p><h2 id=\"TreeMap数据结构\"><a href=\"#TreeMap数据结构\" class=\"headerlink\" title=\"TreeMap数据结构\"></a>TreeMap数据结构</h2><p>TreeMap的定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">NavigableMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。<br>TreeMap中同时也包含了如下几个重要的属性：<br>//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;? <span class=\"keyword\">super</span> K&gt; comparator;</span><br><span class=\"line\"><span class=\"comment\">//TreeMap红-黑节点，为TreeMap的内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Entry&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//容器大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//TreeMap修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//红黑树的节点颜色--红色</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> RED = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//红黑树的节点颜色--黑色</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> BLACK = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure><p></p><p>对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//键</span></span><br><span class=\"line\">K key;</span><br><span class=\"line\"><span class=\"comment\">//值</span></span><br><span class=\"line\">V value;</span><br><span class=\"line\"><span class=\"comment\">//左孩子</span></span><br><span class=\"line\">Entry&lt;K,V&gt; left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//右孩子</span></span><br><span class=\"line\">Entry&lt;K,V&gt; right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//父亲</span></span><br><span class=\"line\">Entry&lt;K,V&gt; parent;</span><br><span class=\"line\"><span class=\"comment\">//颜色</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> color = BLACK;</span><br></pre></td></tr></table></figure><p></p><p>注：前面只是开胃菜，下面是本篇博文的重中之重，在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</p><h2 id=\"TreeMap-put-方法\"><a href=\"#TreeMap-put-方法\" class=\"headerlink\" title=\"TreeMap put()方法\"></a>TreeMap put()方法</h2><p>在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。<br>红黑树增加节点<br>红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。<br><img src=\"/uploads/tree4.png\" alt><br>对于新节点的插入有如下三个关键地方：</p><pre><code>   1、插入新节点总是红色节点 。\n   2、如果插入节点的父节点是黑色, 能维持性质 。\n   3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。\n</code></pre><p>为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：</p><pre><code>    1、每个节点都只能是红色或者黑色\n    2、根节点是黑色\n    3、每个叶节点（NIL节点，空节点）是黑色的。\n    4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n    5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n</code></pre><h3 id=\"为跟节点\"><a href=\"#为跟节点\" class=\"headerlink\" title=\"为跟节点\"></a>为跟节点</h3><pre><code>   若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））\n</code></pre><h3 id=\"父节点为黑色\"><a href=\"#父节点为黑色\" class=\"headerlink\" title=\"父节点为黑色\"></a>父节点为黑色</h3><p>这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））<br><img src=\"/uploads/tree5.png\" alt></p><h3 id=\"若父节点P和P的兄弟节点U都为红色\"><a href=\"#若父节点P和P的兄弟节点U都为红色\" class=\"headerlink\" title=\"若父节点P和P的兄弟节点U都为红色\"></a>若父节点P和P的兄弟节点U都为红色</h3><p>对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。<br><img src=\"/uploads/tree6.png\" alt></p><h3 id=\"若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\"><a href=\"#若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\" class=\"headerlink\" title=\"若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\"></a>若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子</h3><p>对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。<br><img src=\"/uploads/tree7.png\" alt></p><h3 id=\"父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\"><a href=\"#父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\" class=\"headerlink\" title=\"父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\"></a>父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子</h3><p>这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。<br><img src=\"/uploads/tree8.png\" alt><br>上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。</p><h2 id=\"TreeMap-put-方法实现分析\"><a href=\"#TreeMap-put-方法实现分析\" class=\"headerlink\" title=\"TreeMap put()方法实现分析\"></a>TreeMap put()方法实现分析</h2><p>在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。<br>对于排序二叉树的创建，其添加节点的过程如下：<br>1、以根节点为初始节点进行检索。<br>2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。<br>3、循环递归2步骤知道检索出合适的叶子节点为止。<br>4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。<br>按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">       <span class=\"comment\">//用t表示二叉树的当前节点  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; t = root;  </span><br><span class=\"line\">        <span class=\"comment\">//t为null表示一个空树，即TreeMap中没有任何元素，直接插入  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？  </span></span><br><span class=\"line\">            compare(key, key); <span class=\"comment\">// type (and possibly null) check  </span></span><br><span class=\"line\">            <span class=\"comment\">//将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root  </span></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">            <span class=\"comment\">//容器的size = 1，表示TreeMap集合中存在一个元素  </span></span><br><span class=\"line\">            size = <span class=\"number\">1</span>;  </span><br><span class=\"line\">            <span class=\"comment\">//修改次数 + 1  </span></span><br><span class=\"line\">            modCount++;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cmp;     <span class=\"comment\">//cmp表示key排序的返回结果  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; parent;   <span class=\"comment\">//父节点  </span></span><br><span class=\"line\">        <span class=\"comment\">// split comparator and comparable paths  </span></span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;    <span class=\"comment\">//指定的排序算法  </span></span><br><span class=\"line\">        <span class=\"comment\">//如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">                parent = t;      <span class=\"comment\">//parent指向上次循环后的t  </span></span><br><span class=\"line\">                <span class=\"comment\">//比较新增节点的key和当前节点key的大小  </span></span><br><span class=\"line\">                cmp = cpr.compare(key, t.key);  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.left;  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.right;  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t.setValue(value);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//如果cpr为空，则采用默认的排序算法进行创建TreeMap集合  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)     <span class=\"comment\">//key值为空抛出异常  </span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">            <span class=\"comment\">/* 下面处理过程和上面一样 */</span>  </span><br><span class=\"line\">            Comparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;  </span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">                parent = t;  </span><br><span class=\"line\">                cmp = k.compareTo(t.key);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.left;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.right;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span>  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t.setValue(value);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//将新增节点当做parent的子节点  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, parent);  </span><br><span class=\"line\">        <span class=\"comment\">//如果新增节点的key小于parent的key，则当做左子节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">            parent.left = e;  </span><br><span class=\"line\">      <span class=\"comment\">//如果新增节点的key大于parent的key，则当做右子节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            parent.right = e;  </span><br><span class=\"line\">        <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">         *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置  </span></span><br><span class=\"line\"><span class=\"comment\">         *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况  </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        fixAfterInsertion(e);  </span><br><span class=\"line\">        <span class=\"comment\">//TreeMap元素数量 + 1  </span></span><br><span class=\"line\">        size++;  </span><br><span class=\"line\">        <span class=\"comment\">//TreeMap容器修改次数 + 1  </span></span><br><span class=\"line\">        modCount++;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 新增节点后的修复操作 </span></span><br><span class=\"line\"><span class=\"comment\"> * x 表示新增节点 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixAfterInsertion</span><span class=\"params\">(Entry&lt;K,V&gt; x)</span> </span>&#123;  </span><br><span class=\"line\">        x.color = RED;    <span class=\"comment\">//新增节点的颜色为红色  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//循环 直到 x不是根节点，且x的父节点不为红色  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"keyword\">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//如果X的父节点（P）是其父节点的父节点（G）的左节点  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//获取X的叔节点(U)  </span></span><br><span class=\"line\">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));  </span><br><span class=\"line\">                <span class=\"comment\">//如果X的叔节点（U） 为红色（情况三）  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(y) == RED) &#123;       </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的叔节点（U）设置为黑色  </span></span><br><span class=\"line\">                    setColor(y, BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    x = parentOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"comment\">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;     </span><br><span class=\"line\">                    <span class=\"comment\">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x == rightOf(parentOf(x))) &#123;  </span><br><span class=\"line\">                        <span class=\"comment\">//将X的父节点作为X  </span></span><br><span class=\"line\">                        x = parentOf(x);  </span><br><span class=\"line\">                        <span class=\"comment\">//右旋转  </span></span><br><span class=\"line\">                        rotateLeft(x);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    <span class=\"comment\">//（情况五）  </span></span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    <span class=\"comment\">//以X的父节点的父节点（G）为中心右旋转  </span></span><br><span class=\"line\">                    rotateRight(parentOf(parentOf(x)));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">//如果X的父节点（P）是其父节点的父节点（G）的右节点  </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//获取X的叔节点（U）  </span></span><br><span class=\"line\">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));  </span><br><span class=\"line\">              <span class=\"comment\">//如果X的叔节点（U） 为红色（情况三）  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(y) == RED) &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的叔节点（U）设置为黑色  </span></span><br><span class=\"line\">                    setColor(y, BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    x = parentOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">              <span class=\"comment\">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x == leftOf(parentOf(x))) &#123;  </span><br><span class=\"line\">                        <span class=\"comment\">//将X的父节点作为X  </span></span><br><span class=\"line\">                        x = parentOf(x);  </span><br><span class=\"line\">                       <span class=\"comment\">//右旋转  </span></span><br><span class=\"line\">                        rotateRight(x);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    <span class=\"comment\">//（情况五）  </span></span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    <span class=\"comment\">//以X的父节点的父节点（G）为中心右旋转  </span></span><br><span class=\"line\">                    rotateLeft(parentOf(parentOf(x)));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//将根节点G强制设置为黑色  </span></span><br><span class=\"line\">        root.color = BLACK;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p>对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。<br>左旋：rotateLeft()<br>所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left —-&gt; N ,N.left —-&gt; P。</p><p>右旋：rotateRight()<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateLeft</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//获取P的右子节点，其实这里就相当于新增节点N（情况四而言）  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; r = p.right;  </span><br><span class=\"line\">        <span class=\"comment\">//将R的左子树设置为P的右子树  </span></span><br><span class=\"line\">        p.right = r.left;  </span><br><span class=\"line\">        <span class=\"comment\">//若R的左子树不为空，则将P设置为R左子树的父亲  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.left != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            r.left.parent = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将P的父亲设置R的父亲  </span></span><br><span class=\"line\">        r.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P的父亲为空，则将R设置为跟节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = r;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent.left == p)  </span><br><span class=\"line\">            p.parent.left = r;  </span><br><span class=\"line\">        <span class=\"comment\">//否则R设置为P的父节点（G）的右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            p.parent.right = r;  </span><br><span class=\"line\">        <span class=\"comment\">//将P设置为R的左子树  </span></span><br><span class=\"line\">        r.left = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将R设置为P的父节点  </span></span><br><span class=\"line\">        p.parent = r;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所谓右旋转即，P.right —-&gt; G、G.parent —-&gt; P。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateRight</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//将L设置为P的左子树  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; l = p.left;  </span><br><span class=\"line\">        <span class=\"comment\">//将L的右子树设置为P的左子树  </span></span><br><span class=\"line\">        p.left = l.right;  </span><br><span class=\"line\">        <span class=\"comment\">//若L的右子树不为空，则将P设置L的右子树的父节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l.right != <span class=\"keyword\">null</span>)   </span><br><span class=\"line\">            l.right.parent = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将P的父节点设置为L的父节点  </span></span><br><span class=\"line\">        l.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P的父节点为空，则将L设置根节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = l;  </span><br><span class=\"line\">        <span class=\"comment\">//若P为其父节点的右子树，则将L设置为P的父节点的右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent.right == p)  </span><br><span class=\"line\">            p.parent.right = l;  </span><br><span class=\"line\">        <span class=\"comment\">//否则将L设置为P的父节点的左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>   </span><br><span class=\"line\">            p.parent.left = l;  </span><br><span class=\"line\">        <span class=\"comment\">//将P设置为L的右子树  </span></span><br><span class=\"line\">        l.right = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将L设置为P的父节点  </span></span><br><span class=\"line\">        p.parent = l;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>着色：setColor()<br>着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(Entry&lt;K,V&gt; p, <span class=\"keyword\">boolean</span> c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        p.color = c;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"TreeMap-delete-方法\"><a href=\"#TreeMap-delete-方法\" class=\"headerlink\" title=\"TreeMap delete()方法\"></a>TreeMap delete()方法</h2><h3 id=\"红黑树删除节点\"><a href=\"#红黑树删除节点\" class=\"headerlink\" title=\"红黑树删除节点\"></a>红黑树删除节点</h3><p>针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。<br><img src=\"/uploads/tree9.png\" alt><br>红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。<br>红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：<br>1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。<br>2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。<br>3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。<br>下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：<br>1、每个节点都只能是红色或者黑色<br>2、根节点是黑色<br>3、每个叶节点（NIL节点，空节点）是黑色的。<br>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。<br>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>（注：已经讲三遍了，再不记住我就怀疑你是否适合搞IT了 O(∩_∩)O~）<br>诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：<br>1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。<br>2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。<br><img src=\"/uploads/tree10.png\" alt><br>现在我们就上面提到的三种情况进行分析、处理。<br>情况一、无子节点（红色节点）<br>这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点——-如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。<br>情况二、有一个子节点<br>这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）<br>情况三、有两个子节点<br>这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。<br>1、N的兄弟节点W为红色<br>2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。<br>3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。<br>4、N的兄弟w是黑色的，且w的右孩子时红色的。<br>情况3.1、N的兄弟节点W为红色<br>W为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W、P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1、转变为3.2、3.3、3.4中的一种。如下：<br><img src=\"/uploads/tree11.png\" alt><br>情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。<br>这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下<br><img src=\"/uploads/tree12.png\" alt><br>将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1、3.3、3.4中的一种。<br>情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。<br>针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。<br><img src=\"/uploads/tree13.png\" alt><br>此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.<br>情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。<br>交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。<br><img src=\"/uploads/tree14.png\" alt></p><p>总结<br>个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。情况3.1，是将W旋转将其转成情况2、3、4情况进行处理。而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。情况3.4、右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。<br>通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。</p><p><font color=\"#3366ff\"><strong>TreeMap deleteEntry()方法实现分析</strong></font><br>通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点、删除替代节点。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteEntry</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;      <span class=\"comment\">//修改次数 +1  </span></span><br><span class=\"line\">    size--;          <span class=\"comment\">//元素个数 -1  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 </span></span><br><span class=\"line\"><span class=\"comment\">     * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 </span></span><br><span class=\"line\"><span class=\"comment\">     * ---------------------（1） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.left != <span class=\"keyword\">null</span> &amp;&amp; p.right != <span class=\"keyword\">null</span>) &#123;    </span><br><span class=\"line\">        Entry&lt;K,V&gt; s = successor(p);  </span><br><span class=\"line\">        p.key = s.key;  </span><br><span class=\"line\">        p.value = s.value;  </span><br><span class=\"line\">        p = s;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt; replacement = (p.left != <span class=\"keyword\">null</span> ? p.left : p.right);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 删除节点，分为上面提到的三种情况 </span></span><br><span class=\"line\"><span class=\"comment\">     * -----------------------（2） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"comment\">//如果替代节点不为空  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (replacement != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        replacement.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         *replacement来替代P节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"comment\">//若P没有父节点，则跟节点直接变成replacement  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = replacement;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P为左节点，则用replacement来替代为左节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.left)  </span><br><span class=\"line\">            p.parent.left  = replacement;  </span><br><span class=\"line\">      <span class=\"comment\">//如果P为右节点，则用replacement来替代为右节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            p.parent.right = replacement;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//同时将P节点从这棵树中剔除掉  </span></span><br><span class=\"line\">        p.left = p.right = p.parent = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 若P为红色直接删除，红黑树保持平衡 </span></span><br><span class=\"line\"><span class=\"comment\">         * 但是若P为黑色，则需要调整红黑树使其保持平衡 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.color == BLACK)  </span><br><span class=\"line\">            fixAfterDeletion(replacement);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) &#123;     <span class=\"comment\">//p没有父节点，表示为P根节点，直接删除即可  </span></span><br><span class=\"line\">        root = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;      <span class=\"comment\">//P节点不存在子节点，直接删除即可  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.color == BLACK)         <span class=\"comment\">//如果P节点的颜色为黑色，对红黑树进行调整  </span></span><br><span class=\"line\">            fixAfterDeletion(p);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//删除P节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == p.parent.left)  </span><br><span class=\"line\">                p.parent.left = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.right)  </span><br><span class=\"line\">                p.parent.right = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">            p.parent = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>（1）除是寻找替代节点replacement，其实现方法为successor()。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; TreeMap.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">successor</span><span class=\"params\">(Entry&lt;K,V&gt; t)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 寻找右子树的最左子树 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t.right != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; p = t.right;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p.left != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                p = p.left;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;  </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 选择左子树的最右子树 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; p = t.parent;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; ch = t;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; ch == p.right) &#123;  </span><br><span class=\"line\">                ch = p;  </span><br><span class=\"line\">                p = p.parent;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>（2）处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：<br>1、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。<br>2、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。<br>3、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。<br>删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixAfterDeletion</span><span class=\"params\">(Entry&lt;K,V&gt; x)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色  </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == leftOf(parentOf(x))) &#123;      <span class=\"comment\">//若X节点为左节点  </span></span><br><span class=\"line\">            <span class=\"comment\">//获取其兄弟节点  </span></span><br><span class=\"line\">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">             * 如果兄弟节点为红色----（情况3.1） </span></span><br><span class=\"line\"><span class=\"comment\">             * 策略：改变W、P的颜色，然后进行一次左旋转 </span></span><br><span class=\"line\"><span class=\"comment\">             */</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(sib) == RED) &#123;       </span><br><span class=\"line\">                setColor(sib, BLACK);       </span><br><span class=\"line\">                setColor(parentOf(x), RED);    </span><br><span class=\"line\">                rotateLeft(parentOf(x));  </span><br><span class=\"line\">                sib = rightOf(parentOf(x));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">             * 若兄弟节点的两个子节点都为黑色----（情况3.2） </span></span><br><span class=\"line\"><span class=\"comment\">             * 策略：将兄弟节点编程红色 </span></span><br><span class=\"line\"><span class=\"comment\">             */</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;  </span><br><span class=\"line\">                colorOf(rightOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                setColor(sib, RED);  </span><br><span class=\"line\">                x = parentOf(x);  </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                 * 如果兄弟节点只有右子树为黑色----（情况3.3） </span></span><br><span class=\"line\"><span class=\"comment\">                 * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转 </span></span><br><span class=\"line\"><span class=\"comment\">                 * 这时情况会转变为3.4 </span></span><br><span class=\"line\"><span class=\"comment\">                 */</span>  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                    setColor(leftOf(sib), BLACK);  </span><br><span class=\"line\">                    setColor(sib, RED);  </span><br><span class=\"line\">                    rotateRight(sib);  </span><br><span class=\"line\">                    sib = rightOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                 *----情况3.4 </span></span><br><span class=\"line\"><span class=\"comment\">                 *策略：交换兄弟节点和父节点的颜色， </span></span><br><span class=\"line\"><span class=\"comment\">                 *同时将兄弟节点右子树设置为黑色，最后左旋转 </span></span><br><span class=\"line\"><span class=\"comment\">                 */</span>  </span><br><span class=\"line\">                setColor(sib, colorOf(parentOf(x)));  </span><br><span class=\"line\">                setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                setColor(rightOf(sib), BLACK);  </span><br><span class=\"line\">                rotateLeft(parentOf(x));  </span><br><span class=\"line\">                x = root;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(sib) == RED) &#123;  </span><br><span class=\"line\">                setColor(sib, BLACK);  </span><br><span class=\"line\">                setColor(parentOf(x), RED);  </span><br><span class=\"line\">                rotateRight(parentOf(x));  </span><br><span class=\"line\">                sib = leftOf(parentOf(x));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;  </span><br><span class=\"line\">                colorOf(leftOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                setColor(sib, RED);  </span><br><span class=\"line\">                x = parentOf(x);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                    setColor(rightOf(sib), BLACK);  </span><br><span class=\"line\">                    setColor(sib, RED);  </span><br><span class=\"line\">                    rotateLeft(sib);  </span><br><span class=\"line\">                    sib = leftOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                setColor(sib, colorOf(parentOf(x)));  </span><br><span class=\"line\">                setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                setColor(leftOf(sib), BLACK);  </span><br><span class=\"line\">                rotateRight(parentOf(x));  </span><br><span class=\"line\">                x = root;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    setColor(x, BLACK);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。<br>五、写在最后<br>这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。同时这篇博文很大篇幅都在阐述红黑树的实现过程，对Java 的TreeMap聊的比较少，但是我认为如果理解了红黑树的实现过程，对TreeMap那是手到擒来，小菜一碟。<br>同时这篇博文我写了四天，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。LZ大二开始学习数据结构，自认为学的不错，现在发现数据结构我还有太多的地方需要学习了，同时也再一次体味了算法的魅力！！！！</p><p>参考资料：</p><p>1、红黑树数据结构剖析：<a href=\"http://www.cnblogs.com/fanzhidongyzby/p/3187912.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</a><br>2、红黑二叉树详解及理论分析 ：<a href=\"http://blog.csdn.net/kartorz/article/details/8865997\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kartorz/article/details/8865997</a><br>3、教你透彻了解红黑树 ：<a href=\"http://blog.csdn.net/v_july_v/article/details/6105630\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/v_july_v/article/details/6105630</a><br>4、经典算法研究系列：五、红黑树算法的实现与剖析 ：<a href=\"http://blog.csdn.net/v_JULY_v/article/details/6109153\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/v_JULY_v/article/details/6109153</a><br>5、示例，红黑树插入和删除过程：<a href=\"http://saturnman.blog.163.com/blog/static/557611201097221570/\" target=\"_blank\" rel=\"noopener\">http://saturnman.blog.163.com/blog/static/557611201097221570/</a><br>6、红黑二叉树详解及理论分析 ：<a href=\"http://blog.csdn.net/kartorz/article/details/8865997\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kartorz/article/details/8865997</a></p><!-- rebuild by neat -->","site":{"data":{}},"length":20969,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/23299963\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/23299963</a></p></blockquote><p>TreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,其实这篇博文的名字叫做：根据红黑树的算法来分析TreeMap的实现，但是为了与Java提高篇系列博文保持一致还是叫做TreeMap比较好。通过这篇博文你可以获得如下知识点：</p><blockquote><p>1、红黑树的基本概念。<br>2、红黑树增加节点、删除节点的实现过程。<br>3、红黑树左旋转、右旋转的复杂过程。<br>4、Java 中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。</p></blockquote><p>我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。<br>","more":"</p><h2 id=\"红黑树简介\"><a href=\"#红黑树简介\" class=\"headerlink\" title=\"红黑树简介\"></a>红黑树简介</h2><p>红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。<br>我们知道一颗基本的二叉树他们都需要满足一个基本性质—即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP ，红黑树等等。<br>平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。<br><img src=\"/uploads/tree1.png\" alt></p><p>红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：</p><blockquote><p>1、每个节点都只能是红色或者黑色<br>2、根节点是黑色<br>3、每个叶节点（NIL节点，空节点）是黑色的。<br>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。<br>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></blockquote><p>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log n)。下图为一颗典型的红黑二叉树。<br><img src=\"/uploads/tree2.png\" alt><br>对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色<br><img src=\"/uploads/tree3.gif\" alt=\"左旋\"> <img src=\"/uploads/tree4.gif\" alt=\"右旋\"></p><h2 id=\"TreeMap数据结构\"><a href=\"#TreeMap数据结构\" class=\"headerlink\" title=\"TreeMap数据结构\"></a>TreeMap数据结构</h2><p>TreeMap的定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">NavigableMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。<br>TreeMap中同时也包含了如下几个重要的属性：<br>//比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;? <span class=\"keyword\">super</span> K&gt; comparator;</span><br><span class=\"line\"><span class=\"comment\">//TreeMap红-黑节点，为TreeMap的内部类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Entry&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//容器大小</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//TreeMap修改次数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">//红黑树的节点颜色--红色</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> RED = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//红黑树的节点颜色--黑色</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> BLACK = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure><p></p><p>对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//键</span></span><br><span class=\"line\">K key;</span><br><span class=\"line\"><span class=\"comment\">//值</span></span><br><span class=\"line\">V value;</span><br><span class=\"line\"><span class=\"comment\">//左孩子</span></span><br><span class=\"line\">Entry&lt;K,V&gt; left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//右孩子</span></span><br><span class=\"line\">Entry&lt;K,V&gt; right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//父亲</span></span><br><span class=\"line\">Entry&lt;K,V&gt; parent;</span><br><span class=\"line\"><span class=\"comment\">//颜色</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> color = BLACK;</span><br></pre></td></tr></table></figure><p></p><p>注：前面只是开胃菜，下面是本篇博文的重中之重，在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</p><h2 id=\"TreeMap-put-方法\"><a href=\"#TreeMap-put-方法\" class=\"headerlink\" title=\"TreeMap put()方法\"></a>TreeMap put()方法</h2><p>在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。<br>红黑树增加节点<br>红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。<br><img src=\"/uploads/tree4.png\" alt><br>对于新节点的插入有如下三个关键地方：</p><pre><code>   1、插入新节点总是红色节点 。\n   2、如果插入节点的父节点是黑色, 能维持性质 。\n   3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。\n</code></pre><p>为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：</p><pre><code>    1、每个节点都只能是红色或者黑色\n    2、根节点是黑色\n    3、每个叶节点（NIL节点，空节点）是黑色的。\n    4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。\n    5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n</code></pre><h3 id=\"为跟节点\"><a href=\"#为跟节点\" class=\"headerlink\" title=\"为跟节点\"></a>为跟节点</h3><pre><code>   若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））\n</code></pre><h3 id=\"父节点为黑色\"><a href=\"#父节点为黑色\" class=\"headerlink\" title=\"父节点为黑色\"></a>父节点为黑色</h3><p>这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））<br><img src=\"/uploads/tree5.png\" alt></p><h3 id=\"若父节点P和P的兄弟节点U都为红色\"><a href=\"#若父节点P和P的兄弟节点U都为红色\" class=\"headerlink\" title=\"若父节点P和P的兄弟节点U都为红色\"></a>若父节点P和P的兄弟节点U都为红色</h3><p>对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。<br><img src=\"/uploads/tree6.png\" alt></p><h3 id=\"若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\"><a href=\"#若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\" class=\"headerlink\" title=\"若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子\"></a>若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子</h3><p>对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。<br><img src=\"/uploads/tree7.png\" alt></p><h3 id=\"父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\"><a href=\"#父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\" class=\"headerlink\" title=\"父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子\"></a>父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子</h3><p>这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。<br><img src=\"/uploads/tree8.png\" alt><br>上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。</p><h2 id=\"TreeMap-put-方法实现分析\"><a href=\"#TreeMap-put-方法实现分析\" class=\"headerlink\" title=\"TreeMap put()方法实现分析\"></a>TreeMap put()方法实现分析</h2><p>在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。<br>对于排序二叉树的创建，其添加节点的过程如下：<br>1、以根节点为初始节点进行检索。<br>2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。<br>3、循环递归2步骤知道检索出合适的叶子节点为止。<br>4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。<br>按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">       <span class=\"comment\">//用t表示二叉树的当前节点  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; t = root;  </span><br><span class=\"line\">        <span class=\"comment\">//t为null表示一个空树，即TreeMap中没有任何元素，直接插入  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？  </span></span><br><span class=\"line\">            compare(key, key); <span class=\"comment\">// type (and possibly null) check  </span></span><br><span class=\"line\">            <span class=\"comment\">//将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root  </span></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">            <span class=\"comment\">//容器的size = 1，表示TreeMap集合中存在一个元素  </span></span><br><span class=\"line\">            size = <span class=\"number\">1</span>;  </span><br><span class=\"line\">            <span class=\"comment\">//修改次数 + 1  </span></span><br><span class=\"line\">            modCount++;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> cmp;     <span class=\"comment\">//cmp表示key排序的返回结果  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; parent;   <span class=\"comment\">//父节点  </span></span><br><span class=\"line\">        <span class=\"comment\">// split comparator and comparable paths  </span></span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> K&gt; cpr = comparator;    <span class=\"comment\">//指定的排序算法  </span></span><br><span class=\"line\">        <span class=\"comment\">//如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cpr != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">                parent = t;      <span class=\"comment\">//parent指向上次循环后的t  </span></span><br><span class=\"line\">                <span class=\"comment\">//比较新增节点的key和当前节点key的大小  </span></span><br><span class=\"line\">                cmp = cpr.compare(key, t.key);  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.left;  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.right;  </span><br><span class=\"line\">                <span class=\"comment\">//cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t.setValue(value);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//如果cpr为空，则采用默认的排序算法进行创建TreeMap集合  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)     <span class=\"comment\">//key值为空抛出异常  </span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">            <span class=\"comment\">/* 下面处理过程和上面一样 */</span>  </span><br><span class=\"line\">            Comparable&lt;? <span class=\"keyword\">super</span> K&gt; k = (Comparable&lt;? <span class=\"keyword\">super</span> K&gt;) key;  </span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;  </span><br><span class=\"line\">                parent = t;  </span><br><span class=\"line\">                cmp = k.compareTo(t.key);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.left;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cmp &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">                    t = t.right;  </span><br><span class=\"line\">                <span class=\"keyword\">else</span>  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t.setValue(value);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//将新增节点当做parent的子节点  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(key, value, parent);  </span><br><span class=\"line\">        <span class=\"comment\">//如果新增节点的key小于parent的key，则当做左子节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">            parent.left = e;  </span><br><span class=\"line\">      <span class=\"comment\">//如果新增节点的key大于parent的key，则当做右子节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            parent.right = e;  </span><br><span class=\"line\">        <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">         *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置  </span></span><br><span class=\"line\"><span class=\"comment\">         *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况  </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        fixAfterInsertion(e);  </span><br><span class=\"line\">        <span class=\"comment\">//TreeMap元素数量 + 1  </span></span><br><span class=\"line\">        size++;  </span><br><span class=\"line\">        <span class=\"comment\">//TreeMap容器修改次数 + 1  </span></span><br><span class=\"line\">        modCount++;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 新增节点后的修复操作 </span></span><br><span class=\"line\"><span class=\"comment\"> * x 表示新增节点 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixAfterInsertion</span><span class=\"params\">(Entry&lt;K,V&gt; x)</span> </span>&#123;  </span><br><span class=\"line\">        x.color = RED;    <span class=\"comment\">//新增节点的颜色为红色  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//循环 直到 x不是根节点，且x的父节点不为红色  </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"keyword\">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//如果X的父节点（P）是其父节点的父节点（G）的左节点  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//获取X的叔节点(U)  </span></span><br><span class=\"line\">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));  </span><br><span class=\"line\">                <span class=\"comment\">//如果X的叔节点（U） 为红色（情况三）  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(y) == RED) &#123;       </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的叔节点（U）设置为黑色  </span></span><br><span class=\"line\">                    setColor(y, BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    x = parentOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"comment\">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;     </span><br><span class=\"line\">                    <span class=\"comment\">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x == rightOf(parentOf(x))) &#123;  </span><br><span class=\"line\">                        <span class=\"comment\">//将X的父节点作为X  </span></span><br><span class=\"line\">                        x = parentOf(x);  </span><br><span class=\"line\">                        <span class=\"comment\">//右旋转  </span></span><br><span class=\"line\">                        rotateLeft(x);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    <span class=\"comment\">//（情况五）  </span></span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    <span class=\"comment\">//以X的父节点的父节点（G）为中心右旋转  </span></span><br><span class=\"line\">                    rotateRight(parentOf(parentOf(x)));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">//如果X的父节点（P）是其父节点的父节点（G）的右节点  </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">//获取X的叔节点（U）  </span></span><br><span class=\"line\">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));  </span><br><span class=\"line\">              <span class=\"comment\">//如果X的叔节点（U） 为红色（情况三）  </span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(y) == RED) &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的叔节点（U）设置为黑色  </span></span><br><span class=\"line\">                    setColor(y, BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    x = parentOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">              <span class=\"comment\">//如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）  </span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                    <span class=\"comment\">//如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）  </span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (x == leftOf(parentOf(x))) &#123;  </span><br><span class=\"line\">                        <span class=\"comment\">//将X的父节点作为X  </span></span><br><span class=\"line\">                        x = parentOf(x);  </span><br><span class=\"line\">                       <span class=\"comment\">//右旋转  </span></span><br><span class=\"line\">                        rotateRight(x);  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    <span class=\"comment\">//（情况五）  </span></span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点（P）设置为黑色  </span></span><br><span class=\"line\">                    setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                    <span class=\"comment\">//将X的父节点的父节点（G）设置红色  </span></span><br><span class=\"line\">                    setColor(parentOf(parentOf(x)), RED);  </span><br><span class=\"line\">                    <span class=\"comment\">//以X的父节点的父节点（G）为中心右旋转  </span></span><br><span class=\"line\">                    rotateLeft(parentOf(parentOf(x)));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">//将根节点G强制设置为黑色  </span></span><br><span class=\"line\">        root.color = BLACK;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p>对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。<br>左旋：rotateLeft()<br>所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left —-&gt; N ,N.left —-&gt; P。</p><p>右旋：rotateRight()<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateLeft</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//获取P的右子节点，其实这里就相当于新增节点N（情况四而言）  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; r = p.right;  </span><br><span class=\"line\">        <span class=\"comment\">//将R的左子树设置为P的右子树  </span></span><br><span class=\"line\">        p.right = r.left;  </span><br><span class=\"line\">        <span class=\"comment\">//若R的左子树不为空，则将P设置为R左子树的父亲  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.left != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            r.left.parent = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将P的父亲设置R的父亲  </span></span><br><span class=\"line\">        r.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P的父亲为空，则将R设置为跟节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = r;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent.left == p)  </span><br><span class=\"line\">            p.parent.left = r;  </span><br><span class=\"line\">        <span class=\"comment\">//否则R设置为P的父节点（G）的右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            p.parent.right = r;  </span><br><span class=\"line\">        <span class=\"comment\">//将P设置为R的左子树  </span></span><br><span class=\"line\">        r.left = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将R设置为P的父节点  </span></span><br><span class=\"line\">        p.parent = r;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所谓右旋转即，P.right —-&gt; G、G.parent —-&gt; P。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rotateRight</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">//将L设置为P的左子树  </span></span><br><span class=\"line\">        Entry&lt;K,V&gt; l = p.left;  </span><br><span class=\"line\">        <span class=\"comment\">//将L的右子树设置为P的左子树  </span></span><br><span class=\"line\">        p.left = l.right;  </span><br><span class=\"line\">        <span class=\"comment\">//若L的右子树不为空，则将P设置L的右子树的父节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l.right != <span class=\"keyword\">null</span>)   </span><br><span class=\"line\">            l.right.parent = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将P的父节点设置为L的父节点  </span></span><br><span class=\"line\">        l.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P的父节点为空，则将L设置根节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = l;  </span><br><span class=\"line\">        <span class=\"comment\">//若P为其父节点的右子树，则将L设置为P的父节点的右子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent.right == p)  </span><br><span class=\"line\">            p.parent.right = l;  </span><br><span class=\"line\">        <span class=\"comment\">//否则将L设置为P的父节点的左子树  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>   </span><br><span class=\"line\">            p.parent.left = l;  </span><br><span class=\"line\">        <span class=\"comment\">//将P设置为L的右子树  </span></span><br><span class=\"line\">        l.right = p;  </span><br><span class=\"line\">        <span class=\"comment\">//将L设置为P的父节点  </span></span><br><span class=\"line\">        p.parent = l;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>着色：setColor()<br>着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;K,V&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setColor</span><span class=\"params\">(Entry&lt;K,V&gt; p, <span class=\"keyword\">boolean</span> c)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        p.color = c;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"TreeMap-delete-方法\"><a href=\"#TreeMap-delete-方法\" class=\"headerlink\" title=\"TreeMap delete()方法\"></a>TreeMap delete()方法</h2><h3 id=\"红黑树删除节点\"><a href=\"#红黑树删除节点\" class=\"headerlink\" title=\"红黑树删除节点\"></a>红黑树删除节点</h3><p>针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。子节点C的规则是：右分支最左边，或者 左分支最右边的。<br><img src=\"/uploads/tree9.png\" alt><br>红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。<br>红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：<br>1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。<br>2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。<br>3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。<br>下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，请时刻牢记红黑树的5点规定：<br>1、每个节点都只能是红色或者黑色<br>2、根节点是黑色<br>3、每个叶节点（NIL节点，空节点）是黑色的。<br>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。<br>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>（注：已经讲三遍了，再不记住我就怀疑你是否适合搞IT了 O(∩_∩)O~）<br>诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：<br>1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。<br>2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。<br><img src=\"/uploads/tree10.png\" alt><br>现在我们就上面提到的三种情况进行分析、处理。<br>情况一、无子节点（红色节点）<br>这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点——-如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。<br>情况二、有一个子节点<br>这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）<br>情况三、有两个子节点<br>这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。<br>1、N的兄弟节点W为红色<br>2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。<br>3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。<br>4、N的兄弟w是黑色的，且w的右孩子时红色的。<br>情况3.1、N的兄弟节点W为红色<br>W为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W、P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1、转变为3.2、3.3、3.4中的一种。如下：<br><img src=\"/uploads/tree11.png\" alt><br>情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。<br>这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下<br><img src=\"/uploads/tree12.png\" alt><br>将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1、3.3、3.4中的一种。<br>情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。<br>针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。<br><img src=\"/uploads/tree13.png\" alt><br>此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.<br>情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。<br>交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。<br><img src=\"/uploads/tree14.png\" alt></p><p>总结<br>个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。情况3.1，是将W旋转将其转成情况2、3、4情况进行处理。而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。情况3.4、右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。<br>通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。</p><p><font color=\"#3366ff\"><strong>TreeMap deleteEntry()方法实现分析</strong></font><br>通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点、删除替代节点。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteEntry</span><span class=\"params\">(Entry&lt;K,V&gt; p)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;      <span class=\"comment\">//修改次数 +1  </span></span><br><span class=\"line\">    size--;          <span class=\"comment\">//元素个数 -1  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 </span></span><br><span class=\"line\"><span class=\"comment\">     * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 </span></span><br><span class=\"line\"><span class=\"comment\">     * ---------------------（1） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p.left != <span class=\"keyword\">null</span> &amp;&amp; p.right != <span class=\"keyword\">null</span>) &#123;    </span><br><span class=\"line\">        Entry&lt;K,V&gt; s = successor(p);  </span><br><span class=\"line\">        p.key = s.key;  </span><br><span class=\"line\">        p.value = s.value;  </span><br><span class=\"line\">        p = s;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代  </span></span><br><span class=\"line\">    Entry&lt;K,V&gt; replacement = (p.left != <span class=\"keyword\">null</span> ? p.left : p.right);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 删除节点，分为上面提到的三种情况 </span></span><br><span class=\"line\"><span class=\"comment\">     * -----------------------（2） </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"comment\">//如果替代节点不为空  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (replacement != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        replacement.parent = p.parent;  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         *replacement来替代P节点 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"comment\">//若P没有父节点，则跟节点直接变成replacement  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            root = replacement;  </span><br><span class=\"line\">        <span class=\"comment\">//如果P为左节点，则用replacement来替代为左节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.left)  </span><br><span class=\"line\">            p.parent.left  = replacement;  </span><br><span class=\"line\">      <span class=\"comment\">//如果P为右节点，则用replacement来替代为右节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">            p.parent.right = replacement;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//同时将P节点从这棵树中剔除掉  </span></span><br><span class=\"line\">        p.left = p.right = p.parent = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 若P为红色直接删除，红黑树保持平衡 </span></span><br><span class=\"line\"><span class=\"comment\">         * 但是若P为黑色，则需要调整红黑树使其保持平衡 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.color == BLACK)  </span><br><span class=\"line\">            fixAfterDeletion(replacement);  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p.parent == <span class=\"keyword\">null</span>) &#123;     <span class=\"comment\">//p没有父节点，表示为P根节点，直接删除即可  </span></span><br><span class=\"line\">        root = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;      <span class=\"comment\">//P节点不存在子节点，直接删除即可  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.color == BLACK)         <span class=\"comment\">//如果P节点的颜色为黑色，对红黑树进行调整  </span></span><br><span class=\"line\">            fixAfterDeletion(p);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">//删除P节点  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.parent != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == p.parent.left)  </span><br><span class=\"line\">                p.parent.left = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p == p.parent.right)  </span><br><span class=\"line\">                p.parent.right = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">            p.parent = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>（1）除是寻找替代节点replacement，其实现方法为successor()。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;K,V&gt; TreeMap.<span class=\"function\">Entry&lt;K,V&gt; <span class=\"title\">successor</span><span class=\"params\">(Entry&lt;K,V&gt; t)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 寻找右子树的最左子树 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (t.right != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; p = t.right;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p.left != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                p = p.left;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;  </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">         * 选择左子树的最右子树 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; p = t.parent;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; ch = t;  </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; ch == p.right) &#123;  </span><br><span class=\"line\">                ch = p;  </span><br><span class=\"line\">                p = p.parent;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>（2）处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：<br>1、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。<br>2、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。<br>3、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。<br>删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixAfterDeletion</span><span class=\"params\">(Entry&lt;K,V&gt; x)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色  </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == leftOf(parentOf(x))) &#123;      <span class=\"comment\">//若X节点为左节点  </span></span><br><span class=\"line\">            <span class=\"comment\">//获取其兄弟节点  </span></span><br><span class=\"line\">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">             * 如果兄弟节点为红色----（情况3.1） </span></span><br><span class=\"line\"><span class=\"comment\">             * 策略：改变W、P的颜色，然后进行一次左旋转 </span></span><br><span class=\"line\"><span class=\"comment\">             */</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(sib) == RED) &#123;       </span><br><span class=\"line\">                setColor(sib, BLACK);       </span><br><span class=\"line\">                setColor(parentOf(x), RED);    </span><br><span class=\"line\">                rotateLeft(parentOf(x));  </span><br><span class=\"line\">                sib = rightOf(parentOf(x));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">             * 若兄弟节点的两个子节点都为黑色----（情况3.2） </span></span><br><span class=\"line\"><span class=\"comment\">             * 策略：将兄弟节点编程红色 </span></span><br><span class=\"line\"><span class=\"comment\">             */</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;  </span><br><span class=\"line\">                colorOf(rightOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                setColor(sib, RED);  </span><br><span class=\"line\">                x = parentOf(x);  </span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                 * 如果兄弟节点只有右子树为黑色----（情况3.3） </span></span><br><span class=\"line\"><span class=\"comment\">                 * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转 </span></span><br><span class=\"line\"><span class=\"comment\">                 * 这时情况会转变为3.4 </span></span><br><span class=\"line\"><span class=\"comment\">                 */</span>  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                    setColor(leftOf(sib), BLACK);  </span><br><span class=\"line\">                    setColor(sib, RED);  </span><br><span class=\"line\">                    rotateRight(sib);  </span><br><span class=\"line\">                    sib = rightOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">                 *----情况3.4 </span></span><br><span class=\"line\"><span class=\"comment\">                 *策略：交换兄弟节点和父节点的颜色， </span></span><br><span class=\"line\"><span class=\"comment\">                 *同时将兄弟节点右子树设置为黑色，最后左旋转 </span></span><br><span class=\"line\"><span class=\"comment\">                 */</span>  </span><br><span class=\"line\">                setColor(sib, colorOf(parentOf(x)));  </span><br><span class=\"line\">                setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                setColor(rightOf(sib), BLACK);  </span><br><span class=\"line\">                rotateLeft(parentOf(x));  </span><br><span class=\"line\">                x = root;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">         * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了 </span></span><br><span class=\"line\"><span class=\"comment\">         */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(sib) == RED) &#123;  </span><br><span class=\"line\">                setColor(sib, BLACK);  </span><br><span class=\"line\">                setColor(parentOf(x), RED);  </span><br><span class=\"line\">                rotateRight(parentOf(x));  </span><br><span class=\"line\">                sib = leftOf(parentOf(x));  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;  </span><br><span class=\"line\">                colorOf(leftOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                setColor(sib, RED);  </span><br><span class=\"line\">                x = parentOf(x);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;  </span><br><span class=\"line\">                    setColor(rightOf(sib), BLACK);  </span><br><span class=\"line\">                    setColor(sib, RED);  </span><br><span class=\"line\">                    rotateLeft(sib);  </span><br><span class=\"line\">                    sib = leftOf(parentOf(x));  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                setColor(sib, colorOf(parentOf(x)));  </span><br><span class=\"line\">                setColor(parentOf(x), BLACK);  </span><br><span class=\"line\">                setColor(leftOf(sib), BLACK);  </span><br><span class=\"line\">                rotateRight(parentOf(x));  </span><br><span class=\"line\">                x = root;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    setColor(x, BLACK);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。<br>五、写在最后<br>这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。同时这篇博文很大篇幅都在阐述红黑树的实现过程，对Java 的TreeMap聊的比较少，但是我认为如果理解了红黑树的实现过程，对TreeMap那是手到擒来，小菜一碟。<br>同时这篇博文我写了四天，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。LZ大二开始学习数据结构，自认为学的不错，现在发现数据结构我还有太多的地方需要学习了，同时也再一次体味了算法的魅力！！！！</p><p>参考资料：</p><p>1、红黑树数据结构剖析：<a href=\"http://www.cnblogs.com/fanzhidongyzby/p/3187912.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</a><br>2、红黑二叉树详解及理论分析 ：<a href=\"http://blog.csdn.net/kartorz/article/details/8865997\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kartorz/article/details/8865997</a><br>3、教你透彻了解红黑树 ：<a href=\"http://blog.csdn.net/v_july_v/article/details/6105630\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/v_july_v/article/details/6105630</a><br>4、经典算法研究系列：五、红黑树算法的实现与剖析 ：<a href=\"http://blog.csdn.net/v_JULY_v/article/details/6109153\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/v_JULY_v/article/details/6109153</a><br>5、示例，红黑树插入和删除过程：<a href=\"http://saturnman.blog.163.com/blog/static/557611201097221570/\" target=\"_blank\" rel=\"noopener\">http://saturnman.blog.163.com/blog/static/557611201097221570/</a><br>6、红黑二叉树详解及理论分析 ：<a href=\"http://blog.csdn.net/kartorz/article/details/8865997\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/kartorz/article/details/8865997</a></p><!-- rebuild by neat -->"},{"title":"Java提高篇（二八）------TreeSet","abbrlink":"7f0141b7","date":"2017-10-24T05:09:58.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/29218799\n\n与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）-----TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。\n## TreeSet定义\n我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。\n<!-- more -->\n```java\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable\n```\n同时在TreeSet中定义了如下几个变量。\n```java\n    private transient NavigableMap<E,Object> m;\n            \n    //PRESENT会被当做Map的value与key构建成键值对\n    private static final Object PRESENT = new Object();\n```\n其构造方法：\n\n```java\n    //默认构造方法，根据其元素的自然顺序进行排序\n    public TreeSet() {\n        this(new TreeMap<E,Object>());\n    }\n    \n    //构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。\n    public TreeSet(Comparator<? super E> comparator) {\n            this(new TreeMap<>(comparator));\n    }\n    \n    //构造一个新的空 TreeSet，它根据指定比较器进行排序。\n    public TreeSet(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n    \n    //构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。\n    public TreeSet(SortedSet<E> s) {\n        this(s.comparator());\n        addAll(s);\n    }\n    \n    TreeSet(NavigableMap<E,Object> m) {\n        this.m = m;\n    }\n```\n## TreeSet主要方法\n1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。\n```java\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n```\n2、addAll：将指定 collection 中的所有元素添加到此 set 中。\n```java\n    public  boolean addAll(Collection<? extends E> c) {\n        // Use linear-time version if applicable\n        if (m.size()==0 && c.size() > 0 &&\n            c instanceof SortedSet &&\n            m instanceof TreeMap) {\n            SortedSet<? extends E> set = (SortedSet<? extends E>) c;\n            TreeMap<E,Object> map = (TreeMap<E, Object>) m;\n            Comparator<? super E> cc = (Comparator<? super E>) set.comparator();\n            Comparator<? super E> mc = map.comparator();\n            if (cc==mc || (cc != null && cc.equals(mc))) {\n                map.addAllForTreeSet(set, PRESENT);\n                return true;\n            }\n        }\n        return super.addAll(c);\n    }\n```\n3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n```java\n    public E ceiling(E e) {\n        return m.ceilingKey(e);\n    }\n```\n4、clear：移除此 set 中的所有元素。\n```java\n    public void clear() {\n        m.clear();\n    }\n```\n5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。\n```java\n    public Object clone() {\n        TreeSet<E> clone = null;\n        try {\n            clone = (TreeSet<E>) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n\n        clone.m = new TreeMap<>(m);\n        return clone;\n    }\n```\n6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n```java\n    public Comparator<? super E> comparator() {\n        return m.comparator();\n    }\n```\n7、contains：如果此 set 包含指定的元素，则返回 true。\n```java\n    public boolean contains(Object o) {\n        return m.containsKey(o);\n    }\n```\n8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。\n```java\n    public Iterator<E> descendingIterator() {\n        return m.descendingKeySet().iterator();\n    }\n```\n9、descendingSet：返回此 set 中所包含元素的逆序视图。\n```java\n    public NavigableSet<E> descendingSet() {\n        return new TreeSet<>(m.descendingMap());\n    }\n```\n10、first：返回此 set 中当前第一个（最低）元素。\n```java\n    public E first() {\n        return m.firstKey();\n    }\n```\n11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n```java\n    public E floor(E e) {\n        return m.floorKey(e);\n    }\n```\n12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。\n```java\n    public SortedSet<E> headSet(E toElement) {\n        return headSet(toElement, false);\n    }\n```\n13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n```java\n    public E higher(E e) {\n        return m.higherKey(e);\n    }\n```\n14、isEmpty：如果此 set 不包含任何元素，则返回 true。\n```java\n    public boolean isEmpty() {\n        return m.isEmpty();\n    }\n```\n15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。\n```java\n    public Iterator<E> iterator() {\n        return m.navigableKeySet().iterator();\n    }\n```\n16、last：返回此 set 中当前最后一个（最高）元素。\n```java\n    public E last() {\n        return m.lastKey();\n    }\n```\n17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n```java\n    public E lower(E e) {\n        return m.lowerKey(e);\n    }\n```\n18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。\n```java\n    public E pollFirst() {\n        Map.Entry<E,?> e = m.pollFirstEntry();\n        return (e == null) ? null : e.getKey();\n    }\n```\n19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。\n```java\n    public E pollLast() {\n        Map.Entry<E,?> e = m.pollLastEntry();\n        return (e == null) ? null : e.getKey();\n    }\n```\n20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。\n```java\n    public boolean remove(Object o) {\n        return m.remove(o)==PRESENT;\n    }\n```\n21、size：返回 set 中的元素数（set 的容量）。\n```java\n    public int size() {\n        return m.size();\n    }\n```\n22、subSet：返回此 set 的部分视图\n```java\n    /**\n     * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。\n     */\n     public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,\n             E toElement,   boolean toInclusive) {\n             return new TreeSet<>(m.subMap(fromElement, fromInclusive,\n                  toElement,   toInclusive));\n     }\n     \n     /**\n      * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n      */\n     public SortedSet<E> subSet(E fromElement, E toElement) {\n         return subSet(fromElement, true, toElement, false);\n     }\n```\n23、tailSet：返回此 set 的部分视图\n```java\n    /**\n     * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。\n     */\n    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n        return new TreeSet<>(m.tailMap(fromElement, inclusive));\n    }\n    \n    /**\n     * 返回此 set 的部分视图，其元素大于等于 fromElement。\n     */\n    public SortedSet<E> tailSet(E fromElement) {\n        return tailSet(fromElement, true);\n    }\n```\n## 最后\n由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。","source":"_posts/java-toup27.md","raw":"---\ntitle: Java提高篇（二八）------TreeSet\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 7f0141b7\ndate: 2017-10-24 13:09:58\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/29218799\n\n与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）-----TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。\n## TreeSet定义\n我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。\n<!-- more -->\n```java\npublic class TreeSet<E> extends AbstractSet<E>\n    implements NavigableSet<E>, Cloneable, java.io.Serializable\n```\n同时在TreeSet中定义了如下几个变量。\n```java\n    private transient NavigableMap<E,Object> m;\n            \n    //PRESENT会被当做Map的value与key构建成键值对\n    private static final Object PRESENT = new Object();\n```\n其构造方法：\n\n```java\n    //默认构造方法，根据其元素的自然顺序进行排序\n    public TreeSet() {\n        this(new TreeMap<E,Object>());\n    }\n    \n    //构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。\n    public TreeSet(Comparator<? super E> comparator) {\n            this(new TreeMap<>(comparator));\n    }\n    \n    //构造一个新的空 TreeSet，它根据指定比较器进行排序。\n    public TreeSet(Collection<? extends E> c) {\n        this();\n        addAll(c);\n    }\n    \n    //构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。\n    public TreeSet(SortedSet<E> s) {\n        this(s.comparator());\n        addAll(s);\n    }\n    \n    TreeSet(NavigableMap<E,Object> m) {\n        this.m = m;\n    }\n```\n## TreeSet主要方法\n1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。\n```java\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n```\n2、addAll：将指定 collection 中的所有元素添加到此 set 中。\n```java\n    public  boolean addAll(Collection<? extends E> c) {\n        // Use linear-time version if applicable\n        if (m.size()==0 && c.size() > 0 &&\n            c instanceof SortedSet &&\n            m instanceof TreeMap) {\n            SortedSet<? extends E> set = (SortedSet<? extends E>) c;\n            TreeMap<E,Object> map = (TreeMap<E, Object>) m;\n            Comparator<? super E> cc = (Comparator<? super E>) set.comparator();\n            Comparator<? super E> mc = map.comparator();\n            if (cc==mc || (cc != null && cc.equals(mc))) {\n                map.addAllForTreeSet(set, PRESENT);\n                return true;\n            }\n        }\n        return super.addAll(c);\n    }\n```\n3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n```java\n    public E ceiling(E e) {\n        return m.ceilingKey(e);\n    }\n```\n4、clear：移除此 set 中的所有元素。\n```java\n    public void clear() {\n        m.clear();\n    }\n```\n5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。\n```java\n    public Object clone() {\n        TreeSet<E> clone = null;\n        try {\n            clone = (TreeSet<E>) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n\n        clone.m = new TreeMap<>(m);\n        return clone;\n    }\n```\n6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。\n```java\n    public Comparator<? super E> comparator() {\n        return m.comparator();\n    }\n```\n7、contains：如果此 set 包含指定的元素，则返回 true。\n```java\n    public boolean contains(Object o) {\n        return m.containsKey(o);\n    }\n```\n8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。\n```java\n    public Iterator<E> descendingIterator() {\n        return m.descendingKeySet().iterator();\n    }\n```\n9、descendingSet：返回此 set 中所包含元素的逆序视图。\n```java\n    public NavigableSet<E> descendingSet() {\n        return new TreeSet<>(m.descendingMap());\n    }\n```\n10、first：返回此 set 中当前第一个（最低）元素。\n```java\n    public E first() {\n        return m.firstKey();\n    }\n```\n11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n```java\n    public E floor(E e) {\n        return m.floorKey(e);\n    }\n```\n12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。\n```java\n    public SortedSet<E> headSet(E toElement) {\n        return headSet(toElement, false);\n    }\n```\n13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。\n```java\n    public E higher(E e) {\n        return m.higherKey(e);\n    }\n```\n14、isEmpty：如果此 set 不包含任何元素，则返回 true。\n```java\n    public boolean isEmpty() {\n        return m.isEmpty();\n    }\n```\n15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。\n```java\n    public Iterator<E> iterator() {\n        return m.navigableKeySet().iterator();\n    }\n```\n16、last：返回此 set 中当前最后一个（最高）元素。\n```java\n    public E last() {\n        return m.lastKey();\n    }\n```\n17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。\n```java\n    public E lower(E e) {\n        return m.lowerKey(e);\n    }\n```\n18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。\n```java\n    public E pollFirst() {\n        Map.Entry<E,?> e = m.pollFirstEntry();\n        return (e == null) ? null : e.getKey();\n    }\n```\n19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。\n```java\n    public E pollLast() {\n        Map.Entry<E,?> e = m.pollLastEntry();\n        return (e == null) ? null : e.getKey();\n    }\n```\n20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。\n```java\n    public boolean remove(Object o) {\n        return m.remove(o)==PRESENT;\n    }\n```\n21、size：返回 set 中的元素数（set 的容量）。\n```java\n    public int size() {\n        return m.size();\n    }\n```\n22、subSet：返回此 set 的部分视图\n```java\n    /**\n     * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。\n     */\n     public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,\n             E toElement,   boolean toInclusive) {\n             return new TreeSet<>(m.subMap(fromElement, fromInclusive,\n                  toElement,   toInclusive));\n     }\n     \n     /**\n      * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。\n      */\n     public SortedSet<E> subSet(E fromElement, E toElement) {\n         return subSet(fromElement, true, toElement, false);\n     }\n```\n23、tailSet：返回此 set 的部分视图\n```java\n    /**\n     * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。\n     */\n    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n        return new TreeSet<>(m.tailMap(fromElement, inclusive));\n    }\n    \n    /**\n     * 返回此 set 的部分视图，其元素大于等于 fromElement。\n     */\n    public SortedSet<E> tailSet(E fromElement) {\n        return tailSet(fromElement, true);\n    }\n```\n## 最后\n由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。","slug":"java-toup27","published":1,"updated":"2019-09-03T03:40:46.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketew00280vfagvk4v0nf","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/29218799\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/29218799</a></p></blockquote><p>与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）——-TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。</p><h2 id=\"TreeSet定义\"><a href=\"#TreeSet定义\" class=\"headerlink\" title=\"TreeSet定义\"></a>TreeSet定义</h2><p>我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeSet</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">NavigableSet</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>同时在TreeSet中定义了如下几个变量。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//PRESENT会被当做Map的value与key构建成键值对</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure><p></p><p>其构造方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造方法，根据其元素的自然顺序进行排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个新的空 TreeSet，它根据指定比较器进行排序。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(s.comparator());</span><br><span class=\"line\">    addAll(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.m = m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"TreeSet主要方法\"><a href=\"#TreeSet主要方法\" class=\"headerlink\" title=\"TreeSet主要方法\"></a>TreeSet主要方法</h2><p>1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>2、addAll：将指定 collection 中的所有元素添加到此 set 中。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use linear-time version if applicable</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.size()==<span class=\"number\">0</span> &amp;&amp; c.size() &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        c <span class=\"keyword\">instanceof</span> SortedSet &amp;&amp;</span><br><span class=\"line\">        m <span class=\"keyword\">instanceof</span> TreeMap) &#123;</span><br><span class=\"line\">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class=\"line\">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> E&gt; cc = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) set.comparator();</span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> E&gt; mc = map.comparator();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cc==mc || (cc != <span class=\"keyword\">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class=\"line\">            map.addAllForTreeSet(set, PRESENT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">ceiling</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.ceilingKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>4、clear：移除此 set 中的所有元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    m.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    TreeSet&lt;E&gt; clone = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        clone = (TreeSet&lt;E&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    clone.m = <span class=\"keyword\">new</span> TreeMap&lt;&gt;(m);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.comparator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>7、contains：如果此 set 包含指定的元素，则返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.containsKey(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">descendingIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.descendingKeySet().iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>9、descendingSet：返回此 set 中所包含元素的逆序视图。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">descendingSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>10、first：返回此 set 中当前第一个（最低）元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">first</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.firstKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">floor</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.floorKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">headSet</span><span class=\"params\">(E toElement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> headSet(toElement, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">higher</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.higherKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>14、isEmpty：如果此 set 不包含任何元素，则返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.isEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.navigableKeySet().iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>16、last：返回此 set 中当前最后一个（最高）元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">last</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.lastKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">lower</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.lowerKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : e.getKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : e.getKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.remove(o)==PRESENT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>21、size：返回 set 中的元素数（set 的容量）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>22、subSet：返回此 set 的部分视图<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">subSet</span><span class=\"params\">(E fromElement, <span class=\"keyword\">boolean</span> fromInclusive,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         E toElement,   <span class=\"keyword\">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class=\"line\">              toElement,   toInclusive));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">subSet</span><span class=\"params\">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> subSet(fromElement, <span class=\"keyword\">true</span>, toElement, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>23、tailSet：返回此 set 的部分视图<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">tailSet</span><span class=\"params\">(E fromElement, <span class=\"keyword\">boolean</span> inclusive)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素大于等于 fromElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">tailSet</span><span class=\"params\">(E fromElement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tailSet(fromElement, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。</p><!-- rebuild by neat -->","site":{"data":{}},"length":5884,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/29218799\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/29218799</a></p></blockquote><p>与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）——-TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。</p><h2 id=\"TreeSet定义\"><a href=\"#TreeSet定义\" class=\"headerlink\" title=\"TreeSet定义\"></a>TreeSet定义</h2><p>我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeSet</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSet</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">NavigableSet</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>同时在TreeSet中定义了如下几个变量。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">//PRESENT会被当做Map的value与key构建成键值对</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object PRESENT = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure><p></p><p>其构造方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//默认构造方法，根据其元素的自然顺序进行排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个新的空 TreeSet，它根据指定比较器进行排序。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>();</span><br><span class=\"line\">    addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TreeSet</span><span class=\"params\">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(s.comparator());</span><br><span class=\"line\">    addAll(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.m = m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"TreeSet主要方法\"><a href=\"#TreeSet主要方法\" class=\"headerlink\" title=\"TreeSet主要方法\"></a>TreeSet主要方法</h2><p>1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.put(e, PRESENT)==<span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>2、addAll：将指定 collection 中的所有元素添加到此 set 中。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use linear-time version if applicable</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m.size()==<span class=\"number\">0</span> &amp;&amp; c.size() &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        c <span class=\"keyword\">instanceof</span> SortedSet &amp;&amp;</span><br><span class=\"line\">        m <span class=\"keyword\">instanceof</span> TreeMap) &#123;</span><br><span class=\"line\">        SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;</span><br><span class=\"line\">        TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;</span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> E&gt; cc = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) set.comparator();</span><br><span class=\"line\">        Comparator&lt;? <span class=\"keyword\">super</span> E&gt; mc = map.comparator();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cc==mc || (cc != <span class=\"keyword\">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class=\"line\">            map.addAllForTreeSet(set, PRESENT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.addAll(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">ceiling</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.ceilingKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>4、clear：移除此 set 中的所有元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    m.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    TreeSet&lt;E&gt; clone = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        clone = (TreeSet&lt;E&gt;) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    clone.m = <span class=\"keyword\">new</span> TreeMap&lt;&gt;(m);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.comparator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>7、contains：如果此 set 包含指定的元素，则返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.containsKey(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">descendingIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.descendingKeySet().iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>9、descendingSet：返回此 set 中所包含元素的逆序视图。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">descendingSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.descendingMap());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>10、first：返回此 set 中当前第一个（最低）元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">first</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.firstKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">floor</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.floorKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">headSet</span><span class=\"params\">(E toElement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> headSet(toElement, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">higher</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.higherKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>14、isEmpty：如果此 set 不包含任何元素，则返回 true。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.isEmpty();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.navigableKeySet().iterator();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>16、last：返回此 set 中当前最后一个（最高）元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">last</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.lastKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">lower</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.lowerKey(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : e.getKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">pollLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">null</span> : e.getKey();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.remove(o)==PRESENT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>21、size：返回 set 中的元素数（set 的容量）。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>22、subSet：返回此 set 的部分视图<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">subSet</span><span class=\"params\">(E fromElement, <span class=\"keyword\">boolean</span> fromInclusive,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">         E toElement,   <span class=\"keyword\">boolean</span> toInclusive)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive,</span><br><span class=\"line\">              toElement,   toInclusive));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">subSet</span><span class=\"params\">(E fromElement, E toElement)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> subSet(fromElement, <span class=\"keyword\">true</span>, toElement, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>23、tailSet：返回此 set 的部分视图<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> NavigableSet&lt;E&gt; <span class=\"title\">tailSet</span><span class=\"params\">(E fromElement, <span class=\"keyword\">boolean</span> inclusive)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回此 set 的部分视图，其元素大于等于 fromElement。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SortedSet&lt;E&gt; <span class=\"title\">tailSet</span><span class=\"params\">(E fromElement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tailSet(fromElement, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。</p><!-- rebuild by neat -->"},{"title":"java提高篇（二九）-----Vector","abbrlink":"daef29b5","date":"2017-10-24T05:10:01.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/37520981\n\n## Vector简介\nVector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。\nVector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。\nVector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。\nVector 实现了Cloneable接口，支持clone()方法，可以被克隆。\n<!-- more -->\n```java\n    public class Vector<E>  \n        extends AbstractList<E>  \n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable  \n```\nVector提供了四个构造函数：\n```java\n    /** \n     * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 \n     */  \n     public Vector() {  \n            this(10);  \n     }  \n      \n    /** \n     * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 \n     */  \n    public Vector(Collection<? extends E> c) {  \n        elementData = c.toArray();  \n        elementCount = elementData.length;  \n        // c.toArray might (incorrectly) not return Object[] (see 6260652)  \n        if (elementData.getClass() != Object[].class)  \n            elementData = Arrays.copyOf(elementData, elementCount,  \n                    Object[].class);  \n    }  \n      \n    /** \n     * 使用指定的初始容量和等于零的容量增量构造一个空向量。 \n     */  \n    public Vector(int initialCapacity) {  \n        this(initialCapacity, 0);  \n    }  \n      \n    /** \n     *  使用指定的初始容量和容量增量构造一个空的向量。 \n     */  \n    public Vector(int initialCapacity, int capacityIncrement) {  \n        super();  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+  \n                                               initialCapacity);  \n        this.elementData = new Object[initialCapacity];  \n        this.capacityIncrement = capacityIncrement;  \n    }  \n```\n在成员变量方面，Vector提供了elementData , elementCount， capacityIncrement三个成员变量。其中\nelementData ：\"Object[]类型的数组\"，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10.\nelementCount：Vector 对象中的有效组件数。\ncapacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时>，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。\n同时Vector是线程安全的！\n## 源码解析\n对于源码的解析，LZ在这里只就增加（add）删除（remove）两个方法进行讲解。\n### 增加：add(E e)\nadd(E e)：将指定元素添加到此向量的末尾。\n```java\n    public synchronized boolean add(E e) {  \n        modCount++;       \n        ensureCapacityHelper(elementCount + 1);    //确认容器大小，如果操作容量则扩容操作  \n        elementData[elementCount++] = e;   //将e元素添加至末尾  \n        return true;  \n    } \n```\n\n这个方法相对而言比较简单，具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后将E元素添加到此向量的末尾。\n```java\n    private void ensureCapacityHelper(int minCapacity) {  \n        //如果  \n        if (minCapacity - elementData.length > 0)  \n            grow(minCapacity);  \n    }  \n      \n    /** \n     * 进行扩容操作 \n     * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。 \n     * 新数据数组的大小姜维原来的大小 + capacityIncrement， \n     * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。 \n     */  \n    private void grow(int minCapacity) {  \n        int oldCapacity = elementData.length;     //当前容器大小  \n        /* \n         * 新容器大小 \n         * 若容量增量系数(capacityIncrement) > 0，则将容器大小增加到capacityIncrement \n         * 否则将容量增加一倍 \n         */  \n        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?  \n                                         capacityIncrement : oldCapacity);  \n          \n        if (newCapacity - minCapacity < 0)  \n            newCapacity = minCapacity;  \n          \n        if (newCapacity - MAX_ARRAY_SIZE > 0)  \n            newCapacity = hugeCapacity(minCapacity);  \n          \n        elementData = Arrays.copyOf(elementData, newCapacity);  \n    }  \n      \n    /** \n     * 判断是否超出最大范围 \n     * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; \n     */  \n    private static int hugeCapacity(int minCapacity) {  \n        if (minCapacity < 0)  \n            throw new OutOfMemoryError();  \n        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;  \n    }  \n```\n对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement <= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。\n### remove(Object o)\n```java\n    /** \n     * 从Vector容器中移除指定元素E \n     */  \n    public boolean remove(Object o) {  \n        return removeElement(o);  \n    }  \n  \n    public synchronized boolean removeElement(Object obj) {  \n        modCount++;  \n        int i = indexOf(obj);   //计算obj在Vector容器中位置  \n        if (i >= 0) {  \n            removeElementAt(i);   //移除  \n            return true;  \n        }  \n        return false;  \n    }  \n      \n    public synchronized void removeElementAt(int index) {  \n        modCount++;     //修改次数+1  \n        if (index >= elementCount) {   //删除位置大于容器有效大小  \n            throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);  \n        }  \n        else if (index < 0) {    //位置小于 < 0  \n            throw new ArrayIndexOutOfBoundsException(index);  \n        }  \n        int j = elementCount - index - 1;  \n        if (j > 0) {     \n            //从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。  \n            //也就是数组元素从j位置往前移  \n            System.arraycopy(elementData, index + 1, elementData, index, j);  \n        }  \n        elementCount--;   //容器中有效组件个数 - 1  \n        elementData[elementCount] = null;    //将向量的末尾位置设置为null  \n    }  \n```\n因为Vector底层是使用数组实现的，所以它的操作都是对数组进行操作，只不过其是可以随着元素的增加而动态的改变容量大小，其实现方法是是使用Arrays.copyOf方法将旧数据拷贝到一个新的大容量数组中。Vector的整个内部实现都比较简单，这里就不在重述了。\n## Vector遍历\nVector支持4种遍历方式。\n### 随机访问\n因为Vector实现了RandmoAccess接口，可以通过下标来进行随机访问。\n```java\n    for(int i = 0 ; i < vec.size() ; i++){  \n        value = vec.get(i);  \n    }  \n```\n### 迭代器\n```java\n    Iterator it = vec.iterator();  \n    while(it.hasNext()){  \n        value = it.next();  \n        //do something  \n    }  \n```\n### for循环\n```java\n    for(Integer value:vec){  \n        //do something  \n    }  \n```\n### Enumeration循环\n```java\n    Vector vec = new Vector<>();  \n    Enumeration enu = vec.elements();  \n    while (enu.hasMoreElements()) {  \n        value = (Integer)enu.nextElement();  \n    }  \n```","source":"_posts/java-toup28.md","raw":"---\ntitle: java提高篇（二九）-----Vector\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: daef29b5\ndate: 2017-10-24 13:10:01\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/37520981\n\n## Vector简介\nVector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。\nVector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。\nVector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。\nVector 实现了Cloneable接口，支持clone()方法，可以被克隆。\n<!-- more -->\n```java\n    public class Vector<E>  \n        extends AbstractList<E>  \n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable  \n```\nVector提供了四个构造函数：\n```java\n    /** \n     * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 \n     */  \n     public Vector() {  \n            this(10);  \n     }  \n      \n    /** \n     * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 \n     */  \n    public Vector(Collection<? extends E> c) {  \n        elementData = c.toArray();  \n        elementCount = elementData.length;  \n        // c.toArray might (incorrectly) not return Object[] (see 6260652)  \n        if (elementData.getClass() != Object[].class)  \n            elementData = Arrays.copyOf(elementData, elementCount,  \n                    Object[].class);  \n    }  \n      \n    /** \n     * 使用指定的初始容量和等于零的容量增量构造一个空向量。 \n     */  \n    public Vector(int initialCapacity) {  \n        this(initialCapacity, 0);  \n    }  \n      \n    /** \n     *  使用指定的初始容量和容量增量构造一个空的向量。 \n     */  \n    public Vector(int initialCapacity, int capacityIncrement) {  \n        super();  \n        if (initialCapacity < 0)  \n            throw new IllegalArgumentException(\"Illegal Capacity: \"+  \n                                               initialCapacity);  \n        this.elementData = new Object[initialCapacity];  \n        this.capacityIncrement = capacityIncrement;  \n    }  \n```\n在成员变量方面，Vector提供了elementData , elementCount， capacityIncrement三个成员变量。其中\nelementData ：\"Object[]类型的数组\"，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10.\nelementCount：Vector 对象中的有效组件数。\ncapacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时>，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。\n同时Vector是线程安全的！\n## 源码解析\n对于源码的解析，LZ在这里只就增加（add）删除（remove）两个方法进行讲解。\n### 增加：add(E e)\nadd(E e)：将指定元素添加到此向量的末尾。\n```java\n    public synchronized boolean add(E e) {  \n        modCount++;       \n        ensureCapacityHelper(elementCount + 1);    //确认容器大小，如果操作容量则扩容操作  \n        elementData[elementCount++] = e;   //将e元素添加至末尾  \n        return true;  \n    } \n```\n\n这个方法相对而言比较简单，具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后将E元素添加到此向量的末尾。\n```java\n    private void ensureCapacityHelper(int minCapacity) {  \n        //如果  \n        if (minCapacity - elementData.length > 0)  \n            grow(minCapacity);  \n    }  \n      \n    /** \n     * 进行扩容操作 \n     * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。 \n     * 新数据数组的大小姜维原来的大小 + capacityIncrement， \n     * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。 \n     */  \n    private void grow(int minCapacity) {  \n        int oldCapacity = elementData.length;     //当前容器大小  \n        /* \n         * 新容器大小 \n         * 若容量增量系数(capacityIncrement) > 0，则将容器大小增加到capacityIncrement \n         * 否则将容量增加一倍 \n         */  \n        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?  \n                                         capacityIncrement : oldCapacity);  \n          \n        if (newCapacity - minCapacity < 0)  \n            newCapacity = minCapacity;  \n          \n        if (newCapacity - MAX_ARRAY_SIZE > 0)  \n            newCapacity = hugeCapacity(minCapacity);  \n          \n        elementData = Arrays.copyOf(elementData, newCapacity);  \n    }  \n      \n    /** \n     * 判断是否超出最大范围 \n     * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; \n     */  \n    private static int hugeCapacity(int minCapacity) {  \n        if (minCapacity < 0)  \n            throw new OutOfMemoryError();  \n        return (minCapacity > MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;  \n    }  \n```\n对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement <= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。\n### remove(Object o)\n```java\n    /** \n     * 从Vector容器中移除指定元素E \n     */  \n    public boolean remove(Object o) {  \n        return removeElement(o);  \n    }  \n  \n    public synchronized boolean removeElement(Object obj) {  \n        modCount++;  \n        int i = indexOf(obj);   //计算obj在Vector容器中位置  \n        if (i >= 0) {  \n            removeElementAt(i);   //移除  \n            return true;  \n        }  \n        return false;  \n    }  \n      \n    public synchronized void removeElementAt(int index) {  \n        modCount++;     //修改次数+1  \n        if (index >= elementCount) {   //删除位置大于容器有效大小  \n            throw new ArrayIndexOutOfBoundsException(index + \" >= \" + elementCount);  \n        }  \n        else if (index < 0) {    //位置小于 < 0  \n            throw new ArrayIndexOutOfBoundsException(index);  \n        }  \n        int j = elementCount - index - 1;  \n        if (j > 0) {     \n            //从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。  \n            //也就是数组元素从j位置往前移  \n            System.arraycopy(elementData, index + 1, elementData, index, j);  \n        }  \n        elementCount--;   //容器中有效组件个数 - 1  \n        elementData[elementCount] = null;    //将向量的末尾位置设置为null  \n    }  \n```\n因为Vector底层是使用数组实现的，所以它的操作都是对数组进行操作，只不过其是可以随着元素的增加而动态的改变容量大小，其实现方法是是使用Arrays.copyOf方法将旧数据拷贝到一个新的大容量数组中。Vector的整个内部实现都比较简单，这里就不在重述了。\n## Vector遍历\nVector支持4种遍历方式。\n### 随机访问\n因为Vector实现了RandmoAccess接口，可以通过下标来进行随机访问。\n```java\n    for(int i = 0 ; i < vec.size() ; i++){  \n        value = vec.get(i);  \n    }  \n```\n### 迭代器\n```java\n    Iterator it = vec.iterator();  \n    while(it.hasNext()){  \n        value = it.next();  \n        //do something  \n    }  \n```\n### for循环\n```java\n    for(Integer value:vec){  \n        //do something  \n    }  \n```\n### Enumeration循环\n```java\n    Vector vec = new Vector<>();  \n    Enumeration enu = vec.elements();  \n    while (enu.hasMoreElements()) {  \n        value = (Integer)enu.nextElement();  \n    }  \n```","slug":"java-toup28","published":1,"updated":"2019-09-03T03:40:46.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketex002b0vfag6qgti4o","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37520981\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37520981</a></p></blockquote><h2 id=\"Vector简介\"><a href=\"#Vector简介\" class=\"headerlink\" title=\"Vector简介\"></a>Vector简介</h2><p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。<br>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。<br>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。<br>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>Vector提供了四个构造函数：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    elementData = c.toArray();  </span><br><span class=\"line\">    elementCount = elementData.length;  </span><br><span class=\"line\">    <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)  </span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, elementCount,  </span><br><span class=\"line\">                Object[].class);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用指定的初始容量和等于零的容量增量构造一个空向量。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  使用指定的初始容量和容量增量构造一个空的向量。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">int</span> capacityIncrement)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+  </span><br><span class=\"line\">                                           initialCapacity);  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacityIncrement = capacityIncrement;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在成员变量方面，Vector提供了elementData , elementCount， capacityIncrement三个成员变量。其中<br>elementData ：”Object[]类型的数组”，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10.<br>elementCount：Vector 对象中的有效组件数。<br>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。<br>同时Vector是线程安全的！</p><h2 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h2><p>对于源码的解析，LZ在这里只就增加（add）删除（remove）两个方法进行讲解。</p><h3 id=\"增加：add-E-e\"><a href=\"#增加：add-E-e\" class=\"headerlink\" title=\"增加：add(E e)\"></a>增加：add(E e)</h3><p>add(E e)：将指定元素添加到此向量的末尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;       </span><br><span class=\"line\">    ensureCapacityHelper(elementCount + <span class=\"number\">1</span>);    <span class=\"comment\">//确认容器大小，如果操作容量则扩容操作  </span></span><br><span class=\"line\">    elementData[elementCount++] = e;   <span class=\"comment\">//将e元素添加至末尾  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法相对而言比较简单，具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后将E元素添加到此向量的末尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityHelper</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//如果  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        grow(minCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 进行扩容操作 </span></span><br><span class=\"line\"><span class=\"comment\"> * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。 </span></span><br><span class=\"line\"><span class=\"comment\"> * 新数据数组的大小姜维原来的大小 + capacityIncrement， </span></span><br><span class=\"line\"><span class=\"comment\"> * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;     <span class=\"comment\">//当前容器大小  </span></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 新容器大小 </span></span><br><span class=\"line\"><span class=\"comment\">     * 若容量增量系数(capacityIncrement) &gt; 0，则将容器大小增加到capacityIncrement </span></span><br><span class=\"line\"><span class=\"comment\">     * 否则将容量增加一倍 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class=\"number\">0</span>) ?  </span><br><span class=\"line\">                                     capacityIncrement : oldCapacity);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        newCapacity = minCapacity;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否超出最大范围 </span></span><br><span class=\"line\"><span class=\"comment\"> * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement &lt;= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。</p><h3 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 从Vector容器中移除指定元素E </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeElement(o);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeElement</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexOf(obj);   <span class=\"comment\">//计算obj在Vector容器中位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        removeElementAt(i);   <span class=\"comment\">//移除  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">removeElementAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;     <span class=\"comment\">//修改次数+1  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= elementCount) &#123;   <span class=\"comment\">//删除位置大于容器有效大小  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index + <span class=\"string\">\" &gt;= \"</span> + elementCount);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">//位置小于 &lt; 0  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = elementCount - index - <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>) &#123;     </span><br><span class=\"line\">        <span class=\"comment\">//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。  </span></span><br><span class=\"line\">        <span class=\"comment\">//也就是数组元素从j位置往前移  </span></span><br><span class=\"line\">        System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index, j);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    elementCount--;   <span class=\"comment\">//容器中有效组件个数 - 1  </span></span><br><span class=\"line\">    elementData[elementCount] = <span class=\"keyword\">null</span>;    <span class=\"comment\">//将向量的末尾位置设置为null  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>因为Vector底层是使用数组实现的，所以它的操作都是对数组进行操作，只不过其是可以随着元素的增加而动态的改变容量大小，其实现方法是是使用Arrays.copyOf方法将旧数据拷贝到一个新的大容量数组中。Vector的整个内部实现都比较简单，这里就不在重述了。</p><h2 id=\"Vector遍历\"><a href=\"#Vector遍历\" class=\"headerlink\" title=\"Vector遍历\"></a>Vector遍历</h2><p>Vector支持4种遍历方式。</p><h3 id=\"随机访问\"><a href=\"#随机访问\" class=\"headerlink\" title=\"随机访问\"></a>随机访问</h3><p>因为Vector实现了RandmoAccess接口，可以通过下标来进行随机访问。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; vec.size() ; i++)&#123;  </span><br><span class=\"line\">    value = vec.get(i);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator it = vec.iterator();  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;  </span><br><span class=\"line\">    value = it.next();  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Integer value:vec)&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"Enumeration循环\"><a href=\"#Enumeration循环\" class=\"headerlink\" title=\"Enumeration循环\"></a>Enumeration循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector vec = <span class=\"keyword\">new</span> Vector&lt;&gt;();  </span><br><span class=\"line\">Enumeration enu = vec.elements();  </span><br><span class=\"line\"><span class=\"keyword\">while</span> (enu.hasMoreElements()) &#123;  </span><br><span class=\"line\">    value = (Integer)enu.nextElement();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","site":{"data":{}},"length":5687,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37520981\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37520981</a></p></blockquote><h2 id=\"Vector简介\"><a href=\"#Vector简介\" class=\"headerlink\" title=\"Vector简介\"></a>Vector简介</h2><p>Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。<br>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。<br>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。<br>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vector</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure><p></p><p>Vector提供了四个构造函数：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>(<span class=\"number\">10</span>);  </span><br><span class=\"line\"> &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class=\"line\">    elementData = c.toArray();  </span><br><span class=\"line\">    elementCount = elementData.length;  </span><br><span class=\"line\">    <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData.getClass() != Object[].class)  </span><br><span class=\"line\">        elementData = Arrays.copyOf(elementData, elementCount,  </span><br><span class=\"line\">                Object[].class);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 使用指定的初始容量和等于零的容量增量构造一个空向量。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"number\">0</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  使用指定的初始容量和容量增量构造一个空的向量。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Vector</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">int</span> capacityIncrement)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">super</span>();  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+  </span><br><span class=\"line\">                                           initialCapacity);  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.capacityIncrement = capacityIncrement;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在成员变量方面，Vector提供了elementData , elementCount， capacityIncrement三个成员变量。其中<br>elementData ：”Object[]类型的数组”，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10.<br>elementCount：Vector 对象中的有效组件数。<br>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。<br>同时Vector是线程安全的！</p><h2 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h2><p>对于源码的解析，LZ在这里只就增加（add）删除（remove）两个方法进行讲解。</p><h3 id=\"增加：add-E-e\"><a href=\"#增加：add-E-e\" class=\"headerlink\" title=\"增加：add(E e)\"></a>增加：add(E e)</h3><p>add(E e)：将指定元素添加到此向量的末尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;       </span><br><span class=\"line\">    ensureCapacityHelper(elementCount + <span class=\"number\">1</span>);    <span class=\"comment\">//确认容器大小，如果操作容量则扩容操作  </span></span><br><span class=\"line\">    elementData[elementCount++] = e;   <span class=\"comment\">//将e元素添加至末尾  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法相对而言比较简单，具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后将E元素添加到此向量的末尾。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityHelper</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//如果  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        grow(minCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 进行扩容操作 </span></span><br><span class=\"line\"><span class=\"comment\"> * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。 </span></span><br><span class=\"line\"><span class=\"comment\"> * 新数据数组的大小姜维原来的大小 + capacityIncrement， </span></span><br><span class=\"line\"><span class=\"comment\"> * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;     <span class=\"comment\">//当前容器大小  </span></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">     * 新容器大小 </span></span><br><span class=\"line\"><span class=\"comment\">     * 若容量增量系数(capacityIncrement) &gt; 0，则将容器大小增加到capacityIncrement </span></span><br><span class=\"line\"><span class=\"comment\">     * 否则将容量增加一倍 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class=\"number\">0</span>) ?  </span><br><span class=\"line\">                                     capacityIncrement : oldCapacity);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        newCapacity = minCapacity;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否超出最大范围 </span></span><br><span class=\"line\"><span class=\"comment\"> * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement &lt;= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。</p><h3 id=\"remove-Object-o\"><a href=\"#remove-Object-o\" class=\"headerlink\" title=\"remove(Object o)\"></a>remove(Object o)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 从Vector容器中移除指定元素E </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> removeElement(o);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeElement</span><span class=\"params\">(Object obj)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexOf(obj);   <span class=\"comment\">//计算obj在Vector容器中位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        removeElementAt(i);   <span class=\"comment\">//移除  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">removeElementAt</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;     <span class=\"comment\">//修改次数+1  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= elementCount) &#123;   <span class=\"comment\">//删除位置大于容器有效大小  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index + <span class=\"string\">\" &gt;= \"</span> + elementCount);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;    <span class=\"comment\">//位置小于 &lt; 0  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = elementCount - index - <span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &gt; <span class=\"number\">0</span>) &#123;     </span><br><span class=\"line\">        <span class=\"comment\">//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。  </span></span><br><span class=\"line\">        <span class=\"comment\">//也就是数组元素从j位置往前移  </span></span><br><span class=\"line\">        System.arraycopy(elementData, index + <span class=\"number\">1</span>, elementData, index, j);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    elementCount--;   <span class=\"comment\">//容器中有效组件个数 - 1  </span></span><br><span class=\"line\">    elementData[elementCount] = <span class=\"keyword\">null</span>;    <span class=\"comment\">//将向量的末尾位置设置为null  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>因为Vector底层是使用数组实现的，所以它的操作都是对数组进行操作，只不过其是可以随着元素的增加而动态的改变容量大小，其实现方法是是使用Arrays.copyOf方法将旧数据拷贝到一个新的大容量数组中。Vector的整个内部实现都比较简单，这里就不在重述了。</p><h2 id=\"Vector遍历\"><a href=\"#Vector遍历\" class=\"headerlink\" title=\"Vector遍历\"></a>Vector遍历</h2><p>Vector支持4种遍历方式。</p><h3 id=\"随机访问\"><a href=\"#随机访问\" class=\"headerlink\" title=\"随机访问\"></a>随机访问</h3><p>因为Vector实现了RandmoAccess接口，可以通过下标来进行随机访问。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; vec.size() ; i++)&#123;  </span><br><span class=\"line\">    value = vec.get(i);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator it = vec.iterator();  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;  </span><br><span class=\"line\">    value = it.next();  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Integer value:vec)&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"Enumeration循环\"><a href=\"#Enumeration循环\" class=\"headerlink\" title=\"Enumeration循环\"></a>Enumeration循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector vec = <span class=\"keyword\">new</span> Vector&lt;&gt;();  </span><br><span class=\"line\">Enumeration enu = vec.elements();  </span><br><span class=\"line\"><span class=\"keyword\">while</span> (enu.hasMoreElements()) &#123;  </span><br><span class=\"line\">    value = (Integer)enu.nextElement();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->"},{"title":"java提高篇（三十）-----Iterator","abbrlink":"fd665700","date":"2017-10-24T05:10:05.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/37521461\n\n迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。\n```java\n    Iterator iterator = list.iterator();  \n    while(iterator.hasNext()){  \n        String string = iterator.next();  \n        //do something  \n    }  \n```\n<!-- more -->\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：\n对于数组我们是使用下标来进行处理的:\n```java\n    int[] arrays = new int[10];  \n    for(int i = 0 ; i < arrays.length ; i++){  \n       int a = arrays[i];  \n       //do something  \n   } \n```\n\n对于ArrayList是这么处理的:\n```java\n   List<String> list = new ArrayList<String>();  \n   for(int i = 0 ; i < list.size() ;  i++){  \n      String string = list.get(i);  \n      //do something  \n   }  \n```\n对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送\"向前\"，\"向后\"，\"取当前元素\"的命令，就可以间接遍历整个集合。\n上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。\n## java.util.Iterator\n在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：\n1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。\n2、方法名称得到了改进。\n其接口定义如下：\n```java\n    public interface Iterator {  \n    　　boolean hasNext();  \n    　　Object next();  \n    　　void remove();  \n    }  \n```\n其中：\nObject next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型\nboolean hasNext()：判断容器内是否还有可供访问的元素\nvoid remove()：删除迭代器刚越过的元素\n对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：\n```java\nfor(Iterator it = c.iterator(); it.hasNext(); ) {  \n　　Object o = it.next();  \n　　 //do something  \n}  \n```\n前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。\n## 各个集合的Iterator的实现\n下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。\n### ArrayList的Iterator实现\n在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：\n```java\nprivate class Itr implements Iterator<E> {  \n    //do something  \n}  \n```\n\n而ArrayList的iterator()方法实现：\n```java\n    public Iterator<E> iterator() {  \n        return new Itr();  \n    }  \n```\n所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：\n在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置\n```java\nint cursor;               \nint lastRet = -1;       \nint expectedModCount = modCount;  \n```\n\n从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。\n```java\npublic boolean hasNext() {  \n    return cursor != size;  \n} \n```\n\n对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可，\n```java\n        public E next() {  \n            checkForComodification();  \n            int i = cursor;    //记录索引位置  \n            if (i >= size)    //如果获取元素大于集合元素个数，则抛出异常  \n                throw new NoSuchElementException();  \n            Object[] elementData = ArrayList.this.elementData;  \n            if (i >= elementData.length)  \n                throw new ConcurrentModificationException();  \n            cursor = i + 1;      //cursor + 1  \n            return (E) elementData[lastRet = i];  //lastRet + 1 且返回cursor处元素  \n        }  \n```\ncheckForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。在java提高篇（二一）-----ArrayList中已经阐述了。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。\n```java\nfinal void checkForComodification() {  \n     if (modCount != expectedModCount)  \n         throw new ConcurrentModificationException();  \n }\n ```\n\n对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。\n```java\n        public void remove() {  \n            if (lastRet < 0)  \n                throw new IllegalStateException();  \n            checkForComodification();  \n  \n            try {  \n                ArrayList.this.remove(lastRet);  \n                cursor = lastRet;  \n                lastRet = -1;  \n                expectedModCount = modCount;  \n            } catch (IndexOutOfBoundsException ex) {  \n                throw new ConcurrentModificationException();  \n            }  \n        }  \n```\n这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！","source":"_posts/java-toup29.md","raw":"---\ntitle: java提高篇（三十）-----Iterator\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: fd665700\ndate: 2017-10-24 13:10:05\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/37521461\n\n迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。\n```java\n    Iterator iterator = list.iterator();  \n    while(iterator.hasNext()){  \n        String string = iterator.next();  \n        //do something  \n    }  \n```\n<!-- more -->\n迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：\n对于数组我们是使用下标来进行处理的:\n```java\n    int[] arrays = new int[10];  \n    for(int i = 0 ; i < arrays.length ; i++){  \n       int a = arrays[i];  \n       //do something  \n   } \n```\n\n对于ArrayList是这么处理的:\n```java\n   List<String> list = new ArrayList<String>();  \n   for(int i = 0 ; i < list.size() ;  i++){  \n      String string = list.get(i);  \n      //do something  \n   }  \n```\n对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送\"向前\"，\"向后\"，\"取当前元素\"的命令，就可以间接遍历整个集合。\n上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。\n## java.util.Iterator\n在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：\n1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。\n2、方法名称得到了改进。\n其接口定义如下：\n```java\n    public interface Iterator {  \n    　　boolean hasNext();  \n    　　Object next();  \n    　　void remove();  \n    }  \n```\n其中：\nObject next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型\nboolean hasNext()：判断容器内是否还有可供访问的元素\nvoid remove()：删除迭代器刚越过的元素\n对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：\n```java\nfor(Iterator it = c.iterator(); it.hasNext(); ) {  \n　　Object o = it.next();  \n　　 //do something  \n}  \n```\n前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。\n## 各个集合的Iterator的实现\n下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。\n### ArrayList的Iterator实现\n在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：\n```java\nprivate class Itr implements Iterator<E> {  \n    //do something  \n}  \n```\n\n而ArrayList的iterator()方法实现：\n```java\n    public Iterator<E> iterator() {  \n        return new Itr();  \n    }  \n```\n所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：\n在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置\n```java\nint cursor;               \nint lastRet = -1;       \nint expectedModCount = modCount;  \n```\n\n从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。\n```java\npublic boolean hasNext() {  \n    return cursor != size;  \n} \n```\n\n对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可，\n```java\n        public E next() {  \n            checkForComodification();  \n            int i = cursor;    //记录索引位置  \n            if (i >= size)    //如果获取元素大于集合元素个数，则抛出异常  \n                throw new NoSuchElementException();  \n            Object[] elementData = ArrayList.this.elementData;  \n            if (i >= elementData.length)  \n                throw new ConcurrentModificationException();  \n            cursor = i + 1;      //cursor + 1  \n            return (E) elementData[lastRet = i];  //lastRet + 1 且返回cursor处元素  \n        }  \n```\ncheckForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。在java提高篇（二一）-----ArrayList中已经阐述了。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。\n```java\nfinal void checkForComodification() {  \n     if (modCount != expectedModCount)  \n         throw new ConcurrentModificationException();  \n }\n ```\n\n对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。\n```java\n        public void remove() {  \n            if (lastRet < 0)  \n                throw new IllegalStateException();  \n            checkForComodification();  \n  \n            try {  \n                ArrayList.this.remove(lastRet);  \n                cursor = lastRet;  \n                lastRet = -1;  \n                expectedModCount = modCount;  \n            } catch (IndexOutOfBoundsException ex) {  \n                throw new ConcurrentModificationException();  \n            }  \n        }  \n```\n这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！","slug":"java-toup29","published":1,"updated":"2019-09-03T03:40:46.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketf0002f0vfahuyv4say","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37521461\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37521461</a></p></blockquote><p>迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator iterator = list.iterator();  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;  </span><br><span class=\"line\">    String string = iterator.next();  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><a id=\"more\"></a><p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：<br>对于数组我们是使用下标来进行处理的:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">int</span>[] arrays = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; arrays.length ; i++)&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = arrays[i];  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于ArrayList是这么处理的:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; list.size() ;  i++)&#123;  </span><br><span class=\"line\">   String string = list.get(i);  </span><br><span class=\"line\">   <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。<br>上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。</p><h2 id=\"java-util-Iterator\"><a href=\"#java-util-Iterator\" class=\"headerlink\" title=\"java.util.Iterator\"></a>java.util.Iterator</h2><p>在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：<br>1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。<br>2、方法名称得到了改进。<br>其接口定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span> </span>&#123;  </span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">　　<span class=\"function\">Object <span class=\"title\">next</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中：<br>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型<br>boolean hasNext()：判断容器内是否还有可供访问的元素<br>void remove()：删除迭代器刚越过的元素<br>对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterator it = c.iterator(); it.hasNext(); ) &#123;  </span><br><span class=\"line\">　　Object o = it.next();  </span><br><span class=\"line\">　　 <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。</p><h2 id=\"各个集合的Iterator的实现\"><a href=\"#各个集合的Iterator的实现\" class=\"headerlink\" title=\"各个集合的Iterator的实现\"></a>各个集合的Iterator的实现</h2><p>下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。</p><h3 id=\"ArrayList的Iterator实现\"><a href=\"#ArrayList的Iterator实现\" class=\"headerlink\" title=\"ArrayList的Iterator实现\"></a>ArrayList的Iterator实现</h3><p>在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而ArrayList的iterator()方法实现：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：<br>在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cursor;               </span><br><span class=\"line\"><span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;       </span><br><span class=\"line\"><span class=\"keyword\">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure><p></p><p>从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor != size;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可，<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cursor;    <span class=\"comment\">//记录索引位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= size)    <span class=\"comment\">//如果获取元素大于集合元素个数，则抛出异常  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();  </span><br><span class=\"line\">    Object[] elementData = ArrayList.<span class=\"keyword\">this</span>.elementData;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= elementData.length)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    cursor = i + <span class=\"number\">1</span>;      <span class=\"comment\">//cursor + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[lastRet = i];  <span class=\"comment\">//lastRet + 1 且返回cursor处元素  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。在java提高篇（二一）——-ArrayList中已经阐述了。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (modCount != expectedModCount)  </span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.remove(lastRet);  </span><br><span class=\"line\">        cursor = lastRet;  </span><br><span class=\"line\">        lastRet = -<span class=\"number\">1</span>;  </span><br><span class=\"line\">        expectedModCount = modCount;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！</p><!-- rebuild by neat -->","site":{"data":{}},"length":4305,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37521461\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37521461</a></p></blockquote><p>迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator iterator = list.iterator();  </span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;  </span><br><span class=\"line\">    String string = iterator.next();  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p>","more":"<p>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：<br>对于数组我们是使用下标来进行处理的:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">int</span>[] arrays = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];  </span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; arrays.length ; i++)&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = arrays[i];  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于ArrayList是这么处理的:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();  </span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; list.size() ;  i++)&#123;  </span><br><span class=\"line\">   String string = list.get(i);  </span><br><span class=\"line\">   <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送”向前”，”向后”，”取当前元素”的命令，就可以间接遍历整个集合。<br>上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。</p><h2 id=\"java-util-Iterator\"><a href=\"#java-util-Iterator\" class=\"headerlink\" title=\"java.util.Iterator\"></a>java.util.Iterator</h2><p>在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同：<br>1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。<br>2、方法名称得到了改进。<br>其接口定义如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span> </span>&#123;  </span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">　　<span class=\"function\">Object <span class=\"title\">next</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中：<br>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型<br>boolean hasNext()：判断容器内是否还有可供访问的元素<br>void remove()：删除迭代器刚越过的元素<br>对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Iterator it = c.iterator(); it.hasNext(); ) &#123;  </span><br><span class=\"line\">　　Object o = it.next();  </span><br><span class=\"line\">　　 <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。下面就ArrayList的源码进行分析分析。</p><h2 id=\"各个集合的Iterator的实现\"><a href=\"#各个集合的Iterator的实现\" class=\"headerlink\" title=\"各个集合的Iterator的实现\"></a>各个集合的Iterator的实现</h2><p>下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。</p><h3 id=\"ArrayList的Iterator实现\"><a href=\"#ArrayList的Iterator实现\" class=\"headerlink\" title=\"ArrayList的Iterator实现\"></a>ArrayList的Iterator实现</h3><p>在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//do something  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而ArrayList的iterator()方法实现：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：<br>在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> cursor;               </span><br><span class=\"line\"><span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;       </span><br><span class=\"line\"><span class=\"keyword\">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure><p></p><p>从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> cursor != size;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可，<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = cursor;    <span class=\"comment\">//记录索引位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= size)    <span class=\"comment\">//如果获取元素大于集合元素个数，则抛出异常  </span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();  </span><br><span class=\"line\">    Object[] elementData = ArrayList.<span class=\"keyword\">this</span>.elementData;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= elementData.length)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    cursor = i + <span class=\"number\">1</span>;      <span class=\"comment\">//cursor + 1  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (E) elementData[lastRet = i];  <span class=\"comment\">//lastRet + 1 且返回cursor处元素  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。在java提高篇（二一）——-ArrayList中已经阐述了。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">     <span class=\"keyword\">if</span> (modCount != expectedModCount)  </span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure><p></p><p>对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.remove(lastRet);  </span><br><span class=\"line\">        cursor = lastRet;  </span><br><span class=\"line\">        lastRet = -<span class=\"number\">1</span>;  </span><br><span class=\"line\">        expectedModCount = modCount;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！</p><!-- rebuild by neat -->"},{"title":"java提高篇（二）-----理解java的三大特性之继承","abbrlink":"3bc9495a","date":"2017-10-23T02:54:46.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12785831](http://blog.csdn.net/chenssy/article/details/12785831)\n\n在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一---继承。\n\n## 继承\n在讲解之前我们先看一个例子，该例子是前篇博文（[java提高篇-----理解java的三大特性之封装](https://itqhy.github.io/2017/10/21/java-toup2/)）的。\n![](/uploads/java3-1.png) \n\n<!-- more -->\n\n 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？**利用继承！！**\n首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。\n从上面我们就可以基本了解了继承的概念了，**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。\n![](/uploads/java3-2.png) \n 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。\n继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。\n实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。\n诚然，**继承定义了类如何相互关联，共享特性**。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。\n同时在使用继承时需要记住三句话：\n\n         1、子类拥有父类非private的属性和方法。\n         2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n         3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。\n诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。\n## 构造器\n 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的---构造器。**对于构造器而言，它只能够被调用，而不能被继承**。 调用父类的构造方法我们使用super()即可。\n对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(){  \n            System.out.println(\"Person Constrctor...\");  \n        }  \n    }  \n  \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n  \nOutput:  \nPerson Constrctor...  \nHusband Constructor... \n```\n通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。\n但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(String name){  \n            System.out.println(\"Person Constrctor-----\" + name);  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            super(\"chenssy\");  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n    \n    Output:  \n    Person Constrctor-----chenssy  \n    Husband Constructor... \n```\n 所以综上所述：**对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。**\n## protected关键字\n private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。    \n**对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。**\n```java\n    public class Person {  \n        private String name;  \n        private int age;  \n        private String sex;  \n    \n        protected String getName() {  \n            return name;  \n        }  \n    \n        protected void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public String toString(){  \n            return \"this name is \" + name;  \n        }  \n        \n        /** 省略其他setter、getter方法 **/  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        public  String toString(){  \n            setName(\"chenssy\");    //调用父类的setName();  \n            return  super.toString();    //调用父类的toString()方法  \n        }  \n    \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            \n            System.out.println(husband.toString());  \n        }  \n    }  \n    \n    Output：  \n    this name is chenssy  \n```\n从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。\n诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是**将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限**。\n## 向上转型\n在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：\n```java\n    public class Person {  \n        public void display(){  \n            System.out.println(\"Play Person...\");  \n        }  \n        \n        static void display(Person person){  \n            person.display();  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            Person.display(husband);      //向上转型  \n        }  \n    }  \n```\n在这我们通过Person.display(husband)。这句话可以看出husband是person类型。\n将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。\n## 谨慎继承\n上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。\n首先我们需要明确，继承存在如下缺陷：\n\n         1、父类变，子类就必须变。\n         2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n         3、继承是一种强耦合关系。\n 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。\n      <font color=\"red\">**慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！**</font>","source":"_posts/java-toup3.md","raw":"---\ntitle: java提高篇（二）-----理解java的三大特性之继承\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 3bc9495a\ndate: 2017-10-23 10:54:46\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12785831](http://blog.csdn.net/chenssy/article/details/12785831)\n\n在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一---继承。\n\n## 继承\n在讲解之前我们先看一个例子，该例子是前篇博文（[java提高篇-----理解java的三大特性之封装](https://itqhy.github.io/2017/10/21/java-toup2/)）的。\n![](/uploads/java3-1.png) \n\n<!-- more -->\n\n 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？**利用继承！！**\n首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。\n从上面我们就可以基本了解了继承的概念了，**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。\n![](/uploads/java3-2.png) \n 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。\n继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。\n实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。\n诚然，**继承定义了类如何相互关联，共享特性**。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。\n同时在使用继承时需要记住三句话：\n\n         1、子类拥有父类非private的属性和方法。\n         2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n         3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。\n诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。\n## 构造器\n 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的---构造器。**对于构造器而言，它只能够被调用，而不能被继承**。 调用父类的构造方法我们使用super()即可。\n对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(){  \n            System.out.println(\"Person Constrctor...\");  \n        }  \n    }  \n  \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n  \nOutput:  \nPerson Constrctor...  \nHusband Constructor... \n```\n通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。\n但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(String name){  \n            System.out.println(\"Person Constrctor-----\" + name);  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            super(\"chenssy\");  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n    \n    Output:  \n    Person Constrctor-----chenssy  \n    Husband Constructor... \n```\n 所以综上所述：**对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。**\n## protected关键字\n private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。    \n**对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。**\n```java\n    public class Person {  \n        private String name;  \n        private int age;  \n        private String sex;  \n    \n        protected String getName() {  \n            return name;  \n        }  \n    \n        protected void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public String toString(){  \n            return \"this name is \" + name;  \n        }  \n        \n        /** 省略其他setter、getter方法 **/  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        public  String toString(){  \n            setName(\"chenssy\");    //调用父类的setName();  \n            return  super.toString();    //调用父类的toString()方法  \n        }  \n    \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            \n            System.out.println(husband.toString());  \n        }  \n    }  \n    \n    Output：  \n    this name is chenssy  \n```\n从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。\n诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是**将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限**。\n## 向上转型\n在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：\n```java\n    public class Person {  \n        public void display(){  \n            System.out.println(\"Play Person...\");  \n        }  \n        \n        static void display(Person person){  \n            person.display();  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            Person.display(husband);      //向上转型  \n        }  \n    }  \n```\n在这我们通过Person.display(husband)。这句话可以看出husband是person类型。\n将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。\n## 谨慎继承\n上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。\n首先我们需要明确，继承存在如下缺陷：\n\n         1、父类变，子类就必须变。\n         2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n         3、继承是一种强耦合关系。\n 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。\n      <font color=\"red\">**慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！**</font>","slug":"java-toup3","published":1,"updated":"2019-09-03T03:40:46.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketf3002j0vfa78a5zqlt","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12785831\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12785831</a></p></blockquote><p>在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—-继承。</p><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在讲解之前我们先看一个例子，该例子是前篇博文（<a href=\"https://itqhy.github.io/2017/10/21/java-toup2/\">java提高篇——-理解java的三大特性之封装</a>）的。<br><img src=\"/uploads/java3-1.png\" alt></p><a id=\"more\"></a><p>从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？<strong>利用继承！！</strong><br>首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。<br>从上面我们就可以基本了解了继承的概念了，<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。<br><img src=\"/uploads/java3-2.png\" alt><br>对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。<br>继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。<br>实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。<br>诚然，<strong>继承定义了类如何相互关联，共享特性</strong>。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br>同时在使用继承时需要记住三句话：</p><pre><code>     1、子类拥有父类非private的属性和方法。\n     2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n     3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n</code></pre><p>综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。<br>诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。</p><h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—-构造器。<strong>对于构造器而言，它只能够被调用，而不能被继承</strong>。 调用父类的构造方法我们使用super()即可。<br>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> String sex;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person()&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Person Constrctor...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        Husband()&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">            Husband husband  = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Person Constrctor...  </span><br><span class=\"line\">Husband Constructor...</span><br></pre></td></tr></table></figure><p>通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。<br>但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String sex;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(String name)&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Person Constrctor-----\"</span> + name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    Husband()&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband  = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Person Constrctor-----chenssy  </span><br><span class=\"line\">Husband Constructor...</span><br></pre></td></tr></table></figure><p>所以综上所述：<strong>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</strong></p><h2 id=\"protected关键字\"><a href=\"#protected关键字\" class=\"headerlink\" title=\"protected关键字\"></a>protected关键字</h2><p>private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。<br><strong>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</strong><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"this name is \"</span> + name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他setter、getter方法 **/</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"chenssy\"</span>);    <span class=\"comment\">//调用父类的setName();  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"keyword\">super</span>.toString();    <span class=\"comment\">//调用父类的toString()方法  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(husband.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Output：  </span><br><span class=\"line\"><span class=\"keyword\">this</span> name is chenssy</span><br></pre></td></tr></table></figure><p></p><p>从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。<br>诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是<strong>将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限</strong>。</p><h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Play Person...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person person)</span></span>&#123;  </span><br><span class=\"line\">        person.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        Person.display(husband);      <span class=\"comment\">//向上转型  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这我们通过Person.display(husband)。这句话可以看出husband是person类型。<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p><h2 id=\"谨慎继承\"><a href=\"#谨慎继承\" class=\"headerlink\" title=\"谨慎继承\"></a>谨慎继承</h2><p>上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。<br>首先我们需要明确，继承存在如下缺陷：</p><pre><code>     1、父类变，子类就必须变。\n     2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n     3、继承是一种强耦合关系。\n</code></pre><p>所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。<br><font color=\"red\"><strong>慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></font></p><!-- rebuild by neat -->","site":{"data":{}},"length":5275,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12785831\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12785831</a></p></blockquote><p>在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—-继承。</p><h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在讲解之前我们先看一个例子，该例子是前篇博文（<a href=\"https://itqhy.github.io/2017/10/21/java-toup2/\">java提高篇——-理解java的三大特性之封装</a>）的。<br><img src=\"/uploads/java3-1.png\" alt></p>","more":"<p>从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？<strong>利用继承！！</strong><br>首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。<br>从上面我们就可以基本了解了继承的概念了，<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。<br><img src=\"/uploads/java3-2.png\" alt><br>对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。<br>继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。<br>实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。<br>诚然，<strong>继承定义了类如何相互关联，共享特性</strong>。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br>同时在使用继承时需要记住三句话：</p><pre><code>     1、子类拥有父类非private的属性和方法。\n     2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n     3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n</code></pre><p>综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。<br>诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。</p><h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p>通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—-构造器。<strong>对于构造器而言，它只能够被调用，而不能被继承</strong>。 调用父类的构造方法我们使用super()即可。<br>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">        <span class=\"keyword\">protected</span> String sex;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person()&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Person Constrctor...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\">    </span><br><span class=\"line\">        Husband()&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">            Husband husband  = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Person Constrctor...  </span><br><span class=\"line\">Husband Constructor...</span><br></pre></td></tr></table></figure><p>通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。<br>但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String sex;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    Person(String name)&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Person Constrctor-----\"</span> + name);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    Husband()&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband  = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Person Constrctor-----chenssy  </span><br><span class=\"line\">Husband Constructor...</span><br></pre></td></tr></table></figure><p>所以综上所述：<strong>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</strong></p><h2 id=\"protected关键字\"><a href=\"#protected关键字\" class=\"headerlink\" title=\"protected关键字\"></a>protected关键字</h2><p>private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。<br><strong>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</strong><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"this name is \"</span> + name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 省略其他setter、getter方法 **/</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"chenssy\"</span>);    <span class=\"comment\">//调用父类的setName();  </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"keyword\">super</span>.toString();    <span class=\"comment\">//调用父类的toString()方法  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(husband.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">Output：  </span><br><span class=\"line\"><span class=\"keyword\">this</span> name is chenssy</span><br></pre></td></tr></table></figure><p></p><p>从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。<br>诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是<strong>将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限</strong>。</p><h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Play Person...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person person)</span></span>&#123;  </span><br><span class=\"line\">        person.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </span><br><span class=\"line\">        Person.display(husband);      <span class=\"comment\">//向上转型  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这我们通过Person.display(husband)。这句话可以看出husband是person类型。<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p><h2 id=\"谨慎继承\"><a href=\"#谨慎继承\" class=\"headerlink\" title=\"谨慎继承\"></a>谨慎继承</h2><p>上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。<br>首先我们需要明确，继承存在如下缺陷：</p><pre><code>     1、父类变，子类就必须变。\n     2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n     3、继承是一种强耦合关系。\n</code></pre><p>所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。<br><font color=\"red\"><strong>慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></font></p><!-- rebuild by neat -->"},{"title":"Java提高篇（三一）-----Stack","abbrlink":"a7e9a612","date":"2017-10-24T05:10:10.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/37756539\n\n 在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：\n\n\nStack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：\n\n\n|           操作\t          |            说明         |\n|:--------------------------|:------------------------|\n|empty()                    |   测试堆栈是否为空。       |\n|peek()                     |查看堆栈顶部的对象，但不从堆栈中移除它。|\n|pop()                      |移除堆栈顶部的对象，并作为此函数的值返回该对象。|\n|push(E item)               |把项压入堆栈顶部。|\n|search(Object o)           |返回对象在堆栈中的位置，以 1 为基数。|\n\n<!-- more -->\n\nStack继承Vector，他对Vector进行了简单的扩展：\n```java\npublic class Stack<E> extends Vector<E>  \n```\n\nStack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单\n```java\n    /** \n     * 构造函数 \n     */  \n    public Stack() {  \n    }  \n  \n    /** \n     *  push函数：将元素存入栈顶 \n     */  \n    public E push(E item) {  \n        // 将元素存入栈顶。  \n        // addElement()的实现在Vector.java中  \n        addElement(item);  \n  \n        return item;  \n    }  \n  \n    /** \n     * pop函数：返回栈顶元素，并将其从栈中删除 \n     */  \n    public synchronized E pop() {  \n        E    obj;  \n        int    len = size();  \n  \n        obj = peek();  \n        // 删除栈顶元素，removeElementAt()的实现在Vector.java中  \n        removeElementAt(len - 1);  \n  \n        return obj;  \n    }  \n  \n    /** \n     * peek函数：返回栈顶元素，不执行删除操作 \n     */  \n    public synchronized E peek() {  \n        int    len = size();  \n  \n        if (len == 0)  \n            throw new EmptyStackException();  \n        // 返回栈顶元素，elementAt()具体实现在Vector.java中  \n        return elementAt(len - 1);  \n    }  \n  \n    /** \n     * 栈是否为空 \n     */  \n    public boolean empty() {  \n        return size() == 0;  \n    }  \n  \n    /** \n     *  查找“元素o”在栈中的位置：由栈底向栈顶方向数 \n     */  \n    public synchronized int search(Object o) {  \n        // 获取元素索引，elementAt()具体实现在Vector.java中  \n        int i = lastIndexOf(o);  \n  \n        if (i >= 0) {  \n            return size() - i;  \n        }  \n        return -1;  \n    } \n```","source":"_posts/java-toup30.md","raw":"---\ntitle: Java提高篇（三一）-----Stack\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: a7e9a612\ndate: 2017-10-24 13:10:10\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/37756539\n\n 在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：\n\n\nStack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：\n\n\n|           操作\t          |            说明         |\n|:--------------------------|:------------------------|\n|empty()                    |   测试堆栈是否为空。       |\n|peek()                     |查看堆栈顶部的对象，但不从堆栈中移除它。|\n|pop()                      |移除堆栈顶部的对象，并作为此函数的值返回该对象。|\n|push(E item)               |把项压入堆栈顶部。|\n|search(Object o)           |返回对象在堆栈中的位置，以 1 为基数。|\n\n<!-- more -->\n\nStack继承Vector，他对Vector进行了简单的扩展：\n```java\npublic class Stack<E> extends Vector<E>  \n```\n\nStack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单\n```java\n    /** \n     * 构造函数 \n     */  \n    public Stack() {  \n    }  \n  \n    /** \n     *  push函数：将元素存入栈顶 \n     */  \n    public E push(E item) {  \n        // 将元素存入栈顶。  \n        // addElement()的实现在Vector.java中  \n        addElement(item);  \n  \n        return item;  \n    }  \n  \n    /** \n     * pop函数：返回栈顶元素，并将其从栈中删除 \n     */  \n    public synchronized E pop() {  \n        E    obj;  \n        int    len = size();  \n  \n        obj = peek();  \n        // 删除栈顶元素，removeElementAt()的实现在Vector.java中  \n        removeElementAt(len - 1);  \n  \n        return obj;  \n    }  \n  \n    /** \n     * peek函数：返回栈顶元素，不执行删除操作 \n     */  \n    public synchronized E peek() {  \n        int    len = size();  \n  \n        if (len == 0)  \n            throw new EmptyStackException();  \n        // 返回栈顶元素，elementAt()具体实现在Vector.java中  \n        return elementAt(len - 1);  \n    }  \n  \n    /** \n     * 栈是否为空 \n     */  \n    public boolean empty() {  \n        return size() == 0;  \n    }  \n  \n    /** \n     *  查找“元素o”在栈中的位置：由栈底向栈顶方向数 \n     */  \n    public synchronized int search(Object o) {  \n        // 获取元素索引，elementAt()具体实现在Vector.java中  \n        int i = lastIndexOf(o);  \n  \n        if (i >= 0) {  \n            return size() - i;  \n        }  \n        return -1;  \n    } \n```","slug":"java-toup30","published":1,"updated":"2019-09-03T03:40:46.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketf5002n0vfa2ekk5qpi","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37756539\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37756539</a></p></blockquote><p>在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：</p><p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\">操作</th><th style=\"text-align:left\">说明</th></tr></thead><tbody><tr><td style=\"text-align:left\">empty()</td><td style=\"text-align:left\">测试堆栈是否为空。</td></tr><tr><td style=\"text-align:left\">peek()</td><td style=\"text-align:left\">查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td style=\"text-align:left\">pop()</td><td style=\"text-align:left\">移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td style=\"text-align:left\">push(E item)</td><td style=\"text-align:left\">把项压入堆栈顶部。</td></tr><tr><td style=\"text-align:left\">search(Object o)</td><td style=\"text-align:left\">返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table></div><a id=\"more\"></a><p>Stack继承Vector，他对Vector进行了简单的扩展：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Vector</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造函数 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Stack</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  push函数：将元素存入栈顶 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">push</span><span class=\"params\">(E item)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 将元素存入栈顶。  </span></span><br><span class=\"line\">    <span class=\"comment\">// addElement()的实现在Vector.java中  </span></span><br><span class=\"line\">    addElement(item);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> item;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * pop函数：返回栈顶元素，并将其从栈中删除 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    E    obj;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>    len = size();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    obj = peek();  </span><br><span class=\"line\">    <span class=\"comment\">// 删除栈顶元素，removeElementAt()的实现在Vector.java中  </span></span><br><span class=\"line\">    removeElementAt(len - <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * peek函数：返回栈顶元素，不执行删除操作 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>    len = size();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EmptyStackException();  </span><br><span class=\"line\">    <span class=\"comment\">// 返回栈顶元素，elementAt()具体实现在Vector.java中  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementAt(len - <span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 栈是否为空 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  查找“元素o”在栈中的位置：由栈底向栈顶方向数 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 获取元素索引，elementAt()具体实现在Vector.java中  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lastIndexOf(o);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() - i;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":1619,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37756539\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37756539</a></p></blockquote><p>在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：</p><p>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：</p><div class=\"table-container\"><table><thead><tr><th style=\"text-align:left\">操作</th><th style=\"text-align:left\">说明</th></tr></thead><tbody><tr><td style=\"text-align:left\">empty()</td><td style=\"text-align:left\">测试堆栈是否为空。</td></tr><tr><td style=\"text-align:left\">peek()</td><td style=\"text-align:left\">查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td style=\"text-align:left\">pop()</td><td style=\"text-align:left\">移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td style=\"text-align:left\">push(E item)</td><td style=\"text-align:left\">把项压入堆栈顶部。</td></tr><tr><td style=\"text-align:left\">search(Object o)</td><td style=\"text-align:left\">返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table></div>","more":"<p>Stack继承Vector，他对Vector进行了简单的扩展：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Vector</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 构造函数 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Stack</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  push函数：将元素存入栈顶 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">push</span><span class=\"params\">(E item)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 将元素存入栈顶。  </span></span><br><span class=\"line\">    <span class=\"comment\">// addElement()的实现在Vector.java中  </span></span><br><span class=\"line\">    addElement(item);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> item;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * pop函数：返回栈顶元素，并将其从栈中删除 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    E    obj;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>    len = size();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    obj = peek();  </span><br><span class=\"line\">    <span class=\"comment\">// 删除栈顶元素，removeElementAt()的实现在Vector.java中  </span></span><br><span class=\"line\">    removeElementAt(len - <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * peek函数：返回栈顶元素，不执行删除操作 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> E <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>    len = size();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EmptyStackException();  </span><br><span class=\"line\">    <span class=\"comment\">// 返回栈顶元素，elementAt()具体实现在Vector.java中  </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> elementAt(len - <span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 栈是否为空 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> *  查找“元素o”在栈中的位置：由栈底向栈顶方向数 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(Object o)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 获取元素索引，elementAt()具体实现在Vector.java中  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = lastIndexOf(o);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() - i;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"Java提高篇（三二）-----List总结","abbrlink":"d59c343e","date":"2017-10-24T05:10:13.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/37756599\n\n## List接口概述\nList接口，成为有序的Collection也就是序列。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 下图是List接口的框架图： \n![](/uploads/list1.png)\n通过上面的框架图，可以对List的结构了然于心，其各个类、接口如下：\nCollection：Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。\nAbstractCollection：提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。\n<!-- more -->\nterator：迭代器。\nListIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。\nList：继承于Collection的接口。它代表着有序的队列。\nAbstractList：List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。\nQueue：队列。提供队列基本的插入、获取、检查操作。\nDeque：一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。\nAbstractSequentialList：提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。\nLinkedList：List 接口的链接列表实现。它实现所有可选的列表操作。\nArrayList：List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。\nVector：实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。\nStack：后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。\nEnumeration：枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。\n![](/uploads/list2.png)\n\n## 使用场景\n学习知识的根本目的就是使用它。每个知识点都有它的使用范围。集合也是如此，在Java中集合的家族非常庞大，每个成员都有最适合的使用场景。在刚刚接触List时，LZ就说过如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用List。至于是那个List则分如下：\n1、对于需要快速插入、删除元素，则需使用LinkedList。\n2、对于需要快速访问元素，则需使用ArrayList。\n3、对于“单线程环境”或者“多线程环境，但是List仅被一个线程操作”，需要考虑使用非同步的类，如果是“多线程环境，切List可能同时被多个线程操作”，考虑使用同步的类（如Vector）。\n### ArrayList、LinkedList性能分析\n在List中我们使用最普遍的就是LinkedList和ArrayList，同时我们也了解了他们两者之间的使用场景和区别。\n```java\npublic class ListTest {  \n    private static final int COUNT = 100000;  \n      \n    private static ArrayList arrayList = new ArrayList<>();  \n    private static LinkedList linkedList = new LinkedList<>();  \n    private static Vector vector = new Vector<>();  \n      \n    public static void insertToList(List list){  \n        long startTime = System.currentTimeMillis();  \n  \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.add(0,i);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"插入 \" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n      \n    public static void deleteFromList(List list){  \n        long startTime = System.currentTimeMillis();  \n          \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.remove(0);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"删除\" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n      \n    public static void readList(List list){  \n        long startTime = System.currentTimeMillis();  \n          \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.get(i);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"读取\" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n  \n    private static String getName(List list) {  \n        String name = \"\";  \n        if(list instanceof ArrayList){  \n            name = \"ArrayList\";  \n        }  \n        else if(list instanceof LinkedList){  \n            name = \"LinkedList\";  \n        }  \n        else if(list instanceof Vector){  \n            name = \"Vector\";  \n        }  \n        return name;  \n    }  \n      \n    public static void main(String[] args) {  \n        insertToList(arrayList);  \n        insertToList(linkedList);  \n        insertToList(vector);  \n          \n        System.out.println(\"--------------------------------------\");  \n          \n        readList(arrayList);  \n        readList(linkedList);  \n        readList(vector);  \n          \n        System.out.println(\"--------------------------------------\");  \n          \n        deleteFromList(arrayList);  \n        deleteFromList(linkedList);  \n        deleteFromList(vector);  \n    }  \n} \n```\n\n运行结果:\n```java\n插入 100000元素ArrayList花费 3900 毫秒  \n插入 100000元素LinkedList花费 15 毫秒  \n插入 100000元素Vector花费 3933 毫秒  \n--------------------------------------  \n读取100000元素ArrayList花费 0 毫秒  \n读取100000元素LinkedList花费 8877 毫秒  \n读取100000元素Vector花费 16 毫秒  \n--------------------------------------  \n删除100000元素ArrayList花费 4618 毫秒  \n删除100000元素LinkedList花费 16 毫秒  \n删除100000元素Vector花费 4759 毫秒  \n```\n从上面的运行结果我们可以清晰的看出ArrayList、LinkedList、Vector增加、删除、遍历的效率问题。下面我就插入方法add(int index, E element),delete、get方法各位如有兴趣可以研究研究。\n首先我们先看三者之间的源码：\nArrayList\n```java\n    public void add(int index, E element) {  \n        rangeCheckForAdd(index);   //检查是否index是否合法  \n  \n        ensureCapacityInternal(size + 1);  //扩容操作  \n        System.arraycopy(elementData, index, elementData, index + 1, size - index);    //数组拷贝  \n        elementData[index] = element;   //插入  \n        size++;  \n    }  \n```\nrangeCheckForAdd、ensureCapacityInternal两个方法没有什么影响，真正产生影响的是System.arraycopy方法，该方法是个JNI函数，是在JVM中实现的。声明如下：\n```java\n    public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); \n```\n\n目前LZ无法看到源码，具体的实现不是很清楚，不过System.arraycopy源码分析对其进行了比较清晰的分析。但事实上我们只需要了解该方法会移动index后面的所有元素即可，这就意味着ArrayList的add(int index, E element)方法会引起index位置之后所有元素的改变，这真是牵一处而动全身。\nLinkedList  \n```java\n    public void add(int index, E element) {  \n        checkPositionIndex(index);  \n  \n        if (index == size)     //插入位置在末尾  \n            linkLast(element);  \n        else                     \n            linkBefore(element, node(index));  \n    }  \n```\n该方法比较简单，插入位置在末尾则调用linkLast方法，否则调用linkBefore方法，其实linkLast、linkBefore都是非常简单的实现，就是在index位置插入元素，至于index具体为知则有node方法来解决，同时node对index位置检索还有一个加速作用，如下：\n```java\n    Node<E> node(int index) {  \n        if (index < (size >> 1)) {    //如果index 小于 size/2 则从头开始查找  \n            Node<E> x = first;  \n            for (int i = 0; i < index; i++)  \n                x = x.next;  \n            return x;  \n        } else {   //如果index 大于 size/2 则从尾部开始查找  \n            Node<E> x = last;  \n            for (int i = size - 1; i > index; i--)  \n                x = x.prev;  \n            return x;  \n        }  \n    }  \n```\n所以linkedList的插入动作比ArrayList动作快就在于两个方面。1：linkedList不需要执行元素拷贝动作，没有牵一发而动全身的大动作。2:查找插入位置有加速动作即：若index < 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。\nVector\nVector的实现机制和ArrayList一样，同样是使用动态数组来实现的，所以他们两者之间的效率差不多，add的源码也一样，如下：\n```java\n    public void add(int index, E element) {  \n        insertElementAt(element, index);  \n    }  \n      \n    public synchronized void insertElementAt(E obj, int index) {  \n        modCount++;  \n        if (index > elementCount) {  \n            throw new ArrayIndexOutOfBoundsException(index  \n                                                     + \" > \" + elementCount);  \n        }  \n        ensureCapacityHelper(elementCount + 1);  \n        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);  \n        elementData[index] = obj;  \n        elementCount++;  \n    }  \n```\n上面是针对ArrayList、LinkedList、Vector三者之间的add（int index,E element)方法的解释，解释了LinkedList的插入动作要比ArrayList、Vector的插入动作效率为什么要高出这么多！至于delete、get两个方法LZ就不多解释了。\n同时LZ在写上面那个例子时发现了一个非常有趣的现象，就是linkedList在某些时候执行add方法时比ArrayList方法会更慢！至于在什么情况？为什么会慢LZ下篇博客解释，当然不知道这个情况各位是否也遇到过？？\n### Vector和ArrayList的区别\n![](/uploads/list3.png)","source":"_posts/java-toup31.md","raw":"---\ntitle: Java提高篇（三二）-----List总结\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: d59c343e\ndate: 2017-10-24 13:10:13\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/37756599\n\n## List接口概述\nList接口，成为有序的Collection也就是序列。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 下图是List接口的框架图： \n![](/uploads/list1.png)\n通过上面的框架图，可以对List的结构了然于心，其各个类、接口如下：\nCollection：Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。\nAbstractCollection：提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。\n<!-- more -->\nterator：迭代器。\nListIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。\nList：继承于Collection的接口。它代表着有序的队列。\nAbstractList：List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。\nQueue：队列。提供队列基本的插入、获取、检查操作。\nDeque：一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。\nAbstractSequentialList：提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。\nLinkedList：List 接口的链接列表实现。它实现所有可选的列表操作。\nArrayList：List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。\nVector：实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。\nStack：后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。\nEnumeration：枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。\n![](/uploads/list2.png)\n\n## 使用场景\n学习知识的根本目的就是使用它。每个知识点都有它的使用范围。集合也是如此，在Java中集合的家族非常庞大，每个成员都有最适合的使用场景。在刚刚接触List时，LZ就说过如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用List。至于是那个List则分如下：\n1、对于需要快速插入、删除元素，则需使用LinkedList。\n2、对于需要快速访问元素，则需使用ArrayList。\n3、对于“单线程环境”或者“多线程环境，但是List仅被一个线程操作”，需要考虑使用非同步的类，如果是“多线程环境，切List可能同时被多个线程操作”，考虑使用同步的类（如Vector）。\n### ArrayList、LinkedList性能分析\n在List中我们使用最普遍的就是LinkedList和ArrayList，同时我们也了解了他们两者之间的使用场景和区别。\n```java\npublic class ListTest {  \n    private static final int COUNT = 100000;  \n      \n    private static ArrayList arrayList = new ArrayList<>();  \n    private static LinkedList linkedList = new LinkedList<>();  \n    private static Vector vector = new Vector<>();  \n      \n    public static void insertToList(List list){  \n        long startTime = System.currentTimeMillis();  \n  \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.add(0,i);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"插入 \" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n      \n    public static void deleteFromList(List list){  \n        long startTime = System.currentTimeMillis();  \n          \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.remove(0);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"删除\" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n      \n    public static void readList(List list){  \n        long startTime = System.currentTimeMillis();  \n          \n        for(int i = 0 ; i < COUNT ; i++){  \n            list.get(i);  \n        }  \n          \n        long endTime = System.currentTimeMillis();  \n        System.out.println(\"读取\" + COUNT + \"元素\" + getName(list) + \"花费 \" + (endTime - startTime) + \" 毫秒\");  \n    }  \n  \n    private static String getName(List list) {  \n        String name = \"\";  \n        if(list instanceof ArrayList){  \n            name = \"ArrayList\";  \n        }  \n        else if(list instanceof LinkedList){  \n            name = \"LinkedList\";  \n        }  \n        else if(list instanceof Vector){  \n            name = \"Vector\";  \n        }  \n        return name;  \n    }  \n      \n    public static void main(String[] args) {  \n        insertToList(arrayList);  \n        insertToList(linkedList);  \n        insertToList(vector);  \n          \n        System.out.println(\"--------------------------------------\");  \n          \n        readList(arrayList);  \n        readList(linkedList);  \n        readList(vector);  \n          \n        System.out.println(\"--------------------------------------\");  \n          \n        deleteFromList(arrayList);  \n        deleteFromList(linkedList);  \n        deleteFromList(vector);  \n    }  \n} \n```\n\n运行结果:\n```java\n插入 100000元素ArrayList花费 3900 毫秒  \n插入 100000元素LinkedList花费 15 毫秒  \n插入 100000元素Vector花费 3933 毫秒  \n--------------------------------------  \n读取100000元素ArrayList花费 0 毫秒  \n读取100000元素LinkedList花费 8877 毫秒  \n读取100000元素Vector花费 16 毫秒  \n--------------------------------------  \n删除100000元素ArrayList花费 4618 毫秒  \n删除100000元素LinkedList花费 16 毫秒  \n删除100000元素Vector花费 4759 毫秒  \n```\n从上面的运行结果我们可以清晰的看出ArrayList、LinkedList、Vector增加、删除、遍历的效率问题。下面我就插入方法add(int index, E element),delete、get方法各位如有兴趣可以研究研究。\n首先我们先看三者之间的源码：\nArrayList\n```java\n    public void add(int index, E element) {  \n        rangeCheckForAdd(index);   //检查是否index是否合法  \n  \n        ensureCapacityInternal(size + 1);  //扩容操作  \n        System.arraycopy(elementData, index, elementData, index + 1, size - index);    //数组拷贝  \n        elementData[index] = element;   //插入  \n        size++;  \n    }  \n```\nrangeCheckForAdd、ensureCapacityInternal两个方法没有什么影响，真正产生影响的是System.arraycopy方法，该方法是个JNI函数，是在JVM中实现的。声明如下：\n```java\n    public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); \n```\n\n目前LZ无法看到源码，具体的实现不是很清楚，不过System.arraycopy源码分析对其进行了比较清晰的分析。但事实上我们只需要了解该方法会移动index后面的所有元素即可，这就意味着ArrayList的add(int index, E element)方法会引起index位置之后所有元素的改变，这真是牵一处而动全身。\nLinkedList  \n```java\n    public void add(int index, E element) {  \n        checkPositionIndex(index);  \n  \n        if (index == size)     //插入位置在末尾  \n            linkLast(element);  \n        else                     \n            linkBefore(element, node(index));  \n    }  \n```\n该方法比较简单，插入位置在末尾则调用linkLast方法，否则调用linkBefore方法，其实linkLast、linkBefore都是非常简单的实现，就是在index位置插入元素，至于index具体为知则有node方法来解决，同时node对index位置检索还有一个加速作用，如下：\n```java\n    Node<E> node(int index) {  \n        if (index < (size >> 1)) {    //如果index 小于 size/2 则从头开始查找  \n            Node<E> x = first;  \n            for (int i = 0; i < index; i++)  \n                x = x.next;  \n            return x;  \n        } else {   //如果index 大于 size/2 则从尾部开始查找  \n            Node<E> x = last;  \n            for (int i = size - 1; i > index; i--)  \n                x = x.prev;  \n            return x;  \n        }  \n    }  \n```\n所以linkedList的插入动作比ArrayList动作快就在于两个方面。1：linkedList不需要执行元素拷贝动作，没有牵一发而动全身的大动作。2:查找插入位置有加速动作即：若index < 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。\nVector\nVector的实现机制和ArrayList一样，同样是使用动态数组来实现的，所以他们两者之间的效率差不多，add的源码也一样，如下：\n```java\n    public void add(int index, E element) {  \n        insertElementAt(element, index);  \n    }  \n      \n    public synchronized void insertElementAt(E obj, int index) {  \n        modCount++;  \n        if (index > elementCount) {  \n            throw new ArrayIndexOutOfBoundsException(index  \n                                                     + \" > \" + elementCount);  \n        }  \n        ensureCapacityHelper(elementCount + 1);  \n        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);  \n        elementData[index] = obj;  \n        elementCount++;  \n    }  \n```\n上面是针对ArrayList、LinkedList、Vector三者之间的add（int index,E element)方法的解释，解释了LinkedList的插入动作要比ArrayList、Vector的插入动作效率为什么要高出这么多！至于delete、get两个方法LZ就不多解释了。\n同时LZ在写上面那个例子时发现了一个非常有趣的现象，就是linkedList在某些时候执行add方法时比ArrayList方法会更慢！至于在什么情况？为什么会慢LZ下篇博客解释，当然不知道这个情况各位是否也遇到过？？\n### Vector和ArrayList的区别\n![](/uploads/list3.png)","slug":"java-toup31","published":1,"updated":"2019-09-03T03:40:46.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketf8002q0vfae1f3k4jj","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37756599\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37756599</a></p></blockquote><h2 id=\"List接口概述\"><a href=\"#List接口概述\" class=\"headerlink\" title=\"List接口概述\"></a>List接口概述</h2><p>List接口，成为有序的Collection也就是序列。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 下图是List接口的框架图：<br><img src=\"/uploads/list1.png\" alt><br>通过上面的框架图，可以对List的结构了然于心，其各个类、接口如下：<br>Collection：Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。<br>AbstractCollection：提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。<br><a id=\"more\"></a><br>terator：迭代器。<br>ListIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。<br>List：继承于Collection的接口。它代表着有序的队列。<br>AbstractList：List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。<br>Queue：队列。提供队列基本的插入、获取、检查操作。<br>Deque：一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。<br>AbstractSequentialList：提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。<br>LinkedList：List 接口的链接列表实现。它实现所有可选的列表操作。<br>ArrayList：List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br>Vector：实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。<br>Stack：后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。<br>Enumeration：枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。<br><img src=\"/uploads/list2.png\" alt></p><h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>学习知识的根本目的就是使用它。每个知识点都有它的使用范围。集合也是如此，在Java中集合的家族非常庞大，每个成员都有最适合的使用场景。在刚刚接触List时，LZ就说过如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用List。至于是那个List则分如下：<br>1、对于需要快速插入、删除元素，则需使用LinkedList。<br>2、对于需要快速访问元素，则需使用ArrayList。<br>3、对于“单线程环境”或者“多线程环境，但是List仅被一个线程操作”，需要考虑使用非同步的类，如果是“多线程环境，切List可能同时被多个线程操作”，考虑使用同步的类（如Vector）。</p><h3 id=\"ArrayList、LinkedList性能分析\"><a href=\"#ArrayList、LinkedList性能分析\" class=\"headerlink\" title=\"ArrayList、LinkedList性能分析\"></a>ArrayList、LinkedList性能分析</h3><p>在List中我们使用最普遍的就是LinkedList和ArrayList，同时我们也了解了他们两者之间的使用场景和区别。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT = <span class=\"number\">100000</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList arrayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LinkedList linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Vector vector = <span class=\"keyword\">new</span> Vector&lt;&gt;();  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertToList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.add(<span class=\"number\">0</span>,i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"插入 \"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFromList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.remove(<span class=\"number\">0</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"删除\"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">readList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.get(i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"读取\"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(List list)</span> </span>&#123;  </span><br><span class=\"line\">        String name = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> ArrayList)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"ArrayList\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> LinkedList)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"LinkedList\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> Vector)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"Vector\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        insertToList(arrayList);  </span><br><span class=\"line\">        insertToList(linkedList);  </span><br><span class=\"line\">        insertToList(vector);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"--------------------------------------\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        readList(arrayList);  </span><br><span class=\"line\">        readList(linkedList);  </span><br><span class=\"line\">        readList(vector);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"--------------------------------------\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        deleteFromList(arrayList);  </span><br><span class=\"line\">        deleteFromList(linkedList);  </span><br><span class=\"line\">        deleteFromList(vector);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入 <span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">3900</span> 毫秒  </span><br><span class=\"line\">插入 <span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">15</span> 毫秒  </span><br><span class=\"line\">插入 <span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">3933</span> 毫秒  </span><br><span class=\"line\">--------------------------------------  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">0</span> 毫秒  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">8877</span> 毫秒  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">16</span> 毫秒  </span><br><span class=\"line\">--------------------------------------  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">4618</span> 毫秒  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">16</span> 毫秒  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">4759</span> 毫秒</span><br></pre></td></tr></table></figure><p></p><p>从上面的运行结果我们可以清晰的看出ArrayList、LinkedList、Vector增加、删除、遍历的效率问题。下面我就插入方法add(int index, E element),delete、get方法各位如有兴趣可以研究研究。<br>首先我们先看三者之间的源码：<br>ArrayList<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    rangeCheckForAdd(index);   <span class=\"comment\">//检查是否index是否合法  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">//扩容操作  </span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);    <span class=\"comment\">//数组拷贝  </span></span><br><span class=\"line\">    elementData[index] = element;   <span class=\"comment\">//插入  </span></span><br><span class=\"line\">    size++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>rangeCheckForAdd、ensureCapacityInternal两个方法没有什么影响，真正产生影响的是System.arraycopy方法，该方法是个JNI函数，是在JVM中实现的。声明如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">arraycopy</span><span class=\"params\">(Object src, <span class=\"keyword\">int</span> srcPos, Object dest, <span class=\"keyword\">int</span> destPos, <span class=\"keyword\">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>目前LZ无法看到源码，具体的实现不是很清楚，不过System.arraycopy源码分析对其进行了比较清晰的分析。但事实上我们只需要了解该方法会移动index后面的所有元素即可，这就意味着ArrayList的add(int index, E element)方法会引起index位置之后所有元素的改变，这真是牵一处而动全身。<br>LinkedList<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    checkPositionIndex(index);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)     <span class=\"comment\">//插入位置在末尾  </span></span><br><span class=\"line\">        linkLast(element);  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>                     </span><br><span class=\"line\">        linkBefore(element, node(index));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该方法比较简单，插入位置在末尾则调用linkLast方法，否则调用linkBefore方法，其实linkLast、linkBefore都是非常简单的实现，就是在index位置插入元素，至于index具体为知则有node方法来解决，同时node对index位置检索还有一个加速作用，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;    <span class=\"comment\">//如果index 小于 size/2 则从头开始查找  </span></span><br><span class=\"line\">        Node&lt;E&gt; x = first;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)  </span><br><span class=\"line\">            x = x.next;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">//如果index 大于 size/2 则从尾部开始查找  </span></span><br><span class=\"line\">        Node&lt;E&gt; x = last;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)  </span><br><span class=\"line\">            x = x.prev;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以linkedList的插入动作比ArrayList动作快就在于两个方面。1：linkedList不需要执行元素拷贝动作，没有牵一发而动全身的大动作。2:查找插入位置有加速动作即：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。<br>Vector<br>Vector的实现机制和ArrayList一样，同样是使用动态数组来实现的，所以他们两者之间的效率差不多，add的源码也一样，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    insertElementAt(element, index);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">insertElementAt</span><span class=\"params\">(E obj, <span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; elementCount) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index  </span><br><span class=\"line\">                                                 + <span class=\"string\">\" &gt; \"</span> + elementCount);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ensureCapacityHelper(elementCount + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, elementCount - index);  </span><br><span class=\"line\">    elementData[index] = obj;  </span><br><span class=\"line\">    elementCount++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面是针对ArrayList、LinkedList、Vector三者之间的add（int index,E element)方法的解释，解释了LinkedList的插入动作要比ArrayList、Vector的插入动作效率为什么要高出这么多！至于delete、get两个方法LZ就不多解释了。<br>同时LZ在写上面那个例子时发现了一个非常有趣的现象，就是linkedList在某些时候执行add方法时比ArrayList方法会更慢！至于在什么情况？为什么会慢LZ下篇博客解释，当然不知道这个情况各位是否也遇到过？？</p><h3 id=\"Vector和ArrayList的区别\"><a href=\"#Vector和ArrayList的区别\" class=\"headerlink\" title=\"Vector和ArrayList的区别\"></a>Vector和ArrayList的区别</h3><p><img src=\"/uploads/list3.png\" alt></p><!-- rebuild by neat -->","site":{"data":{}},"length":7258,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37756599\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37756599</a></p></blockquote><h2 id=\"List接口概述\"><a href=\"#List接口概述\" class=\"headerlink\" title=\"List接口概述\"></a>List接口概述</h2><p>List接口，成为有序的Collection也就是序列。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 下图是List接口的框架图：<br><img src=\"/uploads/list1.png\" alt><br>通过上面的框架图，可以对List的结构了然于心，其各个类、接口如下：<br>Collection：Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。<br>AbstractCollection：提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。<br>","more":"<br>terator：迭代器。<br>ListIterator：系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。<br>List：继承于Collection的接口。它代表着有序的队列。<br>AbstractList：List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。<br>Queue：队列。提供队列基本的插入、获取、检查操作。<br>Deque：一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。<br>AbstractSequentialList：提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。<br>LinkedList：List 接口的链接列表实现。它实现所有可选的列表操作。<br>ArrayList：List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。<br>Vector：实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。<br>Stack：后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。<br>Enumeration：枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。<br><img src=\"/uploads/list2.png\" alt></p><h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>学习知识的根本目的就是使用它。每个知识点都有它的使用范围。集合也是如此，在Java中集合的家族非常庞大，每个成员都有最适合的使用场景。在刚刚接触List时，LZ就说过如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用List。至于是那个List则分如下：<br>1、对于需要快速插入、删除元素，则需使用LinkedList。<br>2、对于需要快速访问元素，则需使用ArrayList。<br>3、对于“单线程环境”或者“多线程环境，但是List仅被一个线程操作”，需要考虑使用非同步的类，如果是“多线程环境，切List可能同时被多个线程操作”，考虑使用同步的类（如Vector）。</p><h3 id=\"ArrayList、LinkedList性能分析\"><a href=\"#ArrayList、LinkedList性能分析\" class=\"headerlink\" title=\"ArrayList、LinkedList性能分析\"></a>ArrayList、LinkedList性能分析</h3><p>在List中我们使用最普遍的就是LinkedList和ArrayList，同时我们也了解了他们两者之间的使用场景和区别。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT = <span class=\"number\">100000</span>;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList arrayList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LinkedList linkedList = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Vector vector = <span class=\"keyword\">new</span> Vector&lt;&gt;();  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertToList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.add(<span class=\"number\">0</span>,i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"插入 \"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFromList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.remove(<span class=\"number\">0</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"删除\"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">readList</span><span class=\"params\">(List list)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; COUNT ; i++)&#123;  </span><br><span class=\"line\">            list.get(i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">          </span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"读取\"</span> + COUNT + <span class=\"string\">\"元素\"</span> + getName(list) + <span class=\"string\">\"花费 \"</span> + (endTime - startTime) + <span class=\"string\">\" 毫秒\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String <span class=\"title\">getName</span><span class=\"params\">(List list)</span> </span>&#123;  </span><br><span class=\"line\">        String name = <span class=\"string\">\"\"</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> ArrayList)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"ArrayList\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> LinkedList)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"LinkedList\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(list <span class=\"keyword\">instanceof</span> Vector)&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"Vector\"</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        insertToList(arrayList);  </span><br><span class=\"line\">        insertToList(linkedList);  </span><br><span class=\"line\">        insertToList(vector);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"--------------------------------------\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        readList(arrayList);  </span><br><span class=\"line\">        readList(linkedList);  </span><br><span class=\"line\">        readList(vector);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"--------------------------------------\"</span>);  </span><br><span class=\"line\">          </span><br><span class=\"line\">        deleteFromList(arrayList);  </span><br><span class=\"line\">        deleteFromList(linkedList);  </span><br><span class=\"line\">        deleteFromList(vector);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">插入 <span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">3900</span> 毫秒  </span><br><span class=\"line\">插入 <span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">15</span> 毫秒  </span><br><span class=\"line\">插入 <span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">3933</span> 毫秒  </span><br><span class=\"line\">--------------------------------------  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">0</span> 毫秒  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">8877</span> 毫秒  </span><br><span class=\"line\">读取<span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">16</span> 毫秒  </span><br><span class=\"line\">--------------------------------------  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素ArrayList花费 <span class=\"number\">4618</span> 毫秒  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素LinkedList花费 <span class=\"number\">16</span> 毫秒  </span><br><span class=\"line\">删除<span class=\"number\">100000</span>元素Vector花费 <span class=\"number\">4759</span> 毫秒</span><br></pre></td></tr></table></figure><p></p><p>从上面的运行结果我们可以清晰的看出ArrayList、LinkedList、Vector增加、删除、遍历的效率问题。下面我就插入方法add(int index, E element),delete、get方法各位如有兴趣可以研究研究。<br>首先我们先看三者之间的源码：<br>ArrayList<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    rangeCheckForAdd(index);   <span class=\"comment\">//检查是否index是否合法  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">//扩容操作  </span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, size - index);    <span class=\"comment\">//数组拷贝  </span></span><br><span class=\"line\">    elementData[index] = element;   <span class=\"comment\">//插入  </span></span><br><span class=\"line\">    size++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>rangeCheckForAdd、ensureCapacityInternal两个方法没有什么影响，真正产生影响的是System.arraycopy方法，该方法是个JNI函数，是在JVM中实现的。声明如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">arraycopy</span><span class=\"params\">(Object src, <span class=\"keyword\">int</span> srcPos, Object dest, <span class=\"keyword\">int</span> destPos, <span class=\"keyword\">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>目前LZ无法看到源码，具体的实现不是很清楚，不过System.arraycopy源码分析对其进行了比较清晰的分析。但事实上我们只需要了解该方法会移动index后面的所有元素即可，这就意味着ArrayList的add(int index, E element)方法会引起index位置之后所有元素的改变，这真是牵一处而动全身。<br>LinkedList<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    checkPositionIndex(index);  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index == size)     <span class=\"comment\">//插入位置在末尾  </span></span><br><span class=\"line\">        linkLast(element);  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>                     </span><br><span class=\"line\">        linkBefore(element, node(index));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该方法比较简单，插入位置在末尾则调用linkLast方法，否则调用linkBefore方法，其实linkLast、linkBefore都是非常简单的实现，就是在index位置插入元素，至于index具体为知则有node方法来解决，同时node对index位置检索还有一个加速作用，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;    <span class=\"comment\">//如果index 小于 size/2 则从头开始查找  </span></span><br><span class=\"line\">        Node&lt;E&gt; x = first;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)  </span><br><span class=\"line\">            x = x.next;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">//如果index 大于 size/2 则从尾部开始查找  </span></span><br><span class=\"line\">        Node&lt;E&gt; x = last;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)  </span><br><span class=\"line\">            x = x.prev;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以linkedList的插入动作比ArrayList动作快就在于两个方面。1：linkedList不需要执行元素拷贝动作，没有牵一发而动全身的大动作。2:查找插入位置有加速动作即：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。<br>Vector<br>Vector的实现机制和ArrayList一样，同样是使用动态数组来实现的，所以他们两者之间的效率差不多，add的源码也一样，如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    insertElementAt(element, index);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">insertElementAt</span><span class=\"params\">(E obj, <span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; elementCount) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ArrayIndexOutOfBoundsException(index  </span><br><span class=\"line\">                                                 + <span class=\"string\">\" &gt; \"</span> + elementCount);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ensureCapacityHelper(elementCount + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>, elementCount - index);  </span><br><span class=\"line\">    elementData[index] = obj;  </span><br><span class=\"line\">    elementCount++;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面是针对ArrayList、LinkedList、Vector三者之间的add（int index,E element)方法的解释，解释了LinkedList的插入动作要比ArrayList、Vector的插入动作效率为什么要高出这么多！至于delete、get两个方法LZ就不多解释了。<br>同时LZ在写上面那个例子时发现了一个非常有趣的现象，就是linkedList在某些时候执行add方法时比ArrayList方法会更慢！至于在什么情况？为什么会慢LZ下篇博客解释，当然不知道这个情况各位是否也遇到过？？</p><h3 id=\"Vector和ArrayList的区别\"><a href=\"#Vector和ArrayList的区别\" class=\"headerlink\" title=\"Vector和ArrayList的区别\"></a>Vector和ArrayList的区别</h3><p><img src=\"/uploads/list3.png\" alt></p><!-- rebuild by neat -->"},{"title":"Java提高篇（三三）-----Map总结","abbrlink":"b1ccff99","date":"2017-10-24T05:10:16.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/37909815\n\n## Map概述\n首先先看Map的结构示意图\n![](/uploads/map1.png)\n\n        Map：“键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。\n        SortedMap：有序的键值对接口，继承Map接口。\n        NavigableMap：继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。\n        AbstractMap：实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。\n        Dictionary：任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。\n        TreeMap：有序散列表，实现SortedMap 接口，底层通过红黑树实现。\n        HashMap：是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。\n        WeakHashMap：基于“拉链法”实现的散列表。\n        HashTable：基于“拉链法”实现的散列表。\n\n<!-- more -->\n\n总结如下：\n![](/uploads/map2.png)\n他们之间的区别：\n![](/uploads/map3.png)\n## 内部哈希： 哈希映射技术\n几乎所有通用Map都使用哈希映射技术。对于我们程序员来说我们必须要对其有所了解。\n哈希映射技术是一种就元素映射到数组的非常简单的技术。由于哈希映射采用的是数组结果，那么必然存在一中用于确定任意键访问数组的索引机制，该机制能够提供一个小于数组大小的整数，我们将该机制称之为哈希函数。在Java中我们不必为寻找这样的整数而大伤脑筋，因为每个对象都必定存在一个返回整数值的hashCode方法，而我们需要做的就是将其转换为整数，然后再将该值除以数组大小取余即可。如下：\n```java\nint hashValue = Maths.abs(obj.hashCode()) % size;  \n```\n下面是HashMap、HashTable的：\n```java\n----------HashMap------------  \n//计算hash值  \nstatic int hash(int h) {  \n    h ^= (h >>> 20) ^ (h >>> 12);  \n    return h ^ (h >>> 7) ^ (h >>> 4);  \n}  \n//计算key的索引位置  \nstatic int indexFor(int h, int length) {  \n        return h & (length-1);  \n}  \n-----HashTable--------------  \nint index = (hash & 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  \n```\n位置的索引就代表了该节点在数组中的位置。下图是哈希映射的基本原理图：\n![](/uploads/map4.gif)\n在该图中1-4步骤是找到该元素在数组中位置，5-8步骤是将该元素插入数组中。在插入的过程中会遇到一点点小挫折。在众多肯能存在多个元素他们的hash值是一样的，这样就会得到相同的索引位置，也就说多个元素会映射到相同的位置，这个过程我们称之为“冲突”。解决冲突的办法就是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。当然也不是简单的插入，在HashMap中的处理过程如下：获取索引位置的链表，如果该链表为null，则将该元素直接插入，否则通过比较是否存在与该key相同的key，若存在则覆盖原来key的value并返回旧值，否则将该元素保存在链头（最先保存的元素放在链尾）。下面是HashMap的put方法，该方法详细展示了计算索引位置，将元素插入到适当的位置的全部过程：\n```java\n    public V put(K key, V value) {  \n        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  \n        if (key == null)  \n            return putForNullKey(value);  \n        //计算key的hash值  \n        int hash = hash(key.hashCode());                   \n        //计算key hash 值在 table 数组中的位置  \n        int i = indexFor(hash, table.length);              \n        //从i出开始迭代 e,判断是否存在相同的key  \n        for (Entry<K, V> e = table[i]; e != null; e = e.next) {  \n            Object k;  \n            //判断该条链上是否有hash值相同的(key相同)  \n            //若存在相同，则直接覆盖value，返回旧value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n                V oldValue = e.value;    //旧值 = 新值  \n                e.value = value;  \n                e.recordAccess(this);  \n                return oldValue;     //返回旧值  \n            }  \n        }  \n        //修改次数增加1  \n        modCount++;  \n        //将key、value添加至i位置处  \n        addEntry(hash, key, value, i);  \n        return null;  \n    }  \n```\nHashMap的put方法展示了哈希映射的基本思想，其实如果我们查看其它的Map，发现其原理都差不多！\n## Map优化\n首先我们这样假设，假设哈希映射的内部数组的大小只有1，所有的元素都将映射该位置（0），从而构成一条较长的链表。由于我们更新、访问都要对这条链表进行线性搜索，这样势必会降低效率。我们假设，如果存在一个非常大数组，每个位置链表处都只有一个元素，在进行访问时计算其 index 值就会获得该对象，这样做虽然会提高我们搜索的效率，但是它浪费了控件。诚然，虽然这两种方式都是极端的，但是它给我们提供了一种优化思路：使用一个较大的数组让元素能够均匀分布。在Map有两个会影响到其效率，一是容器的初始化大小、二是负载因子。\n### 调整实现大小\n在哈希映射表中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)，我们为了使Map对象能够有效地处理任意数的元素，将Map设计成可以调整自身的大小。我们知道当Map中的元素达到一定量的时候就会调整容器自身的大小，但是这个调整大小的过程其开销是非常大的。调整大小需要将原来所有的元素插入到新数组中。我们知道index = hash(key) % length。这样可能会导致原先冲突的键不在冲突，不冲突的键现在冲突的，重新计算、调整、插入的过程开销是非常大的，效率也比较低下。所以，如果我们开始知道Map的预期大小值，将Map调整的足够大，则可以大大减少甚至不需要重新调整大小，这很有可能会提高速度。下面是HashMap调整容器大小的过程，通过下面的代码我们可以看到其扩容过程的复杂性：\n```java\n        void resize(int newCapacity) {  \n            Entry[] oldTable = table;    //原始容器  \n            int oldCapacity = oldTable.length;    //原始容器大小  \n            if (oldCapacity == MAXIMUM_CAPACITY) {     //是否超过最大值：1073741824  \n                threshold = Integer.MAX_VALUE;  \n                return;  \n            }  \n  \n            //新的数组：大小为 oldCapacity * 2  \n            Entry[] newTable = new Entry[newCapacity];      \n            transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n            table = newTable;  \n           /* \n            * 重新计算阀值 =  newCapacity * loadFactor >  MAXIMUM_CAPACITY + 1 ?  \n            *                         newCapacity * loadFactor :MAXIMUM_CAPACITY + 1 \n            */  \n            threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);     \n        }  \n          \n        //将元素插入到新数组中  \n        void transfer(Entry[] newTable, boolean rehash) {  \n            int newCapacity = newTable.length;  \n            for (Entry<K,V> e : table) {  \n                while(null != e) {  \n                    Entry<K,V> next = e.next;  \n                    if (rehash) {  \n                        e.hash = null == e.key ? 0 : hash(e.key);  \n                    }  \n                    int i = indexFor(e.hash, newCapacity);  \n                    e.next = newTable[i];  \n                    newTable[i] = e;  \n                    e = next;  \n                }  \n            }  \n        }  \n```\n3.2、负载因子\n         为了确认何时需要调整Map容器，Map使用了一个额外的参数并且粗略计算存储容器的密度。在Map调整大小之前，使用”负载因子”来指示Map将会承担的“负载量”，也就是它的负载程度，当容器中元素的数量达到了这个“负载量”，则Map将会进行扩容操作。负载因子、容量、Map大小之间的关系如下：负载因子 * 容量 > map大小  ----->调整Map大小。\n         例如：如果负载因子大小为0.75（HashMap的默认值），默认容量为11，则 11 * 0.75 = 8.25 = 8，所以当我们容器中插入第八个元素的时候，Map就会调整大小。\n        负载因子本身就是在控件和时间之间的折衷。当我使用较小的负载因子时，虽然降低了冲突的可能性，使得单个链表的长度减小了，加快了访问和更新的速度，但是它占用了更多的控件，使得数组中的大部分控件没有得到利用，元素分布比较稀疏，同时由于Map频繁的调整大小，可能会降低性能。但是如果负载因子过大，会使得元素分布比较紧凑，导致产生冲突的可能性加大，从而访问、更新速度较慢。所以我们一般推荐不更改负载因子的值，采用默认值0.75.","source":"_posts/java-toup32.md","raw":"---\ntitle: Java提高篇（三三）-----Map总结\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: b1ccff99\ndate: 2017-10-24 13:10:16\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/37909815\n\n## Map概述\n首先先看Map的结构示意图\n![](/uploads/map1.png)\n\n        Map：“键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。\n        SortedMap：有序的键值对接口，继承Map接口。\n        NavigableMap：继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。\n        AbstractMap：实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。\n        Dictionary：任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。\n        TreeMap：有序散列表，实现SortedMap 接口，底层通过红黑树实现。\n        HashMap：是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。\n        WeakHashMap：基于“拉链法”实现的散列表。\n        HashTable：基于“拉链法”实现的散列表。\n\n<!-- more -->\n\n总结如下：\n![](/uploads/map2.png)\n他们之间的区别：\n![](/uploads/map3.png)\n## 内部哈希： 哈希映射技术\n几乎所有通用Map都使用哈希映射技术。对于我们程序员来说我们必须要对其有所了解。\n哈希映射技术是一种就元素映射到数组的非常简单的技术。由于哈希映射采用的是数组结果，那么必然存在一中用于确定任意键访问数组的索引机制，该机制能够提供一个小于数组大小的整数，我们将该机制称之为哈希函数。在Java中我们不必为寻找这样的整数而大伤脑筋，因为每个对象都必定存在一个返回整数值的hashCode方法，而我们需要做的就是将其转换为整数，然后再将该值除以数组大小取余即可。如下：\n```java\nint hashValue = Maths.abs(obj.hashCode()) % size;  \n```\n下面是HashMap、HashTable的：\n```java\n----------HashMap------------  \n//计算hash值  \nstatic int hash(int h) {  \n    h ^= (h >>> 20) ^ (h >>> 12);  \n    return h ^ (h >>> 7) ^ (h >>> 4);  \n}  \n//计算key的索引位置  \nstatic int indexFor(int h, int length) {  \n        return h & (length-1);  \n}  \n-----HashTable--------------  \nint index = (hash & 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  \n```\n位置的索引就代表了该节点在数组中的位置。下图是哈希映射的基本原理图：\n![](/uploads/map4.gif)\n在该图中1-4步骤是找到该元素在数组中位置，5-8步骤是将该元素插入数组中。在插入的过程中会遇到一点点小挫折。在众多肯能存在多个元素他们的hash值是一样的，这样就会得到相同的索引位置，也就说多个元素会映射到相同的位置，这个过程我们称之为“冲突”。解决冲突的办法就是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。当然也不是简单的插入，在HashMap中的处理过程如下：获取索引位置的链表，如果该链表为null，则将该元素直接插入，否则通过比较是否存在与该key相同的key，若存在则覆盖原来key的value并返回旧值，否则将该元素保存在链头（最先保存的元素放在链尾）。下面是HashMap的put方法，该方法详细展示了计算索引位置，将元素插入到适当的位置的全部过程：\n```java\n    public V put(K key, V value) {  \n        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  \n        if (key == null)  \n            return putForNullKey(value);  \n        //计算key的hash值  \n        int hash = hash(key.hashCode());                   \n        //计算key hash 值在 table 数组中的位置  \n        int i = indexFor(hash, table.length);              \n        //从i出开始迭代 e,判断是否存在相同的key  \n        for (Entry<K, V> e = table[i]; e != null; e = e.next) {  \n            Object k;  \n            //判断该条链上是否有hash值相同的(key相同)  \n            //若存在相同，则直接覆盖value，返回旧value  \n            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  \n                V oldValue = e.value;    //旧值 = 新值  \n                e.value = value;  \n                e.recordAccess(this);  \n                return oldValue;     //返回旧值  \n            }  \n        }  \n        //修改次数增加1  \n        modCount++;  \n        //将key、value添加至i位置处  \n        addEntry(hash, key, value, i);  \n        return null;  \n    }  \n```\nHashMap的put方法展示了哈希映射的基本思想，其实如果我们查看其它的Map，发现其原理都差不多！\n## Map优化\n首先我们这样假设，假设哈希映射的内部数组的大小只有1，所有的元素都将映射该位置（0），从而构成一条较长的链表。由于我们更新、访问都要对这条链表进行线性搜索，这样势必会降低效率。我们假设，如果存在一个非常大数组，每个位置链表处都只有一个元素，在进行访问时计算其 index 值就会获得该对象，这样做虽然会提高我们搜索的效率，但是它浪费了控件。诚然，虽然这两种方式都是极端的，但是它给我们提供了一种优化思路：使用一个较大的数组让元素能够均匀分布。在Map有两个会影响到其效率，一是容器的初始化大小、二是负载因子。\n### 调整实现大小\n在哈希映射表中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)，我们为了使Map对象能够有效地处理任意数的元素，将Map设计成可以调整自身的大小。我们知道当Map中的元素达到一定量的时候就会调整容器自身的大小，但是这个调整大小的过程其开销是非常大的。调整大小需要将原来所有的元素插入到新数组中。我们知道index = hash(key) % length。这样可能会导致原先冲突的键不在冲突，不冲突的键现在冲突的，重新计算、调整、插入的过程开销是非常大的，效率也比较低下。所以，如果我们开始知道Map的预期大小值，将Map调整的足够大，则可以大大减少甚至不需要重新调整大小，这很有可能会提高速度。下面是HashMap调整容器大小的过程，通过下面的代码我们可以看到其扩容过程的复杂性：\n```java\n        void resize(int newCapacity) {  \n            Entry[] oldTable = table;    //原始容器  \n            int oldCapacity = oldTable.length;    //原始容器大小  \n            if (oldCapacity == MAXIMUM_CAPACITY) {     //是否超过最大值：1073741824  \n                threshold = Integer.MAX_VALUE;  \n                return;  \n            }  \n  \n            //新的数组：大小为 oldCapacity * 2  \n            Entry[] newTable = new Entry[newCapacity];      \n            transfer(newTable, initHashSeedAsNeeded(newCapacity));  \n            table = newTable;  \n           /* \n            * 重新计算阀值 =  newCapacity * loadFactor >  MAXIMUM_CAPACITY + 1 ?  \n            *                         newCapacity * loadFactor :MAXIMUM_CAPACITY + 1 \n            */  \n            threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);     \n        }  \n          \n        //将元素插入到新数组中  \n        void transfer(Entry[] newTable, boolean rehash) {  \n            int newCapacity = newTable.length;  \n            for (Entry<K,V> e : table) {  \n                while(null != e) {  \n                    Entry<K,V> next = e.next;  \n                    if (rehash) {  \n                        e.hash = null == e.key ? 0 : hash(e.key);  \n                    }  \n                    int i = indexFor(e.hash, newCapacity);  \n                    e.next = newTable[i];  \n                    newTable[i] = e;  \n                    e = next;  \n                }  \n            }  \n        }  \n```\n3.2、负载因子\n         为了确认何时需要调整Map容器，Map使用了一个额外的参数并且粗略计算存储容器的密度。在Map调整大小之前，使用”负载因子”来指示Map将会承担的“负载量”，也就是它的负载程度，当容器中元素的数量达到了这个“负载量”，则Map将会进行扩容操作。负载因子、容量、Map大小之间的关系如下：负载因子 * 容量 > map大小  ----->调整Map大小。\n         例如：如果负载因子大小为0.75（HashMap的默认值），默认容量为11，则 11 * 0.75 = 8.25 = 8，所以当我们容器中插入第八个元素的时候，Map就会调整大小。\n        负载因子本身就是在控件和时间之间的折衷。当我使用较小的负载因子时，虽然降低了冲突的可能性，使得单个链表的长度减小了，加快了访问和更新的速度，但是它占用了更多的控件，使得数组中的大部分控件没有得到利用，元素分布比较稀疏，同时由于Map频繁的调整大小，可能会降低性能。但是如果负载因子过大，会使得元素分布比较紧凑，导致产生冲突的可能性加大，从而访问、更新速度较慢。所以我们一般推荐不更改负载因子的值，采用默认值0.75.","slug":"java-toup32","published":1,"updated":"2019-09-03T03:40:46.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfc002u0vfarff3wzp1","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37909815\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37909815</a></p></blockquote><h2 id=\"Map概述\"><a href=\"#Map概述\" class=\"headerlink\" title=\"Map概述\"></a>Map概述</h2><p>首先先看Map的结构示意图<br><img src=\"/uploads/map1.png\" alt></p><pre><code>    Map：“键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。\n    SortedMap：有序的键值对接口，继承Map接口。\n    NavigableMap：继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。\n    AbstractMap：实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。\n    Dictionary：任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。\n    TreeMap：有序散列表，实现SortedMap 接口，底层通过红黑树实现。\n    HashMap：是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。\n    WeakHashMap：基于“拉链法”实现的散列表。\n    HashTable：基于“拉链法”实现的散列表。\n</code></pre><a id=\"more\"></a><p>总结如下：<br><img src=\"/uploads/map2.png\" alt><br>他们之间的区别：<br><img src=\"/uploads/map3.png\" alt></p><h2 id=\"内部哈希：-哈希映射技术\"><a href=\"#内部哈希：-哈希映射技术\" class=\"headerlink\" title=\"内部哈希： 哈希映射技术\"></a>内部哈希： 哈希映射技术</h2><p>几乎所有通用Map都使用哈希映射技术。对于我们程序员来说我们必须要对其有所了解。<br>哈希映射技术是一种就元素映射到数组的非常简单的技术。由于哈希映射采用的是数组结果，那么必然存在一中用于确定任意键访问数组的索引机制，该机制能够提供一个小于数组大小的整数，我们将该机制称之为哈希函数。在Java中我们不必为寻找这样的整数而大伤脑筋，因为每个对象都必定存在一个返回整数值的hashCode方法，而我们需要做的就是将其转换为整数，然后再将该值除以数组大小取余即可。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hashValue = Maths.abs(obj.hashCode()) % size;</span><br></pre></td></tr></table></figure><p></p><p>下面是HashMap、HashTable的：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------HashMap------------  </span><br><span class=\"line\"><span class=\"comment\">//计算hash值  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;  </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">//计算key的索引位置  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----HashTable--------------  </span><br><span class=\"line\"><span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;     <span class=\"comment\">//确认该key的索引位置</span></span><br></pre></td></tr></table></figure><p></p><p>位置的索引就代表了该节点在数组中的位置。下图是哈希映射的基本原理图：<br><img src=\"/uploads/map4.gif\" alt><br>在该图中1-4步骤是找到该元素在数组中位置，5-8步骤是将该元素插入数组中。在插入的过程中会遇到一点点小挫折。在众多肯能存在多个元素他们的hash值是一样的，这样就会得到相同的索引位置，也就说多个元素会映射到相同的位置，这个过程我们称之为“冲突”。解决冲突的办法就是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。当然也不是简单的插入，在HashMap中的处理过程如下：获取索引位置的链表，如果该链表为null，则将该元素直接插入，否则通过比较是否存在与该key相同的key，若存在则覆盖原来key的value并返回旧值，否则将该元素保存在链头（最先保存的元素放在链尾）。下面是HashMap的put方法，该方法详细展示了计算索引位置，将元素插入到适当的位置的全部过程：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());                   </span><br><span class=\"line\">    <span class=\"comment\">//计算key hash 值在 table 数组中的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);              </span><br><span class=\"line\">    <span class=\"comment\">//从i出开始迭代 e,判断是否存在相同的key  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//判断该条链上是否有hash值相同的(key相同)  </span></span><br><span class=\"line\">        <span class=\"comment\">//若存在相同，则直接覆盖value，返回旧value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            V oldValue = e.value;    <span class=\"comment\">//旧值 = 新值  </span></span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;     <span class=\"comment\">//返回旧值  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//修改次数增加1  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//将key、value添加至i位置处  </span></span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HashMap的put方法展示了哈希映射的基本思想，其实如果我们查看其它的Map，发现其原理都差不多！</p><h2 id=\"Map优化\"><a href=\"#Map优化\" class=\"headerlink\" title=\"Map优化\"></a>Map优化</h2><p>首先我们这样假设，假设哈希映射的内部数组的大小只有1，所有的元素都将映射该位置（0），从而构成一条较长的链表。由于我们更新、访问都要对这条链表进行线性搜索，这样势必会降低效率。我们假设，如果存在一个非常大数组，每个位置链表处都只有一个元素，在进行访问时计算其 index 值就会获得该对象，这样做虽然会提高我们搜索的效率，但是它浪费了控件。诚然，虽然这两种方式都是极端的，但是它给我们提供了一种优化思路：使用一个较大的数组让元素能够均匀分布。在Map有两个会影响到其效率，一是容器的初始化大小、二是负载因子。</p><h3 id=\"调整实现大小\"><a href=\"#调整实现大小\" class=\"headerlink\" title=\"调整实现大小\"></a>调整实现大小</h3><p>在哈希映射表中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)，我们为了使Map对象能够有效地处理任意数的元素，将Map设计成可以调整自身的大小。我们知道当Map中的元素达到一定量的时候就会调整容器自身的大小，但是这个调整大小的过程其开销是非常大的。调整大小需要将原来所有的元素插入到新数组中。我们知道index = hash(key) % length。这样可能会导致原先冲突的键不在冲突，不冲突的键现在冲突的，重新计算、调整、插入的过程开销是非常大的，效率也比较低下。所以，如果我们开始知道Map的预期大小值，将Map调整的足够大，则可以大大减少甚至不需要重新调整大小，这很有可能会提高速度。下面是HashMap调整容器大小的过程，通过下面的代码我们可以看到其扩容过程的复杂性：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    Entry[] oldTable = table;    <span class=\"comment\">//原始容器  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;    <span class=\"comment\">//原始容器大小  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;     <span class=\"comment\">//是否超过最大值：1073741824  </span></span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//新的数组：大小为 oldCapacity * 2  </span></span><br><span class=\"line\">    Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];      </span><br><span class=\"line\">    transfer(newTable, initHashSeedAsNeeded(newCapacity));  </span><br><span class=\"line\">    table = newTable;  </span><br><span class=\"line\">   <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 重新计算阀值 =  newCapacity * loadFactor &gt;  MAXIMUM_CAPACITY + 1 ?  </span></span><br><span class=\"line\"><span class=\"comment\">    *                         newCapacity * loadFactor :MAXIMUM_CAPACITY + 1 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);     </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//将元素插入到新数组中  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"keyword\">boolean</span> rehash)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != e) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;  </span><br><span class=\"line\">                e.hash = <span class=\"keyword\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);  </span><br><span class=\"line\">            e.next = newTable[i];  </span><br><span class=\"line\">            newTable[i] = e;  </span><br><span class=\"line\">            e = next;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3.2、负载因子<br>为了确认何时需要调整Map容器，Map使用了一个额外的参数并且粗略计算存储容器的密度。在Map调整大小之前，使用”负载因子”来指示Map将会承担的“负载量”，也就是它的负载程度，当容器中元素的数量达到了这个“负载量”，则Map将会进行扩容操作。负载因子、容量、Map大小之间的关系如下：负载因子 <em>容量 &gt; map大小 ——-&gt;调整Map大小。<br>例如：如果负载因子大小为0.75（HashMap的默认值），默认容量为11，则 11 </em>0.75 = 8.25 = 8，所以当我们容器中插入第八个元素的时候，Map就会调整大小。<br>负载因子本身就是在控件和时间之间的折衷。当我使用较小的负载因子时，虽然降低了冲突的可能性，使得单个链表的长度减小了，加快了访问和更新的速度，但是它占用了更多的控件，使得数组中的大部分控件没有得到利用，元素分布比较稀疏，同时由于Map频繁的调整大小，可能会降低性能。但是如果负载因子过大，会使得元素分布比较紧凑，导致产生冲突的可能性加大，从而访问、更新速度较慢。所以我们一般推荐不更改负载因子的值，采用默认值0.75.</p><!-- rebuild by neat -->","site":{"data":{}},"length":4959,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/37909815\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/37909815</a></p></blockquote><h2 id=\"Map概述\"><a href=\"#Map概述\" class=\"headerlink\" title=\"Map概述\"></a>Map概述</h2><p>首先先看Map的结构示意图<br><img src=\"/uploads/map1.png\" alt></p><pre><code>    Map：“键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。\n    SortedMap：有序的键值对接口，继承Map接口。\n    NavigableMap：继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。\n    AbstractMap：实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。\n    Dictionary：任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。\n    TreeMap：有序散列表，实现SortedMap 接口，底层通过红黑树实现。\n    HashMap：是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。\n    WeakHashMap：基于“拉链法”实现的散列表。\n    HashTable：基于“拉链法”实现的散列表。\n</code></pre>","more":"<p>总结如下：<br><img src=\"/uploads/map2.png\" alt><br>他们之间的区别：<br><img src=\"/uploads/map3.png\" alt></p><h2 id=\"内部哈希：-哈希映射技术\"><a href=\"#内部哈希：-哈希映射技术\" class=\"headerlink\" title=\"内部哈希： 哈希映射技术\"></a>内部哈希： 哈希映射技术</h2><p>几乎所有通用Map都使用哈希映射技术。对于我们程序员来说我们必须要对其有所了解。<br>哈希映射技术是一种就元素映射到数组的非常简单的技术。由于哈希映射采用的是数组结果，那么必然存在一中用于确定任意键访问数组的索引机制，该机制能够提供一个小于数组大小的整数，我们将该机制称之为哈希函数。在Java中我们不必为寻找这样的整数而大伤脑筋，因为每个对象都必定存在一个返回整数值的hashCode方法，而我们需要做的就是将其转换为整数，然后再将该值除以数组大小取余即可。如下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hashValue = Maths.abs(obj.hashCode()) % size;</span><br></pre></td></tr></table></figure><p></p><p>下面是HashMap、HashTable的：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">----------HashMap------------  </span><br><span class=\"line\"><span class=\"comment\">//计算hash值  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> h)</span> </span>&#123;  </span><br><span class=\"line\">    h ^= (h &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">12</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> h ^ (h &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (h &gt;&gt;&gt; <span class=\"number\">4</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"comment\">//计算key的索引位置  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-----HashTable--------------  </span><br><span class=\"line\"><span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;     <span class=\"comment\">//确认该key的索引位置</span></span><br></pre></td></tr></table></figure><p></p><p>位置的索引就代表了该节点在数组中的位置。下图是哈希映射的基本原理图：<br><img src=\"/uploads/map4.gif\" alt><br>在该图中1-4步骤是找到该元素在数组中位置，5-8步骤是将该元素插入数组中。在插入的过程中会遇到一点点小挫折。在众多肯能存在多个元素他们的hash值是一样的，这样就会得到相同的索引位置，也就说多个元素会映射到相同的位置，这个过程我们称之为“冲突”。解决冲突的办法就是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。当然也不是简单的插入，在HashMap中的处理过程如下：获取索引位置的链表，如果该链表为null，则将该元素直接插入，否则通过比较是否存在与该key相同的key，若存在则覆盖原来key的value并返回旧值，否则将该元素保存在链头（最先保存的元素放在链尾）。下面是HashMap的put方法，该方法详细展示了计算索引位置，将元素插入到适当的位置的全部过程：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> putForNullKey(value);  </span><br><span class=\"line\">    <span class=\"comment\">//计算key的hash值  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = hash(key.hashCode());                   </span><br><span class=\"line\">    <span class=\"comment\">//计算key hash 值在 table 数组中的位置  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(hash, table.length);              </span><br><span class=\"line\">    <span class=\"comment\">//从i出开始迭代 e,判断是否存在相同的key  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;  </span><br><span class=\"line\">        Object k;  </span><br><span class=\"line\">        <span class=\"comment\">//判断该条链上是否有hash值相同的(key相同)  </span></span><br><span class=\"line\">        <span class=\"comment\">//若存在相同，则直接覆盖value，返回旧value  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class=\"line\">            V oldValue = e.value;    <span class=\"comment\">//旧值 = 新值  </span></span><br><span class=\"line\">            e.value = value;  </span><br><span class=\"line\">            e.recordAccess(<span class=\"keyword\">this</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;     <span class=\"comment\">//返回旧值  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//修改次数增加1  </span></span><br><span class=\"line\">    modCount++;  </span><br><span class=\"line\">    <span class=\"comment\">//将key、value添加至i位置处  </span></span><br><span class=\"line\">    addEntry(hash, key, value, i);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>HashMap的put方法展示了哈希映射的基本思想，其实如果我们查看其它的Map，发现其原理都差不多！</p><h2 id=\"Map优化\"><a href=\"#Map优化\" class=\"headerlink\" title=\"Map优化\"></a>Map优化</h2><p>首先我们这样假设，假设哈希映射的内部数组的大小只有1，所有的元素都将映射该位置（0），从而构成一条较长的链表。由于我们更新、访问都要对这条链表进行线性搜索，这样势必会降低效率。我们假设，如果存在一个非常大数组，每个位置链表处都只有一个元素，在进行访问时计算其 index 值就会获得该对象，这样做虽然会提高我们搜索的效率，但是它浪费了控件。诚然，虽然这两种方式都是极端的，但是它给我们提供了一种优化思路：使用一个较大的数组让元素能够均匀分布。在Map有两个会影响到其效率，一是容器的初始化大小、二是负载因子。</p><h3 id=\"调整实现大小\"><a href=\"#调整实现大小\" class=\"headerlink\" title=\"调整实现大小\"></a>调整实现大小</h3><p>在哈希映射表中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)，我们为了使Map对象能够有效地处理任意数的元素，将Map设计成可以调整自身的大小。我们知道当Map中的元素达到一定量的时候就会调整容器自身的大小，但是这个调整大小的过程其开销是非常大的。调整大小需要将原来所有的元素插入到新数组中。我们知道index = hash(key) % length。这样可能会导致原先冲突的键不在冲突，不冲突的键现在冲突的，重新计算、调整、插入的过程开销是非常大的，效率也比较低下。所以，如果我们开始知道Map的预期大小值，将Map调整的足够大，则可以大大减少甚至不需要重新调整大小，这很有可能会提高速度。下面是HashMap调整容器大小的过程，通过下面的代码我们可以看到其扩容过程的复杂性：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;  </span><br><span class=\"line\">    Entry[] oldTable = table;    <span class=\"comment\">//原始容器  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = oldTable.length;    <span class=\"comment\">//原始容器大小  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;     <span class=\"comment\">//是否超过最大值：1073741824  </span></span><br><span class=\"line\">        threshold = Integer.MAX_VALUE;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//新的数组：大小为 oldCapacity * 2  </span></span><br><span class=\"line\">    Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];      </span><br><span class=\"line\">    transfer(newTable, initHashSeedAsNeeded(newCapacity));  </span><br><span class=\"line\">    table = newTable;  </span><br><span class=\"line\">   <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    * 重新计算阀值 =  newCapacity * loadFactor &gt;  MAXIMUM_CAPACITY + 1 ?  </span></span><br><span class=\"line\"><span class=\"comment\">    *                         newCapacity * loadFactor :MAXIMUM_CAPACITY + 1 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);     </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//将元素插入到新数组中  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"keyword\">boolean</span> rehash)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != e) &#123;  </span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;  </span><br><span class=\"line\">                e.hash = <span class=\"keyword\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);  </span><br><span class=\"line\">            e.next = newTable[i];  </span><br><span class=\"line\">            newTable[i] = e;  </span><br><span class=\"line\">            e = next;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3.2、负载因子<br>为了确认何时需要调整Map容器，Map使用了一个额外的参数并且粗略计算存储容器的密度。在Map调整大小之前，使用”负载因子”来指示Map将会承担的“负载量”，也就是它的负载程度，当容器中元素的数量达到了这个“负载量”，则Map将会进行扩容操作。负载因子、容量、Map大小之间的关系如下：负载因子 <em>容量 &gt; map大小 ——-&gt;调整Map大小。<br>例如：如果负载因子大小为0.75（HashMap的默认值），默认容量为11，则 11 </em>0.75 = 8.25 = 8，所以当我们容器中插入第八个元素的时候，Map就会调整大小。<br>负载因子本身就是在控件和时间之间的折衷。当我使用较小的负载因子时，虽然降低了冲突的可能性，使得单个链表的长度减小了，加快了访问和更新的速度，但是它占用了更多的控件，使得数组中的大部分控件没有得到利用，元素分布比较稀疏，同时由于Map频繁的调整大小，可能会降低性能。但是如果负载因子过大，会使得元素分布比较紧凑，导致产生冲突的可能性加大，从而访问、更新速度较慢。所以我们一般推荐不更改负载因子的值，采用默认值0.75.</p><!-- rebuild by neat -->"},{"title":"Java提高篇（三四）-----fail-fast机制","abbrlink":"a04d7e6d","date":"2017-10-24T05:10:19.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/38151189\n\n在JDK的Collection中我们时常会看到类似于这样的话：\n例如，ArrayList:\n注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。\nHashMap中：\n<!-- more -->\n注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。\n在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？\n“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。\n## fail-fast示例\n```java\npublic class FailFastTest {  \n    private static List<Integer> list = new ArrayList<>();  \n      \n    /** \n     * @desc:线程one迭代list \n     * @Project:test \n     * @file:FailFastTest.java \n     * @Authro:chenssy \n     * @data:2014年7月26日 \n     */  \n    private static class threadOne extends Thread{  \n        public void run() {  \n            Iterator<Integer> iterator = list.iterator();  \n            while(iterator.hasNext()){  \n                int i = iterator.next();  \n                System.out.println(\"ThreadOne 遍历:\" + i);  \n                try {  \n                    Thread.sleep(10);  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n      \n    /** \n     * @desc:当i == 3时，修改list \n     * @Project:test \n     * @file:FailFastTest.java \n     * @Authro:chenssy \n     * @data:2014年7月26日 \n     */  \n    private static class threadTwo extends Thread{  \n        public void run(){  \n            int i = 0 ;   \n            while(i < 6){  \n                System.out.println(\"ThreadTwo run：\" + i);  \n                if(i == 3){  \n                    list.remove(i);  \n                }  \n                i++;  \n            }  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        for(int i = 0 ; i < 10;i++){  \n            list.add(i);  \n        }  \n        new threadOne().start();  \n        new threadTwo().start();  \n    }  \n}  \n\t 运行结果：\n```java\nThreadOne 遍历:0  \nThreadTwo run：0  \nThreadTwo run：1  \nThreadTwo run：2  \nThreadTwo run：3  \nThreadTwo run：4  \nThreadTwo run：5  \nException in thread \"Thread-0\" java.util.ConcurrentModificationException  \n    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)  \n    at java.util.ArrayList$Itr.next(Unknown Source)  \n    at test.ArrayListTest$threadOne.run(ArrayListTest.java:23)  \n```\n\n## fail-fast产生原因\n通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。\n要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。\n诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。\n从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：\n```java\n    private class Itr implements Iterator<E> {  \n        int cursor;  \n        int lastRet = -1;  \n        int expectedModCount = ArrayList.this.modCount;  \n  \n        public boolean hasNext() {  \n            return (this.cursor != ArrayList.this.size);  \n        }  \n  \n        public E next() {  \n            checkForComodification();  \n            /** 省略此处代码 */  \n        }  \n  \n        public void remove() {  \n            if (this.lastRet < 0)  \n                throw new IllegalStateException();  \n            checkForComodification();  \n            /** 省略此处代码 */  \n        }  \n  \n        final void checkForComodification() {  \n            if (ArrayList.this.modCount == this.expectedModCount)  \n                return;  \n            throw new ConcurrentModificationException();  \n        }  \n    }  \n```\n从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。\nexpectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：\n```java\nprotected transient int modCount = 0;  \n```\n那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：\n```java\n    public boolean add(E paramE) {  \n        ensureCapacityInternal(this.size + 1);  \n        /** 省略此处代码 */  \n    }  \n    \n    private void ensureCapacityInternal(int paramInt) {  \n        if (this.elementData == EMPTY_ELEMENTDATA)  \n            paramInt = Math.max(10, paramInt);  \n        ensureExplicitCapacity(paramInt);  \n    }  \n    \n    private void ensureExplicitCapacity(int paramInt) {  \n        this.modCount += 1;    //修改modCount  \n        /** 省略此处代码 */  \n    }  \n    \n    public boolean remove(Object paramObject) {  \n        int i;  \n        if (paramObject == null)  \n            for (i = 0; i < this.size; ++i) {  \n                if (this.elementData[i] != null)  \n                    continue;  \n                fastRemove(i);  \n                return true;  \n            }  \n        else  \n            for (i = 0; i < this.size; ++i) {  \n                if (!(paramObject.equals(this.elementData[i])))  \n                    continue;  \n                fastRemove(i);  \n                return true;  \n            }  \n        return false;  \n    }  \n    \n    private void fastRemove(int paramInt) {  \n        this.modCount += 1;   //修改modCount  \n        /** 省略此处代码 */  \n    }  \n    \n    public void clear() {  \n        this.modCount += 1;    //修改modCount  \n        /** 省略此处代码 */  \n    }  \n```\n从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：\n有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。\n所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。\n## fail-fast解决办法\n通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：\n方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。\n方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。\nCopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？\n第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。\n第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：\n```java\n    private static class COWIterator<E> implements ListIterator<E> {  \n        /** 省略此处代码 */  \n        public E next() {  \n            if (!(hasNext()))  \n                throw new NoSuchElementException();  \n            return this.snapshot[(this.cursor++)];  \n        }  \n  \n        /** 省略此处代码 */  \n    } \n```\nCopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：\n```java\n    public boolean add(E paramE) {  \n        ReentrantLock localReentrantLock = this.lock;  \n        localReentrantLock.lock();  \n        try {  \n            Object[] arrayOfObject1 = getArray();  \n            int i = arrayOfObject1.length;  \n            Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);  \n            arrayOfObject2[i] = paramE;  \n            setArray(arrayOfObject2);  \n            int j = 1;  \n            return j;  \n        } finally {  \n            localReentrantLock.unlock();  \n        }  \n    }  \n  \n      \n    final void setArray(Object[] paramArrayOfObject) {  \n        this.array = paramArrayOfObject;  \n    } \n```\n\nCopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：\n```java\n    Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);  \n    arrayOfObject2[i] = paramE;  \n    setArray(arrayOfObject2);  \n```\n就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。\n所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。","source":"_posts/java-toup33.md","raw":"---\ntitle: Java提高篇（三四）-----fail-fast机制\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: a04d7e6d\ndate: 2017-10-24 13:10:19\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/38151189\n\n在JDK的Collection中我们时常会看到类似于这样的话：\n例如，ArrayList:\n注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。\nHashMap中：\n<!-- more -->\n注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。\n在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？\n“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。\n## fail-fast示例\n```java\npublic class FailFastTest {  \n    private static List<Integer> list = new ArrayList<>();  \n      \n    /** \n     * @desc:线程one迭代list \n     * @Project:test \n     * @file:FailFastTest.java \n     * @Authro:chenssy \n     * @data:2014年7月26日 \n     */  \n    private static class threadOne extends Thread{  \n        public void run() {  \n            Iterator<Integer> iterator = list.iterator();  \n            while(iterator.hasNext()){  \n                int i = iterator.next();  \n                System.out.println(\"ThreadOne 遍历:\" + i);  \n                try {  \n                    Thread.sleep(10);  \n                } catch (InterruptedException e) {  \n                    e.printStackTrace();  \n                }  \n            }  \n        }  \n    }  \n      \n    /** \n     * @desc:当i == 3时，修改list \n     * @Project:test \n     * @file:FailFastTest.java \n     * @Authro:chenssy \n     * @data:2014年7月26日 \n     */  \n    private static class threadTwo extends Thread{  \n        public void run(){  \n            int i = 0 ;   \n            while(i < 6){  \n                System.out.println(\"ThreadTwo run：\" + i);  \n                if(i == 3){  \n                    list.remove(i);  \n                }  \n                i++;  \n            }  \n        }  \n    }  \n      \n    public static void main(String[] args) {  \n        for(int i = 0 ; i < 10;i++){  \n            list.add(i);  \n        }  \n        new threadOne().start();  \n        new threadTwo().start();  \n    }  \n}  \n\t 运行结果：\n```java\nThreadOne 遍历:0  \nThreadTwo run：0  \nThreadTwo run：1  \nThreadTwo run：2  \nThreadTwo run：3  \nThreadTwo run：4  \nThreadTwo run：5  \nException in thread \"Thread-0\" java.util.ConcurrentModificationException  \n    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)  \n    at java.util.ArrayList$Itr.next(Unknown Source)  \n    at test.ArrayListTest$threadOne.run(ArrayListTest.java:23)  \n```\n\n## fail-fast产生原因\n通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。\n要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。\n诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。\n从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：\n```java\n    private class Itr implements Iterator<E> {  \n        int cursor;  \n        int lastRet = -1;  \n        int expectedModCount = ArrayList.this.modCount;  \n  \n        public boolean hasNext() {  \n            return (this.cursor != ArrayList.this.size);  \n        }  \n  \n        public E next() {  \n            checkForComodification();  \n            /** 省略此处代码 */  \n        }  \n  \n        public void remove() {  \n            if (this.lastRet < 0)  \n                throw new IllegalStateException();  \n            checkForComodification();  \n            /** 省略此处代码 */  \n        }  \n  \n        final void checkForComodification() {  \n            if (ArrayList.this.modCount == this.expectedModCount)  \n                return;  \n            throw new ConcurrentModificationException();  \n        }  \n    }  \n```\n从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。\nexpectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：\n```java\nprotected transient int modCount = 0;  \n```\n那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：\n```java\n    public boolean add(E paramE) {  \n        ensureCapacityInternal(this.size + 1);  \n        /** 省略此处代码 */  \n    }  \n    \n    private void ensureCapacityInternal(int paramInt) {  \n        if (this.elementData == EMPTY_ELEMENTDATA)  \n            paramInt = Math.max(10, paramInt);  \n        ensureExplicitCapacity(paramInt);  \n    }  \n    \n    private void ensureExplicitCapacity(int paramInt) {  \n        this.modCount += 1;    //修改modCount  \n        /** 省略此处代码 */  \n    }  \n    \n    public boolean remove(Object paramObject) {  \n        int i;  \n        if (paramObject == null)  \n            for (i = 0; i < this.size; ++i) {  \n                if (this.elementData[i] != null)  \n                    continue;  \n                fastRemove(i);  \n                return true;  \n            }  \n        else  \n            for (i = 0; i < this.size; ++i) {  \n                if (!(paramObject.equals(this.elementData[i])))  \n                    continue;  \n                fastRemove(i);  \n                return true;  \n            }  \n        return false;  \n    }  \n    \n    private void fastRemove(int paramInt) {  \n        this.modCount += 1;   //修改modCount  \n        /** 省略此处代码 */  \n    }  \n    \n    public void clear() {  \n        this.modCount += 1;    //修改modCount  \n        /** 省略此处代码 */  \n    }  \n```\n从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：\n有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。\n所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。\n## fail-fast解决办法\n通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：\n方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。\n方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。\nCopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？\n第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。\n第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：\n```java\n    private static class COWIterator<E> implements ListIterator<E> {  \n        /** 省略此处代码 */  \n        public E next() {  \n            if (!(hasNext()))  \n                throw new NoSuchElementException();  \n            return this.snapshot[(this.cursor++)];  \n        }  \n  \n        /** 省略此处代码 */  \n    } \n```\nCopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：\n```java\n    public boolean add(E paramE) {  \n        ReentrantLock localReentrantLock = this.lock;  \n        localReentrantLock.lock();  \n        try {  \n            Object[] arrayOfObject1 = getArray();  \n            int i = arrayOfObject1.length;  \n            Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);  \n            arrayOfObject2[i] = paramE;  \n            setArray(arrayOfObject2);  \n            int j = 1;  \n            return j;  \n        } finally {  \n            localReentrantLock.unlock();  \n        }  \n    }  \n  \n      \n    final void setArray(Object[] paramArrayOfObject) {  \n        this.array = paramArrayOfObject;  \n    } \n```\n\nCopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：\n```java\n    Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);  \n    arrayOfObject2[i] = paramE;  \n    setArray(arrayOfObject2);  \n```\n就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。\n所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。","slug":"java-toup33","published":1,"updated":"2019-09-03T03:40:46.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfe002x0vfa93snap34","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38151189\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38151189</a></p></blockquote><p>在JDK的Collection中我们时常会看到类似于这样的话：<br>例如，ArrayList:<br>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。<br>HashMap中：<br><a id=\"more\"></a><br>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。<br>在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？<br>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><h2 id=\"fail-fast示例\"><a href=\"#fail-fast示例\" class=\"headerlink\" title=\"fail-fast示例\"></a>fail-fast示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FailFastTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span>:线程one迭代list </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Project</span>:test </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@file</span>:FailFastTest.java </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Authro</span>:chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span>:2014年7月26日 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">threadOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            Iterator&lt;Integer&gt; iterator = list.iterator();  </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(iterator.hasNext())&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = iterator.next();  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ThreadOne 遍历:\"</span> + i);  </span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);  </span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;  </span><br><span class=\"line\">                    e.printStackTrace();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span>:当i == 3时，修改list </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Project</span>:test </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@file</span>:FailFastTest.java </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Authro</span>:chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span>:2014年7月26日 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">threadTwo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ;   </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; <span class=\"number\">6</span>)&#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ThreadTwo run：\"</span> + i);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">                    list.remove(i);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                i++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span>;i++)&#123;  </span><br><span class=\"line\">            list.add(i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> threadOne().start();  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> threadTwo().start();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">\t 运行结果：</span><br><span class=\"line\">```java</span><br><span class=\"line\">ThreadOne 遍历:<span class=\"number\">0</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">0</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">1</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">2</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">3</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">4</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">5</span>  </span><br><span class=\"line\">Exception in thread <span class=\"string\">\"Thread-0\"</span> java.util.ConcurrentModificationException  </span><br><span class=\"line\">    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)  </span><br><span class=\"line\">    at java.util.ArrayList$Itr.next(Unknown Source)  </span><br><span class=\"line\">    at test.ArrayListTest$threadOne.run(ArrayListTest.java:<span class=\"number\">23</span>)</span><br></pre></td></tr></table></figure><h2 id=\"fail-fast产生原因\"><a href=\"#fail-fast产生原因\" class=\"headerlink\" title=\"fail-fast产生原因\"></a>fail-fast产生原因</h2><p>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。<br>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。<br>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。<br>从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = ArrayList.<span class=\"keyword\">this</span>.modCount;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.cursor != ArrayList.<span class=\"keyword\">this</span>.size);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lastRet &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ArrayList.<span class=\"keyword\">this</span>.modCount == <span class=\"keyword\">this</span>.expectedModCount)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。<br>expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><p></p><p>那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E paramE)</span> </span>&#123;  </span><br><span class=\"line\">    ensureCapacityInternal(<span class=\"keyword\">this</span>.size + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elementData == EMPTY_ELEMENTDATA)  </span><br><span class=\"line\">        paramInt = Math.max(<span class=\"number\">10</span>, paramInt);  </span><br><span class=\"line\">    ensureExplicitCapacity(paramInt);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;    <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object paramObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (paramObject == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.size; ++i) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elementData[i] != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            fastRemove(i);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.size; ++i) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(paramObject.equals(<span class=\"keyword\">this</span>.elementData[i])))  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            fastRemove(i);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;   <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;    <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：<br>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount = N ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。<br>所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</p><h2 id=\"fail-fast解决办法\"><a href=\"#fail-fast解决办法\" class=\"headerlink\" title=\"fail-fast解决办法\"></a>fail-fast解决办法</h2><p>通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：<br>方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。<br>CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？<br>第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。<br>第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">COWIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(hasNext()))  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snapshot[(<span class=\"keyword\">this</span>.cursor++)];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E paramE)</span> </span>&#123;  </span><br><span class=\"line\">    ReentrantLock localReentrantLock = <span class=\"keyword\">this</span>.lock;  </span><br><span class=\"line\">    localReentrantLock.lock();  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        Object[] arrayOfObject1 = getArray();  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = arrayOfObject1.length;  </span><br><span class=\"line\">        Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + <span class=\"number\">1</span>);  </span><br><span class=\"line\">        arrayOfObject2[i] = paramE;  </span><br><span class=\"line\">        setArray(arrayOfObject2);  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;  </span><br><span class=\"line\">        localReentrantLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setArray</span><span class=\"params\">(Object[] paramArrayOfObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.array = paramArrayOfObject;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + <span class=\"number\">1</span>);  </span><br><span class=\"line\">arrayOfObject2[i] = paramE;  </span><br><span class=\"line\">setArray(arrayOfObject2);</span><br></pre></td></tr></table></figure><p></p><p>就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。<br>所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p><!-- rebuild by neat -->","site":{"data":{}},"length":8661,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38151189\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38151189</a></p></blockquote><p>在JDK的Collection中我们时常会看到类似于这样的话：<br>例如，ArrayList:<br>注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。<br>HashMap中：<br>","more":"<br>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。<br>在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？<br>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p><h2 id=\"fail-fast示例\"><a href=\"#fail-fast示例\" class=\"headerlink\" title=\"fail-fast示例\"></a>fail-fast示例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FailFastTest</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span>:线程one迭代list </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Project</span>:test </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@file</span>:FailFastTest.java </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Authro</span>:chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span>:2014年7月26日 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">threadOne</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">            Iterator&lt;Integer&gt; iterator = list.iterator();  </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(iterator.hasNext())&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">int</span> i = iterator.next();  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ThreadOne 遍历:\"</span> + i);  </span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);  </span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;  </span><br><span class=\"line\">                    e.printStackTrace();  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@desc</span>:当i == 3时，修改list </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Project</span>:test </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@file</span>:FailFastTest.java </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Authro</span>:chenssy </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@data</span>:2014年7月26日 </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">threadTwo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ;   </span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; <span class=\"number\">6</span>)&#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"ThreadTwo run：\"</span> + i);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">                    list.remove(i);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                i++;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span>;i++)&#123;  </span><br><span class=\"line\">            list.add(i);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> threadOne().start();  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> threadTwo().start();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">\t 运行结果：</span><br><span class=\"line\">```java</span><br><span class=\"line\">ThreadOne 遍历:<span class=\"number\">0</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">0</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">1</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">2</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">3</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">4</span>  </span><br><span class=\"line\">ThreadTwo run：<span class=\"number\">5</span>  </span><br><span class=\"line\">Exception in thread <span class=\"string\">\"Thread-0\"</span> java.util.ConcurrentModificationException  </span><br><span class=\"line\">    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)  </span><br><span class=\"line\">    at java.util.ArrayList$Itr.next(Unknown Source)  </span><br><span class=\"line\">    at test.ArrayListTest$threadOne.run(ArrayListTest.java:<span class=\"number\">23</span>)</span><br></pre></td></tr></table></figure><h2 id=\"fail-fast产生原因\"><a href=\"#fail-fast产生原因\" class=\"headerlink\" title=\"fail-fast产生原因\"></a>fail-fast产生原因</h2><p>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。<br>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。<br>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。<br>从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = ArrayList.<span class=\"keyword\">this</span>.modCount;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.cursor != ArrayList.<span class=\"keyword\">this</span>.size);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.lastRet &lt; <span class=\"number\">0</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ArrayList.<span class=\"keyword\">this</span>.modCount == <span class=\"keyword\">this</span>.expectedModCount)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。<br>expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure><p></p><p>那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E paramE)</span> </span>&#123;  </span><br><span class=\"line\">    ensureCapacityInternal(<span class=\"keyword\">this</span>.size + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elementData == EMPTY_ELEMENTDATA)  </span><br><span class=\"line\">        paramInt = Math.max(<span class=\"number\">10</span>, paramInt);  </span><br><span class=\"line\">    ensureExplicitCapacity(paramInt);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;    <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object paramObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (paramObject == <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.size; ++i) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.elementData[i] != <span class=\"keyword\">null</span>)  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            fastRemove(i);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">else</span>  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.size; ++i) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!(paramObject.equals(<span class=\"keyword\">this</span>.elementData[i])))  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            fastRemove(i);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fastRemove</span><span class=\"params\">(<span class=\"keyword\">int</span> paramInt)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;   <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modCount += <span class=\"number\">1</span>;    <span class=\"comment\">//修改modCount  </span></span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：<br>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount = N ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。<br>所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</p><h2 id=\"fail-fast解决办法\"><a href=\"#fail-fast解决办法\" class=\"headerlink\" title=\"fail-fast解决办法\"></a>fail-fast解决办法</h2><p>通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：<br>方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。<br>方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。<br>CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？<br>第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。<br>第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">COWIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(hasNext()))  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.snapshot[(<span class=\"keyword\">this</span>.cursor++)];  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** 省略此处代码 */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E paramE)</span> </span>&#123;  </span><br><span class=\"line\">    ReentrantLock localReentrantLock = <span class=\"keyword\">this</span>.lock;  </span><br><span class=\"line\">    localReentrantLock.lock();  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        Object[] arrayOfObject1 = getArray();  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = arrayOfObject1.length;  </span><br><span class=\"line\">        Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + <span class=\"number\">1</span>);  </span><br><span class=\"line\">        arrayOfObject2[i] = paramE;  </span><br><span class=\"line\">        setArray(arrayOfObject2);  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> j;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;  </span><br><span class=\"line\">        localReentrantLock.unlock();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setArray</span><span class=\"params\">(Object[] paramArrayOfObject)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">this</span>.array = paramArrayOfObject;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + <span class=\"number\">1</span>);  </span><br><span class=\"line\">arrayOfObject2[i] = paramE;  </span><br><span class=\"line\">setArray(arrayOfObject2);</span><br></pre></td></tr></table></figure><p></p><p>就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。<br>所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</p><!-- rebuild by neat -->"},{"title":"Java提高篇（三五）-----Java集合细节（一）：请为集合指定初始容量","abbrlink":"17dabf45","date":"2017-10-24T05:10:22.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/38373833\n\n集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。\n\n\n```java\n    public static void main(String[] args) {  \n        StudentVO student = null;  \n        long begin1 = System.currentTimeMillis();  \n        List<StudentVO> list1 = new ArrayList<>();  \n        for(int i = 0 ; i < 1000000; i++){  \n            student = new StudentVO(i,\"chenssy_\"+i,i);  \n            list1.add(student);  \n        }  \n        long end1 = System.currentTimeMillis();  \n        System.out.println(\"list1 time：\" + (end1 - begin1));  \n          \n        long begin2 = System.currentTimeMillis();  \n        List<StudentVO> list2 = new ArrayList<>(1000000);  \n        for(int i = 0 ; i < 1000000; i++){  \n            student = new StudentVO(i,\"chenssy_\"+i,i);  \n            list2.add(student);  \n        }  \n        long end2 = System.currentTimeMillis();  \n        System.out.println(\"list2 time：\" + (end2 - begin2));  \n    } \n```\n\n上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：\n<!--more -->\n\n```java\nlist1 time：1638  \nlist2 time：921  \n```\n从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：\n\n\n```java\n    public boolean add(E e) {    \n        ensureCapacity(size + 1);     \n        elementData[size++] = e;    \n        return true;    \n    }    \n      \n    public void ensureCapacity(int minCapacity) {    \n        modCount++;         //修改计数器  \n        int oldCapacity = elementData.length;      \n        //当前需要的长度超过了数组长度，进行扩容处理  \n        if (minCapacity > oldCapacity) {    \n            Object oldData[] = elementData;    \n            //新的容量 = 旧容量 * 1.5 + 1  \n            int newCapacity = (oldCapacity * 3)/2 + 1;    \n                if (newCapacity < minCapacity)    \n                    newCapacity = minCapacity;    \n          //数组拷贝，生成新的数组   \n          elementData = Arrays.copyOf(elementData, newCapacity);    \n        }    \n    }  \n```\nArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。","source":"_posts/java-toup34.md","raw":"---\ntitle: Java提高篇（三五）-----Java集合细节（一）：请为集合指定初始容量\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 17dabf45\ndate: 2017-10-24 13:10:22\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/38373833\n\n集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。\n\n\n```java\n    public static void main(String[] args) {  \n        StudentVO student = null;  \n        long begin1 = System.currentTimeMillis();  \n        List<StudentVO> list1 = new ArrayList<>();  \n        for(int i = 0 ; i < 1000000; i++){  \n            student = new StudentVO(i,\"chenssy_\"+i,i);  \n            list1.add(student);  \n        }  \n        long end1 = System.currentTimeMillis();  \n        System.out.println(\"list1 time：\" + (end1 - begin1));  \n          \n        long begin2 = System.currentTimeMillis();  \n        List<StudentVO> list2 = new ArrayList<>(1000000);  \n        for(int i = 0 ; i < 1000000; i++){  \n            student = new StudentVO(i,\"chenssy_\"+i,i);  \n            list2.add(student);  \n        }  \n        long end2 = System.currentTimeMillis();  \n        System.out.println(\"list2 time：\" + (end2 - begin2));  \n    } \n```\n\n上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：\n<!--more -->\n\n```java\nlist1 time：1638  \nlist2 time：921  \n```\n从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：\n\n\n```java\n    public boolean add(E e) {    \n        ensureCapacity(size + 1);     \n        elementData[size++] = e;    \n        return true;    \n    }    \n      \n    public void ensureCapacity(int minCapacity) {    \n        modCount++;         //修改计数器  \n        int oldCapacity = elementData.length;      \n        //当前需要的长度超过了数组长度，进行扩容处理  \n        if (minCapacity > oldCapacity) {    \n            Object oldData[] = elementData;    \n            //新的容量 = 旧容量 * 1.5 + 1  \n            int newCapacity = (oldCapacity * 3)/2 + 1;    \n                if (newCapacity < minCapacity)    \n                    newCapacity = minCapacity;    \n          //数组拷贝，生成新的数组   \n          elementData = Arrays.copyOf(elementData, newCapacity);    \n        }    \n    }  \n```\nArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。","slug":"java-toup34","published":1,"updated":"2019-09-03T03:40:46.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfg00310vfa5868xxv7","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38373833\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38373833</a></p></blockquote><p>集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    StudentVO student = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin1 = System.currentTimeMillis();  </span><br><span class=\"line\">    List&lt;StudentVO&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">1000000</span>; i++)&#123;  </span><br><span class=\"line\">        student = <span class=\"keyword\">new</span> StudentVO(i,<span class=\"string\">\"chenssy_\"</span>+i,i);  </span><br><span class=\"line\">        list1.add(student);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> end1 = System.currentTimeMillis();  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 time：\"</span> + (end1 - begin1));  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin2 = System.currentTimeMillis();  </span><br><span class=\"line\">    List&lt;StudentVO&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1000000</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">1000000</span>; i++)&#123;  </span><br><span class=\"line\">        student = <span class=\"keyword\">new</span> StudentVO(i,<span class=\"string\">\"chenssy_\"</span>+i,i);  </span><br><span class=\"line\">        list2.add(student);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> end2 = System.currentTimeMillis();  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list2 time：\"</span> + (end2 - begin2));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：<br><a id=\"more\"></a></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 time：<span class=\"number\">1638</span>  </span><br><span class=\"line\">list2 time：<span class=\"number\">921</span></span><br></pre></td></tr></table></figure><p>从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;    </span><br><span class=\"line\">    ensureCapacity(size + <span class=\"number\">1</span>);     </span><br><span class=\"line\">    elementData[size++] = e;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;    </span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;    </span><br><span class=\"line\">    modCount++;         <span class=\"comment\">//修改计数器  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;      </span><br><span class=\"line\">    <span class=\"comment\">//当前需要的长度超过了数组长度，进行扩容处理  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; oldCapacity) &#123;    </span><br><span class=\"line\">        Object oldData[] = elementData;    </span><br><span class=\"line\">        <span class=\"comment\">//新的容量 = 旧容量 * 1.5 + 1  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>)/<span class=\"number\">2</span> + <span class=\"number\">1</span>;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newCapacity &lt; minCapacity)    </span><br><span class=\"line\">                newCapacity = minCapacity;    </span><br><span class=\"line\">      <span class=\"comment\">//数组拷贝，生成新的数组   </span></span><br><span class=\"line\">      elementData = Arrays.copyOf(elementData, newCapacity);    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p><!-- rebuild by neat -->","site":{"data":{}},"length":2142,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38373833\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38373833</a></p></blockquote><p>集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：对于已知的情景，请为集合指定初始容量。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    StudentVO student = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin1 = System.currentTimeMillis();  </span><br><span class=\"line\">    List&lt;StudentVO&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">1000000</span>; i++)&#123;  </span><br><span class=\"line\">        student = <span class=\"keyword\">new</span> StudentVO(i,<span class=\"string\">\"chenssy_\"</span>+i,i);  </span><br><span class=\"line\">        list1.add(student);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> end1 = System.currentTimeMillis();  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 time：\"</span> + (end1 - begin1));  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">long</span> begin2 = System.currentTimeMillis();  </span><br><span class=\"line\">    List&lt;StudentVO&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1000000</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">1000000</span>; i++)&#123;  </span><br><span class=\"line\">        student = <span class=\"keyword\">new</span> StudentVO(i,<span class=\"string\">\"chenssy_\"</span>+i,i);  </span><br><span class=\"line\">        list2.add(student);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">long</span> end2 = System.currentTimeMillis();  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list2 time：\"</span> + (end2 - begin2));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：<br>","more":"</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 time：<span class=\"number\">1638</span>  </span><br><span class=\"line\">list2 time：<span class=\"number\">921</span></span><br></pre></td></tr></table></figure><p>从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;    </span><br><span class=\"line\">    ensureCapacity(size + <span class=\"number\">1</span>);     </span><br><span class=\"line\">    elementData[size++] = e;    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;    </span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;    </span><br><span class=\"line\">    modCount++;         <span class=\"comment\">//修改计数器  </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;      </span><br><span class=\"line\">    <span class=\"comment\">//当前需要的长度超过了数组长度，进行扩容处理  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &gt; oldCapacity) &#123;    </span><br><span class=\"line\">        Object oldData[] = elementData;    </span><br><span class=\"line\">        <span class=\"comment\">//新的容量 = 旧容量 * 1.5 + 1  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>)/<span class=\"number\">2</span> + <span class=\"number\">1</span>;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newCapacity &lt; minCapacity)    </span><br><span class=\"line\">                newCapacity = minCapacity;    </span><br><span class=\"line\">      <span class=\"comment\">//数组拷贝，生成新的数组   </span></span><br><span class=\"line\">      elementData = Arrays.copyOf(elementData, newCapacity);    </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p><!-- rebuild by neat -->"},{"title":"Java提高篇（三六）-----java集合细节（二）：asList的缺陷","abbrlink":"5991a9fa","date":"2017-10-24T05:10:25.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/38373877\n\n在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：\n## 避免使用基本数据类型数组转换为列表\n使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：\n```java\n    public static void main(String[] args) {  \n        int[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        System.out.println(\"list'size：\" + list.size());  \n    }  \n    ------------------------------------  \n    outPut：  \n    list'size：1  \n```\n程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<>(a);  \n    }  \n```\nasList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：\n<!--more -->\n```java\npublic static void main(String[] args) {  \n    int[] ints = {1,2,3,4,5};  \n    List list = Arrays.asList(ints);  \n    System.out.println(\"list 的类型:\" + list.get(0).getClass());  \n    System.out.println(\"list.get(0) == ints：\" + list.get(0).equals(ints));  \n}  \n--------------------------------------------  \noutPut:  \nlist 的类型:class [I  \nlist.get(0) == ints：true  \n```\n从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。\n```java\n    public static void main(String[] args) {  \n        Integer[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        System.out.println(\"list'size：\" + list.size());  \n        System.out.println(\"list.get(0) 的类型:\" + list.get(0).getClass());  \n        System.out.println(\"list.get(0) == ints[0]：\" + list.get(0).equals(ints[0]));  \n    }  \n    ----------------------------------------  \n    outPut:  \n    list'size：5  \n    list.get(0) 的类型:class java.lang.Integer  \n    list.get(0) == ints[0]：true  \n```\nJava细节（2.1）：在使用asList时不要将基本数据类型当做参数。\n## asList产生的列表不可操作\n对于上面的实例我们再做一个小小的修改：\n```java\n    public static void main(String[] args) {  \n        Integer[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        list.add(6);  \n    }  \n```\n该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException  \n    at java.util.AbstractList.add(Unknown Source)  \n    at java.util.AbstractList.add(Unknown Source)  \n    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:10)  \n```\n运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<>(a);  \n    }  \n```\nasList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:\n```java\n    private static class ArrayList<E> extends AbstractList<E>  \n    implements RandomAccess, java.io.Serializable{  \n        private static final long serialVersionUID = -2764017481108945198L;  \n        private final E[] a;  \n  \n        ArrayList(E[] array) {  \n            if (array==null)  \n                throw new NullPointerException();  \n            a = array;  \n        }  \n        //.................  \n    }  \n```\n这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：\n```java\n    public boolean add(E e) {  \n        add(size(), e);  \n        return true;  \n    }  \n      \n    public E set(int index, E element) {  \n        throw new UnsupportedOperationException();  \n    }  \n      \n    public void add(int index, E element) {  \n        throw new UnsupportedOperationException();  \n    }  \n      \n    public E remove(int index) {  \n        throw new UnsupportedOperationException();  \n    }  \n```\n通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：\nJava细节（2.2）：不要试图改变asList返回的列表，否则你会自食苦果。\n","source":"_posts/java-toup35.md","raw":"---\ntitle: Java提高篇（三六）-----java集合细节（二）：asList的缺陷\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 5991a9fa\ndate: 2017-10-24 13:10:25\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/38373877\n\n在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：\n## 避免使用基本数据类型数组转换为列表\n使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：\n```java\n    public static void main(String[] args) {  \n        int[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        System.out.println(\"list'size：\" + list.size());  \n    }  \n    ------------------------------------  \n    outPut：  \n    list'size：1  \n```\n程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<>(a);  \n    }  \n```\nasList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：\n<!--more -->\n```java\npublic static void main(String[] args) {  \n    int[] ints = {1,2,3,4,5};  \n    List list = Arrays.asList(ints);  \n    System.out.println(\"list 的类型:\" + list.get(0).getClass());  \n    System.out.println(\"list.get(0) == ints：\" + list.get(0).equals(ints));  \n}  \n--------------------------------------------  \noutPut:  \nlist 的类型:class [I  \nlist.get(0) == ints：true  \n```\n从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。\n```java\n    public static void main(String[] args) {  \n        Integer[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        System.out.println(\"list'size：\" + list.size());  \n        System.out.println(\"list.get(0) 的类型:\" + list.get(0).getClass());  \n        System.out.println(\"list.get(0) == ints[0]：\" + list.get(0).equals(ints[0]));  \n    }  \n    ----------------------------------------  \n    outPut:  \n    list'size：5  \n    list.get(0) 的类型:class java.lang.Integer  \n    list.get(0) == ints[0]：true  \n```\nJava细节（2.1）：在使用asList时不要将基本数据类型当做参数。\n## asList产生的列表不可操作\n对于上面的实例我们再做一个小小的修改：\n```java\n    public static void main(String[] args) {  \n        Integer[] ints = {1,2,3,4,5};  \n        List list = Arrays.asList(ints);  \n        list.add(6);  \n    }  \n```\n该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：\n```java\nException in thread \"main\" java.lang.UnsupportedOperationException  \n    at java.util.AbstractList.add(Unknown Source)  \n    at java.util.AbstractList.add(Unknown Source)  \n    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:10)  \n```\n运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：\n```java\n    public static <T> List<T> asList(T... a) {  \n        return new ArrayList<>(a);  \n    }  \n```\nasList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:\n```java\n    private static class ArrayList<E> extends AbstractList<E>  \n    implements RandomAccess, java.io.Serializable{  \n        private static final long serialVersionUID = -2764017481108945198L;  \n        private final E[] a;  \n  \n        ArrayList(E[] array) {  \n            if (array==null)  \n                throw new NullPointerException();  \n            a = array;  \n        }  \n        //.................  \n    }  \n```\n这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：\n```java\n    public boolean add(E e) {  \n        add(size(), e);  \n        return true;  \n    }  \n      \n    public E set(int index, E element) {  \n        throw new UnsupportedOperationException();  \n    }  \n      \n    public void add(int index, E element) {  \n        throw new UnsupportedOperationException();  \n    }  \n      \n    public E remove(int index) {  \n        throw new UnsupportedOperationException();  \n    }  \n```\n通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：\nJava细节（2.2）：不要试图改变asList返回的列表，否则你会自食苦果。\n","slug":"java-toup35","published":1,"updated":"2019-09-03T03:40:46.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfh00340vfax8i52rc1","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38373877\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38373877</a></p></blockquote><p>在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：</p><h2 id=\"避免使用基本数据类型数组转换为列表\"><a href=\"#避免使用基本数据类型数组转换为列表\" class=\"headerlink\" title=\"避免使用基本数据类型数组转换为列表\"></a>避免使用基本数据类型数组转换为列表</h2><p>使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list'size：\"</span> + list.size());  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">------------------------------------  </span><br><span class=\"line\">outPut：  </span><br><span class=\"line\">list<span class=\"string\">'size：1</span></span><br></pre></td></tr></table></figure><p></p><p>程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>asList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list 的类型:\"</span> + list.get(<span class=\"number\">0</span>).getClass());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) == ints：\"</span> + list.get(<span class=\"number\">0</span>).equals(ints));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------------------------------  </span><br><span class=\"line\">outPut:  </span><br><span class=\"line\">list 的类型:class [I  </span><br><span class=\"line\">list.get(<span class=\"number\">0</span>) == ints：<span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure><p></p><p>从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Integer[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list'size：\"</span> + list.size());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) 的类型:\"</span> + list.get(<span class=\"number\">0</span>).getClass());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) == ints[0]：\"</span> + list.get(<span class=\"number\">0</span>).equals(ints[<span class=\"number\">0</span>]));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------------------------------  </span><br><span class=\"line\">outPut:  </span><br><span class=\"line\">list<span class=\"string\">'size：5  </span></span><br><span class=\"line\"><span class=\"string\">list.get(0) 的类型:class java.lang.Integer  </span></span><br><span class=\"line\"><span class=\"string\">list.get(0) == ints[0]：true</span></span><br></pre></td></tr></table></figure><p></p><p>Java细节（2.1）：在使用asList时不要将基本数据类型当做参数。</p><h2 id=\"asList产生的列表不可操作\"><a href=\"#asList产生的列表不可操作\" class=\"headerlink\" title=\"asList产生的列表不可操作\"></a>asList产生的列表不可操作</h2><p>对于上面的实例我们再做一个小小的修改：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Integer[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    list.add(<span class=\"number\">6</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException  </span><br><span class=\"line\">    at java.util.AbstractList.add(Unknown Source)  </span><br><span class=\"line\">    at java.util.AbstractList.add(Unknown Source)  </span><br><span class=\"line\">    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>asList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2764017481108945198L</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> E[] a;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ArrayList(E[] array) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array==<span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">        a = array;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//.................  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    add(size(), e);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：<br>Java细节（2.2）：不要试图改变asList返回的列表，否则你会自食苦果。</p><!-- rebuild by neat -->","site":{"data":{}},"length":3704,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/38373877\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/38373877</a></p></blockquote><p>在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：</p><h2 id=\"避免使用基本数据类型数组转换为列表\"><a href=\"#避免使用基本数据类型数组转换为列表\" class=\"headerlink\" title=\"避免使用基本数据类型数组转换为列表\"></a>避免使用基本数据类型数组转换为列表</h2><p>使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list'size：\"</span> + list.size());  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">------------------------------------  </span><br><span class=\"line\">outPut：  </span><br><span class=\"line\">list<span class=\"string\">'size：1</span></span><br></pre></td></tr></table></figure><p></p><p>程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>asList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list 的类型:\"</span> + list.get(<span class=\"number\">0</span>).getClass());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) == ints：\"</span> + list.get(<span class=\"number\">0</span>).equals(ints));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------------------------------  </span><br><span class=\"line\">outPut:  </span><br><span class=\"line\">list 的类型:class [I  </span><br><span class=\"line\">list.get(<span class=\"number\">0</span>) == ints：<span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure><p></p><p>从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Integer[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list'size：\"</span> + list.size());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) 的类型:\"</span> + list.get(<span class=\"number\">0</span>).getClass());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list.get(0) == ints[0]：\"</span> + list.get(<span class=\"number\">0</span>).equals(ints[<span class=\"number\">0</span>]));  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------------------------------  </span><br><span class=\"line\">outPut:  </span><br><span class=\"line\">list<span class=\"string\">'size：5  </span></span><br><span class=\"line\"><span class=\"string\">list.get(0) 的类型:class java.lang.Integer  </span></span><br><span class=\"line\"><span class=\"string\">list.get(0) == ints[0]：true</span></span><br></pre></td></tr></table></figure><p></p><p>Java细节（2.1）：在使用asList时不要将基本数据类型当做参数。</p><h2 id=\"asList产生的列表不可操作\"><a href=\"#asList产生的列表不可操作\" class=\"headerlink\" title=\"asList产生的列表不可操作\"></a>asList产生的列表不可操作</h2><p>对于上面的实例我们再做一个小小的修改：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    Integer[] ints = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;  </span><br><span class=\"line\">    List list = Arrays.asList(ints);  </span><br><span class=\"line\">    list.add(<span class=\"number\">6</span>);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread <span class=\"string\">\"main\"</span> java.lang.UnsupportedOperationException  </span><br><span class=\"line\">    at java.util.AbstractList.add(Unknown Source)  </span><br><span class=\"line\">    at java.util.AbstractList.add(Unknown Source)  </span><br><span class=\"line\">    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">asList</span><span class=\"params\">(T... a)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ArrayList&lt;&gt;(a);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>asList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2764017481108945198L</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> E[] a;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    ArrayList(E[] array) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array==<span class=\"keyword\">null</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();  </span><br><span class=\"line\">        a = array;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">//.................  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;  </span><br><span class=\"line\">    add(size(), e);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：<br>Java细节（2.2）：不要试图改变asList返回的列表，否则你会自食苦果。</p><!-- rebuild by neat -->"},{"title":"Java提高篇（三七）—–Java集合细节（三）：subList的缺陷","abbrlink":"46384154","date":"2017-10-24T05:10:28.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/44102915\n\n我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。\n\n## subList返回仅仅只是一个视图\n\n首先我们先看如下实例：\n\n```java\n    public static void main(String[] args) {  \n        List<Integer> list1 = new ArrayList<Integer>();  \n        list1.add(1);  \n        list1.add(2);  \n          \n        //通过构造函数新建一个包含list1的列表 list2  \n        List<Integer> list2 = new ArrayList<Integer>(list1);  \n          \n        //通过subList生成一个与list1一样的列表 list3  \n        List<Integer> list3 = list1.subList(0, list1.size());  \n          \n        //修改list3  \n        list3.add(3);  \n          \n        System.out.println(\"list1 == list2：\" + list1.equals(list2));  \n        System.out.println(\"list1 == list3：\" + list1.equals(list3));  \n    }  \n```\n<!-- more -->\n这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：\n\n```java\nlist1 == list2：true  \nlist1 == list3: false  \n```\n首先我们先不论结果的正确与否，我们先看subList的源码：\n\n```java\n    public List<E> subList(int fromIndex, int toIndex) {  \n        subListRangeCheck(fromIndex, toIndex, size);  \n        return new SubList(this, 0, fromIndex, toIndex);  \n    }  \n```\nsubListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。\n\n```java\n    /** \n     * 继承AbstractList类，实现RandomAccess接口 \n     */  \n    private class SubList extends AbstractList<E> implements RandomAccess {  \n        private final AbstractList<E> parent;    //列表  \n        private final int parentOffset;     \n        private final int offset;  \n        int size;  \n  \n        //构造函数  \n        SubList(AbstractList<E> parent,  \n                int offset, int fromIndex, int toIndex) {  \n            this.parent = parent;  \n            this.parentOffset = fromIndex;  \n            this.offset = offset + fromIndex;  \n            this.size = toIndex - fromIndex;  \n            this.modCount = ArrayList.this.modCount;  \n        }  \n  \n        //set方法  \n        public E set(int index, E e) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            E oldValue = ArrayList.this.elementData(offset + index);  \n            ArrayList.this.elementData[offset + index] = e;  \n            return oldValue;  \n        }  \n  \n        //get方法  \n        public E get(int index) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            return ArrayList.this.elementData(offset + index);  \n        }  \n  \n        //add方法  \n        public void add(int index, E e) {  \n            rangeCheckForAdd(index);  \n            checkForComodification();  \n            parent.add(parentOffset + index, e);  \n            this.modCount = parent.modCount;  \n            this.size++;  \n        }  \n  \n        //remove方法  \n        public E remove(int index) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            E result = parent.remove(parentOffset + index);  \n            this.modCount = parent.modCount;  \n            this.size--;  \n            return result;  \n        }  \n    }  \n```\n该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：\n1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。\n\n2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。\n\n我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：\n\n```java\nparent.add(parentOffset + index, e);  \nthis.modCount = parent.modCount;  \n```\nremove方法里面的\n\n```java\nE result = parent.remove(parentOffset + index);  \nthis.modCount = parent.modCount;  \n```\n诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。\n\n那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：\n\n```java\nlist1 == list2：false  \nlist1 == list3：true  \n```\nJava细节（3.1）：subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上\n\n## subList生成子列表后，不要试图去操作原列表\n\n从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？\n\n```java\n    public static void main(String[] args) {  \n        List<Integer> list1 = new ArrayList<Integer>();  \n        list1.add(1);  \n        list1.add(2);  \n          \n        //通过subList生成一个与list1一样的列表 list3  \n        List<Integer> list3 = list1.subList(0, list1.size());  \n        //修改list3  \n        list1.add(3);  \n          \n        System.out.println(\"list1'size：\" + list1.size());  \n        System.out.println(\"list3'size：\" + list3.size());  \n    }  \n```\n该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：\n\n```java\nlist1'size：3  \nException in thread \"main\" java.util.ConcurrentModificationException  \n    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)  \n    at java.util.ArrayList$SubList.size(Unknown Source)  \n    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)  \n```\nlist1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了（更多请点这里：Java提高篇（三四）—–fail-fast机制）。我们再看size方法：\n\n```java\n        public int size() {  \n            checkForComodification();  \n            return this.size;  \n        }  \n```\nsize方法首先会通过checkForComodification验证，然后再返回this.size。\n\n```java\n        private void checkForComodification() {  \n            if (ArrayList.this.modCount != this.modCount)  \n                throw new ConcurrentModificationException();  \n        }  \n```\n该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。\n\n对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：\n\n```java\n//通过subList生成一个与list1一样的列表 list3  \nList<Integer> list3 = list1.subList(0, list1.size());  \n          \n//对list1设置为只读状态  \nlist1 = Collections.unmodifiableList(list1);  \n```\nJava细节（3.2）：生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常\n\n## 推荐使用subList处理局部列表\n\n在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：\n\n```java\nfor(int i = 0 ; i < list1.size() ; i++){  \n   if(i >= 100 && i <= 200){  \n       list1.remove(i);  \n       /* \n        * 当然这段代码存在问题，list remove之后后面的元素会填充上来， \n        * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。 \n        */  \n   }  \n}  \n```\n这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：\n\n```java\nlist1.subList(100, 200).clear();  \n```\n简单而不失华丽！！！！！\n","source":"_posts/java-toup36.md","raw":"---\ntitle: Java提高篇（三七）—–Java集合细节（三）：subList的缺陷\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: '46384154'\ndate: 2017-10-24 13:10:28\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/44102915\n\n我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。\n\n## subList返回仅仅只是一个视图\n\n首先我们先看如下实例：\n\n```java\n    public static void main(String[] args) {  \n        List<Integer> list1 = new ArrayList<Integer>();  \n        list1.add(1);  \n        list1.add(2);  \n          \n        //通过构造函数新建一个包含list1的列表 list2  \n        List<Integer> list2 = new ArrayList<Integer>(list1);  \n          \n        //通过subList生成一个与list1一样的列表 list3  \n        List<Integer> list3 = list1.subList(0, list1.size());  \n          \n        //修改list3  \n        list3.add(3);  \n          \n        System.out.println(\"list1 == list2：\" + list1.equals(list2));  \n        System.out.println(\"list1 == list3：\" + list1.equals(list3));  \n    }  \n```\n<!-- more -->\n这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：\n\n```java\nlist1 == list2：true  \nlist1 == list3: false  \n```\n首先我们先不论结果的正确与否，我们先看subList的源码：\n\n```java\n    public List<E> subList(int fromIndex, int toIndex) {  \n        subListRangeCheck(fromIndex, toIndex, size);  \n        return new SubList(this, 0, fromIndex, toIndex);  \n    }  \n```\nsubListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。\n\n```java\n    /** \n     * 继承AbstractList类，实现RandomAccess接口 \n     */  \n    private class SubList extends AbstractList<E> implements RandomAccess {  \n        private final AbstractList<E> parent;    //列表  \n        private final int parentOffset;     \n        private final int offset;  \n        int size;  \n  \n        //构造函数  \n        SubList(AbstractList<E> parent,  \n                int offset, int fromIndex, int toIndex) {  \n            this.parent = parent;  \n            this.parentOffset = fromIndex;  \n            this.offset = offset + fromIndex;  \n            this.size = toIndex - fromIndex;  \n            this.modCount = ArrayList.this.modCount;  \n        }  \n  \n        //set方法  \n        public E set(int index, E e) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            E oldValue = ArrayList.this.elementData(offset + index);  \n            ArrayList.this.elementData[offset + index] = e;  \n            return oldValue;  \n        }  \n  \n        //get方法  \n        public E get(int index) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            return ArrayList.this.elementData(offset + index);  \n        }  \n  \n        //add方法  \n        public void add(int index, E e) {  \n            rangeCheckForAdd(index);  \n            checkForComodification();  \n            parent.add(parentOffset + index, e);  \n            this.modCount = parent.modCount;  \n            this.size++;  \n        }  \n  \n        //remove方法  \n        public E remove(int index) {  \n            rangeCheck(index);  \n            checkForComodification();  \n            E result = parent.remove(parentOffset + index);  \n            this.modCount = parent.modCount;  \n            this.size--;  \n            return result;  \n        }  \n    }  \n```\n该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：\n1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。\n\n2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。\n\n我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：\n\n```java\nparent.add(parentOffset + index, e);  \nthis.modCount = parent.modCount;  \n```\nremove方法里面的\n\n```java\nE result = parent.remove(parentOffset + index);  \nthis.modCount = parent.modCount;  \n```\n诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。\n\n那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：\n\n```java\nlist1 == list2：false  \nlist1 == list3：true  \n```\nJava细节（3.1）：subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上\n\n## subList生成子列表后，不要试图去操作原列表\n\n从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？\n\n```java\n    public static void main(String[] args) {  \n        List<Integer> list1 = new ArrayList<Integer>();  \n        list1.add(1);  \n        list1.add(2);  \n          \n        //通过subList生成一个与list1一样的列表 list3  \n        List<Integer> list3 = list1.subList(0, list1.size());  \n        //修改list3  \n        list1.add(3);  \n          \n        System.out.println(\"list1'size：\" + list1.size());  \n        System.out.println(\"list3'size：\" + list3.size());  \n    }  \n```\n该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：\n\n```java\nlist1'size：3  \nException in thread \"main\" java.util.ConcurrentModificationException  \n    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)  \n    at java.util.ArrayList$SubList.size(Unknown Source)  \n    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)  \n```\nlist1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了（更多请点这里：Java提高篇（三四）—–fail-fast机制）。我们再看size方法：\n\n```java\n        public int size() {  \n            checkForComodification();  \n            return this.size;  \n        }  \n```\nsize方法首先会通过checkForComodification验证，然后再返回this.size。\n\n```java\n        private void checkForComodification() {  \n            if (ArrayList.this.modCount != this.modCount)  \n                throw new ConcurrentModificationException();  \n        }  \n```\n该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。\n\n对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：\n\n```java\n//通过subList生成一个与list1一样的列表 list3  \nList<Integer> list3 = list1.subList(0, list1.size());  \n          \n//对list1设置为只读状态  \nlist1 = Collections.unmodifiableList(list1);  \n```\nJava细节（3.2）：生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常\n\n## 推荐使用subList处理局部列表\n\n在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：\n\n```java\nfor(int i = 0 ; i < list1.size() ; i++){  \n   if(i >= 100 && i <= 200){  \n       list1.remove(i);  \n       /* \n        * 当然这段代码存在问题，list remove之后后面的元素会填充上来， \n        * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。 \n        */  \n   }  \n}  \n```\n这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：\n\n```java\nlist1.subList(100, 200).clear();  \n```\n简单而不失华丽！！！！！\n","slug":"java-toup36","published":1,"updated":"2019-09-03T03:40:46.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfl00380vfaab1htujq","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/44102915\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/44102915</a></p></blockquote><p>我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。</p><h2 id=\"subList返回仅仅只是一个视图\"><a href=\"#subList返回仅仅只是一个视图\" class=\"headerlink\" title=\"subList返回仅仅只是一个视图\"></a>subList返回仅仅只是一个视图</h2><p>首先我们先看如下实例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    List&lt;Integer&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class=\"line\">    list1.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list1.add(<span class=\"number\">2</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过构造函数新建一个包含list1的列表 list2  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(list1);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//修改list3  </span></span><br><span class=\"line\">    list3.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 == list2：\"</span> + list1.equals(list2));  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 == list3：\"</span> + list1.equals(list3));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><p>这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 == list2：<span class=\"keyword\">true</span>  </span><br><span class=\"line\">list1 == list3: <span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure><p>首先我们先不论结果的正确与否，我们先看subList的源码：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;  </span><br><span class=\"line\">    subListRangeCheck(fromIndex, toIndex, size);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SubList(<span class=\"keyword\">this</span>, <span class=\"number\">0</span>, fromIndex, toIndex);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 继承AbstractList类，实现RandomAccess接口 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractList&lt;E&gt; parent;    <span class=\"comment\">//列表  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentOffset;     </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//构造函数  </span></span><br><span class=\"line\">    SubList(AbstractList&lt;E&gt; parent,  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parentOffset = fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.offset = offset + fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = toIndex - fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = ArrayList.<span class=\"keyword\">this</span>.modCount;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//set方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        E oldValue = ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);  </span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.elementData[offset + index] = e;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//get方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//add方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheckForAdd(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        parent.add(parentOffset + index, e);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = parent.modCount;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//remove方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        E result = parent.remove(parentOffset + index);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = parent.modCount;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size--;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：<br>1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。</p><p>2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。</p><p>我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.add(parentOffset + index, e);  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.modCount = parent.modCount;</span><br></pre></td></tr></table></figure><p>remove方法里面的</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E result = parent.remove(parentOffset + index);  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.modCount = parent.modCount;</span><br></pre></td></tr></table></figure><p>诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。</p><p>那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 == list2：<span class=\"keyword\">false</span>  </span><br><span class=\"line\">list1 == list3：<span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure><p>Java细节（3.1）：subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上</p><h2 id=\"subList生成子列表后，不要试图去操作原列表\"><a href=\"#subList生成子列表后，不要试图去操作原列表\" class=\"headerlink\" title=\"subList生成子列表后，不要试图去操作原列表\"></a>subList生成子列表后，不要试图去操作原列表</h2><p>从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    List&lt;Integer&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class=\"line\">    list1.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list1.add(<span class=\"number\">2</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">    <span class=\"comment\">//修改list3  </span></span><br><span class=\"line\">    list1.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1'size：\"</span> + list1.size());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list3'size：\"</span> + list3.size());  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1<span class=\"string\">'size：3  </span></span><br><span class=\"line\"><span class=\"string\">Exception in thread \"main\" java.util.ConcurrentModificationException  </span></span><br><span class=\"line\"><span class=\"string\">    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)  </span></span><br><span class=\"line\"><span class=\"string\">    at java.util.ArrayList$SubList.size(Unknown Source)  </span></span><br><span class=\"line\"><span class=\"string\">    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)</span></span><br></pre></td></tr></table></figure><p>list1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了（更多请点这里：Java提高篇（三四）—–fail-fast机制）。我们再看size方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>size方法首先会通过checkForComodification验证，然后再返回this.size。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ArrayList.<span class=\"keyword\">this</span>.modCount != <span class=\"keyword\">this</span>.modCount)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。</p><p>对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"comment\">//对list1设置为只读状态  </span></span><br><span class=\"line\">list1 = Collections.unmodifiableList(list1);</span><br></pre></td></tr></table></figure><p>Java细节（3.2）：生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常</p><h2 id=\"推荐使用subList处理局部列表\"><a href=\"#推荐使用subList处理局部列表\" class=\"headerlink\" title=\"推荐使用subList处理局部列表\"></a>推荐使用subList处理局部列表</h2><p>在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; list1.size() ; i++)&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">100</span> &amp;&amp; i &lt;= <span class=\"number\">200</span>)&#123;  </span><br><span class=\"line\">       list1.remove(i);  </span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        * 当然这段代码存在问题，list remove之后后面的元素会填充上来， </span></span><br><span class=\"line\"><span class=\"comment\">        * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span>  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.subList(<span class=\"number\">100</span>, <span class=\"number\">200</span>).clear();</span><br></pre></td></tr></table></figure><p>简单而不失华丽！！！！！</p><!-- rebuild by neat -->","site":{"data":{}},"length":6258,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/44102915\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/44102915</a></p></blockquote><p>我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。</p><h2 id=\"subList返回仅仅只是一个视图\"><a href=\"#subList返回仅仅只是一个视图\" class=\"headerlink\" title=\"subList返回仅仅只是一个视图\"></a>subList返回仅仅只是一个视图</h2><p>首先我们先看如下实例：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    List&lt;Integer&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class=\"line\">    list1.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list1.add(<span class=\"number\">2</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过构造函数新建一个包含list1的列表 list2  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list2 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;(list1);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//修改list3  </span></span><br><span class=\"line\">    list3.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 == list2：\"</span> + list1.equals(list2));  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1 == list3：\"</span> + list1.equals(list3));  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 == list2：<span class=\"keyword\">true</span>  </span><br><span class=\"line\">list1 == list3: <span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure><p>首先我们先不论结果的正确与否，我们先看subList的源码：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span> </span>&#123;  </span><br><span class=\"line\">    subListRangeCheck(fromIndex, toIndex, size);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SubList(<span class=\"keyword\">this</span>, <span class=\"number\">0</span>, fromIndex, toIndex);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 继承AbstractList类，实现RandomAccess接口 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubList</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RandomAccess</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractList&lt;E&gt; parent;    <span class=\"comment\">//列表  </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> parentOffset;     </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> offset;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//构造函数  </span></span><br><span class=\"line\">    SubList(AbstractList&lt;E&gt; parent,  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset, <span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parentOffset = fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.offset = offset + fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = toIndex - fromIndex;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = ArrayList.<span class=\"keyword\">this</span>.modCount;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//set方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        E oldValue = ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);  </span><br><span class=\"line\">        ArrayList.<span class=\"keyword\">this</span>.elementData[offset + index] = e;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//get方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> ArrayList.<span class=\"keyword\">this</span>.elementData(offset + index);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//add方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E e)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheckForAdd(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        parent.add(parentOffset + index, e);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = parent.modCount;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//remove方法  </span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;  </span><br><span class=\"line\">        rangeCheck(index);  </span><br><span class=\"line\">        checkForComodification();  </span><br><span class=\"line\">        E result = parent.remove(parentOffset + index);  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.modCount = parent.modCount;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size--;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：<br>1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。</p><p>2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。</p><p>我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.add(parentOffset + index, e);  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.modCount = parent.modCount;</span><br></pre></td></tr></table></figure><p>remove方法里面的</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E result = parent.remove(parentOffset + index);  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.modCount = parent.modCount;</span><br></pre></td></tr></table></figure><p>诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。</p><p>那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 == list2：<span class=\"keyword\">false</span>  </span><br><span class=\"line\">list1 == list3：<span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure><p>Java细节（3.1）：subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上</p><h2 id=\"subList生成子列表后，不要试图去操作原列表\"><a href=\"#subList生成子列表后，不要试图去操作原列表\" class=\"headerlink\" title=\"subList生成子列表后，不要试图去操作原列表\"></a>subList生成子列表后，不要试图去操作原列表</h2><p>从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">    List&lt;Integer&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class=\"line\">    list1.add(<span class=\"number\">1</span>);  </span><br><span class=\"line\">    list1.add(<span class=\"number\">2</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">    List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">    <span class=\"comment\">//修改list3  </span></span><br><span class=\"line\">    list1.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">      </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list1'size：\"</span> + list1.size());  </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"list3'size：\"</span> + list3.size());  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1<span class=\"string\">'size：3  </span></span><br><span class=\"line\"><span class=\"string\">Exception in thread \"main\" java.util.ConcurrentModificationException  </span></span><br><span class=\"line\"><span class=\"string\">    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)  </span></span><br><span class=\"line\"><span class=\"string\">    at java.util.ArrayList$SubList.size(Unknown Source)  </span></span><br><span class=\"line\"><span class=\"string\">    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)</span></span><br></pre></td></tr></table></figure><p>list1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了（更多请点这里：Java提高篇（三四）—–fail-fast机制）。我们再看size方法：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    checkForComodification();  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.size;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>size方法首先会通过checkForComodification验证，然后再返回this.size。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ArrayList.<span class=\"keyword\">this</span>.modCount != <span class=\"keyword\">this</span>.modCount)  </span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。</p><p>对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过subList生成一个与list1一样的列表 list3  </span></span><br><span class=\"line\">List&lt;Integer&gt; list3 = list1.subList(<span class=\"number\">0</span>, list1.size());  </span><br><span class=\"line\">          </span><br><span class=\"line\"><span class=\"comment\">//对list1设置为只读状态  </span></span><br><span class=\"line\">list1 = Collections.unmodifiableList(list1);</span><br></pre></td></tr></table></figure><p>Java细节（3.2）：生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常</p><h2 id=\"推荐使用subList处理局部列表\"><a href=\"#推荐使用subList处理局部列表\" class=\"headerlink\" title=\"推荐使用subList处理局部列表\"></a>推荐使用subList处理局部列表</h2><p>在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; list1.size() ; i++)&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">if</span>(i &gt;= <span class=\"number\">100</span> &amp;&amp; i &lt;= <span class=\"number\">200</span>)&#123;  </span><br><span class=\"line\">       list1.remove(i);  </span><br><span class=\"line\">       <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        * 当然这段代码存在问题，list remove之后后面的元素会填充上来， </span></span><br><span class=\"line\"><span class=\"comment\">        * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。 </span></span><br><span class=\"line\"><span class=\"comment\">        */</span>  </span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1.subList(<span class=\"number\">100</span>, <span class=\"number\">200</span>).clear();</span><br></pre></td></tr></table></figure><p>简单而不失华丽！！！！！</p><!-- rebuild by neat -->"},{"title":"java提高篇（三）-----理解java的三大特性之多态","abbrlink":"522e350e","date":"2017-10-23T03:23:01.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12786385](http://blog.csdn.net/chenssy/article/details/12786385)\n\n\n面向对象编程有三大特性：封装、继承、多态。\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：\n <font color=\"#0000ff\">**所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。**</font>\n <!-- more -->\n       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：\n       酒 a = 剑南春\n       酒 b = 五粮液\n       酒 c = 酒鬼酒\n       …\n       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。\n       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：\n       JNC a = new JNC();\n       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？\n       Wine a = new JNC();\n       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。\n       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了---1。\n\n```java\n    public class Wine {  \n        public void fun1(){  \n            System.out.println(\"Wine 的Fun.....\");  \n            fun2();  \n        }  \n        \n        public void fun2(){  \n            System.out.println(\"Wine 的Fun2...\");  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        /** \n        * @desc 子类重写父类方法 \n        *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 \n        * @param a \n        * @return void \n        */  \n        public void fun1(String a){  \n            System.out.println(\"JNC 的 Fun1...\");  \n            fun2();  \n        }  \n        \n        /** \n        * 子类重写父类方法 \n        * 指向子类的父类引用调用fun2时，必定是调用该方法 \n        */  \n        public void fun2(){  \n            System.out.println(\"JNC 的Fun2...\");  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            Wine a = new JNC();  \n            a.fun1();  \n        }  \n    }  \n    -------------------------------------------------  \n    Output:  \n    Wine 的Fun.....  \n    JNC 的Fun2... \n```\n从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。\n      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。\n      所以对于多态我们可以总结如下：\n      <font color=\"#0000ff\">**指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。**</font>\n      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n\n## 多态的实现\n\n### 实现条件\n在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。\n\n<font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font>\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font>\n\n### 实现形式\n在Java中有两种形式可以实现多态。继承和接口。\n\n#### 基于继承实现的多态\n基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。\n```java\n    public class Wine {  \n        private String name;  \n        \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Wine(){  \n        }  \n        \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return null;  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        public JNC(){  \n            setName(\"JNC\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class JGJ extends Wine{  \n        public JGJ(){  \n            setName(\"JGJ\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            //定义父类数组  \n            Wine[] wines = new Wine[2];  \n            //定义两个子类  \n            JNC jnc = new JNC();  \n            JGJ jgj = new JGJ();  \n            \n            //父类引用子类对象  \n            wines[0] = jnc;  \n            wines[1] = jgj;  \n            \n            for(int i = 0 ; i < 2 ; i++){  \n                System.out.println(wines[i].toString() + \"--\" + wines[i].drink());  \n            }  \n            System.out.println(\"-------------------------------\");  \n    \n        }  \n    }  \n    OUTPUT:  \n    Wine : JNC--喝的是 JNC  \n    Wine : JGJ--喝的是 JGJ  \n    -------------------------------  \n```\n在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。\n我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：\n```html\n    Object o = new JGJ();  \n    System.out.println(o.toString()); \n```\n输出的结果是Wine : JGJ。\n      Object、Wine、JGJ三者继承链关系是：JGJ—>Wine—>Object。所以我们可以这样说：<font color=\"#0000ff\">**当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用**</font>。但是注意如果这样写：\n```java\n    Object o = new Wine();  \n    System.out.println(o.toString()); \n```\n 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。\n所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\">**对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。**</font>\n如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。\n\n#### 基于接口实现的多态\n继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。\n在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。\n继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。\n\n## 经典实例\n\n通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：[http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx](http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx)。\n\n```java\n    public class A {  \n        public String show(D obj) {  \n            return (\"A and D\");  \n        }  \n    \n        public String show(A obj) {  \n            return (\"A and A\");  \n        }   \n    \n    }  \n    \n    public class B extends A{  \n        public String show(B obj){  \n            return (\"B and B\");  \n        }  \n        \n        public String show(A obj){  \n            return (\"B and A\");  \n        }   \n    }  \n    \n    public class C extends B{  \n    \n    }  \n    \n    public class D extends B{  \n    \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            A a1 = new A();  \n            A a2 = new B();  \n            B b = new B();  \n            C c = new C();  \n            D d = new D();  \n            \n            System.out.println(\"1--\" + a1.show(b));  \n            System.out.println(\"2--\" + a1.show(c));  \n            System.out.println(\"3--\" + a1.show(d));  \n            System.out.println(\"4--\" + a2.show(b));  \n            System.out.println(\"5--\" + a2.show(c));  \n            System.out.println(\"6--\" + a2.show(d));  \n            System.out.println(\"7--\" + b.show(b));  \n            System.out.println(\"8--\" + b.show(c));  \n            System.out.println(\"9--\" + b.show(d));        \n        }  \n    }  \n\n```\n\n 运行结果：\n\n ```java\n    1--A and A  \n    2--A and A  \n    3--A and D  \n    4--B and A  \n    5--B and A  \n    6--A and D  \n    7--B and B  \n    8--B and B  \n    9--A and D \n ````\n\n 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？\n首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\">**其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)**</font>。\n分析：\n从上面的程序中我们可以看出A、B、C、D存在如下关系。\n![](/uploads/java4-1.png)\n\n首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。\n      按照同样的方法我也可以确认其他的答案。\n      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；\n      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。\n      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。\n      参考资料：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\n      百度文库：http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\n","source":"_posts/java-toup4.md","raw":"---\ntitle: java提高篇（三）-----理解java的三大特性之多态\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 522e350e\ndate: 2017-10-23 11:23:01\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12786385](http://blog.csdn.net/chenssy/article/details/12786385)\n\n\n面向对象编程有三大特性：封装、继承、多态。\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：\n <font color=\"#0000ff\">**所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。**</font>\n <!-- more -->\n       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：\n       酒 a = 剑南春\n       酒 b = 五粮液\n       酒 c = 酒鬼酒\n       …\n       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。\n       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：\n       JNC a = new JNC();\n       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？\n       Wine a = new JNC();\n       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。\n       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了---1。\n\n```java\n    public class Wine {  \n        public void fun1(){  \n            System.out.println(\"Wine 的Fun.....\");  \n            fun2();  \n        }  \n        \n        public void fun2(){  \n            System.out.println(\"Wine 的Fun2...\");  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        /** \n        * @desc 子类重写父类方法 \n        *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 \n        * @param a \n        * @return void \n        */  \n        public void fun1(String a){  \n            System.out.println(\"JNC 的 Fun1...\");  \n            fun2();  \n        }  \n        \n        /** \n        * 子类重写父类方法 \n        * 指向子类的父类引用调用fun2时，必定是调用该方法 \n        */  \n        public void fun2(){  \n            System.out.println(\"JNC 的Fun2...\");  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            Wine a = new JNC();  \n            a.fun1();  \n        }  \n    }  \n    -------------------------------------------------  \n    Output:  \n    Wine 的Fun.....  \n    JNC 的Fun2... \n```\n从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。\n      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。\n      所以对于多态我们可以总结如下：\n      <font color=\"#0000ff\">**指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。**</font>\n      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n\n## 多态的实现\n\n### 实现条件\n在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。\n\n<font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font>\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font>\n\n### 实现形式\n在Java中有两种形式可以实现多态。继承和接口。\n\n#### 基于继承实现的多态\n基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。\n```java\n    public class Wine {  \n        private String name;  \n        \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Wine(){  \n        }  \n        \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return null;  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        public JNC(){  \n            setName(\"JNC\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class JGJ extends Wine{  \n        public JGJ(){  \n            setName(\"JGJ\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            //定义父类数组  \n            Wine[] wines = new Wine[2];  \n            //定义两个子类  \n            JNC jnc = new JNC();  \n            JGJ jgj = new JGJ();  \n            \n            //父类引用子类对象  \n            wines[0] = jnc;  \n            wines[1] = jgj;  \n            \n            for(int i = 0 ; i < 2 ; i++){  \n                System.out.println(wines[i].toString() + \"--\" + wines[i].drink());  \n            }  \n            System.out.println(\"-------------------------------\");  \n    \n        }  \n    }  \n    OUTPUT:  \n    Wine : JNC--喝的是 JNC  \n    Wine : JGJ--喝的是 JGJ  \n    -------------------------------  \n```\n在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。\n我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：\n```html\n    Object o = new JGJ();  \n    System.out.println(o.toString()); \n```\n输出的结果是Wine : JGJ。\n      Object、Wine、JGJ三者继承链关系是：JGJ—>Wine—>Object。所以我们可以这样说：<font color=\"#0000ff\">**当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用**</font>。但是注意如果这样写：\n```java\n    Object o = new Wine();  \n    System.out.println(o.toString()); \n```\n 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。\n所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\">**对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。**</font>\n如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。\n\n#### 基于接口实现的多态\n继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。\n在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。\n继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。\n\n## 经典实例\n\n通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：[http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx](http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx)。\n\n```java\n    public class A {  \n        public String show(D obj) {  \n            return (\"A and D\");  \n        }  \n    \n        public String show(A obj) {  \n            return (\"A and A\");  \n        }   \n    \n    }  \n    \n    public class B extends A{  \n        public String show(B obj){  \n            return (\"B and B\");  \n        }  \n        \n        public String show(A obj){  \n            return (\"B and A\");  \n        }   \n    }  \n    \n    public class C extends B{  \n    \n    }  \n    \n    public class D extends B{  \n    \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            A a1 = new A();  \n            A a2 = new B();  \n            B b = new B();  \n            C c = new C();  \n            D d = new D();  \n            \n            System.out.println(\"1--\" + a1.show(b));  \n            System.out.println(\"2--\" + a1.show(c));  \n            System.out.println(\"3--\" + a1.show(d));  \n            System.out.println(\"4--\" + a2.show(b));  \n            System.out.println(\"5--\" + a2.show(c));  \n            System.out.println(\"6--\" + a2.show(d));  \n            System.out.println(\"7--\" + b.show(b));  \n            System.out.println(\"8--\" + b.show(c));  \n            System.out.println(\"9--\" + b.show(d));        \n        }  \n    }  \n\n```\n\n 运行结果：\n\n ```java\n    1--A and A  \n    2--A and A  \n    3--A and D  \n    4--B and A  \n    5--B and A  \n    6--A and D  \n    7--B and B  \n    8--B and B  \n    9--A and D \n ````\n\n 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？\n首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\">**其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)**</font>。\n分析：\n从上面的程序中我们可以看出A、B、C、D存在如下关系。\n![](/uploads/java4-1.png)\n\n首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。\n      按照同样的方法我也可以确认其他的答案。\n      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；\n      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。\n      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。\n      参考资料：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\n      百度文库：http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\n","slug":"java-toup4","published":1,"updated":"2019-09-03T03:40:46.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfm003b0vfanch9tlls","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12786385\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12786385</a></p></blockquote><p>面向对象编程有三大特性：封装、继承、多态。<br>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。<br>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：<br><font color=\"#0000ff\"><strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></font><br><a id=\"more\"></a><br>比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：<br>酒 a = 剑南春<br>酒 b = 五粮液<br>酒 c = 酒鬼酒<br>…<br>这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。<br>诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：<br>JNC a = new JNC();<br>对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？<br>Wine a = new JNC();<br>在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—-1。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun.....\"</span>);  </span><br><span class=\"line\">        fun2();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun2...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 子类重写父类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> a </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(String a)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的 Fun1...\"</span>);  </span><br><span class=\"line\">        fun2();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 子类重写父类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    * 指向子类的父类引用调用fun2时，必定是调用该方法 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的Fun2...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Wine a = <span class=\"keyword\">new</span> JNC();  </span><br><span class=\"line\">        a.fun1();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Wine 的Fun.....  </span><br><span class=\"line\">JNC 的Fun2...</span><br></pre></td></tr></table></figure><p>从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。<br>分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>所以对于多态我们可以总结如下：<br><font color=\"#0000ff\"><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</strong></font><br>对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h2 id=\"多态的实现\"><a href=\"#多态的实现\" class=\"headerlink\" title=\"多态的实现\"></a>多态的实现</h2><h3 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h3><p>在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。</p><font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font> 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font><h3 id=\"实现形式\"><a href=\"#实现形式\" class=\"headerlink\" title=\"实现形式\"></a>实现形式</h3><p>在Java中有两种形式可以实现多态。继承和接口。</p><h4 id=\"基于继承实现的多态\"><a href=\"#基于继承实现的多态\" class=\"headerlink\" title=\"基于继承实现的多态\"></a>基于继承实现的多态</h4><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Wine</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JNC</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"JNC\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JGJ</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JGJ</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"JGJ\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//定义父类数组  </span></span><br><span class=\"line\">        Wine[] wines = <span class=\"keyword\">new</span> Wine[<span class=\"number\">2</span>];  </span><br><span class=\"line\">        <span class=\"comment\">//定义两个子类  </span></span><br><span class=\"line\">        JNC jnc = <span class=\"keyword\">new</span> JNC();  </span><br><span class=\"line\">        JGJ jgj = <span class=\"keyword\">new</span> JGJ();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//父类引用子类对象  </span></span><br><span class=\"line\">        wines[<span class=\"number\">0</span>] = jnc;  </span><br><span class=\"line\">        wines[<span class=\"number\">1</span>] = jgj;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++)&#123;  </span><br><span class=\"line\">            System.out.println(wines[i].toString() + <span class=\"string\">\"--\"</span> + wines[i].drink());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------------------------------\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">OUTPUT:  </span><br><span class=\"line\">Wine : JNC--喝的是 JNC  </span><br><span class=\"line\">Wine : JGJ--喝的是 JGJ  </span><br><span class=\"line\">-------------------------------</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。<br>我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：<br></p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = new JGJ();  </span><br><span class=\"line\">System.out.println(o.toString());</span><br></pre></td></tr></table></figure><p></p><p>输出的结果是Wine : JGJ。<br>Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：<font color=\"#0000ff\"><strong>当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用</strong></font>。但是注意如果这样写：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = <span class=\"keyword\">new</span> Wine();  </span><br><span class=\"line\">System.out.println(o.toString());</span><br></pre></td></tr></table></figure><p></p><p>输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。<br>所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\"><strong>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</strong></font><br>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</p><h4 id=\"基于接口实现的多态\"><a href=\"#基于接口实现的多态\" class=\"headerlink\" title=\"基于接口实现的多态\"></a>基于接口实现的多态</h4><p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p><h2 id=\"经典实例\"><a href=\"#经典实例\" class=\"headerlink\" title=\"经典实例\"></a>经典实例</h2><p>通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a>。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(D obj)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and D\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and A\"</span>);  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(B obj)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and B\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and A\"</span>);  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        A a1 = <span class=\"keyword\">new</span> A();  </span><br><span class=\"line\">        A a2 = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\">        B b = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\">        C c = <span class=\"keyword\">new</span> C();  </span><br><span class=\"line\">        D d = <span class=\"keyword\">new</span> D();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"1--\"</span> + a1.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"2--\"</span> + a1.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"3--\"</span> + a1.show(d));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"4--\"</span> + a2.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"5--\"</span> + a2.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"6--\"</span> + a2.show(d));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"7--\"</span> + b.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"8--\"</span> + b.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"9--\"</span> + b.show(d));        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">1</span>--A and A  </span><br><span class=\"line\">   <span class=\"number\">2</span>--A and A  </span><br><span class=\"line\">   <span class=\"number\">3</span>--A and D  </span><br><span class=\"line\">   <span class=\"number\">4</span>--B and A  </span><br><span class=\"line\">   <span class=\"number\">5</span>--B and A  </span><br><span class=\"line\">   <span class=\"number\">6</span>--A and D  </span><br><span class=\"line\">   <span class=\"number\">7</span>--B and B  </span><br><span class=\"line\">   <span class=\"number\">8</span>--B and B  </span><br><span class=\"line\">   <span class=\"number\">9</span>--A and D </span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure><p>在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？<br>首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\"><strong>其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></font>。<br>分析：<br>从上面的程序中我们可以看出A、B、C、D存在如下关系。<br><img src=\"/uploads/java4-1.png\" alt></p><p>首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。<br>按照同样的方法我也可以确认其他的答案。<br>方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；<br>这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。<br>所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。<br>参考资料：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a><br>百度文库：<a href=\"http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\" target=\"_blank\" rel=\"noopener\">http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html</a></p><!-- rebuild by neat -->","site":{"data":{}},"length":8866,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12786385\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12786385</a></p></blockquote><p>面向对象编程有三大特性：封装、继承、多态。<br>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。<br>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：<br><font color=\"#0000ff\"><strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></font><br>","more":"<br>比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：<br>酒 a = 剑南春<br>酒 b = 五粮液<br>酒 c = 酒鬼酒<br>…<br>这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。<br>诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：<br>JNC a = new JNC();<br>对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？<br>Wine a = new JNC();<br>在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—-1。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun.....\"</span>);  </span><br><span class=\"line\">        fun2();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun2...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 子类重写父类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> a </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(String a)</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的 Fun1...\"</span>);  </span><br><span class=\"line\">        fun2();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 子类重写父类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    * 指向子类的父类引用调用fun2时，必定是调用该方法 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的Fun2...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Wine a = <span class=\"keyword\">new</span> JNC();  </span><br><span class=\"line\">        a.fun1();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Wine 的Fun.....  </span><br><span class=\"line\">JNC 的Fun2...</span><br></pre></td></tr></table></figure><p>从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。<br>分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>所以对于多态我们可以总结如下：<br><font color=\"#0000ff\"><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</strong></font><br>对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p><h2 id=\"多态的实现\"><a href=\"#多态的实现\" class=\"headerlink\" title=\"多态的实现\"></a>多态的实现</h2><h3 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h3><p>在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。</p><font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font> 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font><h3 id=\"实现形式\"><a href=\"#实现形式\" class=\"headerlink\" title=\"实现形式\"></a>实现形式</h3><p>在Java中有两种形式可以实现多态。继承和接口。</p><h4 id=\"基于继承实现的多态\"><a href=\"#基于继承实现的多态\" class=\"headerlink\" title=\"基于继承实现的多态\"></a>基于继承实现的多态</h4><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Wine</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JNC</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"JNC\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JGJ</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JGJ</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        setName(<span class=\"string\">\"JGJ\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 重写toString() </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//定义父类数组  </span></span><br><span class=\"line\">        Wine[] wines = <span class=\"keyword\">new</span> Wine[<span class=\"number\">2</span>];  </span><br><span class=\"line\">        <span class=\"comment\">//定义两个子类  </span></span><br><span class=\"line\">        JNC jnc = <span class=\"keyword\">new</span> JNC();  </span><br><span class=\"line\">        JGJ jgj = <span class=\"keyword\">new</span> JGJ();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//父类引用子类对象  </span></span><br><span class=\"line\">        wines[<span class=\"number\">0</span>] = jnc;  </span><br><span class=\"line\">        wines[<span class=\"number\">1</span>] = jgj;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++)&#123;  </span><br><span class=\"line\">            System.out.println(wines[i].toString() + <span class=\"string\">\"--\"</span> + wines[i].drink());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"-------------------------------\"</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">OUTPUT:  </span><br><span class=\"line\">Wine : JNC--喝的是 JNC  </span><br><span class=\"line\">Wine : JGJ--喝的是 JGJ  </span><br><span class=\"line\">-------------------------------</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。<br>我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：<br></p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = new JGJ();  </span><br><span class=\"line\">System.out.println(o.toString());</span><br></pre></td></tr></table></figure><p></p><p>输出的结果是Wine : JGJ。<br>Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：<font color=\"#0000ff\"><strong>当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用</strong></font>。但是注意如果这样写：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object o = <span class=\"keyword\">new</span> Wine();  </span><br><span class=\"line\">System.out.println(o.toString());</span><br></pre></td></tr></table></figure><p></p><p>输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。<br>所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\"><strong>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</strong></font><br>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</p><h4 id=\"基于接口实现的多态\"><a href=\"#基于接口实现的多态\" class=\"headerlink\" title=\"基于接口实现的多态\"></a>基于接口实现的多态</h4><p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p><h2 id=\"经典实例\"><a href=\"#经典实例\" class=\"headerlink\" title=\"经典实例\"></a>经典实例</h2><p>通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a>。</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(D obj)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and D\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and A\"</span>);  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(B obj)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and B\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and A\"</span>);  </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        A a1 = <span class=\"keyword\">new</span> A();  </span><br><span class=\"line\">        A a2 = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\">        B b = <span class=\"keyword\">new</span> B();  </span><br><span class=\"line\">        C c = <span class=\"keyword\">new</span> C();  </span><br><span class=\"line\">        D d = <span class=\"keyword\">new</span> D();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"1--\"</span> + a1.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"2--\"</span> + a1.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"3--\"</span> + a1.show(d));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"4--\"</span> + a2.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"5--\"</span> + a2.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"6--\"</span> + a2.show(d));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"7--\"</span> + b.show(b));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"8--\"</span> + b.show(c));  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"9--\"</span> + b.show(d));        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"number\">1</span>--A and A  </span><br><span class=\"line\">   <span class=\"number\">2</span>--A and A  </span><br><span class=\"line\">   <span class=\"number\">3</span>--A and D  </span><br><span class=\"line\">   <span class=\"number\">4</span>--B and A  </span><br><span class=\"line\">   <span class=\"number\">5</span>--B and A  </span><br><span class=\"line\">   <span class=\"number\">6</span>--A and D  </span><br><span class=\"line\">   <span class=\"number\">7</span>--B and B  </span><br><span class=\"line\">   <span class=\"number\">8</span>--B and B  </span><br><span class=\"line\">   <span class=\"number\">9</span>--A and D </span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure><p>在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？<br>首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\"><strong>其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></font>。<br>分析：<br>从上面的程序中我们可以看出A、B、C、D存在如下关系。<br><img src=\"/uploads/java4-1.png\" alt></p><p>首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。<br>按照同样的方法我也可以确认其他的答案。<br>方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；<br>这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。<br>所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。<br>参考资料：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a><br>百度文库：<a href=\"http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\" target=\"_blank\" rel=\"noopener\">http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html</a></p><!-- rebuild by neat -->"},{"title":"提问的智慧","abbrlink":"fb3832f5","date":"2017-10-24T05:10:31.000Z","_content":"\n# 提问的智慧\n\n**How To Ask Questions The Smart Way**\n\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n\n原文网址：[http://www.catb.org/~esr/faqs/smart-questions.html](http://www.catb.org/~esr/faqs/smart-questions.html)\n\nCopyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n<!-- more -->\n## 目录\n  * [声明](#声明)\n  * [简介](#简介)\n  * [在提问之前](#在提问之前)\n  * [当你提问时](#当你提问时)\n    * [慎选提问的论坛](#慎选提问的论坛)\n    * [Stack Overflow](#stack-overflow)\n    * [网站和 IRC 论坛](#网站和-irc-论坛)\n    * [第二步，使用项目邮件列表](#第二步使用项目邮件列表)\n    * [使用有意义且描述明确的标题](#使用有意义且描述明确的标题)\n    * [使问题容易回复](#使问题容易回复)\n    * [用清晰、正确、精准并合法语法的语句](#用清晰正确精准并合法语法的语句)\n    * [使用易于读取且标准的文件格式发送问题](#使用易于读取且标准的文件格式发送问题)\n    * [精确的描述问题并言之有物](#精确的描述问题并言之有物)\n    * [话不在多而在精](#话不在多而在精)\n    * [别动辄声称找到 Bug](#别动辄声称找到-bug)\n    * [可以低声下气，但还是要先做功课](#可以低声下气但还是要先做功课)\n    * [描述问题症状而非猜测](#描述问题症状而非猜测)\n    * [按发生时间先后列出问题症状](#按发生时间先后列出问题症状)\n    * [描述目标而不是过程](#描述目标而不是过程)\n    * [别要求使用私人电邮回复](#别要求使用私人电邮回复)\n    * [清楚明确的表达你的问题以及需求](#清楚明确的表达你的问题以及需求)\n    * [询问有关代码的问题时](#询问有关代码的问题时)\n    * [别把自己家庭作业的问题贴上来](#别把自己家庭作业的问题贴上来)\n    * [去掉无意义的提问句](#去掉无意义的提问句)\n    * [即使你很急也不要在标题写紧急](#即使你很急也不要在标题写紧急)\n    * [礼多人不怪，而且有时还很有帮助](#礼多人不怪而且有时还很有帮助)\n    * [问题解决后，加个简短的补充说明](#问题解决后加个简短的补充说明)\n  * [如何解读答案](#如何解读答案)\n    * [RTFM 和 STFW：如何知道你已完全搞砸了](#rtfm-和-stfw如何知道你已完全搞砸了)\n    * [如果还是搞不懂](#如果还是搞不懂)\n    * [处理无礼的回应](#处理无礼的回应)\n  * [如何避免扮演失败者](#如何避免扮演失败者)\n  * [不该问的问题](#不该问的问题)\n  * [好问题与蠢问题](#好问题与蠢问题)\n  * [如果得不到回答](#如果得不到回答)\n  * [如何更好地回答问题](#如何更好地回答问题)\n  * [相关资源](#相关资源)\n  * [鸣谢](#鸣谢)\n\n## 声明\n\n许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：\n\n****本指南不提供此项目的实际支持服务！****\n\n我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。\n\n如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n\n## 简介\n\n在[黑客](http://www.catb.org/~esr/faqs/hacker-howto.html)的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。\n\n不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件**好事**；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。\n\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，\"好问题！\"是诚挚的大力称赞。\n\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 ``失败者（撸瑟）`` （由于历史原因，我们有时把它拼作 ``lusers``）。\n\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。\n\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答``赢家（winner）``的问题。\n\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 -- 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 -- 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 -- 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n\n（欢迎对本指南提出改进意见。你可以 email 你的建议至 [esr@thyrsus.com](esr@thyrsus.com) 或 [respond-auto@linuxmafia.com](respond-auto@linuxmafia.com)。然而请注意，本文并非[网络礼节](http://www.ietf.org/rfc/rfc1855.txt)的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）\n\n## 在提问之前\n\n在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n  1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n  1. 尝试上网搜索以找到答案。\n  1. 尝试阅读手册以找到答案。\n  1. 尝试阅读常见问题文件（FAQ）以找到答案。\n  1. 尝试自己检查或试验以找到答案\n  1. 向你身边的强者朋友打听以找到答案。\n  1. 如果你是程序开发者，请尝试阅读源代码以找到答案。\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所**学到**的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 [Google 论坛](http://groups.google.com/)，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 ``我在 Google 中搜过下列句子但没有找到什么有用的东西`` 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n\n准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着``蠢问题…``， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n\n绝不要自以为**够格**得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去**挣到**一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 --一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。``谁能给点提示？``、``我的这个例子里缺了什么？``以及``我应该检查什么地方``比``请把我需要的确切的过程贴出来``更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n\n## 当你提问时\n\n### 慎选提问的论坛\n\n小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n  * 在与主题不合的论坛上贴出你的问题\n  * 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然\n  * 在太多的不同新闻群组上重复转贴同样的问题（cross-post）\n  * 向既非熟人也没有义务解决你问题的人发送私人电邮\n\n黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括**阅读** FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 -- 如果你不确定，那就向别处发送，或者压根别发。\n\n在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n\n别像机关枪似的一次\"扫射\"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 -- 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。\n\n### Stack Overflow\n\n搜索，**然后** 在 Stack Exchange 问。\n\n近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\n\nStack Exchange 已经成长到[超过一百个网站](http://stackexchange.com/sites)，以下是最常用的几个站：\n\n* Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。\n* Stack Overflow 是问写程序有关的问题。\n* Server Fault 是问服务器和网管相关的问题。\n\n### 网站和 IRC 论坛\n\n本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 \"用**我们的**版本\"。\n\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n\n通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n\n### 第二步，使用项目邮件列表\n\n当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n\n  * 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。\n  * 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n  * 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n  * 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n如果一个项目既有\"使用者\" 也有\"开发者\"（或\"黑客\"）邮件列表或论坛，而你又不会动到那些源代码，那么就向\"使用者\"列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n\n然而，如果你**确信**你的问题很特别，而且在\"使用者\" 列表或论坛中几天都没有回复，可以试试前往\"开发者\"列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n\n### 使用有意义且描述明确的标题\n\n在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的``帮帮忙``、``跪求``、``急``（更别说``救命啊！！！！``这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n\n一个好标题范例是``目标 -- 差异``式的描述，许多技术支持组织就是这样做的。在``目标``部分指出是哪一个或哪一组东西有问题，在``差异``部分则描述与期望的行为不一致的地方。\n\n\n> 蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n\n> 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。\n\n> 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n编写``目标 -- 差异`` 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境**和**你遇到的问题。\n\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 ``Re: 测试`` 或者 ``Re: 新 bug`` 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你**只想**在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n\n### 使问题容易回复\n\n以``请将你的回复寄到……``来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，[换个好点的](http://linuxmafia.com/faq/Mail/muas.html)；如果是操作系统不支持这种邮件程序，也换个好点的。\n\n在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如``追踪此讨论串``、``有回复时发送邮件提醒``等功能。\n\n### 用清晰、正确、精准并语法正确的语句\n\n我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n\n正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 -- 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它**必须很**准确，而且有迹象表明你是在思考和关注问题。\n\n正确地拼写、使用标点和大小写，不要将``its``混淆为``it's``，``loose``搞成``lose``或者将``discrete``弄成``discreet``。不要**全部用大写**，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。[Alan Cox](http://en.wikipedia.org/wiki/Alan_Cox) 也许可以这样做，但你不行。）\n\n更白话的说，如果你写得像是个半文盲[译注：[小白](http://zh.wikipedia.org/zh-tw/小白)]，那多半得不到理睬。也不要使用即时通讯中的简写或[火星文](http://zh.wikipedia.org/zh-tw/火星文)，如将``的``简化为``ㄉ``会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：\n[译注：以下附上原文以供使用]\n\n> English is not my native language; please excuse typing errors.\n\n* 英文不是我的母语，请原谅我的错字或语法\n\n\n> If you speak $LANGUAGE, please email/PM me;\n> I may need assistance translating my question.\n\n* 如果你说**某语言**，请寄信/私讯给我；我需要有人协助我翻译我的问题\n\n\n> I am familiar with the technical terms,\n> but some slang expressions and idioms are difficult for me.\n\n* 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。\n\n\n> I've posted my question in $LANGUAGE and English.\n> I'll be glad to translate responses, if you only use one or the other.\n\n* 我把我的问题用**某语言**和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。\n\n### 使用易于读取且标准的文件格式发送问题\n\n如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n\n* 使用纯文字而不是 HTML ([关闭 HTML](http://archive.birdhouse.org/etc/evilmail.html) 并不难）。\n* 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。\n* 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。\n* 但是，对一些特殊的文件**不要**设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。\n* 在英语论坛中，不要使用``Quoted-Printable`` MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的``=20``符号既难看也分散注意力，甚至有可能破坏内容的语意。\n* 绝对，**永远**不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。\n* 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的``智能引号``功能 （从[选项] > [校订] > [自动校正选项]，勾选掉``智能引号``单选框），以免在你的邮件中到处散布垃圾字符。\n* 在论坛，勿滥用``表情符号``和``HTML``功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。\n\n如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的``查看源代码``命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n\n### 精确的描述问题并言之有物\n\n* 仔细、清楚地描述你的问题或 Bug 的症状。\n* 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：``Fedora Core 4``、``Slackware 9.1``等）。\n* 描述在提问前你是怎样去研究和理解这个问题的。\n* 描述在提问前为确定问题而采取的诊断步骤。\n* 描述最近做过什么可能相关的硬件或软件变更。\n* 尽可能的提供一个可以``重现这个问题的可控环境``的方法。\n\n尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。\n\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\n\n[Simon Tatham](http://www.chiark.greenend.org.uk/~sgtatham/) 写过一篇名为《[如何有效的报告 Bug](http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html)》的出色文章。强力推荐你也读一读。\n\n### 话不在多而在精\n\n你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n\n这样做的用处至少有三点。\n第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；\n第二，简化问题使你更有可能得到**有用**的答案；\n第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n\n### 别动辄声称找到 Bug\n\n当你在使用软件中遇到问题，除非你非常、**非常**的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的``Bug``，你应该能提供相应位置的修正或替代文件。\n\n请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前[已经做了这些，是吧](#在提问之前)？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有``Bug``时，这尤其严重。\n\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是**你**做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n\n### 低声下气不能代替你的功课\n\n有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 -- 低声下气：``我知道我只是个可悲的新手，一个撸瑟，但...``。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n\n### 描述问题症状而非你的猜测\n\n告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n\n***蠢问题***\n\n> 我在编译内核时接连遇到 SIG11 错误，\n> 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n\n***聪明问题***\n> 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），\n> 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，\n> 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。\n> 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。\n\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：``所有的诊断专家都来自密苏里州。`` 美国国务院的官方座右铭则是：``让我看看``（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：``我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。``） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！\n\n### 按发生时间先后列出问题症状\n\n问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，``多``不等于``好``。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n\n### 描述目标而不是过程\n\n如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n\n**蠢问题**\n> 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？\n\n**聪明问题**\n> 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），\n> 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。\n\n第二种提问法比较聪明，你可能得到像是``建议采用另一个更合适的工具``的回复。\n\n### 别要求使用私人电邮回复\n\n黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让**回复者**来决定是否私下回答 -- 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。\n\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是``向我发电邮，我将为论坛归纳这些回复``。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 -- 但你必须信守诺言。\n\n### 清楚明确的表达你的问题以及需求\n\n漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 -- 但这技巧通常和简化问题有所区别。因此，问``我想更好的理解 X，可否指点一下哪有好一点说明？``通常比问``你能解释一下 X 吗？``更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n\n### 询问有关代码的问题时\n\n别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：``它不能工作``会让你完全被忽略。只贴几十行代码，然后说一句：``在第七行以后，我期待它显示 <x>，但实际出现的是 <y>``比较有可能让你得到回应。\n\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能**刚好**展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看[话不在多而在精](#话不在多而在精)一节）。\n\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n\n### 别把自己家庭作业的问题贴上来\n\n黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由**你**来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的**使用者**邮件列表或论坛中提问。尽管黑客们**会**看出来，但一些有经验的使用者也许仍会给你一些提示。\n\n### 去掉无意义的提问句\n\n避免用无意义的话结束提问，例如``有人能帮我吗？``或者``这有答案吗？``。\n\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 -- 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：``没错，有人能帮你``或者``不，没答案``。\n\n一般来说，避免用 ``是或否``、``对或错``、``有或没有``类型的问句，除非你想得到[是或否类型的回答](http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html)。\n\n### 即使你很急也不要在标题写``紧急``\n\n这是你的问题，不是我们的。宣称``紧急``极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，``紧急``这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 -- 你希望能看到你问题的人可能永远也看不到。\n\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如``紧急：帮我救救这个毛绒绒的小海豹！``肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。\n\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。\n\n### 礼多人不怪，而且有时还很有帮助\n\n彬彬有礼，多用``请``和``谢谢您的关注``，或``谢谢你的关照``。让大家都知道你对他们花时间免费提供帮助心存感激。\n\n坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）\n\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n\n（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得``先谢了``意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说``先谢了``，**然后**事后再对回复者表示感谢，或者换种方式表达感激，譬如用``谢谢你的关注``或``谢谢你的关照``。）\n\n### 问题解决后，加个简短的补充说明\n\n问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含``已修正``，``已解决``或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串``问题 X``和``问题 X - 已解决``的潜在回复者就明白不用再浪费时间了（除非他个人觉得``问题 X``的有趣），因此可以利用此时间去解决其它问题。\n\n补充说明不必很长或是很深入；简单的一句``你好，原来是网线出了问题！谢谢大家 – Bill``比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此**之后**才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n\n## 如何解读答案\n\n<a id=\"RTFM\"></a>\n### RTFM 和 STFW：如何知道你已完全搞砸了\n\n有一个古老而神圣的传统：如果你收到``RTFM （Read The Fucking Manual）``的回应，回答者认为你**应该去读他妈的手册**。当然，基本上他是对的，你应该去读一读。\n\nRTFM 有一个年轻的亲戚。如果你收到``STFW（Search The Fucking Web）``的回应，回答者认为你**应该到他妈的网上搜索**过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **[Google 是你的朋友](http://lmgtfy.com/)**！）\n\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为\n\n* **你需要的信息非常容易获得**；\n* **你自己去搜索这些信息比灌给你，能让你学到更多**。\n\n你不应该因此不爽；**依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见**。你应该对他祖母般的慈祥表示感谢。\n\n### 如果还是搞不懂\n\n如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。\n\n比方说，如果我回答你：``看来似乎是 zentry 卡住了；你应该先清除它。``，然后，这是一个**很糟的**后续问题回应：``zentry 是什么？`` **好**的问法应该是这样：``哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？``\n\n### 处理无礼的回应\n\n很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这**没有**发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而**你**将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。\n\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会**正常**交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们**喜欢**我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）\n\nJeff Bigler 的观察总结和这个相关也值得一读 (**[tact filters](http://www.mit.edu/~jcb/tact.html)**)。\n\n在下一节，我们会谈到另一个问题，当**你**行为不当时所会受到的``冒犯``。\n\n## 如何避免扮演失败者\n\n在黑客社区的论坛中有那么几次你可能会搞砸 -- 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：\n\n熬过去，这很正常。事实上，它是有益健康且合理的。\n\n社区的标准不会自行维持，它们是通过参与者积极而**公开地**执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。\n\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称``如果你不想帮助用户就闭嘴。`` 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。\n\n夸张的讲法是：你要的是**友善**（以上述方式）还是有用？两个里面挑一个。\n\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心**你**和**他的社区**而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。\n\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是**真的**会把问题搞砸。\n\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。\n\n也别让自己卷入口水战，最好不要理睬大多数的口水战 -- 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n\n## 不该问的问题\n\n以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n\n问题：[我能在哪找到 X 程序或 X 资源？](#q1)\n\n问题：[我怎样用 X 做 Y？](#q2)\n\n问题：[如何设定我的 shell 提示？](#q3)\n\n问题：[我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？](#q4)\n\n问题：[我的程序/设定/SQL 语句没有用](#q5)\n\n问题：[我的 Windows 电脑有问题，你能帮我吗？](#q6)\n\n问题：[我的程序不会动了，我认为系统工具 X 有问题](#q7)\n\n问题：[我在安装 Linux（或者 X ）时有问题，你能帮我吗？](#q8)\n\n问题：[我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？](#q9)\n\n---\n\n<a id=\"q1\"></a>\n> 问题：我能在哪找到 X 程序或 X 资源？\n\n回答：就在我找到它的地方啊，白痴 -- 搜索引擎的那一头。天哪！难道还有人不会用 [Google](http://www.google.com) 吗？\n\n<a id=\"q2\"></a>\n> 问题：我怎样用 X 做 Y？\n\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n\n<a id=\"q3\"></a>\n>问题：如何设定我的 shell 提示？？\n\n\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 [RTFM](#RTFM)，然后自己去找出来。\n\n<a id=\"q4\"></a>\n> 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？\n\n\n回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。\n\n<a id=\"q5\"></a>\n> 问题：我的{程序/设定/SQL 语句}不工作\n\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 -- 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n\n  * 你还有什么要补充的吗？\n  * 真糟糕，希望你能搞定。\n  * 这关我有什么屁事？\n\n<a id=\"q6\"></a>\n> 问题：我的 Windows 电脑有问题，你能帮我吗？\n\n回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。\n\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你**可以**问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n\n<a id=\"q7\"></a>\n> 问题：我的程序不会动了，我认为系统工具 X 有问题\n\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。\n\n<a id=\"q8\"></a>\n> 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在[这儿](http://www.linux.org/groups/index.html)找到使用者群组的清单）。\n\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 ``Linux`` 和**所有**被怀疑的硬件作关键词仔细搜索。\n\n<a id=\"q9\"></a>\n> 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n\n## 好问题与蠢问题\n\n最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。\n\n\n****蠢问题****：\n\n> 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n\n这种问法无非想得到 [STFW](#RTFM) 这样的回答。\n\n****聪明问题****：\n\n> 我用 Google 搜索过 \"Foonly Flurbamatic 2600\"，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？\n\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n\n\n****蠢问题****\n\n> 我从 foo 项目找来的源码没法编译。它怎么这么烂？\n\n他觉得都是别人的错，这个傲慢自大的提问者。\n\n****聪明问题****\n\n> foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？\n\n提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。\n\n\n****蠢问题****\n\n> 我的主机板有问题了，谁来帮我？\n\n某黑客对这类问题的回答通常是：``好的，还要帮你拍拍背和换尿布吗？``，然后按下删除键。\n\n****聪明问题****\n\n> 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。\n\n在最后一个问题中，注意``告诉我答案``和``给我启示，指出我还应该做什么诊断工作``之间微妙而又重要的区别。\n\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。\n\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。\n\n事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的**名**人，而是因为我用了正确的方式来提问。\n\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我**像**个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。\n\n## 如果得不到回答\n\n如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n\n总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n\n有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了-- 完全可能如此 --你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。\n\n## 如何更好地回答问题\n\n**态度和善一点**。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n\n**对初犯者私下回复**。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n\n**如果你不确定，一定要说出来**！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n\n**如果帮不了忙，也别妨碍他**。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 --有些可怜的呆瓜会把它当成真的指令。\n\n**试探性的反问以引出更多的细节**。如果你做得好，提问者可以学到点东西 --你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n\n尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。\n\n**如果你决定回答，就请给出好的答案**。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。\n\n**正面的回答问题**！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 ``试试看 A 或是 B`` 或者 ``试试 X 、 Y 、 Z 、 A 、 B 、 C`` 并附上一个链接一点用都没有。\n\n**帮助你的社区从问题中学习**。当回复一个好问题时，问问自己``如何修改相关文件或常见问题文件以免再次解答同样的问题？``，接着再向文件维护者发一份补丁。\n\n如果你是在研究一番后才做出的回答，**展现你的技巧而不是直接端出结果**。毕竟``授人以鱼不如授人以渔``。\n\n## 相关资源\n\n如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 [Unix 系统和网络基本原理](http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/)。\n\n当你发布软件或补丁时，试着按[软件发布实践](http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html)操作。\n\n## 鸣谢\nEvelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写``如何更好地回答问题``这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","source":"_posts/java-toup37.md","raw":"---\ntitle: 提问的智慧\ntags:\n  - 随笔\ncategories: 转载\nabbrlink: fb3832f5\ndate: 2017-10-24 13:10:31\n---\n\n# 提问的智慧\n\n**How To Ask Questions The Smart Way**\n\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen\n\n本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n\n原文网址：[http://www.catb.org/~esr/faqs/smart-questions.html](http://www.catb.org/~esr/faqs/smart-questions.html)\n\nCopyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu\n<!-- more -->\n## 目录\n  * [声明](#声明)\n  * [简介](#简介)\n  * [在提问之前](#在提问之前)\n  * [当你提问时](#当你提问时)\n    * [慎选提问的论坛](#慎选提问的论坛)\n    * [Stack Overflow](#stack-overflow)\n    * [网站和 IRC 论坛](#网站和-irc-论坛)\n    * [第二步，使用项目邮件列表](#第二步使用项目邮件列表)\n    * [使用有意义且描述明确的标题](#使用有意义且描述明确的标题)\n    * [使问题容易回复](#使问题容易回复)\n    * [用清晰、正确、精准并合法语法的语句](#用清晰正确精准并合法语法的语句)\n    * [使用易于读取且标准的文件格式发送问题](#使用易于读取且标准的文件格式发送问题)\n    * [精确的描述问题并言之有物](#精确的描述问题并言之有物)\n    * [话不在多而在精](#话不在多而在精)\n    * [别动辄声称找到 Bug](#别动辄声称找到-bug)\n    * [可以低声下气，但还是要先做功课](#可以低声下气但还是要先做功课)\n    * [描述问题症状而非猜测](#描述问题症状而非猜测)\n    * [按发生时间先后列出问题症状](#按发生时间先后列出问题症状)\n    * [描述目标而不是过程](#描述目标而不是过程)\n    * [别要求使用私人电邮回复](#别要求使用私人电邮回复)\n    * [清楚明确的表达你的问题以及需求](#清楚明确的表达你的问题以及需求)\n    * [询问有关代码的问题时](#询问有关代码的问题时)\n    * [别把自己家庭作业的问题贴上来](#别把自己家庭作业的问题贴上来)\n    * [去掉无意义的提问句](#去掉无意义的提问句)\n    * [即使你很急也不要在标题写紧急](#即使你很急也不要在标题写紧急)\n    * [礼多人不怪，而且有时还很有帮助](#礼多人不怪而且有时还很有帮助)\n    * [问题解决后，加个简短的补充说明](#问题解决后加个简短的补充说明)\n  * [如何解读答案](#如何解读答案)\n    * [RTFM 和 STFW：如何知道你已完全搞砸了](#rtfm-和-stfw如何知道你已完全搞砸了)\n    * [如果还是搞不懂](#如果还是搞不懂)\n    * [处理无礼的回应](#处理无礼的回应)\n  * [如何避免扮演失败者](#如何避免扮演失败者)\n  * [不该问的问题](#不该问的问题)\n  * [好问题与蠢问题](#好问题与蠢问题)\n  * [如果得不到回答](#如果得不到回答)\n  * [如何更好地回答问题](#如何更好地回答问题)\n  * [相关资源](#相关资源)\n  * [鸣谢](#鸣谢)\n\n## 声明\n\n许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：\n\n****本指南不提供此项目的实际支持服务！****\n\n我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。\n\n如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n\n## 简介\n\n在[黑客](http://www.catb.org/~esr/faqs/hacker-howto.html)的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。\n\n不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件**好事**；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。\n\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，\"好问题！\"是诚挚的大力称赞。\n\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 ``失败者（撸瑟）`` （由于历史原因，我们有时把它拼作 ``lusers``）。\n\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。\n\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答``赢家（winner）``的问题。\n\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 -- 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 -- 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 -- 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n\n（欢迎对本指南提出改进意见。你可以 email 你的建议至 [esr@thyrsus.com](esr@thyrsus.com) 或 [respond-auto@linuxmafia.com](respond-auto@linuxmafia.com)。然而请注意，本文并非[网络礼节](http://www.ietf.org/rfc/rfc1855.txt)的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）\n\n## 在提问之前\n\n在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n  1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n  1. 尝试上网搜索以找到答案。\n  1. 尝试阅读手册以找到答案。\n  1. 尝试阅读常见问题文件（FAQ）以找到答案。\n  1. 尝试自己检查或试验以找到答案\n  1. 向你身边的强者朋友打听以找到答案。\n  1. 如果你是程序开发者，请尝试阅读源代码以找到答案。\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所**学到**的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n\n运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 [Google 论坛](http://groups.google.com/)，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 ``我在 Google 中搜过下列句子但没有找到什么有用的东西`` 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n\n别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n\n准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着``蠢问题…``， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n\n绝不要自以为**够格**得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去**挣到**一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 --一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。``谁能给点提示？``、``我的这个例子里缺了什么？``以及``我应该检查什么地方``比``请把我需要的确切的过程贴出来``更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n\n## 当你提问时\n\n### 慎选提问的论坛\n\n小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n  * 在与主题不合的论坛上贴出你的问题\n  * 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然\n  * 在太多的不同新闻群组上重复转贴同样的问题（cross-post）\n  * 向既非熟人也没有义务解决你问题的人发送私人电邮\n\n黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。\n\n因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括**阅读** FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。\n\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 -- 如果你不确定，那就向别处发送，或者压根别发。\n\n在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。\n\n别像机关枪似的一次\"扫射\"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。\n\n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。\n\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。\n\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 -- 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。\n\n### Stack Overflow\n\n搜索，**然后** 在 Stack Exchange 问。\n\n近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。\n\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\n\nStack Exchange 已经成长到[超过一百个网站](http://stackexchange.com/sites)，以下是最常用的几个站：\n\n* Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。\n* Stack Overflow 是问写程序有关的问题。\n* Server Fault 是问服务器和网管相关的问题。\n\n### 网站和 IRC 论坛\n\n本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。\n\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 \"用**我们的**版本\"。\n\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。\n\n通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n\n在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。\n\n### 第二步，使用项目邮件列表\n\n当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：\n\n  * 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。\n  * 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n  * 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n  * 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n如果一个项目既有\"使用者\" 也有\"开发者\"（或\"黑客\"）邮件列表或论坛，而你又不会动到那些源代码，那么就向\"使用者\"列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n\n然而，如果你**确信**你的问题很特别，而且在\"使用者\" 列表或论坛中几天都没有回复，可以试试前往\"开发者\"列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）\n\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n\n### 使用有意义且描述明确的标题\n\n在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的``帮帮忙``、``跪求``、``急``（更别说``救命啊！！！！``这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。\n\n一个好标题范例是``目标 -- 差异``式的描述，许多技术支持组织就是这样做的。在``目标``部分指出是哪一个或哪一组东西有问题，在``差异``部分则描述与期望的行为不一致的地方。\n\n\n> 蠢问题：救命啊！我的笔记本电脑不能正常显示了！\n\n> 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。\n\n> 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n编写``目标 -- 差异`` 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境**和**你遇到的问题。\n\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 ``Re: 测试`` 或者 ``Re: 新 bug`` 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。\n\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。\n\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。\n\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你**只想**在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n\n### 使问题容易回复\n\n以``请将你的回复寄到……``来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，[换个好点的](http://linuxmafia.com/faq/Mail/muas.html)；如果是操作系统不支持这种邮件程序，也换个好点的。\n\n在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如``追踪此讨论串``、``有回复时发送邮件提醒``等功能。\n\n### 用清晰、正确、精准并语法正确的语句\n\n我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。\n\n正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 -- 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它**必须很**准确，而且有迹象表明你是在思考和关注问题。\n\n正确地拼写、使用标点和大小写，不要将``its``混淆为``it's``，``loose``搞成``lose``或者将``discrete``弄成``discreet``。不要**全部用大写**，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。[Alan Cox](http://en.wikipedia.org/wiki/Alan_Cox) 也许可以这样做，但你不行。）\n\n更白话的说，如果你写得像是个半文盲[译注：[小白](http://zh.wikipedia.org/zh-tw/小白)]，那多半得不到理睬。也不要使用即时通讯中的简写或[火星文](http://zh.wikipedia.org/zh-tw/火星文)，如将``的``简化为``ㄉ``会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。\n\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：\n[译注：以下附上原文以供使用]\n\n> English is not my native language; please excuse typing errors.\n\n* 英文不是我的母语，请原谅我的错字或语法\n\n\n> If you speak $LANGUAGE, please email/PM me;\n> I may need assistance translating my question.\n\n* 如果你说**某语言**，请寄信/私讯给我；我需要有人协助我翻译我的问题\n\n\n> I am familiar with the technical terms,\n> but some slang expressions and idioms are difficult for me.\n\n* 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。\n\n\n> I've posted my question in $LANGUAGE and English.\n> I'll be glad to translate responses, if you only use one or the other.\n\n* 我把我的问题用**某语言**和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。\n\n### 使用易于读取且标准的文件格式发送问题\n\n如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n\n* 使用纯文字而不是 HTML ([关闭 HTML](http://archive.birdhouse.org/etc/evilmail.html) 并不难）。\n* 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。\n* 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。\n* 但是，对一些特殊的文件**不要**设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。\n* 在英语论坛中，不要使用``Quoted-Printable`` MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的``=20``符号既难看也分散注意力，甚至有可能破坏内容的语意。\n* 绝对，**永远**不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。\n* 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的``智能引号``功能 （从[选项] > [校订] > [自动校正选项]，勾选掉``智能引号``单选框），以免在你的邮件中到处散布垃圾字符。\n* 在论坛，勿滥用``表情符号``和``HTML``功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。\n\n如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的``查看源代码``命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。\n\n### 精确的描述问题并言之有物\n\n* 仔细、清楚地描述你的问题或 Bug 的症状。\n* 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：``Fedora Core 4``、``Slackware 9.1``等）。\n* 描述在提问前你是怎样去研究和理解这个问题的。\n* 描述在提问前为确定问题而采取的诊断步骤。\n* 描述最近做过什么可能相关的硬件或软件变更。\n* 尽可能的提供一个可以``重现这个问题的可控环境``的方法。\n\n尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。\n\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\n\n[Simon Tatham](http://www.chiark.greenend.org.uk/~sgtatham/) 写过一篇名为《[如何有效的报告 Bug](http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html)》的出色文章。强力推荐你也读一读。\n\n### 话不在多而在精\n\n你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n\n这样做的用处至少有三点。\n第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；\n第二，简化问题使你更有可能得到**有用**的答案；\n第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n\n### 别动辄声称找到 Bug\n\n当你在使用软件中遇到问题，除非你非常、**非常**的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的``Bug``，你应该能提供相应位置的修正或替代文件。\n\n请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前[已经做了这些，是吧](#在提问之前)？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有``Bug``时，这尤其严重。\n\n提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是**你**做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。\n\n### 低声下气不能代替你的功课\n\n有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 -- 低声下气：``我知道我只是个可悲的新手，一个撸瑟，但...``。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。\n\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。\n\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。\n\n### 描述问题症状而非你的猜测\n\n告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n\n***蠢问题***\n\n> 我在编译内核时接连遇到 SIG11 错误，\n> 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n\n***聪明问题***\n> 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），\n> 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，\n> 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。\n> 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。\n\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：``所有的诊断专家都来自密苏里州。`` 美国国务院的官方座右铭则是：``让我看看``（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：``我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。``） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！\n\n### 按发生时间先后列出问题症状\n\n问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。\n\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，``多``不等于``好``。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。\n\n### 描述目标而不是过程\n\n如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\n\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n\n**蠢问题**\n> 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？\n\n**聪明问题**\n> 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），\n> 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。\n\n第二种提问法比较聪明，你可能得到像是``建议采用另一个更合适的工具``的回复。\n\n### 别要求使用私人电邮回复\n\n黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。\n\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让**回复者**来决定是否私下回答 -- 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。\n\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是``向我发电邮，我将为论坛归纳这些回复``。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 -- 但你必须信守诺言。\n\n### 清楚明确的表达你的问题以及需求\n\n漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。\n\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。\n\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 -- 但这技巧通常和简化问题有所区别。因此，问``我想更好的理解 X，可否指点一下哪有好一点说明？``通常比问``你能解释一下 X 吗？``更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\n\n### 询问有关代码的问题时\n\n别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：``它不能工作``会让你完全被忽略。只贴几十行代码，然后说一句：``在第七行以后，我期待它显示 <x>，但实际出现的是 <y>``比较有可能让你得到回应。\n\n最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能**刚好**展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看[话不在多而在精](#话不在多而在精)一节）。\n\n一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n\n### 别把自己家庭作业的问题贴上来\n\n黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由**你**来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的**使用者**邮件列表或论坛中提问。尽管黑客们**会**看出来，但一些有经验的使用者也许仍会给你一些提示。\n\n### 去掉无意义的提问句\n\n避免用无意义的话结束提问，例如``有人能帮我吗？``或者``这有答案吗？``。\n\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 -- 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：``没错，有人能帮你``或者``不，没答案``。\n\n一般来说，避免用 ``是或否``、``对或错``、``有或没有``类型的问句，除非你想得到[是或否类型的回答](http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html)。\n\n### 即使你很急也不要在标题写``紧急``\n\n这是你的问题，不是我们的。宣称``紧急``极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，``紧急``这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 -- 你希望能看到你问题的人可能永远也看不到。\n\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如``紧急：帮我救救这个毛绒绒的小海豹！``肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。\n\n如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。\n\n### 礼多人不怪，而且有时还很有帮助\n\n彬彬有礼，多用``请``和``谢谢您的关注``，或``谢谢你的关照``。让大家都知道你对他们花时间免费提供帮助心存感激。\n\n坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）\n\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n\n（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得``先谢了``意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说``先谢了``，**然后**事后再对回复者表示感谢，或者换种方式表达感激，譬如用``谢谢你的关注``或``谢谢你的关照``。）\n\n### 问题解决后，加个简短的补充说明\n\n问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含``已修正``，``已解决``或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串``问题 X``和``问题 X - 已解决``的潜在回复者就明白不用再浪费时间了（除非他个人觉得``问题 X``的有趣），因此可以利用此时间去解决其它问题。\n\n补充说明不必很长或是很深入；简单的一句``你好，原来是网线出了问题！谢谢大家 – Bill``比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此**之后**才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n\n## 如何解读答案\n\n<a id=\"RTFM\"></a>\n### RTFM 和 STFW：如何知道你已完全搞砸了\n\n有一个古老而神圣的传统：如果你收到``RTFM （Read The Fucking Manual）``的回应，回答者认为你**应该去读他妈的手册**。当然，基本上他是对的，你应该去读一读。\n\nRTFM 有一个年轻的亲戚。如果你收到``STFW（Search The Fucking Web）``的回应，回答者认为你**应该到他妈的网上搜索**过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **[Google 是你的朋友](http://lmgtfy.com/)**！）\n\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为\n\n* **你需要的信息非常容易获得**；\n* **你自己去搜索这些信息比灌给你，能让你学到更多**。\n\n你不应该因此不爽；**依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见**。你应该对他祖母般的慈祥表示感谢。\n\n### 如果还是搞不懂\n\n如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。\n\n比方说，如果我回答你：``看来似乎是 zentry 卡住了；你应该先清除它。``，然后，这是一个**很糟的**后续问题回应：``zentry 是什么？`` **好**的问法应该是这样：``哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？``\n\n### 处理无礼的回应\n\n很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这**没有**发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而**你**将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n\n另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。\n\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会**正常**交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们**喜欢**我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）\n\nJeff Bigler 的观察总结和这个相关也值得一读 (**[tact filters](http://www.mit.edu/~jcb/tact.html)**)。\n\n在下一节，我们会谈到另一个问题，当**你**行为不当时所会受到的``冒犯``。\n\n## 如何避免扮演失败者\n\n在黑客社区的论坛中有那么几次你可能会搞砸 -- 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：\n\n熬过去，这很正常。事实上，它是有益健康且合理的。\n\n社区的标准不会自行维持，它们是通过参与者积极而**公开地**执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。\n\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称``如果你不想帮助用户就闭嘴。`` 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。\n\n夸张的讲法是：你要的是**友善**（以上述方式）还是有用？两个里面挑一个。\n\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心**你**和**他的社区**而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。\n\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是**真的**会把问题搞砸。\n\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。\n\n也别让自己卷入口水战，最好不要理睬大多数的口水战 -- 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n\n## 不该问的问题\n\n以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n\n问题：[我能在哪找到 X 程序或 X 资源？](#q1)\n\n问题：[我怎样用 X 做 Y？](#q2)\n\n问题：[如何设定我的 shell 提示？](#q3)\n\n问题：[我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？](#q4)\n\n问题：[我的程序/设定/SQL 语句没有用](#q5)\n\n问题：[我的 Windows 电脑有问题，你能帮我吗？](#q6)\n\n问题：[我的程序不会动了，我认为系统工具 X 有问题](#q7)\n\n问题：[我在安装 Linux（或者 X ）时有问题，你能帮我吗？](#q8)\n\n问题：[我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？](#q9)\n\n---\n\n<a id=\"q1\"></a>\n> 问题：我能在哪找到 X 程序或 X 资源？\n\n回答：就在我找到它的地方啊，白痴 -- 搜索引擎的那一头。天哪！难道还有人不会用 [Google](http://www.google.com) 吗？\n\n<a id=\"q2\"></a>\n> 问题：我怎样用 X 做 Y？\n\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n\n<a id=\"q3\"></a>\n>问题：如何设定我的 shell 提示？？\n\n\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 [RTFM](#RTFM)，然后自己去找出来。\n\n<a id=\"q4\"></a>\n> 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？\n\n\n回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。\n\n<a id=\"q5\"></a>\n> 问题：我的{程序/设定/SQL 语句}不工作\n\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 -- 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n\n  * 你还有什么要补充的吗？\n  * 真糟糕，希望你能搞定。\n  * 这关我有什么屁事？\n\n<a id=\"q6\"></a>\n> 问题：我的 Windows 电脑有问题，你能帮我吗？\n\n回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。\n\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你**可以**问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n\n<a id=\"q7\"></a>\n> 问题：我的程序不会动了，我认为系统工具 X 有问题\n\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。\n\n<a id=\"q8\"></a>\n> 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在[这儿](http://www.linux.org/groups/index.html)找到使用者群组的清单）。\n\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 ``Linux`` 和**所有**被怀疑的硬件作关键词仔细搜索。\n\n<a id=\"q9\"></a>\n> 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？\n\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n\n## 好问题与蠢问题\n\n最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。\n\n\n****蠢问题****：\n\n> 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n\n这种问法无非想得到 [STFW](#RTFM) 这样的回答。\n\n****聪明问题****：\n\n> 我用 Google 搜索过 \"Foonly Flurbamatic 2600\"，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？\n\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n\n\n****蠢问题****\n\n> 我从 foo 项目找来的源码没法编译。它怎么这么烂？\n\n他觉得都是别人的错，这个傲慢自大的提问者。\n\n****聪明问题****\n\n> foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？\n\n提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。\n\n\n****蠢问题****\n\n> 我的主机板有问题了，谁来帮我？\n\n某黑客对这类问题的回答通常是：``好的，还要帮你拍拍背和换尿布吗？``，然后按下删除键。\n\n****聪明问题****\n\n> 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。\n\n在最后一个问题中，注意``告诉我答案``和``给我启示，指出我还应该做什么诊断工作``之间微妙而又重要的区别。\n\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。\n\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。\n\n事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的**名**人，而是因为我用了正确的方式来提问。\n\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我**像**个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。\n\n## 如果得不到回答\n\n如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n\n总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n\n有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了-- 完全可能如此 --你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。\n\n## 如何更好地回答问题\n\n**态度和善一点**。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n\n**对初犯者私下回复**。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\n\n**如果你不确定，一定要说出来**！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n\n**如果帮不了忙，也别妨碍他**。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 --有些可怜的呆瓜会把它当成真的指令。\n\n**试探性的反问以引出更多的细节**。如果你做得好，提问者可以学到点东西 --你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。\n\n尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。\n\n**如果你决定回答，就请给出好的答案**。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。\n\n**正面的回答问题**！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 ``试试看 A 或是 B`` 或者 ``试试 X 、 Y 、 Z 、 A 、 B 、 C`` 并附上一个链接一点用都没有。\n\n**帮助你的社区从问题中学习**。当回复一个好问题时，问问自己``如何修改相关文件或常见问题文件以免再次解答同样的问题？``，接着再向文件维护者发一份补丁。\n\n如果你是在研究一番后才做出的回答，**展现你的技巧而不是直接端出结果**。毕竟``授人以鱼不如授人以渔``。\n\n## 相关资源\n\n如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 [Unix 系统和网络基本原理](http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/)。\n\n当你发布软件或补丁时，试着按[软件发布实践](http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html)操作。\n\n## 鸣谢\nEvelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写``如何更好地回答问题``这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","slug":"java-toup37","published":1,"updated":"2019-09-03T03:40:46.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfq003f0vfaew2w6tky","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h1 id=\"提问的智慧\"><a href=\"#提问的智慧\" class=\"headerlink\" title=\"提问的智慧\"></a>提问的智慧</h1><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href=\"http://www.catb.org/~esr/faqs/smart-questions.html\" target=\"_blank\" rel=\"noopener\">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu<br><a id=\"more\"></a></p><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul><li><a href=\"#声明\">声明</a></li><li><a href=\"#简介\">简介</a></li><li><a href=\"#在提问之前\">在提问之前</a></li><li><a href=\"#当你提问时\">当你提问时</a><ul><li><a href=\"#慎选提问的论坛\">慎选提问的论坛</a></li><li><a href=\"#stack-overflow\">Stack Overflow</a></li><li><a href=\"#网站和-irc-论坛\">网站和 IRC 论坛</a></li><li><a href=\"#第二步使用项目邮件列表\">第二步，使用项目邮件列表</a></li><li><a href=\"#使用有意义且描述明确的标题\">使用有意义且描述明确的标题</a></li><li><a href=\"#使问题容易回复\">使问题容易回复</a></li><li><a href=\"#用清晰正确精准并合法语法的语句\">用清晰、正确、精准并合法语法的语句</a></li><li><a href=\"#使用易于读取且标准的文件格式发送问题\">使用易于读取且标准的文件格式发送问题</a></li><li><a href=\"#精确的描述问题并言之有物\">精确的描述问题并言之有物</a></li><li><a href=\"#话不在多而在精\">话不在多而在精</a></li><li><a href=\"#别动辄声称找到-bug\">别动辄声称找到 Bug</a></li><li><a href=\"#可以低声下气但还是要先做功课\">可以低声下气，但还是要先做功课</a></li><li><a href=\"#描述问题症状而非猜测\">描述问题症状而非猜测</a></li><li><a href=\"#按发生时间先后列出问题症状\">按发生时间先后列出问题症状</a></li><li><a href=\"#描述目标而不是过程\">描述目标而不是过程</a></li><li><a href=\"#别要求使用私人电邮回复\">别要求使用私人电邮回复</a></li><li><a href=\"#清楚明确的表达你的问题以及需求\">清楚明确的表达你的问题以及需求</a></li><li><a href=\"#询问有关代码的问题时\">询问有关代码的问题时</a></li><li><a href=\"#别把自己家庭作业的问题贴上来\">别把自己家庭作业的问题贴上来</a></li><li><a href=\"#去掉无意义的提问句\">去掉无意义的提问句</a></li><li><a href=\"#即使你很急也不要在标题写紧急\">即使你很急也不要在标题写紧急</a></li><li><a href=\"#礼多人不怪而且有时还很有帮助\">礼多人不怪，而且有时还很有帮助</a></li><li><a href=\"#问题解决后加个简短的补充说明\">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href=\"#如何解读答案\">如何解读答案</a><ul><li><a href=\"#rtfm-和-stfw如何知道你已完全搞砸了\">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href=\"#如果还是搞不懂\">如果还是搞不懂</a></li><li><a href=\"#处理无礼的回应\">处理无礼的回应</a></li></ul></li><li><a href=\"#如何避免扮演失败者\">如何避免扮演失败者</a></li><li><a href=\"#不该问的问题\">不该问的问题</a></li><li><a href=\"#好问题与蠢问题\">好问题与蠢问题</a></li><li><a href=\"#如果得不到回答\">如果得不到回答</a></li><li><a href=\"#如何更好地回答问题\">如何更好地回答问题</a></li><li><a href=\"#相关资源\">相关资源</a></li><li><a href=\"#鸣谢\">鸣谢</a></li></ul><h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong><strong>本指南不提供此项目的实际支持服务！</strong></strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在<a href=\"http://www.catb.org/~esr/faqs/hacker-howto.html\" target=\"_blank\" rel=\"noopener\">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 — 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 — 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 — 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href=\"esr@thyrsus.com\">esr@thyrsus.com</a> 或 <a href=\"respond-auto@linuxmafia.com\">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href=\"http://www.ietf.org/rfc/rfc1855.txt\" target=\"_blank\" rel=\"noopener\">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）</p><h2 id=\"在提问之前\"><a href=\"#在提问之前\" class=\"headerlink\" title=\"在提问之前\"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href=\"http://groups.google.com/\" target=\"_blank\" rel=\"noopener\">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id=\"当你提问时\"><a href=\"#当你提问时\" class=\"headerlink\" title=\"当你提问时\"></a>当你提问时</h2><h3 id=\"慎选提问的论坛\"><a href=\"#慎选提问的论坛\" class=\"headerlink\" title=\"慎选提问的论坛\"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 — 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 — 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id=\"Stack-Overflow\"><a href=\"#Stack-Overflow\" class=\"headerlink\" title=\"Stack Overflow\"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href=\"http://stackexchange.com/sites\" target=\"_blank\" rel=\"noopener\">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id=\"网站和-IRC-论坛\"><a href=\"#网站和-IRC-论坛\" class=\"headerlink\" title=\"网站和 IRC 论坛\"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id=\"第二步，使用项目邮件列表\"><a href=\"#第二步，使用项目邮件列表\" class=\"headerlink\" title=\"第二步，使用项目邮件列表\"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id=\"使用有意义且描述明确的标题\"><a href=\"#使用有意义且描述明确的标题\" class=\"headerlink\" title=\"使用有意义且描述明确的标题\"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 -- 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 -- 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id=\"使问题容易回复\"><a href=\"#使问题容易回复\" class=\"headerlink\" title=\"使问题容易回复\"></a>使问题容易回复</h3><p>以<code>请将你的回复寄到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href=\"http://linuxmafia.com/faq/Mail/muas.html\" target=\"_blank\" rel=\"noopener\">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id=\"用清晰、正确、精准并语法正确的语句\"><a href=\"#用清晰、正确、精准并语法正确的语句\" class=\"headerlink\" title=\"用清晰、正确、精准并语法正确的语句\"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 — 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href=\"http://en.wikipedia.org/wiki/Alan_Cox\" target=\"_blank\" rel=\"noopener\">Alan Cox</a> 也许可以这样做，但你不行。）</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href=\"http://zh.wikipedia.org/zh-tw/小白\" target=\"_blank\" rel=\"noopener\">小白</a>]，那多半得不到理睬。也不要使用即时通讯中的简写或<a href=\"http://zh.wikipedia.org/zh-tw/火星文\" target=\"_blank\" rel=\"noopener\">火星文</a>，如将<code>的</code>简化为<code>ㄉ</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id=\"使用易于读取且标准的文件格式发送问题\"><a href=\"#使用易于读取且标准的文件格式发送问题\" class=\"headerlink\" title=\"使用易于读取且标准的文件格式发送问题\"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href=\"http://archive.birdhouse.org/etc/evilmail.html\" target=\"_blank\" rel=\"noopener\">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id=\"精确的描述问题并言之有物\"><a href=\"#精确的描述问题并言之有物\" class=\"headerlink\" title=\"精确的描述问题并言之有物\"></a>精确的描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href=\"http://www.chiark.greenend.org.uk/~sgtatham/\" target=\"_blank\" rel=\"noopener\">Simon Tatham</a> 写过一篇名为《<a href=\"http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html\" target=\"_blank\" rel=\"noopener\">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id=\"话不在多而在精\"><a href=\"#话不在多而在精\" class=\"headerlink\" title=\"话不在多而在精\"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id=\"别动辄声称找到-Bug\"><a href=\"#别动辄声称找到-Bug\" class=\"headerlink\" title=\"别动辄声称找到 Bug\"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href=\"#在提问之前\">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id=\"低声下气不能代替你的功课\"><a href=\"#低声下气不能代替你的功课\" class=\"headerlink\" title=\"低声下气不能代替你的功课\"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 — 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id=\"描述问题症状而非你的猜测\"><a href=\"#描述问题症状而非你的猜测\" class=\"headerlink\" title=\"描述问题症状而非你的猜测\"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong><em>蠢问题</em></strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong><em>聪明问题</em></strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id=\"按发生时间先后列出问题症状\"><a href=\"#按发生时间先后列出问题症状\" class=\"headerlink\" title=\"按发生时间先后列出问题症状\"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id=\"描述目标而不是过程\"><a href=\"#描述目标而不是过程\" class=\"headerlink\" title=\"描述目标而不是过程\"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id=\"别要求使用私人电邮回复\"><a href=\"#别要求使用私人电邮回复\" class=\"headerlink\" title=\"别要求使用私人电邮回复\"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 — 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 — 但你必须信守诺言。</p><h3 id=\"清楚明确的表达你的问题以及需求\"><a href=\"#清楚明确的表达你的问题以及需求\" class=\"headerlink\" title=\"清楚明确的表达你的问题以及需求\"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 — 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id=\"询问有关代码的问题时\"><a href=\"#询问有关代码的问题时\" class=\"headerlink\" title=\"询问有关代码的问题时\"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href=\"#话不在多而在精\">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id=\"别把自己家庭作业的问题贴上来\"><a href=\"#别把自己家庭作业的问题贴上来\" class=\"headerlink\" title=\"别把自己家庭作业的问题贴上来\"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id=\"去掉无意义的提问句\"><a href=\"#去掉无意义的提问句\" class=\"headerlink\" title=\"去掉无意义的提问句\"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 — 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href=\"http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html\" target=\"_blank\" rel=\"noopener\">是或否类型的回答</a>。</p><h3 id=\"即使你很急也不要在标题写紧急\"><a href=\"#即使你很急也不要在标题写紧急\" class=\"headerlink\" title=\"即使你很急也不要在标题写紧急\"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 — 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id=\"礼多人不怪，而且有时还很有帮助\"><a href=\"#礼多人不怪，而且有时还很有帮助\" class=\"headerlink\" title=\"礼多人不怪，而且有时还很有帮助\"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id=\"问题解决后，加个简短的补充说明\"><a href=\"#问题解决后，加个简短的补充说明\" class=\"headerlink\" title=\"问题解决后，加个简短的补充说明\"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id=\"如何解读答案\"><a href=\"#如何解读答案\" class=\"headerlink\" title=\"如何解读答案\"></a>如何解读答案</h2><p><a id=\"RTFM\"></a></p><h3 id=\"RTFM-和-STFW：如何知道你已完全搞砸了\"><a href=\"#RTFM-和-STFW：如何知道你已完全搞砸了\" class=\"headerlink\" title=\"RTFM 和 STFW：如何知道你已完全搞砸了\"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href=\"http://lmgtfy.com/\" target=\"_blank\" rel=\"noopener\">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id=\"如果还是搞不懂\"><a href=\"#如果还是搞不懂\" class=\"headerlink\" title=\"如果还是搞不懂\"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id=\"处理无礼的回应\"><a href=\"#处理无礼的回应\" class=\"headerlink\" title=\"处理无礼的回应\"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href=\"http://www.mit.edu/~jcb/tact.html\" target=\"_blank\" rel=\"noopener\">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id=\"如何避免扮演失败者\"><a href=\"#如何避免扮演失败者\" class=\"headerlink\" title=\"如何避免扮演失败者\"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 — 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是<strong>友善</strong>（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 — 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id=\"不该问的问题\"><a href=\"#不该问的问题\" class=\"headerlink\" title=\"不该问的问题\"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href=\"#q1\">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href=\"#q2\">我怎样用 X 做 Y？</a></p><p>问题：<a href=\"#q3\">如何设定我的 shell 提示？</a></p><p>问题：<a href=\"#q4\">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href=\"#q5\">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href=\"#q6\">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href=\"#q7\">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href=\"#q8\">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href=\"#q9\">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id=\"q1\"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 — 搜索引擎的那一头。天哪！难道还有人不会用 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">Google</a> 吗？</p><p><a id=\"q2\"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id=\"q3\"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href=\"#RTFM\">RTFM</a>，然后自己去找出来。</p><p><a id=\"q4\"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id=\"q5\"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 — 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id=\"q6\"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id=\"q7\"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id=\"q8\"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href=\"http://www.linux.org/groups/index.html\" target=\"_blank\" rel=\"noopener\">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id=\"q9\"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id=\"好问题与蠢问题\"><a href=\"#好问题与蠢问题\" class=\"headerlink\" title=\"好问题与蠢问题\"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong><strong>蠢问题</strong></strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href=\"#RTFM\">STFW</a> 这样的回答。</p><p><strong><strong>聪明问题</strong></strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong><strong>蠢问题</strong></strong></p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong><strong>聪明问题</strong></strong></p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong><strong>蠢问题</strong></strong></p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong><strong>聪明问题</strong></strong></p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id=\"如果得不到回答\"><a href=\"#如果得不到回答\" class=\"headerlink\" title=\"如果得不到回答\"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了— 完全可能如此 —你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。</p><h2 id=\"如何更好地回答问题\"><a href=\"#如何更好地回答问题\" class=\"headerlink\" title=\"如何更好地回答问题\"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href=\"http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/\" target=\"_blank\" rel=\"noopener\">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href=\"http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html\" target=\"_blank\" rel=\"noopener\">软件发布实践</a>操作。</p><h2 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p><!-- rebuild by neat -->","site":{"data":{}},"length":21308,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h1 id=\"提问的智慧\"><a href=\"#提问的智慧\" class=\"headerlink\" title=\"提问的智慧\"></a>提问的智慧</h1><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href=\"http://www.catb.org/~esr/faqs/smart-questions.html\" target=\"_blank\" rel=\"noopener\">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu<br>","more":"</p><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul><li><a href=\"#声明\">声明</a></li><li><a href=\"#简介\">简介</a></li><li><a href=\"#在提问之前\">在提问之前</a></li><li><a href=\"#当你提问时\">当你提问时</a><ul><li><a href=\"#慎选提问的论坛\">慎选提问的论坛</a></li><li><a href=\"#stack-overflow\">Stack Overflow</a></li><li><a href=\"#网站和-irc-论坛\">网站和 IRC 论坛</a></li><li><a href=\"#第二步使用项目邮件列表\">第二步，使用项目邮件列表</a></li><li><a href=\"#使用有意义且描述明确的标题\">使用有意义且描述明确的标题</a></li><li><a href=\"#使问题容易回复\">使问题容易回复</a></li><li><a href=\"#用清晰正确精准并合法语法的语句\">用清晰、正确、精准并合法语法的语句</a></li><li><a href=\"#使用易于读取且标准的文件格式发送问题\">使用易于读取且标准的文件格式发送问题</a></li><li><a href=\"#精确的描述问题并言之有物\">精确的描述问题并言之有物</a></li><li><a href=\"#话不在多而在精\">话不在多而在精</a></li><li><a href=\"#别动辄声称找到-bug\">别动辄声称找到 Bug</a></li><li><a href=\"#可以低声下气但还是要先做功课\">可以低声下气，但还是要先做功课</a></li><li><a href=\"#描述问题症状而非猜测\">描述问题症状而非猜测</a></li><li><a href=\"#按发生时间先后列出问题症状\">按发生时间先后列出问题症状</a></li><li><a href=\"#描述目标而不是过程\">描述目标而不是过程</a></li><li><a href=\"#别要求使用私人电邮回复\">别要求使用私人电邮回复</a></li><li><a href=\"#清楚明确的表达你的问题以及需求\">清楚明确的表达你的问题以及需求</a></li><li><a href=\"#询问有关代码的问题时\">询问有关代码的问题时</a></li><li><a href=\"#别把自己家庭作业的问题贴上来\">别把自己家庭作业的问题贴上来</a></li><li><a href=\"#去掉无意义的提问句\">去掉无意义的提问句</a></li><li><a href=\"#即使你很急也不要在标题写紧急\">即使你很急也不要在标题写紧急</a></li><li><a href=\"#礼多人不怪而且有时还很有帮助\">礼多人不怪，而且有时还很有帮助</a></li><li><a href=\"#问题解决后加个简短的补充说明\">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href=\"#如何解读答案\">如何解读答案</a><ul><li><a href=\"#rtfm-和-stfw如何知道你已完全搞砸了\">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href=\"#如果还是搞不懂\">如果还是搞不懂</a></li><li><a href=\"#处理无礼的回应\">处理无礼的回应</a></li></ul></li><li><a href=\"#如何避免扮演失败者\">如何避免扮演失败者</a></li><li><a href=\"#不该问的问题\">不该问的问题</a></li><li><a href=\"#好问题与蠢问题\">好问题与蠢问题</a></li><li><a href=\"#如果得不到回答\">如果得不到回答</a></li><li><a href=\"#如何更好地回答问题\">如何更好地回答问题</a></li><li><a href=\"#相关资源\">相关资源</a></li><li><a href=\"#鸣谢\">鸣谢</a></li></ul><h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p>许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p><p><strong><strong>本指南不提供此项目的实际支持服务！</strong></strong></p><p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p><p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在<a href=\"http://www.catb.org/~esr/faqs/hacker-howto.html\" target=\"_blank\" rel=\"noopener\">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p><p>不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 — 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 — 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 — 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href=\"esr@thyrsus.com\">esr@thyrsus.com</a> 或 <a href=\"respond-auto@linuxmafia.com\">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href=\"http://www.ietf.org/rfc/rfc1855.txt\" target=\"_blank\" rel=\"noopener\">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）</p><h2 id=\"在提问之前\"><a href=\"#在提问之前\" class=\"headerlink\" title=\"在提问之前\"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href=\"http://groups.google.com/\" target=\"_blank\" rel=\"noopener\">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id=\"当你提问时\"><a href=\"#当你提问时\" class=\"headerlink\" title=\"当你提问时\"></a>当你提问时</h2><h3 id=\"慎选提问的论坛\"><a href=\"#慎选提问的论坛\" class=\"headerlink\" title=\"慎选提问的论坛\"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 — 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 — 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p><h3 id=\"Stack-Overflow\"><a href=\"#Stack-Overflow\" class=\"headerlink\" title=\"Stack Overflow\"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p><p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>Stack Exchange 已经成长到<a href=\"http://stackexchange.com/sites\" target=\"_blank\" rel=\"noopener\">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id=\"网站和-IRC-论坛\"><a href=\"#网站和-IRC-论坛\" class=\"headerlink\" title=\"网站和 IRC 论坛\"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id=\"第二步，使用项目邮件列表\"><a href=\"#第二步，使用项目邮件列表\" class=\"headerlink\" title=\"第二步，使用项目邮件列表\"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id=\"使用有意义且描述明确的标题\"><a href=\"#使用有意义且描述明确的标题\" class=\"headerlink\" title=\"使用有意义且描述明确的标题\"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 -- 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p><p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p><p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 -- 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id=\"使问题容易回复\"><a href=\"#使问题容易回复\" class=\"headerlink\" title=\"使问题容易回复\"></a>使问题容易回复</h3><p>以<code>请将你的回复寄到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href=\"http://linuxmafia.com/faq/Mail/muas.html\" target=\"_blank\" rel=\"noopener\">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id=\"用清晰、正确、精准并语法正确的语句\"><a href=\"#用清晰、正确、精准并语法正确的语句\" class=\"headerlink\" title=\"用清晰、正确、精准并语法正确的语句\"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 — 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href=\"http://en.wikipedia.org/wiki/Alan_Cox\" target=\"_blank\" rel=\"noopener\">Alan Cox</a> 也许可以这样做，但你不行。）</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href=\"http://zh.wikipedia.org/zh-tw/小白\" target=\"_blank\" rel=\"noopener\">小白</a>]，那多半得不到理睬。也不要使用即时通讯中的简写或<a href=\"http://zh.wikipedia.org/zh-tw/火星文\" target=\"_blank\" rel=\"noopener\">火星文</a>，如将<code>的</code>简化为<code>ㄉ</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请寄信/私讯给我；我需要有人协助我翻译我的问题</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li></ul><h3 id=\"使用易于读取且标准的文件格式发送问题\"><a href=\"#使用易于读取且标准的文件格式发送问题\" class=\"headerlink\" title=\"使用易于读取且标准的文件格式发送问题\"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href=\"http://archive.birdhouse.org/etc/evilmail.html\" target=\"_blank\" rel=\"noopener\">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id=\"精确的描述问题并言之有物\"><a href=\"#精确的描述问题并言之有物\" class=\"headerlink\" title=\"精确的描述问题并言之有物\"></a>精确的描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href=\"http://www.chiark.greenend.org.uk/~sgtatham/\" target=\"_blank\" rel=\"noopener\">Simon Tatham</a> 写过一篇名为《<a href=\"http://www.chiark.greenend.org.uk/~sgtatham/bugs-tw.html\" target=\"_blank\" rel=\"noopener\">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id=\"话不在多而在精\"><a href=\"#话不在多而在精\" class=\"headerlink\" title=\"话不在多而在精\"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id=\"别动辄声称找到-Bug\"><a href=\"#别动辄声称找到-Bug\" class=\"headerlink\" title=\"别动辄声称找到 Bug\"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href=\"#在提问之前\">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id=\"低声下气不能代替你的功课\"><a href=\"#低声下气不能代替你的功课\" class=\"headerlink\" title=\"低声下气不能代替你的功课\"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 — 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id=\"描述问题症状而非你的猜测\"><a href=\"#描述问题症状而非你的猜测\" class=\"headerlink\" title=\"描述问题症状而非你的猜测\"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong><em>蠢问题</em></strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong><em>聪明问题</em></strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p><h3 id=\"按发生时间先后列出问题症状\"><a href=\"#按发生时间先后列出问题症状\" class=\"headerlink\" title=\"按发生时间先后列出问题症状\"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id=\"描述目标而不是过程\"><a href=\"#描述目标而不是过程\" class=\"headerlink\" title=\"描述目标而不是过程\"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id=\"别要求使用私人电邮回复\"><a href=\"#别要求使用私人电邮回复\" class=\"headerlink\" title=\"别要求使用私人电邮回复\"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 — 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 — 但你必须信守诺言。</p><h3 id=\"清楚明确的表达你的问题以及需求\"><a href=\"#清楚明确的表达你的问题以及需求\" class=\"headerlink\" title=\"清楚明确的表达你的问题以及需求\"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 — 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id=\"询问有关代码的问题时\"><a href=\"#询问有关代码的问题时\" class=\"headerlink\" title=\"询问有关代码的问题时\"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href=\"#话不在多而在精\">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id=\"别把自己家庭作业的问题贴上来\"><a href=\"#别把自己家庭作业的问题贴上来\" class=\"headerlink\" title=\"别把自己家庭作业的问题贴上来\"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p><h3 id=\"去掉无意义的提问句\"><a href=\"#去掉无意义的提问句\" class=\"headerlink\" title=\"去掉无意义的提问句\"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 — 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href=\"http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html\" target=\"_blank\" rel=\"noopener\">是或否类型的回答</a>。</p><h3 id=\"即使你很急也不要在标题写紧急\"><a href=\"#即使你很急也不要在标题写紧急\" class=\"headerlink\" title=\"即使你很急也不要在标题写紧急\"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 — 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id=\"礼多人不怪，而且有时还很有帮助\"><a href=\"#礼多人不怪，而且有时还很有帮助\" class=\"headerlink\" title=\"礼多人不怪，而且有时还很有帮助\"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id=\"问题解决后，加个简短的补充说明\"><a href=\"#问题解决后，加个简短的补充说明\" class=\"headerlink\" title=\"问题解决后，加个简短的补充说明\"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id=\"如何解读答案\"><a href=\"#如何解读答案\" class=\"headerlink\" title=\"如何解读答案\"></a>如何解读答案</h2><p><a id=\"RTFM\"></a></p><h3 id=\"RTFM-和-STFW：如何知道你已完全搞砸了\"><a href=\"#RTFM-和-STFW：如何知道你已完全搞砸了\" class=\"headerlink\" title=\"RTFM 和 STFW：如何知道你已完全搞砸了\"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href=\"http://lmgtfy.com/\" target=\"_blank\" rel=\"noopener\">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id=\"如果还是搞不懂\"><a href=\"#如果还是搞不懂\" class=\"headerlink\" title=\"如果还是搞不懂\"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id=\"处理无礼的回应\"><a href=\"#处理无礼的回应\" class=\"headerlink\" title=\"处理无礼的回应\"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href=\"http://www.mit.edu/~jcb/tact.html\" target=\"_blank\" rel=\"noopener\">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id=\"如何避免扮演失败者\"><a href=\"#如何避免扮演失败者\" class=\"headerlink\" title=\"如何避免扮演失败者\"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 — 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是<strong>友善</strong>（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 — 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id=\"不该问的问题\"><a href=\"#不该问的问题\" class=\"headerlink\" title=\"不该问的问题\"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href=\"#q1\">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href=\"#q2\">我怎样用 X 做 Y？</a></p><p>问题：<a href=\"#q3\">如何设定我的 shell 提示？</a></p><p>问题：<a href=\"#q4\">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p><p>问题：<a href=\"#q5\">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href=\"#q6\">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href=\"#q7\">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href=\"#q8\">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href=\"#q9\">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id=\"q1\"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 — 搜索引擎的那一头。天哪！难道还有人不会用 <a href=\"http://www.google.com\" target=\"_blank\" rel=\"noopener\">Google</a> 吗？</p><p><a id=\"q2\"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id=\"q3\"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href=\"#RTFM\">RTFM</a>，然后自己去找出来。</p><p><a id=\"q4\"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p><p><a id=\"q5\"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}不工作</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 — 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我有什么屁事？</li></ul><p><a id=\"q6\"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id=\"q7\"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id=\"q8\"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href=\"http://www.linux.org/groups/index.html\" target=\"_blank\" rel=\"noopener\">这儿</a>找到使用者群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id=\"q9\"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id=\"好问题与蠢问题\"><a href=\"#好问题与蠢问题\" class=\"headerlink\" title=\"好问题与蠢问题\"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong><strong>蠢问题</strong></strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href=\"#RTFM\">STFW</a> 这样的回答。</p><p><strong><strong>聪明问题</strong></strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong><strong>蠢问题</strong></strong></p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong><strong>聪明问题</strong></strong></p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong><strong>蠢问题</strong></strong></p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong><strong>聪明问题</strong></strong></p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id=\"如果得不到回答\"><a href=\"#如果得不到回答\" class=\"headerlink\" title=\"如果得不到回答\"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了— 完全可能如此 —你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。</p><h2 id=\"如何更好地回答问题\"><a href=\"#如何更好地回答问题\" class=\"headerlink\" title=\"如何更好地回答问题\"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href=\"http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/\" target=\"_blank\" rel=\"noopener\">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href=\"http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html\" target=\"_blank\" rel=\"noopener\">软件发布实践</a>操作。</p><h2 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p><!-- rebuild by neat -->"},{"title":"java提高篇（四）-----抽象类与接口","abbrlink":"ea4aa8e","date":"2017-10-23T05:04:03.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12858267](http://blog.csdn.net/chenssy/article/details/12858267)\n\n接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。\n       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。\n\n## 抽象类\n我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。\n<!-- more -->\n在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。\n同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）\n在使用抽象类时需要注意几点：\n\n        1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n        2、抽象方法必须由子类来进行重写。\n        3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n        4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n        5、子类中的抽象方法不能与父类的抽象方法同名。\n        6、abstract不能与final并列修饰同一个类。\n        7、abstract 不能与private、static、final或native并列修饰同一个方法。\n\n实例：\n定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：\n\n```java\n    public abstract class Animal {  \n        public abstract void cry();  \n    }  \n    \n    public class Cat extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"猫叫：喵喵...\");  \n        }  \n    }  \n    \n    public class Dog extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"狗叫:汪汪...\");  \n        }  \n    \n    }  \n    \n    public class Test {  \n    \n        public static void main(String[] args) {  \n            Animal a1 = new Cat();  \n            Animal a2 = new Dog();  \n            \n            a1.cry();  \n            a2.cry();  \n        }  \n    }  \n    \n    --------------------------------------------------------------------  \n    Output:  \n    猫叫：喵喵...  \n    狗叫:汪汪...  \n```\n 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）\n\n ## 接口\n\n接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。\n接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。\n接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。\n在使用接口过程中需要注意如下几个问题：\n\n         1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n         3、接口中不存在实现的方法。\n         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n         5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n         例如：if(anObject instanceof Comparable){}。\n         6、在实现多接口的时候一定要避免方法名的重复。\n\n## 抽象类与接口的区别\n\n 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。\n ### 语法层次\n   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。\n      使用抽象类来实现:\n\n```java\n    public abstract class Demo {  \n        abstract void method1();  \n        \n        \n        void method2(){  \n            //实现  \n        }  \n    }  \n```\n\n 使用接口来实现\n ```java\n    interface Demo {  \n        void method1();  \n        void method2();  \n    }  \n ```\n抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。\n对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。\n\n### 设计层次\n上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：\n\n        1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n        2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n        但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n        这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，\n        即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n        3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n        至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n        猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n        我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n**（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）**\n为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：http://blog.csdn.net/ttgjz/article/details/2960451\n我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n抽象类：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close()；  \n    }  \n```\n接口：\n```java\n    interface Door{  \n        void open();  \n        void close();  \n    }  \n```\n\n至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。\n但是现在如果我们需要门具有报警的功能，那么该如何实现呢？\n\n**解决方案一**：给Door增加一个报警方法:clarm();\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n        abstract void alarm();  \n    } \n```\n或者\n\n```java\n    interface Door{  \n        void open();  \n        void close();  \n        void alarm();  \n    }  \n```\n这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念\"报警器\"的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为\"报警器\"这个概念的改变而改变，反之依然。\n\n**解决方案二**\n      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：\n       1、两个都使用抽象类来定义。\n      2、两个都使用接口来定义。\n      3、一个使用抽象类定义，一个是用接口定义。\n      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。\n      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。\n     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n    }  \n    \n    interface Alarm{  \n        void alarm();  \n    }  \n    \n    class AlarmDoor extends Door implements Alarm{  \n        void open(){}  \n        void close(){}  \n        void alarm(){}  \n    }  \n```\n\n 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是\"is-a\"关系，接口表示的是\"like-a\"关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。\n\n **批注：**\n>  <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。\n>   一个类对另外一个类的依赖性应当是建立在最小的接口上的。\n>   一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n## 总结\n\n      1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n      抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n      只有对问题域的本质有良好的理解，才能做出正确、合理的设计。","source":"_posts/java-toup5.md","raw":"---\ntitle: java提高篇（四）-----抽象类与接口\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: ea4aa8e\ndate: 2017-10-23 13:04:03\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12858267](http://blog.csdn.net/chenssy/article/details/12858267)\n\n接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。\n       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。\n\n## 抽象类\n我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。\n<!-- more -->\n在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。\n同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）\n在使用抽象类时需要注意几点：\n\n        1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n        2、抽象方法必须由子类来进行重写。\n        3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n        4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n        5、子类中的抽象方法不能与父类的抽象方法同名。\n        6、abstract不能与final并列修饰同一个类。\n        7、abstract 不能与private、static、final或native并列修饰同一个方法。\n\n实例：\n定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：\n\n```java\n    public abstract class Animal {  \n        public abstract void cry();  \n    }  \n    \n    public class Cat extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"猫叫：喵喵...\");  \n        }  \n    }  \n    \n    public class Dog extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"狗叫:汪汪...\");  \n        }  \n    \n    }  \n    \n    public class Test {  \n    \n        public static void main(String[] args) {  \n            Animal a1 = new Cat();  \n            Animal a2 = new Dog();  \n            \n            a1.cry();  \n            a2.cry();  \n        }  \n    }  \n    \n    --------------------------------------------------------------------  \n    Output:  \n    猫叫：喵喵...  \n    狗叫:汪汪...  \n```\n 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）\n\n ## 接口\n\n接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。\n接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。\n接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。\n在使用接口过程中需要注意如下几个问题：\n\n         1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n         3、接口中不存在实现的方法。\n         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n         5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n         例如：if(anObject instanceof Comparable){}。\n         6、在实现多接口的时候一定要避免方法名的重复。\n\n## 抽象类与接口的区别\n\n 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。\n ### 语法层次\n   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。\n      使用抽象类来实现:\n\n```java\n    public abstract class Demo {  \n        abstract void method1();  \n        \n        \n        void method2(){  \n            //实现  \n        }  \n    }  \n```\n\n 使用接口来实现\n ```java\n    interface Demo {  \n        void method1();  \n        void method2();  \n    }  \n ```\n抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。\n对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。\n\n### 设计层次\n上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：\n\n        1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n        2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n        但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n        这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，\n        即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n        3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n        至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n        猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n        我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n**（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）**\n为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：http://blog.csdn.net/ttgjz/article/details/2960451\n我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n抽象类：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close()；  \n    }  \n```\n接口：\n```java\n    interface Door{  \n        void open();  \n        void close();  \n    }  \n```\n\n至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。\n但是现在如果我们需要门具有报警的功能，那么该如何实现呢？\n\n**解决方案一**：给Door增加一个报警方法:clarm();\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n        abstract void alarm();  \n    } \n```\n或者\n\n```java\n    interface Door{  \n        void open();  \n        void close();  \n        void alarm();  \n    }  \n```\n这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念\"报警器\"的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为\"报警器\"这个概念的改变而改变，反之依然。\n\n**解决方案二**\n      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：\n       1、两个都使用抽象类来定义。\n      2、两个都使用接口来定义。\n      3、一个使用抽象类定义，一个是用接口定义。\n      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。\n      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。\n     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n    }  \n    \n    interface Alarm{  \n        void alarm();  \n    }  \n    \n    class AlarmDoor extends Door implements Alarm{  \n        void open(){}  \n        void close(){}  \n        void alarm(){}  \n    }  \n```\n\n 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是\"is-a\"关系，接口表示的是\"like-a\"关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。\n\n **批注：**\n>  <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。\n>   一个类对另外一个类的依赖性应当是建立在最小的接口上的。\n>   一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n## 总结\n\n      1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n      抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n      只有对问题域的本质有良好的理解，才能做出正确、合理的设计。","slug":"java-toup5","published":1,"updated":"2019-09-03T03:40:46.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfr003i0vfa4s5nh0ym","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12858267</a></p></blockquote><p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。<br>抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。</p><h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。<br><a id=\"more\"></a><br>在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。<br>同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）<br>在使用抽象类时需要注意几点：</p><pre><code>    1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n    2、抽象方法必须由子类来进行重写。\n    3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n    4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n    5、子类中的抽象方法不能与父类的抽象方法同名。\n    6、abstract不能与final并列修饰同一个类。\n    7、abstract 不能与private、static、final或native并列修饰同一个方法。\n</code></pre><p>实例：<br>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"猫叫：喵喵...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"狗叫:汪汪...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Animal a1 = <span class=\"keyword\">new</span> Cat();  </span><br><span class=\"line\">        Animal a2 = <span class=\"keyword\">new</span> Dog();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        a1.cry();  </span><br><span class=\"line\">        a2.cry();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------------------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">猫叫：喵喵...  </span><br><span class=\"line\">狗叫:汪汪...</span><br></pre></td></tr></table></figure><p>创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）</p><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。<br>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。<br>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。<br>在使用接口过程中需要注意如下几个问题：</p><pre><code>     1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n     2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n     3、接口中不存在实现的方法。\n     4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n     5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n     例如：if(anObject instanceof Comparable){}。\n     6、在实现多接口的时候一定要避免方法名的重复。\n</code></pre><h2 id=\"抽象类与接口的区别\"><a href=\"#抽象类与接口的区别\" class=\"headerlink\" title=\"抽象类与接口的区别\"></a>抽象类与接口的区别</h2><p>尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p><h3 id=\"语法层次\"><a href=\"#语法层次\" class=\"headerlink\" title=\"语法层次\"></a>语法层次</h3><p>在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>使用抽象类来实现:</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//实现  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>使用接口来实现<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Demo</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id=\"设计层次\"><a href=\"#设计层次\" class=\"headerlink\" title=\"设计层次\"></a>设计层次</h3><p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p><pre><code>    1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n    2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n    但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n    这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系，\n    即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n    3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n    至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n    猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n    我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n</code></pre><p><strong>（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）</strong><br>为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：<a href=\"http://blog.csdn.net/ttgjz/article/details/2960451\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/ttgjz/article/details/2960451</a><br>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>抽象类：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span>；  </span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure><p>接口：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。<br>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p><p><strong>解决方案一</strong>：给Door增加一个报警方法:clarm();<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p><p><strong>解决方案二</strong><br>既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：<br>1、两个都使用抽象类来定义。<br>2、两个都使用接口来定义。<br>3、一个使用抽象类定义，一个是用接口定义。<br>由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。<br>如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。<br>第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p><p><strong>批注：</strong></p><blockquote><font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。 一个类对另外一个类的依赖性应当是建立在最小的接口上的。 一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font></blockquote><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code>  1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n  2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n  3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n  抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n  只有对问题域的本质有良好的理解，才能做出正确、合理的设计。\n</code></pre><!-- rebuild by neat -->","site":{"data":{}},"length":6375,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12858267</a></p></blockquote><p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。<br>抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。</p><h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。<br>","more":"<br>在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。<br>同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）<br>在使用抽象类时需要注意几点：</p><pre><code>    1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n    2、抽象方法必须由子类来进行重写。\n    3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n    4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n    5、子类中的抽象方法不能与父类的抽象方法同名。\n    6、abstract不能与final并列修饰同一个类。\n    7、abstract 不能与private、static、final或native并列修饰同一个方法。\n</code></pre><p>实例：<br>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"猫叫：喵喵...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"狗叫:汪汪...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Animal a1 = <span class=\"keyword\">new</span> Cat();  </span><br><span class=\"line\">        Animal a2 = <span class=\"keyword\">new</span> Dog();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        a1.cry();  </span><br><span class=\"line\">        a2.cry();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">--------------------------------------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">猫叫：喵喵...  </span><br><span class=\"line\">狗叫:汪汪...</span><br></pre></td></tr></table></figure><p>创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）</p><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。<br>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。<br>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。<br>在使用接口过程中需要注意如下几个问题：</p><pre><code>     1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n     2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n     3、接口中不存在实现的方法。\n     4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n     5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n     例如：if(anObject instanceof Comparable){}。\n     6、在实现多接口的时候一定要避免方法名的重复。\n</code></pre><h2 id=\"抽象类与接口的区别\"><a href=\"#抽象类与接口的区别\" class=\"headerlink\" title=\"抽象类与接口的区别\"></a>抽象类与接口的区别</h2><p>尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p><h3 id=\"语法层次\"><a href=\"#语法层次\" class=\"headerlink\" title=\"语法层次\"></a>语法层次</h3><p>在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>使用抽象类来实现:</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//实现  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>使用接口来实现<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Demo</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p><h3 id=\"设计层次\"><a href=\"#设计层次\" class=\"headerlink\" title=\"设计层次\"></a>设计层次</h3><p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p><pre><code>    1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n    2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n    但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n    这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系，\n    即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n    3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n    至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n    猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n    我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n</code></pre><p><strong>（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）</strong><br>为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：<a href=\"http://blog.csdn.net/ttgjz/article/details/2960451\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/ttgjz/article/details/2960451</a><br>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>抽象类：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span>；  </span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure><p>接口：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。<br>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p><p><strong>解决方案一</strong>：给Door增加一个报警方法:clarm();<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>或者</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p><p><strong>解决方案二</strong><br>既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：<br>1、两个都使用抽象类来定义。<br>2、两个都使用接口来定义。<br>3、一个使用抽象类定义，一个是用接口定义。<br>由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。<br>如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。<br>第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p><p><strong>批注：</strong></p><blockquote><font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。 一个类对另外一个类的依赖性应当是建立在最小的接口上的。 一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font></blockquote><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code>  1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n  2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n  3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n  抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n  只有对问题域的本质有良好的理解，才能做出正确、合理的设计。\n</code></pre><!-- rebuild by neat -->"},{"title":"java提高篇（五）-----使用序列化实现对象的拷贝","abbrlink":"a11bddda","date":"2017-10-23T05:22:02.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12952063](http://blog.csdn.net/chenssy/article/details/12952063)\n\n我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝\n## 浅拷贝问题\n我们先看如下代码：\n```java\n    public class Person implements Cloneable{  \n        /** 姓名 **/  \n        private String name;  \n        \n        /** 电子邮件 **/  \n        private Email email;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Email getEmail() {  \n            return email;  \n        }  \n    \n        public void setEmail(Email email) {  \n            this.email = email;  \n        }  \n        \n        public Person(String name,Email email){  \n            this.name  = name;  \n            this.email = email;  \n        }  \n        \n        public Person(String name){  \n            this.name = name;  \n        }  \n    \n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        }  \n    }  \n    \n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    --------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:30到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议...  \n```\n\n<!-- more -->\n\n在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n```\n在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议...。但是结果是：\n```java\n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:00到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:00到二会议室参加会议...  \n```\n这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！\n其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：\n1、 基本类型\n    如果变量是基本很类型，则拷贝其值，比如int、float等。\n2、 对象\n    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。\n3、 String字符串\n    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。\n对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：\n```java\n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n                person.setEmail(new Email(person.getEmail().getObject(),person.getEmail().getContent()));  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        } \n```\n所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。\n对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。\n## 利用序列化实现对象的拷贝\n如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```java\n    public class CloneUtils {  \n        @SuppressWarnings(\"unchecked\")  \n        public static <T extends Serializable> T clone(T obj){  \n            T cloneObj = null;  \n            try {  \n                //写入字节流  \n                ByteArrayOutputStream out = new ByteArrayOutputStream();  \n                ObjectOutputStream obs = new ObjectOutputStream(out);  \n                obs.writeObject(obj);  \n                obs.close();  \n                \n                //分配内存，写入原始对象，生成新对象  \n                ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());  \n                ObjectInputStream ois = new ObjectInputStream(ios);  \n                //返回生成的新对象  \n                cloneObj = (T) ois.readObject();  \n                ois.close();  \n            } catch (Exception e) {  \n                e.printStackTrace();  \n            }  \n            return cloneObj;  \n        }  \n    }  \n```\n使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。\n```java\n    public class Person implements Serializable{  \n        private static final long serialVersionUID = 2631590509760908280L;  \n    \n        ..................  \n        //去除clone()方法  \n    \n    }  \n    \n    public class Email implements Serializable{  \n        private static final long serialVersionUID = 1267293988171991494L;  \n        \n        ....................  \n    }  \n```\n所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  CloneUtils.clone(person1);  \n            person2.setName(\"李四\");  \n            Person person3 =  CloneUtils.clone(person1);  \n            person3.setName(\"王五\");  \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    -------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议... \n```","source":"_posts/java-toup6.md","raw":"---\ntitle: java提高篇（五）-----使用序列化实现对象的拷贝\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: a11bddda\ndate: 2017-10-23 13:22:02\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12952063](http://blog.csdn.net/chenssy/article/details/12952063)\n\n我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝\n## 浅拷贝问题\n我们先看如下代码：\n```java\n    public class Person implements Cloneable{  \n        /** 姓名 **/  \n        private String name;  \n        \n        /** 电子邮件 **/  \n        private Email email;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Email getEmail() {  \n            return email;  \n        }  \n    \n        public void setEmail(Email email) {  \n            this.email = email;  \n        }  \n        \n        public Person(String name,Email email){  \n            this.name  = name;  \n            this.email = email;  \n        }  \n        \n        public Person(String name){  \n            this.name = name;  \n        }  \n    \n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        }  \n    }  \n    \n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    --------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:30到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议...  \n```\n\n<!-- more -->\n\n在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n```\n在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议...。但是结果是：\n```java\n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:00到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:00到二会议室参加会议...  \n```\n这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！\n其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：\n1、 基本类型\n    如果变量是基本很类型，则拷贝其值，比如int、float等。\n2、 对象\n    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。\n3、 String字符串\n    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。\n对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：\n```java\n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n                person.setEmail(new Email(person.getEmail().getObject(),person.getEmail().getContent()));  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        } \n```\n所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。\n对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。\n## 利用序列化实现对象的拷贝\n如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```java\n    public class CloneUtils {  \n        @SuppressWarnings(\"unchecked\")  \n        public static <T extends Serializable> T clone(T obj){  \n            T cloneObj = null;  \n            try {  \n                //写入字节流  \n                ByteArrayOutputStream out = new ByteArrayOutputStream();  \n                ObjectOutputStream obs = new ObjectOutputStream(out);  \n                obs.writeObject(obj);  \n                obs.close();  \n                \n                //分配内存，写入原始对象，生成新对象  \n                ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());  \n                ObjectInputStream ois = new ObjectInputStream(ios);  \n                //返回生成的新对象  \n                cloneObj = (T) ois.readObject();  \n                ois.close();  \n            } catch (Exception e) {  \n                e.printStackTrace();  \n            }  \n            return cloneObj;  \n        }  \n    }  \n```\n使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。\n```java\n    public class Person implements Serializable{  \n        private static final long serialVersionUID = 2631590509760908280L;  \n    \n        ..................  \n        //去除clone()方法  \n    \n    }  \n    \n    public class Email implements Serializable{  \n        private static final long serialVersionUID = 1267293988171991494L;  \n        \n        ....................  \n    }  \n```\n所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  CloneUtils.clone(person1);  \n            person2.setName(\"李四\");  \n            Person person3 =  CloneUtils.clone(person1);  \n            person3.setName(\"王五\");  \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    -------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议... \n```","slug":"java-toup6","published":1,"updated":"2019-09-03T03:40:46.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfu003n0vfajz4514b6","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12952063</a></p></blockquote><p>我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝</p><h2 id=\"浅拷贝问题\"><a href=\"#浅拷贝问题\" class=\"headerlink\" title=\"浅拷贝问题\"></a>浅拷贝问题</h2><p>我们先看如下代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** 姓名 **/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 电子邮件 **/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Email <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(Email email)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name,Email email)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name  = name;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        Person person = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            person = (Person) <span class=\"keyword\">super</span>.clone();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> person;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  person1.clone();  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  person1.clone();  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p><a id=\"more\"></a><p>在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  person1.clone();  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  person1.clone();  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p><p>这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！<br>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：<br>1、 基本类型<br>如果变量是基本很类型，则拷贝其值，比如int、float等。<br>2、 对象<br>如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。<br>3、 String字符串<br>若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。<br>对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    Person person = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        person = (Person) <span class=\"keyword\">super</span>.clone();  </span><br><span class=\"line\">        person.setEmail(<span class=\"keyword\">new</span> Email(person.getEmail().getObject(),person.getEmail().getContent()));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> person;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。<br>对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。</p><h2 id=\"利用序列化实现对象的拷贝\"><a href=\"#利用序列化实现对象的拷贝\" class=\"headerlink\" title=\"利用序列化实现对象的拷贝\"></a>利用序列化实现对象的拷贝</h2><p>如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneUtils</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Serializable&gt; <span class=\"function\">T <span class=\"title\">clone</span><span class=\"params\">(T obj)</span></span>&#123;  </span><br><span class=\"line\">        T cloneObj = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//写入字节流  </span></span><br><span class=\"line\">            ByteArrayOutputStream out = <span class=\"keyword\">new</span> ByteArrayOutputStream();  </span><br><span class=\"line\">            ObjectOutputStream obs = <span class=\"keyword\">new</span> ObjectOutputStream(out);  </span><br><span class=\"line\">            obs.writeObject(obj);  </span><br><span class=\"line\">            obs.close();  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//分配内存，写入原始对象，生成新对象  </span></span><br><span class=\"line\">            ByteArrayInputStream ios = <span class=\"keyword\">new</span> ByteArrayInputStream(out.toByteArray());  </span><br><span class=\"line\">            ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(ios);  </span><br><span class=\"line\">            <span class=\"comment\">//返回生成的新对象  </span></span><br><span class=\"line\">            cloneObj = (T) ois.readObject();  </span><br><span class=\"line\">            ois.close();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cloneObj;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2631590509760908280L</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    ..................  </span><br><span class=\"line\">    <span class=\"comment\">//去除clone()方法  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1267293988171991494L</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    ....................  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  CloneUtils.clone(person1);  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  CloneUtils.clone(person1);  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":6537,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/12952063</a></p></blockquote><p>我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝</p><h2 id=\"浅拷贝问题\"><a href=\"#浅拷贝问题\" class=\"headerlink\" title=\"浅拷贝问题\"></a>浅拷贝问题</h2><p>我们先看如下代码：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">/** 姓名 **/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 电子邮件 **/</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Email <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(Email email)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name,Email email)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name  = name;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        Person person = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            person = (Person) <span class=\"keyword\">super</span>.clone();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> person;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  person1.clone();  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  person1.clone();  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p>","more":"<p>在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  person1.clone();  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  person1.clone();  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p><p>这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！<br>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：<br>1、 基本类型<br>如果变量是基本很类型，则拷贝其值，比如int、float等。<br>2、 对象<br>如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。<br>3、 String字符串<br>若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。<br>对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    Person person = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        person = (Person) <span class=\"keyword\">super</span>.clone();  </span><br><span class=\"line\">        person.setEmail(<span class=\"keyword\">new</span> Email(person.getEmail().getObject(),person.getEmail().getContent()));  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> person;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。<br>对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。</p><h2 id=\"利用序列化实现对象的拷贝\"><a href=\"#利用序列化实现对象的拷贝\" class=\"headerlink\" title=\"利用序列化实现对象的拷贝\"></a>利用序列化实现对象的拷贝</h2><p>如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneUtils</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Serializable&gt; <span class=\"function\">T <span class=\"title\">clone</span><span class=\"params\">(T obj)</span></span>&#123;  </span><br><span class=\"line\">        T cloneObj = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            <span class=\"comment\">//写入字节流  </span></span><br><span class=\"line\">            ByteArrayOutputStream out = <span class=\"keyword\">new</span> ByteArrayOutputStream();  </span><br><span class=\"line\">            ObjectOutputStream obs = <span class=\"keyword\">new</span> ObjectOutputStream(out);  </span><br><span class=\"line\">            obs.writeObject(obj);  </span><br><span class=\"line\">            obs.close();  </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//分配内存，写入原始对象，生成新对象  </span></span><br><span class=\"line\">            ByteArrayInputStream ios = <span class=\"keyword\">new</span> ByteArrayInputStream(out.toByteArray());  </span><br><span class=\"line\">            ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(ios);  </span><br><span class=\"line\">            <span class=\"comment\">//返回生成的新对象  </span></span><br><span class=\"line\">            cloneObj = (T) ois.readObject();  </span><br><span class=\"line\">            ois.close();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> cloneObj;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2631590509760908280L</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    ..................  </span><br><span class=\"line\">    <span class=\"comment\">//去除clone()方法  </span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1267293988171991494L</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    ....................  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">//写封邮件  </span></span><br><span class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        Person person2 =  CloneUtils.clone(person1);  </span><br><span class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </span><br><span class=\"line\">        Person person3 =  CloneUtils.clone(person1);  </span><br><span class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </span><br><span class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </span><br><span class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </span><br><span class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </span><br><span class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"java提高篇（六）-----关键字static","abbrlink":"6310ff69","date":"2017-10-23T05:38:04.000Z","_content":"\n> 转载： http://blog.csdn.net/chenssy/article/details/13004291\n\n## static代表着什么\n在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。\nJava把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。\n同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。\n<!-- more -->\n```java\n    public class User {  \n        private static int userNumber  = 0 ;  \n        \n        public User(){  \n            userNumber ++;  \n        }  \n        \n        public static void main(String[] args) {  \n            User user1 = new User();  \n            User user2 = new User();  \n            \n            System.out.println(\"user1 userNumber：\" + User.userNumber);  \n            System.out.println(\"user2 userNumber：\" + User.userNumber);  \n        }  \n    }      \n    ------------  \n    Output:  \n    user1 userNumber：2  \n    user2 userNumber：2  \n```\n\n##  怎么使用static\nstatic可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。\nClassName..propertyName\nClassName.methodName(……)\nStatic修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）\n\n### static变量\nstatic修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：\n静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。\n但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。\n### static方法\nstatic修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。\nStatic方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。\n### static代码块\n被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。\n\n## Static的局限\nStatic确实是存在诸多的作用，但是它也存在一些缺陷。\n\n        1、它只能调用static变量。\n        2、它只能调用static方法。\n        3、不能以任何形式引用this、super。\n        4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经\"准备好了\",也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font>","source":"_posts/java-toup7.md","raw":"---\ntitle: java提高篇（六）-----关键字static\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: 6310ff69\ndate: 2017-10-23 13:38:04\n---\n\n> 转载： http://blog.csdn.net/chenssy/article/details/13004291\n\n## static代表着什么\n在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。\nJava把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。\n同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。\n<!-- more -->\n```java\n    public class User {  \n        private static int userNumber  = 0 ;  \n        \n        public User(){  \n            userNumber ++;  \n        }  \n        \n        public static void main(String[] args) {  \n            User user1 = new User();  \n            User user2 = new User();  \n            \n            System.out.println(\"user1 userNumber：\" + User.userNumber);  \n            System.out.println(\"user2 userNumber：\" + User.userNumber);  \n        }  \n    }      \n    ------------  \n    Output:  \n    user1 userNumber：2  \n    user2 userNumber：2  \n```\n\n##  怎么使用static\nstatic可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。\nClassName..propertyName\nClassName.methodName(……)\nStatic修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）\n\n### static变量\nstatic修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：\n静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。\n但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。\n### static方法\nstatic修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。\nStatic方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。\n### static代码块\n被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。\n\n## Static的局限\nStatic确实是存在诸多的作用，但是它也存在一些缺陷。\n\n        1、它只能调用static变量。\n        2、它只能调用static方法。\n        3、不能以任何形式引用this、super。\n        4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经\"准备好了\",也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font>","slug":"java-toup7","published":1,"updated":"2019-09-03T03:40:46.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfw003q0vfa7xbgi56h","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13004291\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13004291</a></p></blockquote><h2 id=\"static代表着什么\"><a href=\"#static代表着什么\" class=\"headerlink\" title=\"static代表着什么\"></a>static代表着什么</h2><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。<br>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。<br><a id=\"more\"></a><br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> userNumber  = <span class=\"number\">0</span> ;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        userNumber ++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();  </span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user1 userNumber：\"</span> + User.userNumber);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user2 userNumber：\"</span> + User.userNumber);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;      </span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">user1 userNumber：<span class=\"number\">2</span>  </span><br><span class=\"line\">user2 userNumber：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure><p></p><h2 id=\"怎么使用static\"><a href=\"#怎么使用static\" class=\"headerlink\" title=\"怎么使用static\"></a>怎么使用static</h2><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。<br>ClassName..propertyName<br>ClassName.methodName(……)<br>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）</p><h3 id=\"static变量\"><a href=\"#static变量\" class=\"headerlink\" title=\"static变量\"></a>static变量</h3><p>static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。<br>但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。<br>所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。</p><h3 id=\"static方法\"><a href=\"#static方法\" class=\"headerlink\" title=\"static方法\"></a>static方法</h3><p>static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。<br>Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p><h3 id=\"static代码块\"><a href=\"#static代码块\" class=\"headerlink\" title=\"static代码块\"></a>static代码块</h3><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。</p><h2 id=\"Static的局限\"><a href=\"#Static的局限\" class=\"headerlink\" title=\"Static的局限\"></a>Static的局限</h2><p>Static确实是存在诸多的作用，但是它也存在一些缺陷。</p><pre><code>    1、它只能调用static变量。\n    2、它只能调用static方法。\n    3、不能以任何形式引用this、super。\n    4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n</code></pre><p>总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font></p><!-- rebuild by neat -->","site":{"data":{}},"length":1923,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13004291\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13004291</a></p></blockquote><h2 id=\"static代表着什么\"><a href=\"#static代表着什么\" class=\"headerlink\" title=\"static代表着什么\"></a>static代表着什么</h2><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。<br>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。<br>","more":"<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> userNumber  = <span class=\"number\">0</span> ;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        userNumber ++;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();  </span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user1 userNumber：\"</span> + User.userNumber);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user2 userNumber：\"</span> + User.userNumber);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;      </span><br><span class=\"line\">------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">user1 userNumber：<span class=\"number\">2</span>  </span><br><span class=\"line\">user2 userNumber：<span class=\"number\">2</span></span><br></pre></td></tr></table></figure><p></p><h2 id=\"怎么使用static\"><a href=\"#怎么使用static\" class=\"headerlink\" title=\"怎么使用static\"></a>怎么使用static</h2><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。<br>ClassName..propertyName<br>ClassName.methodName(……)<br>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）</p><h3 id=\"static变量\"><a href=\"#static变量\" class=\"headerlink\" title=\"static变量\"></a>static变量</h3><p>static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。<br>但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。<br>所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。</p><h3 id=\"static方法\"><a href=\"#static方法\" class=\"headerlink\" title=\"static方法\"></a>static方法</h3><p>static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。<br>Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p><h3 id=\"static代码块\"><a href=\"#static代码块\" class=\"headerlink\" title=\"static代码块\"></a>static代码块</h3><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。</p><h2 id=\"Static的局限\"><a href=\"#Static的局限\" class=\"headerlink\" title=\"Static的局限\"></a>Static的局限</h2><p>Static确实是存在诸多的作用，但是它也存在一些缺陷。</p><pre><code>    1、它只能调用static变量。\n    2、它只能调用static方法。\n    3、不能以任何形式引用this、super。\n    4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n</code></pre><p>总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font></p><!-- rebuild by neat -->"},{"title":"java提高篇（七）-----详解内部类","abbrlink":"30043e85","date":"2017-10-23T05:38:12.000Z","_content":"> 转载：http://blog.csdn.net/chenssy/article/details/13024951\n\n可以将一个类的定义放在另一个类的定义内部，这就是内部类。\n内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。\n第一次见面\n内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。\n```java\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            this.age = age;  \n        }  \n        \n        class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n        }  \n    }  \n```\n在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。\n<!-- more -->\n\n## 为什么要使用内部类\n为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n```java\n\n    public interface Father {  \n    \n    }  \n    \n    public interface Mother {  \n    \n    }  \n    \n    public class Son implements Father, Mother {  \n    \n    }  \n    \n    public class Daughter implements Father{  \n    \n        class Mother_ implements Mother{  \n            \n        }  \n    }  \n```\n\n其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。\n其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n   \n    1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n    2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n    3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n    4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n    5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 内部类基础\n在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。\n当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。\n```java\n\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        /**省略getter和setter方法**/  \n        \n        public class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n            \n            public void display(){  \n                System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.display();  \n        }  \n    }  \n    --------------  \n    Output：  \n    name：chenssy   ;age：23  \n```\n\n在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。\n其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。\n同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。\n```java\n    public class OuterClass {  \n        public void display(){  \n            System.out.println(\"OuterClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public OuterClass getOuterClass(){  \n                return OuterClass.this;  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.getOuterClass().display();  \n        }  \n    }  \n    -------------  \n    Output:  \n    OuterClass...  \n```\n到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。\n在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。\n\n## 成员内部类\n成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n```java\n    public class OuterClass {  \n        private String str;  \n        \n        public void outerDisplay(){  \n            System.out.println(\"outerClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public void innerDisplay(){  \n                //使用外围内的属性  \n                str = \"chenssy...\";  \n                System.out.println(str);  \n                //使用外围内的方法  \n                outerDisplay();  \n            }  \n        }  \n        \n        /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */  \n        public InnerClass getInnerClass(){  \n            return new InnerClass();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            OuterClass.InnerClass inner = outer.getInnerClass();  \n            inner.innerDisplay();  \n        }  \n    }  \n    --------------------  \n    chenssy...  \n    outerClass...  \n```\n推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。\n\n## 局部内部类\n有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\n对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。\n定义在方法里：\n```java\n    public class Parcel5 {  \n        public Destionation destionation(String str){  \n            class PDestionation implements Destionation{  \n                private String label;  \n                private PDestionation(String whereTo){  \n                    label = whereTo;  \n                }  \n                public String readLabel(){  \n                    return label;  \n                }  \n            }  \n            return new PDestionation(str);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel5 parcel5 = new Parcel5();  \n            Destionation d = parcel5.destionation(\"chenssy\");  \n        }  \n    }  \n```\n定义在作用域内:\n```java\n    public class Parcel6 {  \n        private void internalTracking(boolean b){  \n            if(b){  \n                class TrackingSlip{  \n                    private String id;  \n                    TrackingSlip(String s) {  \n                        id = s;  \n                    }  \n                    String getSlip(){  \n                        return id;  \n                    }  \n                }  \n                TrackingSlip ts = new TrackingSlip(\"chenssy\");  \n                String string = ts.getSlip();  \n            }  \n        }  \n        \n        public void track(){  \n            internalTracking(true);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel6 parcel6 = new Parcel6();  \n            parcel6.track();  \n        }  \n    }  \n```\n## 匿名内部类\n在做Swing编程中，我们经常使用这种方式来绑定事件\n```java\n    button2.addActionListener(    \n                    new ActionListener(){    \n                        public void actionPerformed(ActionEvent e) {    \n                            System.out.println(\"你按了按钮二\");    \n                        }    \n                    });  \n```\n        我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n```java\n    public class OuterClass {  \n        public InnerClass getInnerClass(final int num,String str2){  \n            return new InnerClass(){  \n                int number = num + 3;  \n                public int getNumber(){  \n                    return number;  \n                }  \n            };        /* 注意：分号不能省 */  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass out = new OuterClass();  \n            InnerClass inner = out.getInnerClass(2, \"chenssy\");  \n            System.out.println(inner.getNumber());  \n        }  \n    }  \n    \n    interface InnerClass {  \n        int getNumber();  \n    }  \n    \n    ----------------  \n    Output:  \n    5  \n```\n这里我们就需要看清几个地方\n1、 匿名内部类是没有访问修饰符的。\n2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\nPS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇-----详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……\n\n## 静态内部类\n在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：\n1、 它的创建是不需要依赖于外围类的。\n2、 它不能使用任何外围类的非static成员变量和方法。\n```java\n    public class OuterClass {  \n        private String sex;  \n        public static String name = \"chenssy\";  \n        \n        /** \n        *静态内部类 \n        */  \n        static class InnerClass1{  \n            /* 在静态内部类中可以存在静态成员 */  \n            public static String _name1 = \"chenssy_static\";  \n            \n            public void display(){  \n                /*  \n                * 静态内部类只能访问外围类的静态成员变量和方法 \n                * 不能访问外围类的非静态成员变量和方法 \n                */  \n                System.out.println(\"OutClass name :\" + name);  \n            }  \n        }  \n        \n        /** \n        * 非静态内部类 \n        */  \n        class InnerClass2{  \n            /* 非静态内部类中不能存在静态成员 */  \n            public String _name2 = \"chenssy_inner\";  \n            /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */  \n            public void display(){  \n                System.out.println(\"OuterClass name：\" + name);  \n            }  \n        }  \n        \n        /** \n        * @desc 外围类方法 \n        * @author chenssy \n        * @data 2013-10-25 \n        * @return void \n        */  \n        public void display(){  \n            /* 外围类访问静态内部类：内部类. */  \n            System.out.println(InnerClass1._name1);  \n            /* 静态内部类 可以直接创建实例不需要依赖于外围类 */  \n            new InnerClass1().display();  \n            \n            /* 非静态内部的创建需要依赖于外围类 */  \n            OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();  \n            /* 方位非静态内部类的成员需要使用非静态内部类的实例 */  \n            System.out.println(inner2._name2);  \n            inner2.display();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            outer.display();  \n        }  \n    }  \n    ----------------  \n    Output:  \n    chenssy_static  \n    OutClass name :chenssy  \n    chenssy_inner  \n    OuterClass name：chenssy  \n```\n上面这个例子充分展现了静态内部类和非静态内部类的区别。\n到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!\n","source":"_posts/java-toup8.md","raw":"---\ntitle: java提高篇（七）-----详解内部类\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: '30043e85'\ndate: 2017-10-23 13:38:12\n---\n> 转载：http://blog.csdn.net/chenssy/article/details/13024951\n\n可以将一个类的定义放在另一个类的定义内部，这就是内部类。\n内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。\n第一次见面\n内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。\n```java\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            this.age = age;  \n        }  \n        \n        class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n        }  \n    }  \n```\n在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。\n<!-- more -->\n\n## 为什么要使用内部类\n为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n```java\n\n    public interface Father {  \n    \n    }  \n    \n    public interface Mother {  \n    \n    }  \n    \n    public class Son implements Father, Mother {  \n    \n    }  \n    \n    public class Daughter implements Father{  \n    \n        class Mother_ implements Mother{  \n            \n        }  \n    }  \n```\n\n其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。\n其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n   \n    1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n    2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n    3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n    4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n    5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 内部类基础\n在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。\n当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。\n```java\n\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        /**省略getter和setter方法**/  \n        \n        public class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n            \n            public void display(){  \n                System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.display();  \n        }  \n    }  \n    --------------  \n    Output：  \n    name：chenssy   ;age：23  \n```\n\n在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。\n其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。\n同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。\n```java\n    public class OuterClass {  \n        public void display(){  \n            System.out.println(\"OuterClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public OuterClass getOuterClass(){  \n                return OuterClass.this;  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.getOuterClass().display();  \n        }  \n    }  \n    -------------  \n    Output:  \n    OuterClass...  \n```\n到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。\n在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。\n\n## 成员内部类\n成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n```java\n    public class OuterClass {  \n        private String str;  \n        \n        public void outerDisplay(){  \n            System.out.println(\"outerClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public void innerDisplay(){  \n                //使用外围内的属性  \n                str = \"chenssy...\";  \n                System.out.println(str);  \n                //使用外围内的方法  \n                outerDisplay();  \n            }  \n        }  \n        \n        /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */  \n        public InnerClass getInnerClass(){  \n            return new InnerClass();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            OuterClass.InnerClass inner = outer.getInnerClass();  \n            inner.innerDisplay();  \n        }  \n    }  \n    --------------------  \n    chenssy...  \n    outerClass...  \n```\n推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。\n\n## 局部内部类\n有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\n对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。\n定义在方法里：\n```java\n    public class Parcel5 {  \n        public Destionation destionation(String str){  \n            class PDestionation implements Destionation{  \n                private String label;  \n                private PDestionation(String whereTo){  \n                    label = whereTo;  \n                }  \n                public String readLabel(){  \n                    return label;  \n                }  \n            }  \n            return new PDestionation(str);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel5 parcel5 = new Parcel5();  \n            Destionation d = parcel5.destionation(\"chenssy\");  \n        }  \n    }  \n```\n定义在作用域内:\n```java\n    public class Parcel6 {  \n        private void internalTracking(boolean b){  \n            if(b){  \n                class TrackingSlip{  \n                    private String id;  \n                    TrackingSlip(String s) {  \n                        id = s;  \n                    }  \n                    String getSlip(){  \n                        return id;  \n                    }  \n                }  \n                TrackingSlip ts = new TrackingSlip(\"chenssy\");  \n                String string = ts.getSlip();  \n            }  \n        }  \n        \n        public void track(){  \n            internalTracking(true);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel6 parcel6 = new Parcel6();  \n            parcel6.track();  \n        }  \n    }  \n```\n## 匿名内部类\n在做Swing编程中，我们经常使用这种方式来绑定事件\n```java\n    button2.addActionListener(    \n                    new ActionListener(){    \n                        public void actionPerformed(ActionEvent e) {    \n                            System.out.println(\"你按了按钮二\");    \n                        }    \n                    });  \n```\n        我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n```java\n    public class OuterClass {  \n        public InnerClass getInnerClass(final int num,String str2){  \n            return new InnerClass(){  \n                int number = num + 3;  \n                public int getNumber(){  \n                    return number;  \n                }  \n            };        /* 注意：分号不能省 */  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass out = new OuterClass();  \n            InnerClass inner = out.getInnerClass(2, \"chenssy\");  \n            System.out.println(inner.getNumber());  \n        }  \n    }  \n    \n    interface InnerClass {  \n        int getNumber();  \n    }  \n    \n    ----------------  \n    Output:  \n    5  \n```\n这里我们就需要看清几个地方\n1、 匿名内部类是没有访问修饰符的。\n2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\nPS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇-----详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……\n\n## 静态内部类\n在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：\n1、 它的创建是不需要依赖于外围类的。\n2、 它不能使用任何外围类的非static成员变量和方法。\n```java\n    public class OuterClass {  \n        private String sex;  \n        public static String name = \"chenssy\";  \n        \n        /** \n        *静态内部类 \n        */  \n        static class InnerClass1{  \n            /* 在静态内部类中可以存在静态成员 */  \n            public static String _name1 = \"chenssy_static\";  \n            \n            public void display(){  \n                /*  \n                * 静态内部类只能访问外围类的静态成员变量和方法 \n                * 不能访问外围类的非静态成员变量和方法 \n                */  \n                System.out.println(\"OutClass name :\" + name);  \n            }  \n        }  \n        \n        /** \n        * 非静态内部类 \n        */  \n        class InnerClass2{  \n            /* 非静态内部类中不能存在静态成员 */  \n            public String _name2 = \"chenssy_inner\";  \n            /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */  \n            public void display(){  \n                System.out.println(\"OuterClass name：\" + name);  \n            }  \n        }  \n        \n        /** \n        * @desc 外围类方法 \n        * @author chenssy \n        * @data 2013-10-25 \n        * @return void \n        */  \n        public void display(){  \n            /* 外围类访问静态内部类：内部类. */  \n            System.out.println(InnerClass1._name1);  \n            /* 静态内部类 可以直接创建实例不需要依赖于外围类 */  \n            new InnerClass1().display();  \n            \n            /* 非静态内部的创建需要依赖于外围类 */  \n            OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();  \n            /* 方位非静态内部类的成员需要使用非静态内部类的实例 */  \n            System.out.println(inner2._name2);  \n            inner2.display();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            outer.display();  \n        }  \n    }  \n    ----------------  \n    Output:  \n    chenssy_static  \n    OutClass name :chenssy  \n    chenssy_inner  \n    OuterClass name：chenssy  \n```\n上面这个例子充分展现了静态内部类和非静态内部类的区别。\n到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!\n","slug":"java-toup8","published":1,"updated":"2019-09-03T03:40:46.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketfy003u0vfa13g220u6","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/13024951\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13024951</a></p></blockquote><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。<br>内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。<br>第一次见面<br>内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">            age = <span class=\"number\">23</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。<br><a id=\"more\"></a></p><h2 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h2><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p><pre><code>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n</code></pre><h2 id=\"内部类基础\"><a href=\"#内部类基础\" class=\"headerlink\" title=\"内部类基础\"></a>内部类基础</h2><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**省略getter和setter方法**/</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">            age = <span class=\"number\">23</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"name：\"</span> + getName() +<span class=\"string\">\"   ;age：\"</span> + getAge());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </span><br><span class=\"line\">        innerClass.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------  </span><br><span class=\"line\">Output：  </span><br><span class=\"line\">name：chenssy   ;age：<span class=\"number\">23</span></span><br></pre></td></tr></table></figure><p></p><p>在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。<br>同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"OuterClass...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> OuterClass <span class=\"title\">getOuterClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> OuterClass.<span class=\"keyword\">this</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </span><br><span class=\"line\">        innerClass.getOuterClass().display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">OuterClass...</span><br></pre></td></tr></table></figure><p></p><p>到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p><h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String str;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">outerDisplay</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"outerClass...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerDisplay</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//使用外围内的属性  </span></span><br><span class=\"line\">            str = <span class=\"string\">\"chenssy...\"</span>;  </span><br><span class=\"line\">            System.out.println(str);  </span><br><span class=\"line\">            <span class=\"comment\">//使用外围内的方法  </span></span><br><span class=\"line\">            outerDisplay();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass inner = outer.getInnerClass();  </span><br><span class=\"line\">        inner.innerDisplay();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------  </span><br><span class=\"line\">chenssy...  </span><br><span class=\"line\">outerClass...</span><br></pre></td></tr></table></figure><p></p><p>推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。</p><h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。<br>定义在方法里：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel5</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destionation <span class=\"title\">destionation</span><span class=\"params\">(String str)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PDestionation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Destionation</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> String label;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PDestionation</span><span class=\"params\">(String whereTo)</span></span>&#123;  </span><br><span class=\"line\">                label = whereTo;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> label;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PDestionation(str);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Parcel5 parcel5 = <span class=\"keyword\">new</span> Parcel5();  </span><br><span class=\"line\">        Destionation d = parcel5.destionation(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>定义在作用域内:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel6</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">internalTracking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b)&#123;  </span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackingSlip</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">private</span> String id;  </span><br><span class=\"line\">                TrackingSlip(String s) &#123;  </span><br><span class=\"line\">                    id = s;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"function\">String <span class=\"title\">getSlip</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> id;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            TrackingSlip ts = <span class=\"keyword\">new</span> TrackingSlip(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">            String string = ts.getSlip();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">track</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        internalTracking(<span class=\"keyword\">true</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Parcel6 parcel6 = <span class=\"keyword\">new</span> Parcel6();  </span><br><span class=\"line\">        parcel6.track();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button2.addActionListener(    </span><br><span class=\"line\">                <span class=\"keyword\">new</span> ActionListener()&#123;    </span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent e)</span> </span>&#123;    </span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"你按了按钮二\"</span>);    </span><br><span class=\"line\">                    &#125;    </span><br><span class=\"line\">                &#125;);</span><br></pre></td></tr></table></figure><p></p><pre><code>    我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num,String str2)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass()&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> number = num + <span class=\"number\">3</span>;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> number;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;        <span class=\"comment\">/* 注意：分号不能省 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass out = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        InnerClass inner = out.getInnerClass(<span class=\"number\">2</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner.getNumber());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InnerClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">----------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure><p>这里我们就需要看清几个地方<br>1、 匿名内部类是没有访问修饰符的。<br>2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。<br>PS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇——-详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……</p><h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>在java提高篇——-关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：<br>1、 它的创建是不需要依赖于外围类的。<br>2、 它不能使用任何外围类的非static成员变量和方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    *静态内部类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass1</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 在静态内部类中可以存在静态成员 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String _name1 = <span class=\"string\">\"chenssy_static\"</span>;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">            * 静态内部类只能访问外围类的静态成员变量和方法 </span></span><br><span class=\"line\"><span class=\"comment\">            * 不能访问外围类的非静态成员变量和方法 </span></span><br><span class=\"line\"><span class=\"comment\">            */</span>  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"OutClass name :\"</span> + name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 非静态内部类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass2</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部类中不能存在静态成员 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">public</span> String _name2 = <span class=\"string\">\"chenssy_inner\"</span>;  </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"OuterClass name：\"</span> + name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 外围类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-10-25 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 外围类访问静态内部类：内部类. */</span>  </span><br><span class=\"line\">        System.out.println(InnerClass1._name1);  </span><br><span class=\"line\">        <span class=\"comment\">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> InnerClass1().display();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部的创建需要依赖于外围类 */</span>  </span><br><span class=\"line\">        OuterClass.InnerClass2 inner2 = <span class=\"keyword\">new</span> OuterClass().new InnerClass2();  </span><br><span class=\"line\">        <span class=\"comment\">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span>  </span><br><span class=\"line\">        System.out.println(inner2._name2);  </span><br><span class=\"line\">        inner2.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        outer.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">chenssy_static  </span><br><span class=\"line\">OutClass name :chenssy  </span><br><span class=\"line\">chenssy_inner  </span><br><span class=\"line\">OuterClass name：chenssy</span><br></pre></td></tr></table></figure><p></p><p>上面这个例子充分展现了静态内部类和非静态内部类的区别。<br>到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!</p><!-- rebuild by neat -->","site":{"data":{}},"length":9991,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/13024951\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13024951</a></p></blockquote><p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。<br>内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。<br>第一次见面<br>内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">            age = <span class=\"number\">23</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。<br>","more":"</p><h2 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h2><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p><pre><code>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n</code></pre><h2 id=\"内部类基础\"><a href=\"#内部类基础\" class=\"headerlink\" title=\"内部类基础\"></a>内部类基础</h2><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name ;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**省略getter和setter方法**/</span>  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">            age = <span class=\"number\">23</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"name：\"</span> + getName() +<span class=\"string\">\"   ;age：\"</span> + getAge());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </span><br><span class=\"line\">        innerClass.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------  </span><br><span class=\"line\">Output：  </span><br><span class=\"line\">name：chenssy   ;age：<span class=\"number\">23</span></span><br></pre></td></tr></table></figure><p></p><p>在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。<br>同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"OuterClass...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> OuterClass <span class=\"title\">getOuterClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> OuterClass.<span class=\"keyword\">this</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </span><br><span class=\"line\">        innerClass.getOuterClass().display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">-------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">OuterClass...</span><br></pre></td></tr></table></figure><p></p><p>到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p><h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String str;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">outerDisplay</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"outerClass...\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerDisplay</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//使用外围内的属性  </span></span><br><span class=\"line\">            str = <span class=\"string\">\"chenssy...\"</span>;  </span><br><span class=\"line\">            System.out.println(str);  </span><br><span class=\"line\">            <span class=\"comment\">//使用外围内的方法  </span></span><br><span class=\"line\">            outerDisplay();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        OuterClass.InnerClass inner = outer.getInnerClass();  </span><br><span class=\"line\">        inner.innerDisplay();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">--------------------  </span><br><span class=\"line\">chenssy...  </span><br><span class=\"line\">outerClass...</span><br></pre></td></tr></table></figure><p></p><p>推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。</p><h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。<br>定义在方法里：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel5</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destionation <span class=\"title\">destionation</span><span class=\"params\">(String str)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PDestionation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Destionation</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> String label;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PDestionation</span><span class=\"params\">(String whereTo)</span></span>&#123;  </span><br><span class=\"line\">                label = whereTo;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> label;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PDestionation(str);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Parcel5 parcel5 = <span class=\"keyword\">new</span> Parcel5();  </span><br><span class=\"line\">        Destionation d = parcel5.destionation(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>定义在作用域内:<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel6</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">internalTracking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b)&#123;  </span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackingSlip</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">private</span> String id;  </span><br><span class=\"line\">                TrackingSlip(String s) &#123;  </span><br><span class=\"line\">                    id = s;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                <span class=\"function\">String <span class=\"title\">getSlip</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">return</span> id;  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            TrackingSlip ts = <span class=\"keyword\">new</span> TrackingSlip(<span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">            String string = ts.getSlip();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">track</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        internalTracking(<span class=\"keyword\">true</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Parcel6 parcel6 = <span class=\"keyword\">new</span> Parcel6();  </span><br><span class=\"line\">        parcel6.track();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button2.addActionListener(    </span><br><span class=\"line\">                <span class=\"keyword\">new</span> ActionListener()&#123;    </span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent e)</span> </span>&#123;    </span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"你按了按钮二\"</span>);    </span><br><span class=\"line\">                    &#125;    </span><br><span class=\"line\">                &#125;);</span><br></pre></td></tr></table></figure><p></p><pre><code>    我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num,String str2)</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass()&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> number = num + <span class=\"number\">3</span>;  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> number;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;        <span class=\"comment\">/* 注意：分号不能省 */</span>  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass out = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        InnerClass inner = out.getInnerClass(<span class=\"number\">2</span>, <span class=\"string\">\"chenssy\"</span>);  </span><br><span class=\"line\">        System.out.println(inner.getNumber());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InnerClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">----------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure><p>这里我们就需要看清几个地方<br>1、 匿名内部类是没有访问修饰符的。<br>2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。<br>PS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇——-详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……</p><h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>在java提高篇——-关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：<br>1、 它的创建是不需要依赖于外围类的。<br>2、 它不能使用任何外围类的非static成员变量和方法。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String name = <span class=\"string\">\"chenssy\"</span>;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    *静态内部类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass1</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 在静态内部类中可以存在静态成员 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String _name1 = <span class=\"string\">\"chenssy_static\"</span>;  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">            * 静态内部类只能访问外围类的静态成员变量和方法 </span></span><br><span class=\"line\"><span class=\"comment\">            * 不能访问外围类的非静态成员变量和方法 </span></span><br><span class=\"line\"><span class=\"comment\">            */</span>  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"OutClass name :\"</span> + name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 非静态内部类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass2</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部类中不能存在静态成员 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">public</span> String _name2 = <span class=\"string\">\"chenssy_inner\"</span>;  </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"OuterClass name：\"</span> + name);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 外围类方法 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-10-25 </span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"comment\">/* 外围类访问静态内部类：内部类. */</span>  </span><br><span class=\"line\">        System.out.println(InnerClass1._name1);  </span><br><span class=\"line\">        <span class=\"comment\">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span>  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> InnerClass1().display();  </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/* 非静态内部的创建需要依赖于外围类 */</span>  </span><br><span class=\"line\">        OuterClass.InnerClass2 inner2 = <span class=\"keyword\">new</span> OuterClass().new InnerClass2();  </span><br><span class=\"line\">        <span class=\"comment\">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span>  </span><br><span class=\"line\">        System.out.println(inner2._name2);  </span><br><span class=\"line\">        inner2.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </span><br><span class=\"line\">        outer.display();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">chenssy_static  </span><br><span class=\"line\">OutClass name :chenssy  </span><br><span class=\"line\">chenssy_inner  </span><br><span class=\"line\">OuterClass name：chenssy</span><br></pre></td></tr></table></figure><p></p><p>上面这个例子充分展现了静态内部类和非静态内部类的区别。<br>到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!</p><!-- rebuild by neat -->"},{"title":"java提高篇（八）-----实现多重继承","abbrlink":"f13260f4","date":"2017-10-23T05:38:22.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","source":"_posts/java-toup9.md","raw":"---\ntitle: java提高篇（八）-----实现多重继承\ntags:\n  - java\n  - 转载\ncategories: java开发\nabbrlink: f13260f4\ndate: 2017-10-23 13:38:22\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","slug":"java-toup9","published":1,"updated":"2019-09-03T03:40:46.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketg2003x0vfa4s7syn6g","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13168265</a></p></blockquote><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br><a id=\"more\"></a><br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重头戏在这里，儿子类Son：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </span><br><span class=\"line\">Son 的kind：<span class=\"number\">6</span></span><br></pre></td></tr></table></figure><p></p><p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p><!-- rebuild by neat -->","site":{"data":{}},"length":2448,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/chenssy/article/details/13168265</a></p></blockquote><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br>","more":"<br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重头戏在这里，儿子类Son：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span>  </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试程序：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </span><br><span class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">----------------------------------------  </span><br><span class=\"line\">Output:  </span><br><span class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </span><br><span class=\"line\">Son 的kind：<span class=\"number\">6</span></span><br></pre></td></tr></table></figure><p></p><p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p><!-- rebuild by neat -->"},{"title":"记“刺客信条”三部曲：水月镜像，无心去来","comments":1,"brief":"第一次有冲动为一个游戏写文字","abbrlink":"dcb13445","date":"2017-10-19T14:40:00.000Z","_content":"> 转载： http://litten.me/2012/12/18/assassins-creed/\n\n![刺客信条-兄弟会海报](/uploads/ckxt0.jpg)\n> Nothing is true,everything is permitted. 万事皆虚，万物皆允。\n\n*—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲*\n<!-- more -->\n实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。\n\n## **虚**\nEzio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。\n\n![奔波到威尼斯的Ezio](/uploads/ckxt1.jpg)\n以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。\n\nEzio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。\n\n![刺客从天而降](/uploads/ckxt2.jpg)\n\n因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。\n\n## **允**\n\n任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。\n\n![信仰之跃](/uploads/ckxt3.jpg)      \n\n他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。\n                 \n游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。\n![年迈的Ezio](/uploads/ckxt4.jpg)      \n\n到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。\n\nEzio最后的信：\n> When I was a young man,              \n> 当我还是个年轻的小伙子                \n> I had liberty, but I did not see it.                 \n> 我拥有自由，却从未认知                  \n> I had time, but I did not know it.                   \n> 我拥有时间，却毫不知情                   \n> And I had love, but I did not feel it.                   \n> 而我亦拥有爱，却从未感觉到                   \n> Many decades would pass before I understood the meaning of all three.                   \n> 直到数十年过去后，我才真正理解这三项的意义                   \n> And now, the twilight of my life, misunderstanding has past into contentment.                   \n> 而现在，垂暮之年的我，这领悟让我感到满足                   \n> Love, liberty, and time: once was so disposable, are the fuels that drive me forward.                   \n> 曾经能自由支配的爱，自由以及时间，是支持我前进的动力                   \n> And love, most especially, mia caro.                   \n> 而爱，是最特别的一个， 亲爱的                   \n> For you, our children, our brothers and sisters.                   \n> 为你，为我们的孩子以及为我们的兄弟姐妹们                   \n> And for the vast and wonderful world that gives us lives and keeps us guessing,                   \n> 为这赐予我们生命与惊奇的广阔，精彩的世界                   \n> endless affection，mio Sofia,                   \n> 至死不渝的挚爱， 我的索菲亚                   \n> Forever yours, Ezio Auditore                   \n> 永远属于你的， Ezio Auditore","source":"_posts/myFirstBlog.md","raw":"---\ntitle: 记“刺客信条”三部曲：水月镜像，无心去来\ntags:\n  - 游戏\n  - 旧事\ncategories:\n  - 转载\ncomments: true\nbrief: 第一次有冲动为一个游戏写文字\nabbrlink: dcb13445\ndate: 2017-10-19 22:40:00\n---\n> 转载： http://litten.me/2012/12/18/assassins-creed/\n\n![刺客信条-兄弟会海报](/uploads/ckxt0.jpg)\n> Nothing is true,everything is permitted. 万事皆虚，万物皆允。\n\n*—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲*\n<!-- more -->\n实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。\n\n## **虚**\nEzio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。\n\n![奔波到威尼斯的Ezio](/uploads/ckxt1.jpg)\n以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。\n\nEzio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。\n\n![刺客从天而降](/uploads/ckxt2.jpg)\n\n因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。\n\n## **允**\n\n任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。\n\n![信仰之跃](/uploads/ckxt3.jpg)      \n\n他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。\n                 \n游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。\n![年迈的Ezio](/uploads/ckxt4.jpg)      \n\n到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。\n\nEzio最后的信：\n> When I was a young man,              \n> 当我还是个年轻的小伙子                \n> I had liberty, but I did not see it.                 \n> 我拥有自由，却从未认知                  \n> I had time, but I did not know it.                   \n> 我拥有时间，却毫不知情                   \n> And I had love, but I did not feel it.                   \n> 而我亦拥有爱，却从未感觉到                   \n> Many decades would pass before I understood the meaning of all three.                   \n> 直到数十年过去后，我才真正理解这三项的意义                   \n> And now, the twilight of my life, misunderstanding has past into contentment.                   \n> 而现在，垂暮之年的我，这领悟让我感到满足                   \n> Love, liberty, and time: once was so disposable, are the fuels that drive me forward.                   \n> 曾经能自由支配的爱，自由以及时间，是支持我前进的动力                   \n> And love, most especially, mia caro.                   \n> 而爱，是最特别的一个， 亲爱的                   \n> For you, our children, our brothers and sisters.                   \n> 为你，为我们的孩子以及为我们的兄弟姐妹们                   \n> And for the vast and wonderful world that gives us lives and keeps us guessing,                   \n> 为这赐予我们生命与惊奇的广阔，精彩的世界                   \n> endless affection，mio Sofia,                   \n> 至死不渝的挚爱， 我的索菲亚                   \n> Forever yours, Ezio Auditore                   \n> 永远属于你的， Ezio Auditore","slug":"myFirstBlog","published":1,"updated":"2019-09-03T03:40:46.229Z","layout":"post","photos":[],"link":"","_id":"ck07ketg700410vfamchpl6zu","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2012/12/18/assassins-creed/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2012/12/18/assassins-creed/</a></p></blockquote><p><img src=\"/uploads/ckxt0.jpg\" alt=\"刺客信条-兄弟会海报\"></p><blockquote><p>Nothing is true,everything is permitted. 万事皆虚，万物皆允。</p></blockquote><p><em>—— 《刺客信条2》 《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲</em><br><a id=\"more\"></a><br>实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。</p><h2 id=\"虚\"><a href=\"#虚\" class=\"headerlink\" title=\"虚\"></a><strong>虚</strong></h2><p>Ezio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。</p><p><img src=\"/uploads/ckxt1.jpg\" alt=\"奔波到威尼斯的Ezio\"><br>以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。</p><p>Ezio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。</p><p><img src=\"/uploads/ckxt2.jpg\" alt=\"刺客从天而降\"></p><p>因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。</p><h2 id=\"允\"><a href=\"#允\" class=\"headerlink\" title=\"允\"></a><strong>允</strong></h2><p>任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。</p><p><img src=\"/uploads/ckxt3.jpg\" alt=\"信仰之跃\"></p><p>他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。</p><p>游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。<br><img src=\"/uploads/ckxt4.jpg\" alt=\"年迈的Ezio\"></p><p>到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。</p><p>Ezio最后的信：</p><blockquote><p>When I was a young man,<br>当我还是个年轻的小伙子<br>I had liberty, but I did not see it.<br>我拥有自由，却从未认知<br>I had time, but I did not know it.<br>我拥有时间，却毫不知情<br>And I had love, but I did not feel it.<br>而我亦拥有爱，却从未感觉到<br>Many decades would pass before I understood the meaning of all three.<br>直到数十年过去后，我才真正理解这三项的意义<br>And now, the twilight of my life, misunderstanding has past into contentment.<br>而现在，垂暮之年的我，这领悟让我感到满足<br>Love, liberty, and time: once was so disposable, are the fuels that drive me forward.<br>曾经能自由支配的爱，自由以及时间，是支持我前进的动力<br>And love, most especially, mia caro.<br>而爱，是最特别的一个， 亲爱的<br>For you, our children, our brothers and sisters.<br>为你，为我们的孩子以及为我们的兄弟姐妹们<br>And for the vast and wonderful world that gives us lives and keeps us guessing,<br>为这赐予我们生命与惊奇的广阔，精彩的世界<br>endless affection，mio Sofia,<br>至死不渝的挚爱， 我的索菲亚<br>Forever yours, Ezio Auditore<br>永远属于你的， Ezio Auditore</p></blockquote><!-- rebuild by neat -->","site":{"data":{}},"length":3177,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2012/12/18/assassins-creed/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2012/12/18/assassins-creed/</a></p></blockquote><p><img src=\"/uploads/ckxt0.jpg\" alt=\"刺客信条-兄弟会海报\"></p><blockquote><p>Nothing is true,everything is permitted. 万事皆虚，万物皆允。</p></blockquote><p><em>—— 《刺客信条2》 《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲</em><br>","more":"<br>实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。</p><h2 id=\"虚\"><a href=\"#虚\" class=\"headerlink\" title=\"虚\"></a><strong>虚</strong></h2><p>Ezio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。</p><p><img src=\"/uploads/ckxt1.jpg\" alt=\"奔波到威尼斯的Ezio\"><br>以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。</p><p>Ezio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。</p><p><img src=\"/uploads/ckxt2.jpg\" alt=\"刺客从天而降\"></p><p>因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。</p><h2 id=\"允\"><a href=\"#允\" class=\"headerlink\" title=\"允\"></a><strong>允</strong></h2><p>任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。</p><p><img src=\"/uploads/ckxt3.jpg\" alt=\"信仰之跃\"></p><p>他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。</p><p>游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。<br><img src=\"/uploads/ckxt4.jpg\" alt=\"年迈的Ezio\"></p><p>到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。</p><p>Ezio最后的信：</p><blockquote><p>When I was a young man,<br>当我还是个年轻的小伙子<br>I had liberty, but I did not see it.<br>我拥有自由，却从未认知<br>I had time, but I did not know it.<br>我拥有时间，却毫不知情<br>And I had love, but I did not feel it.<br>而我亦拥有爱，却从未感觉到<br>Many decades would pass before I understood the meaning of all three.<br>直到数十年过去后，我才真正理解这三项的意义<br>And now, the twilight of my life, misunderstanding has past into contentment.<br>而现在，垂暮之年的我，这领悟让我感到满足<br>Love, liberty, and time: once was so disposable, are the fuels that drive me forward.<br>曾经能自由支配的爱，自由以及时间，是支持我前进的动力<br>And love, most especially, mia caro.<br>而爱，是最特别的一个， 亲爱的<br>For you, our children, our brothers and sisters.<br>为你，为我们的孩子以及为我们的兄弟姐妹们<br>And for the vast and wonderful world that gives us lives and keeps us guessing,<br>为这赐予我们生命与惊奇的广阔，精彩的世界<br>endless affection，mio Sofia,<br>至死不渝的挚爱， 我的索菲亚<br>Forever yours, Ezio Auditore<br>永远属于你的， Ezio Auditore</p></blockquote><!-- rebuild by neat -->"},{"title":"mysql主从同步配置","abbrlink":"b1d2b707","date":"2019-08-19T06:07:00.000Z","_content":"mysql主从同步主要基于日志（binlog）的主从复制方式\n\n\n## 主库配置\n在主库的mysql配置文件my.cnf的 [mysqld]下添加配置：\n\n```java\n## 开启日志文件\nlog-bin=mysql-bin\n## 服务器ID 一般为IP末尾\nserver-id=27\n## 不参与主从的数据库名\nbinlog-ignore-db=mysql\n##需要同步的数据库，多个的话另外起一行配置 binlog-do-db=test\nbinlog-do-db=boot\n\n```\n\n主库新增用户，主服务器给从服务器账号授权：\n```java\n##创建用户\ncreate user 'mstest'@'%' identified WITH mysql_native_password by '123456'; \n##用户授权\nGRANT REPLICATION SLAVE ON *.* to 'mstest'@'%' ; \n```\n如果报错，记得修改mysql密码验证策略\n<!-- more -->\n执行 show master status;\n\n![upload successful](/uploads/mysql-master.png)\n\n\n## 从库配置\n\n```java\n[mysqld]\nserver-id=187\nlog-bin=mysql-bin\n\n```\n\n重启mysql\n\n进入mysql, mysql -u root -p;\n\n```java\nstop slave;\nchange master to \nmaster_host='192.168.1.128',\nmaster_user='mstest',\nmaster_password='123456',\nmaster_log_file='mysql-bin.000003',\nmaster_log_pos=852;\nstart slave;\n\n```\nmaster_host: 主库IP地址\n\nmaster_user：上面新建的用户名\n\nmaster_password：密码\n\nmaster_log_file：主库的日志文件\n\nmaster_log_pos： 主库日志文件起始位置，具体查看上图\n\n执行show slave status\\G;\n\n\n\n![upload successful](/uploads/mysql-slave.png)\n\n## MySQL同步故障：\" Slave_SQL_Running:No\"\n\n\n一般是事务回滚造成的：\n解决办法：\n```java\n stop slave ;\n set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;\n start slave ;\n ```","source":"_posts/mysql主从同步配置.md","raw":"---\ntitle: mysql主从同步配置\ntags:\n  - Mysql\ncategories:\n  - Mysql\nabbrlink: b1d2b707\ndate: 2019-08-19 14:07:00\n---\nmysql主从同步主要基于日志（binlog）的主从复制方式\n\n\n## 主库配置\n在主库的mysql配置文件my.cnf的 [mysqld]下添加配置：\n\n```java\n## 开启日志文件\nlog-bin=mysql-bin\n## 服务器ID 一般为IP末尾\nserver-id=27\n## 不参与主从的数据库名\nbinlog-ignore-db=mysql\n##需要同步的数据库，多个的话另外起一行配置 binlog-do-db=test\nbinlog-do-db=boot\n\n```\n\n主库新增用户，主服务器给从服务器账号授权：\n```java\n##创建用户\ncreate user 'mstest'@'%' identified WITH mysql_native_password by '123456'; \n##用户授权\nGRANT REPLICATION SLAVE ON *.* to 'mstest'@'%' ; \n```\n如果报错，记得修改mysql密码验证策略\n<!-- more -->\n执行 show master status;\n\n![upload successful](/uploads/mysql-master.png)\n\n\n## 从库配置\n\n```java\n[mysqld]\nserver-id=187\nlog-bin=mysql-bin\n\n```\n\n重启mysql\n\n进入mysql, mysql -u root -p;\n\n```java\nstop slave;\nchange master to \nmaster_host='192.168.1.128',\nmaster_user='mstest',\nmaster_password='123456',\nmaster_log_file='mysql-bin.000003',\nmaster_log_pos=852;\nstart slave;\n\n```\nmaster_host: 主库IP地址\n\nmaster_user：上面新建的用户名\n\nmaster_password：密码\n\nmaster_log_file：主库的日志文件\n\nmaster_log_pos： 主库日志文件起始位置，具体查看上图\n\n执行show slave status\\G;\n\n\n\n![upload successful](/uploads/mysql-slave.png)\n\n## MySQL同步故障：\" Slave_SQL_Running:No\"\n\n\n一般是事务回滚造成的：\n解决办法：\n```java\n stop slave ;\n set GLOBAL SQL_SLAVE_SKIP_COUNTER=1;\n start slave ;\n ```","slug":"mysql主从同步配置","published":1,"updated":"2019-09-03T03:40:46.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketg900440vfafu9p3np3","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>mysql主从同步主要基于日志（binlog）的主从复制方式</p><h2 id=\"主库配置\"><a href=\"#主库配置\" class=\"headerlink\" title=\"主库配置\"></a>主库配置</h2><p>在主库的mysql配置文件my.cnf的 [mysqld]下添加配置：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 开启日志文件</span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">## 服务器ID 一般为IP末尾</span><br><span class=\"line\">server-id=<span class=\"number\">27</span></span><br><span class=\"line\">## 不参与主从的数据库名</span><br><span class=\"line\">binlog-ignore-db=mysql</span><br><span class=\"line\">##需要同步的数据库，多个的话另外起一行配置 binlog-do-db=test</span><br><span class=\"line\">binlog-<span class=\"keyword\">do</span>-db=boot</span><br></pre></td></tr></table></figure><p>主库新增用户，主服务器给从服务器账号授权：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">##创建用户</span><br><span class=\"line\">create user <span class=\"string\">'mstest'</span>@<span class=\"string\">'%'</span> identified WITH mysql_native_password by <span class=\"string\">'123456'</span>; </span><br><span class=\"line\">##用户授权</span><br><span class=\"line\">GRANT REPLICATION SLAVE ON *.* to <span class=\"string\">'mstest'</span>@<span class=\"string\">'%'</span> ;</span><br></pre></td></tr></table></figure><p></p><p>如果报错，记得修改mysql密码验证策略<br><a id=\"more\"></a><br>执行 show master status;</p><p><img src=\"/uploads/mysql-master.png\" alt=\"upload successful\"></p><h2 id=\"从库配置\"><a href=\"#从库配置\" class=\"headerlink\" title=\"从库配置\"></a>从库配置</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">server-id=<span class=\"number\">187</span></span><br><span class=\"line\">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><p>重启mysql</p><p>进入mysql, mysql -u root -p;</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stop slave;</span><br><span class=\"line\">change master to </span><br><span class=\"line\">master_host=<span class=\"string\">'192.168.1.128'</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'mstest'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_log_file=<span class=\"string\">'mysql-bin.000003'</span>,</span><br><span class=\"line\">master_log_pos=<span class=\"number\">852</span>;</span><br><span class=\"line\">start slave;</span><br></pre></td></tr></table></figure><p>master_host: 主库IP地址</p><p>master_user：上面新建的用户名</p><p>master_password：密码</p><p>master_log_file：主库的日志文件</p><p>master_log_pos： 主库日志文件起始位置，具体查看上图</p><p>执行show slave status\\G;</p><p><img src=\"/uploads/mysql-slave.png\" alt=\"upload successful\"></p><h2 id=\"MySQL同步故障：”-Slave-SQL-Running-No”\"><a href=\"#MySQL同步故障：”-Slave-SQL-Running-No”\" class=\"headerlink\" title=\"MySQL同步故障：” Slave_SQL_Running:No”\"></a>MySQL同步故障：” Slave_SQL_Running:No”</h2><p>一般是事务回滚造成的：<br>解决办法：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stop slave ;</span><br><span class=\"line\">set GLOBAL SQL_SLAVE_SKIP_COUNTER=<span class=\"number\">1</span>;</span><br><span class=\"line\">start slave ;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":928,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>mysql主从同步主要基于日志（binlog）的主从复制方式</p><h2 id=\"主库配置\"><a href=\"#主库配置\" class=\"headerlink\" title=\"主库配置\"></a>主库配置</h2><p>在主库的mysql配置文件my.cnf的 [mysqld]下添加配置：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 开启日志文件</span><br><span class=\"line\">log-bin=mysql-bin</span><br><span class=\"line\">## 服务器ID 一般为IP末尾</span><br><span class=\"line\">server-id=<span class=\"number\">27</span></span><br><span class=\"line\">## 不参与主从的数据库名</span><br><span class=\"line\">binlog-ignore-db=mysql</span><br><span class=\"line\">##需要同步的数据库，多个的话另外起一行配置 binlog-do-db=test</span><br><span class=\"line\">binlog-<span class=\"keyword\">do</span>-db=boot</span><br></pre></td></tr></table></figure><p>主库新增用户，主服务器给从服务器账号授权：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">##创建用户</span><br><span class=\"line\">create user <span class=\"string\">'mstest'</span>@<span class=\"string\">'%'</span> identified WITH mysql_native_password by <span class=\"string\">'123456'</span>; </span><br><span class=\"line\">##用户授权</span><br><span class=\"line\">GRANT REPLICATION SLAVE ON *.* to <span class=\"string\">'mstest'</span>@<span class=\"string\">'%'</span> ;</span><br></pre></td></tr></table></figure><p></p><p>如果报错，记得修改mysql密码验证策略<br>","more":"<br>执行 show master status;</p><p><img src=\"/uploads/mysql-master.png\" alt=\"upload successful\"></p><h2 id=\"从库配置\"><a href=\"#从库配置\" class=\"headerlink\" title=\"从库配置\"></a>从库配置</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">server-id=<span class=\"number\">187</span></span><br><span class=\"line\">log-bin=mysql-bin</span><br></pre></td></tr></table></figure><p>重启mysql</p><p>进入mysql, mysql -u root -p;</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stop slave;</span><br><span class=\"line\">change master to </span><br><span class=\"line\">master_host=<span class=\"string\">'192.168.1.128'</span>,</span><br><span class=\"line\">master_user=<span class=\"string\">'mstest'</span>,</span><br><span class=\"line\">master_password=<span class=\"string\">'123456'</span>,</span><br><span class=\"line\">master_log_file=<span class=\"string\">'mysql-bin.000003'</span>,</span><br><span class=\"line\">master_log_pos=<span class=\"number\">852</span>;</span><br><span class=\"line\">start slave;</span><br></pre></td></tr></table></figure><p>master_host: 主库IP地址</p><p>master_user：上面新建的用户名</p><p>master_password：密码</p><p>master_log_file：主库的日志文件</p><p>master_log_pos： 主库日志文件起始位置，具体查看上图</p><p>执行show slave status\\G;</p><p><img src=\"/uploads/mysql-slave.png\" alt=\"upload successful\"></p><h2 id=\"MySQL同步故障：”-Slave-SQL-Running-No”\"><a href=\"#MySQL同步故障：”-Slave-SQL-Running-No”\" class=\"headerlink\" title=\"MySQL同步故障：” Slave_SQL_Running:No”\"></a>MySQL同步故障：” Slave_SQL_Running:No”</h2><p>一般是事务回滚造成的：<br>解决办法：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stop slave ;</span><br><span class=\"line\">set GLOBAL SQL_SLAVE_SKIP_COUNTER=<span class=\"number\">1</span>;</span><br><span class=\"line\">start slave ;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"Nginx能为前端开发带来什么？","abbrlink":"7b869b23","date":"2017-10-20T02:12:22.000Z","_content":"> 转载： http://litten.me/2015/11/03/nginx-in-fe/\n\n\nNginx那么好，我想去看看。\n接连逛了两个书城后，我发现并没有Nginx相关的书籍。\n这就很奇怪！\n\n![](/uploads/nginx0.jpg)\n\nNginx，一名**网红**（网络服务器红人...)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。\n\n后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。\n后来发现了原因，大概是因为“**使用太简单了，都不值得出书**“。\n是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。\n当它呈现到你面前时，感觉独具匠心。\n<!-- more -->\n\n### Nginx与NodeJs\n\n\n（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）\n\n有人说，作为一名前端，**我的真爱是NodeJs**。\n同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。\n\n这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。\n\n在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。\n\n合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。\n\n以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。\n\n### 场景一：环境切换\n\n前端开发中，经常面临多个部署环境切换的问题。\n我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。\n\n然而在拓展性和易用性方面，还不足够好。\n而Nginx作为反向代理，就很容易处理资源转发的问题。\n\n思路很简单：\n\n> 1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；\n> 2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;\n\n```javascript\n    set $env_id \"1.1.1.1\";\n    if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") {\n        set $env_id $1;\n    }\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass   http://$env_id:80;\n    }\n```\n```java\n    public boolean isPosupplier(String opacct) throws TException {\n\t\t\t\t\n\t\tString qrystr = \" e.cfgsct ='posper' and e.cfgval ='\"+opacct+\"'\";\n\t\tList<Appcfg> appcfgs = this.jdsdb.APPCFG().list(qrystr);\n\t\tif(appcfgs == null || appcfgs.size()<=0){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n那接下来的事情，**就是怎样用最简便的方式，把IP种在cookie里**？\n我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。\n\n这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。\n![](/uploads/nginx1.jpg)\n\n切换环境，如今只需点击一次。\n\n### 场景二：SourceMap\n\n\n在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。\n\n而SourceMap正好可以解决此问题。\n\n在最新的各版本浏览器里，如果满足：\n1. 压缩后的js文件后面有 `` //# sourceMappingURL=xxx.map``格式的注释\n2.浏览器能正常访问到sourceMappingURL\n那么，就能把压缩过的代码还原。\n要实现这样的功能，就必须：\n\n1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）\n2.测试环境带注释，能访问sourceMap\n\n这样的模型，用``反向代理+内容篡改``的思路再合适不过。\n每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加``.map后缀``。随后，使用Nginx，通过这几行配置就能把此功能实现：\n\n```\n    location  ~ \\.js${\n        footer \"\\n//# sourceMappingURL=$request_uri.map\";\n        footer_types \"*\";\n    }\n\n```\n只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。\n你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。\n![](/uploads/nginx2.jpg)\n\n### 场景三：内容纂改\n\n\n其实在以上两个场景里，都涉及了“内容纂改”。\n无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。\n\n统一介绍下，Nginx涉及纂改的模块有：\n\n* [nginx_http_footer_filter](https://m.oschina.net/blog/156826):往文件的底部添加文字，可包含Nginx的内置变量；\n* [nginx_http_addition_module](http://nginx.org/en/docs/http/ngx_http_addition_module.html)：从一个url去读取内容，将之添加到文件的头部或顶部；\n* [nginx_http_sub_module](http://nginx.org/en/docs/http/ngx_http_sub_module.html)：替换字符\n\n除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。            \n单单针对移动web前端开发，就可以实现：\n> 1. 将[weinre](http://people.apache.org/~pmuellr/weinre-docs/latest/)脚本插入到html里，让移动web调试更加便捷。\n> 2. 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。\n> 3. 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等\n\n\n### 场景四：本地映射\n\n在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。                \n而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   \n\n比如：**线上接口映射到本地文件**。            \n想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           \n\n而且，我们可以做得更灵活，比如：\n* 同时支持慢速调试\n* 同时支持目录层级映射\n* 同时支持正则匹配\n* JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据\n\n这些场景，只运用到Nginx里的“[rewrite规则](http://www.linuxidc.com/Linux/2014-01/95493.htm)”。                \n从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 \n\n最简单的模型中，我们把所有带``cgi-bin``路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，      \n仅需这三行配置即可：\n```\nlocation ~ /cgi-bin/* {\n    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;\n}\n```\n后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 \n\n### 场景五：移动侧调试\n\n`Fiddler` 有一个勾选项 `Allow remote computers to connect`，并可以指定 `listen port` 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 `hosts` 配合会很实用。\n\n这个功能，用Nginx也很容易做到。           \n通过 `default_server` 作为代理，手机终端通过设置网络代理为本机IP和相应的 `listen port`，从而可以访问本机的 Web 服务。\n\n其中也是用到了[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)模块的配置：\n```js\n server {\n    listen  80 default_server;\n    server_name  localhost;\n    resolver 8.8.8.8;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://$host;\n    }\n}\n\nserver {\n    listen  80;\n    server_name  ke.qq.com;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://127.0.0.1:9091/;\n    }\n}\n```\n\n### 边角料\n\n除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。\n\n1.[nginx_http_concat](https://github.com/alibaba/nginx-http-concat)               \n资源合并，处理CDN combo。例如通过这样的方式``http://example.com/??style1.css,style2.css,foo/style3.css``访问合并后的资源。\n\n2.[ngx_http_image_filter_module](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)                  \n图片处理。提供图片缩放，jpg压缩，旋转等特性。\n\n3.适配PC与移动web                              \n总体可运用[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)，去实现路径转发。判断平台类型的Nginx配置，在开源项目[detectmobilebrowsers](http://detectmobilebrowsers.com/)中可以找到。\n\n### 后记\n\n学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。   \n于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。    \n**但既然是工具，熟手就好**。 \n\n\n比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。\n\n\n\n话说回来，后来心情有些惆怅。            \n想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。            \n不过我又想，**既然我已经花了时间去写，为什么还要花时间去用？！** \n \n \n \n心情又好起来了。（等等有什么不对，管它呢…）\n______________","source":"_posts/nginx.md","raw":"---\ntitle: Nginx能为前端开发带来什么？\ntags:\n  - 前端\n  - nginx\ncategories: 转载\nabbrlink: 7b869b23\ndate: 2017-10-20 10:12:22\n---\n> 转载： http://litten.me/2015/11/03/nginx-in-fe/\n\n\nNginx那么好，我想去看看。\n接连逛了两个书城后，我发现并没有Nginx相关的书籍。\n这就很奇怪！\n\n![](/uploads/nginx0.jpg)\n\nNginx，一名**网红**（网络服务器红人...)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。\n\n后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。\n后来发现了原因，大概是因为“**使用太简单了，都不值得出书**“。\n是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。\n当它呈现到你面前时，感觉独具匠心。\n<!-- more -->\n\n### Nginx与NodeJs\n\n\n（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）\n\n有人说，作为一名前端，**我的真爱是NodeJs**。\n同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。\n\n这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。\n\n在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。\n\n合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。\n\n以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。\n\n### 场景一：环境切换\n\n前端开发中，经常面临多个部署环境切换的问题。\n我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。\n\n然而在拓展性和易用性方面，还不足够好。\n而Nginx作为反向代理，就很容易处理资源转发的问题。\n\n思路很简单：\n\n> 1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；\n> 2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;\n\n```javascript\n    set $env_id \"1.1.1.1\";\n    if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") {\n        set $env_id $1;\n    }\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass   http://$env_id:80;\n    }\n```\n```java\n    public boolean isPosupplier(String opacct) throws TException {\n\t\t\t\t\n\t\tString qrystr = \" e.cfgsct ='posper' and e.cfgval ='\"+opacct+\"'\";\n\t\tList<Appcfg> appcfgs = this.jdsdb.APPCFG().list(qrystr);\n\t\tif(appcfgs == null || appcfgs.size()<=0){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n那接下来的事情，**就是怎样用最简便的方式，把IP种在cookie里**？\n我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。\n\n这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。\n![](/uploads/nginx1.jpg)\n\n切换环境，如今只需点击一次。\n\n### 场景二：SourceMap\n\n\n在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。\n\n而SourceMap正好可以解决此问题。\n\n在最新的各版本浏览器里，如果满足：\n1. 压缩后的js文件后面有 `` //# sourceMappingURL=xxx.map``格式的注释\n2.浏览器能正常访问到sourceMappingURL\n那么，就能把压缩过的代码还原。\n要实现这样的功能，就必须：\n\n1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）\n2.测试环境带注释，能访问sourceMap\n\n这样的模型，用``反向代理+内容篡改``的思路再合适不过。\n每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加``.map后缀``。随后，使用Nginx，通过这几行配置就能把此功能实现：\n\n```\n    location  ~ \\.js${\n        footer \"\\n//# sourceMappingURL=$request_uri.map\";\n        footer_types \"*\";\n    }\n\n```\n只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。\n你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。\n![](/uploads/nginx2.jpg)\n\n### 场景三：内容纂改\n\n\n其实在以上两个场景里，都涉及了“内容纂改”。\n无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。\n\n统一介绍下，Nginx涉及纂改的模块有：\n\n* [nginx_http_footer_filter](https://m.oschina.net/blog/156826):往文件的底部添加文字，可包含Nginx的内置变量；\n* [nginx_http_addition_module](http://nginx.org/en/docs/http/ngx_http_addition_module.html)：从一个url去读取内容，将之添加到文件的头部或顶部；\n* [nginx_http_sub_module](http://nginx.org/en/docs/http/ngx_http_sub_module.html)：替换字符\n\n除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。            \n单单针对移动web前端开发，就可以实现：\n> 1. 将[weinre](http://people.apache.org/~pmuellr/weinre-docs/latest/)脚本插入到html里，让移动web调试更加便捷。\n> 2. 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。\n> 3. 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等\n\n\n### 场景四：本地映射\n\n在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。                \n而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   \n\n比如：**线上接口映射到本地文件**。            \n想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           \n\n而且，我们可以做得更灵活，比如：\n* 同时支持慢速调试\n* 同时支持目录层级映射\n* 同时支持正则匹配\n* JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据\n\n这些场景，只运用到Nginx里的“[rewrite规则](http://www.linuxidc.com/Linux/2014-01/95493.htm)”。                \n从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 \n\n最简单的模型中，我们把所有带``cgi-bin``路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，      \n仅需这三行配置即可：\n```\nlocation ~ /cgi-bin/* {\n    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;\n}\n```\n后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 \n\n### 场景五：移动侧调试\n\n`Fiddler` 有一个勾选项 `Allow remote computers to connect`，并可以指定 `listen port` 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 `hosts` 配合会很实用。\n\n这个功能，用Nginx也很容易做到。           \n通过 `default_server` 作为代理，手机终端通过设置网络代理为本机IP和相应的 `listen port`，从而可以访问本机的 Web 服务。\n\n其中也是用到了[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)模块的配置：\n```js\n server {\n    listen  80 default_server;\n    server_name  localhost;\n    resolver 8.8.8.8;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://$host;\n    }\n}\n\nserver {\n    listen  80;\n    server_name  ke.qq.com;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://127.0.0.1:9091/;\n    }\n}\n```\n\n### 边角料\n\n除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。\n\n1.[nginx_http_concat](https://github.com/alibaba/nginx-http-concat)               \n资源合并，处理CDN combo。例如通过这样的方式``http://example.com/??style1.css,style2.css,foo/style3.css``访问合并后的资源。\n\n2.[ngx_http_image_filter_module](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)                  \n图片处理。提供图片缩放，jpg压缩，旋转等特性。\n\n3.适配PC与移动web                              \n总体可运用[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)，去实现路径转发。判断平台类型的Nginx配置，在开源项目[detectmobilebrowsers](http://detectmobilebrowsers.com/)中可以找到。\n\n### 后记\n\n学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。   \n于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。    \n**但既然是工具，熟手就好**。 \n\n\n比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。\n\n\n\n话说回来，后来心情有些惆怅。            \n想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。            \n不过我又想，**既然我已经花了时间去写，为什么还要花时间去用？！** \n \n \n \n心情又好起来了。（等等有什么不对，管它呢…）\n______________","slug":"nginx","published":1,"updated":"2019-09-03T03:40:46.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketgd00480vfalo1ffudk","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2015/11/03/nginx-in-fe/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2015/11/03/nginx-in-fe/</a></p></blockquote><p>Nginx那么好，我想去看看。<br>接连逛了两个书城后，我发现并没有Nginx相关的书籍。<br>这就很奇怪！</p><p><img src=\"/uploads/nginx0.jpg\" alt></p><p>Nginx，一名<strong>网红</strong>（网络服务器红人…)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。</p><p>后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为“<strong>使用太简单了，都不值得出书</strong>“。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。<br><a id=\"more\"></a></p><h3 id=\"Nginx与NodeJs\"><a href=\"#Nginx与NodeJs\" class=\"headerlink\" title=\"Nginx与NodeJs\"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p><p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。</p><p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。</p><p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。</p><p>合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。</p><p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。</p><h3 id=\"场景一：环境切换\"><a href=\"#场景一：环境切换\" class=\"headerlink\" title=\"场景一：环境切换\"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。</p><p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。</p><p>思路很简单：</p><blockquote><p>1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；<br>2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</p></blockquote><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> $env_id \"1.1.1.1\";</span><br><span class=\"line\">if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") &#123;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> $env_id $1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    proxy_set_header Host $host;</span><br><span class=\"line\">    proxy_pass   http:<span class=\"comment\">//$env_id:80;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPosupplier</span><span class=\"params\">(String opacct)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\tString qrystr = <span class=\"string\">\" e.cfgsct ='posper' and e.cfgval ='\"</span>+opacct+<span class=\"string\">\"'\"</span>;</span><br><span class=\"line\">\tList&lt;Appcfg&gt; appcfgs = <span class=\"keyword\">this</span>.jdsdb.APPCFG().list(qrystr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(appcfgs == <span class=\"keyword\">null</span> || appcfgs.size()&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>那接下来的事情，<strong>就是怎样用最简便的方式，把IP种在cookie里</strong>？<br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p><p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src=\"/uploads/nginx1.jpg\" alt></p><p>切换环境，如今只需点击一次。</p><h3 id=\"场景二：SourceMap\"><a href=\"#场景二：SourceMap\" class=\"headerlink\" title=\"场景二：SourceMap\"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p><p>而SourceMap正好可以解决此问题。</p><p>在最新的各版本浏览器里，如果满足：</p><ol><li>压缩后的js文件后面有 <code>//# sourceMappingURL=xxx.map</code>格式的注释<br>2.浏览器能正常访问到sourceMappingURL<br>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</li></ol><p>1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）<br>2.测试环境带注释，能访问sourceMap</p><p>这样的模型，用<code>反向代理+内容篡改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map后缀</code>。随后，使用Nginx，通过这几行配置就能把此功能实现：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location  ~ \\.js$&#123;</span><br><span class=\"line\">    footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;;</span><br><span class=\"line\">    footer_types &quot;*&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src=\"/uploads/nginx2.jpg\" alt></p><h3 id=\"场景三：内容纂改\"><a href=\"#场景三：内容纂改\" class=\"headerlink\" title=\"场景三：内容纂改\"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p><p>统一介绍下，Nginx涉及纂改的模块有：</p><ul><li><a href=\"https://m.oschina.net/blog/156826\" target=\"_blank\" rel=\"noopener\">nginx_http_footer_filter</a>:往文件的底部添加文字，可包含Nginx的内置变量；</li><li><a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html\" target=\"_blank\" rel=\"noopener\">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li><li><a href=\"http://nginx.org/en/docs/http/ngx_http_sub_module.html\" target=\"_blank\" rel=\"noopener\">nginx_http_sub_module</a>：替换字符</li></ul><p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现：</p><blockquote><ol><li>将<a href=\"http://people.apache.org/~pmuellr/weinre-docs/latest/\" target=\"_blank\" rel=\"noopener\">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li><li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li><li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li></ol></blockquote><h3 id=\"场景四：本地映射\"><a href=\"#场景四：本地映射\" class=\"headerlink\" title=\"场景四：本地映射\"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。</p><p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。</p><p>而且，我们可以做得更灵活，比如：</p><ul><li>同时支持慢速调试</li><li>同时支持目录层级映射</li><li>同时支持正则匹配</li><li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li></ul><p>这些场景，只运用到Nginx里的“<a href=\"http://www.linuxidc.com/Linux/2014-01/95493.htm\" target=\"_blank\" rel=\"noopener\">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。</p><p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ /cgi-bin/* &#123;</span><br><span class=\"line\">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。</p><h3 id=\"场景五：移动侧调试\"><a href=\"#场景五：移动侧调试\" class=\"headerlink\" title=\"场景五：移动侧调试\"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p><p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p><p>其中也是用到了<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_proxy_module</a>模块的配置：<br></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen  <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    resolver <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">        proxy_pass http:<span class=\"comment\">//$host;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen  <span class=\"number\">80</span>;</span><br><span class=\"line\">    server_name  ke.qq.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">        proxy_pass http:<span class=\"comment\">//127.0.0.1:9091/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id=\"边角料\"><a href=\"#边角料\" class=\"headerlink\" title=\"边角料\"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p><p>1.<a href=\"https://github.com/alibaba/nginx-http-concat\" target=\"_blank\" rel=\"noopener\">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p><p>2.<a href=\"http://nginx.org/en/docs/http/ngx_http_image_filter_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p><p>3.适配PC与移动web<br>总体可运用<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href=\"http://detectmobilebrowsers.com/\" target=\"_blank\" rel=\"noopener\">detectmobilebrowsers</a>中可以找到。</p><h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。</p><p>比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p><p>话说回来，后来心情有些惆怅。<br>想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。<br>不过我又想，<strong>既然我已经花了时间去写，为什么还要花时间去用？！</strong></p><p>心情又好起来了。（等等有什么不对，管它呢…）</p><hr><!-- rebuild by neat -->","site":{"data":{}},"length":4436,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2015/11/03/nginx-in-fe/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2015/11/03/nginx-in-fe/</a></p></blockquote><p>Nginx那么好，我想去看看。<br>接连逛了两个书城后，我发现并没有Nginx相关的书籍。<br>这就很奇怪！</p><p><img src=\"/uploads/nginx0.jpg\" alt></p><p>Nginx，一名<strong>网红</strong>（网络服务器红人…)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。</p><p>后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为“<strong>使用太简单了，都不值得出书</strong>“。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。<br>","more":"</p><h3 id=\"Nginx与NodeJs\"><a href=\"#Nginx与NodeJs\" class=\"headerlink\" title=\"Nginx与NodeJs\"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p><p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。</p><p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。</p><p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。</p><p>合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。</p><p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。</p><h3 id=\"场景一：环境切换\"><a href=\"#场景一：环境切换\" class=\"headerlink\" title=\"场景一：环境切换\"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。</p><p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。</p><p>思路很简单：</p><blockquote><p>1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；<br>2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</p></blockquote><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> $env_id \"1.1.1.1\";</span><br><span class=\"line\">if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") &#123;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> $env_id $1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    proxy_set_header Host $host;</span><br><span class=\"line\">    proxy_pass   http:<span class=\"comment\">//$env_id:80;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPosupplier</span><span class=\"params\">(String opacct)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\tString qrystr = <span class=\"string\">\" e.cfgsct ='posper' and e.cfgval ='\"</span>+opacct+<span class=\"string\">\"'\"</span>;</span><br><span class=\"line\">\tList&lt;Appcfg&gt; appcfgs = <span class=\"keyword\">this</span>.jdsdb.APPCFG().list(qrystr);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(appcfgs == <span class=\"keyword\">null</span> || appcfgs.size()&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>那接下来的事情，<strong>就是怎样用最简便的方式，把IP种在cookie里</strong>？<br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p><p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src=\"/uploads/nginx1.jpg\" alt></p><p>切换环境，如今只需点击一次。</p><h3 id=\"场景二：SourceMap\"><a href=\"#场景二：SourceMap\" class=\"headerlink\" title=\"场景二：SourceMap\"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p><p>而SourceMap正好可以解决此问题。</p><p>在最新的各版本浏览器里，如果满足：</p><ol><li>压缩后的js文件后面有 <code>//# sourceMappingURL=xxx.map</code>格式的注释<br>2.浏览器能正常访问到sourceMappingURL<br>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</li></ol><p>1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）<br>2.测试环境带注释，能访问sourceMap</p><p>这样的模型，用<code>反向代理+内容篡改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map后缀</code>。随后，使用Nginx，通过这几行配置就能把此功能实现：</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location  ~ \\.js$&#123;</span><br><span class=\"line\">    footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;;</span><br><span class=\"line\">    footer_types &quot;*&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src=\"/uploads/nginx2.jpg\" alt></p><h3 id=\"场景三：内容纂改\"><a href=\"#场景三：内容纂改\" class=\"headerlink\" title=\"场景三：内容纂改\"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p><p>统一介绍下，Nginx涉及纂改的模块有：</p><ul><li><a href=\"https://m.oschina.net/blog/156826\" target=\"_blank\" rel=\"noopener\">nginx_http_footer_filter</a>:往文件的底部添加文字，可包含Nginx的内置变量；</li><li><a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html\" target=\"_blank\" rel=\"noopener\">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li><li><a href=\"http://nginx.org/en/docs/http/ngx_http_sub_module.html\" target=\"_blank\" rel=\"noopener\">nginx_http_sub_module</a>：替换字符</li></ul><p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现：</p><blockquote><ol><li>将<a href=\"http://people.apache.org/~pmuellr/weinre-docs/latest/\" target=\"_blank\" rel=\"noopener\">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li><li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li><li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li></ol></blockquote><h3 id=\"场景四：本地映射\"><a href=\"#场景四：本地映射\" class=\"headerlink\" title=\"场景四：本地映射\"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。</p><p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。</p><p>而且，我们可以做得更灵活，比如：</p><ul><li>同时支持慢速调试</li><li>同时支持目录层级映射</li><li>同时支持正则匹配</li><li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li></ul><p>这些场景，只运用到Nginx里的“<a href=\"http://www.linuxidc.com/Linux/2014-01/95493.htm\" target=\"_blank\" rel=\"noopener\">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。</p><p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br></p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ /cgi-bin/* &#123;</span><br><span class=\"line\">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。</p><h3 id=\"场景五：移动侧调试\"><a href=\"#场景五：移动侧调试\" class=\"headerlink\" title=\"场景五：移动侧调试\"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p><p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p><p>其中也是用到了<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_proxy_module</a>模块的配置：<br></p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen  <span class=\"number\">80</span> default_server;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    resolver <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">        proxy_pass http:<span class=\"comment\">//$host;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen  <span class=\"number\">80</span>;</span><br><span class=\"line\">    server_name  ke.qq.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">        proxy_pass http:<span class=\"comment\">//127.0.0.1:9091/;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id=\"边角料\"><a href=\"#边角料\" class=\"headerlink\" title=\"边角料\"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p><p>1.<a href=\"https://github.com/alibaba/nginx-http-concat\" target=\"_blank\" rel=\"noopener\">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p><p>2.<a href=\"http://nginx.org/en/docs/http/ngx_http_image_filter_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p><p>3.适配PC与移动web<br>总体可运用<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"noopener\">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href=\"http://detectmobilebrowsers.com/\" target=\"_blank\" rel=\"noopener\">detectmobilebrowsers</a>中可以找到。</p><h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。</p><p>比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p><p>话说回来，后来心情有些惆怅。<br>想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。<br>不过我又想，<strong>既然我已经花了时间去写，为什么还要花时间去用？！</strong></p><p>心情又好起来了。（等等有什么不对，管它呢…）</p><hr><!-- rebuild by neat -->"},{"title":"Spring Security 在配置文件中配置ignoreUrls","abbrlink":"8a0eef75","date":"2019-07-02T07:57:48.000Z","_content":"\nSpring Security 资源服务器配置免登录链接如下：\n\n```java\n@Configuration\npublic class WebSecurityConfigurer extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n                .authorizeRequests()\n                .antMatchers(\"/actuator/**\").permitAll()\n                .anyRequest().authenticated();\n    }\n}\n```\n\n多个项目时，为了方便配置，现在将配置从Java Config中提取yml中。\n主要原理是借用 ImportBeanDefinitionRegistrar 接口实现动态注入 ResourceServerConfigurerAdapter\n<!-- more -->\n\n## **获取需要拦截的URL**\n\n```java\n@Data\n@Configuration\n@RefreshScope\n@ConditionalOnExpression(\"!'${security.oauth2.client.ignore-urls}'.isEmpty()\")\n@ConfigurationProperties(prefix = \"security.oauth2.client\")\npublic class PermitAllUrlProperties {\n    private List<String> ignoreUrls = new ArrayList<>();\n}\n\n```\n\n## **重写ResourceServerConfigurerAdapter**\n\n```java\npublic class BootResourceServerConfigurerAdapter extends ResourceServerConfigurerAdapter {\n\n    @Autowired\n    private PermitAllUrlProperties permitAllUrlProperties;\n\n\n    @Override\n    @SneakyThrows\n    public void configure(HttpSecurity http) {\n        //允许使用iframe 嵌套，避免swagger-ui 不被加载的问题\n        http.headers().frameOptions().disable();\n        ExpressionUrlAuthorizationConfigurer<HttpSecurity>\n            .ExpressionInterceptUrlRegistry registry = http\n            .authorizeRequests();\n        permitAllUrlProperties.getIgnoreUrls().forEach(url-> registry.antMatchers(url).permitAll());\n        registry.anyRequest().authenticated()\n                .and().csrf().disable();\n    }\n}\n\n```\n\n\n## **动态注入资源服务器配置**\n\n```java\npublic class SecurityBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        if (registry.isBeanNameInUse(SecurityConstants.RESOURCE_SERVER_CONFIGURER)) {\n            log.warn(\"本地存在资源服务器配置，覆盖默认配置:\" + SecurityConstants.RESOURCE_SERVER_CONFIGURER);\n            return;\n        }\n        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n        beanDefinition.setBeanClass(BootResourceServerConfigurerAdapter.class);\n        registry.registerBeanDefinition(SecurityConstants.RESOURCE_SERVER_CONFIGURER,beanDefinition);\n    }\n}\n\n```\n\n\n自定义EnableResourceServer注解\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@EnableResourceServer\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n@Import({BootResourceServerAutoConfiguration.class, SecurityBeanDefinitionRegistrar.class})\npublic @interface EnableBootResourceServer {\n}\n\n\n```\n\nBootResourceServerAutoConfiguration主要是配置了包扫描 ComponentScan","source":"_posts/spring-security-ignore-url.md","raw":"---\ntitle: Spring Security 在配置文件中配置ignoreUrls\ntags: 软件配置\ncategories: Spring Security\nabbrlink: 8a0eef75\ndate: 2019-07-02 15:57:48\n---\n\nSpring Security 资源服务器配置免登录链接如下：\n\n```java\n@Configuration\npublic class WebSecurityConfigurer extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n                .authorizeRequests()\n                .antMatchers(\"/actuator/**\").permitAll()\n                .anyRequest().authenticated();\n    }\n}\n```\n\n多个项目时，为了方便配置，现在将配置从Java Config中提取yml中。\n主要原理是借用 ImportBeanDefinitionRegistrar 接口实现动态注入 ResourceServerConfigurerAdapter\n<!-- more -->\n\n## **获取需要拦截的URL**\n\n```java\n@Data\n@Configuration\n@RefreshScope\n@ConditionalOnExpression(\"!'${security.oauth2.client.ignore-urls}'.isEmpty()\")\n@ConfigurationProperties(prefix = \"security.oauth2.client\")\npublic class PermitAllUrlProperties {\n    private List<String> ignoreUrls = new ArrayList<>();\n}\n\n```\n\n## **重写ResourceServerConfigurerAdapter**\n\n```java\npublic class BootResourceServerConfigurerAdapter extends ResourceServerConfigurerAdapter {\n\n    @Autowired\n    private PermitAllUrlProperties permitAllUrlProperties;\n\n\n    @Override\n    @SneakyThrows\n    public void configure(HttpSecurity http) {\n        //允许使用iframe 嵌套，避免swagger-ui 不被加载的问题\n        http.headers().frameOptions().disable();\n        ExpressionUrlAuthorizationConfigurer<HttpSecurity>\n            .ExpressionInterceptUrlRegistry registry = http\n            .authorizeRequests();\n        permitAllUrlProperties.getIgnoreUrls().forEach(url-> registry.antMatchers(url).permitAll());\n        registry.anyRequest().authenticated()\n                .and().csrf().disable();\n    }\n}\n\n```\n\n\n## **动态注入资源服务器配置**\n\n```java\npublic class SecurityBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n        if (registry.isBeanNameInUse(SecurityConstants.RESOURCE_SERVER_CONFIGURER)) {\n            log.warn(\"本地存在资源服务器配置，覆盖默认配置:\" + SecurityConstants.RESOURCE_SERVER_CONFIGURER);\n            return;\n        }\n        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\n        beanDefinition.setBeanClass(BootResourceServerConfigurerAdapter.class);\n        registry.registerBeanDefinition(SecurityConstants.RESOURCE_SERVER_CONFIGURER,beanDefinition);\n    }\n}\n\n```\n\n\n自定义EnableResourceServer注解\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@EnableResourceServer\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n@Import({BootResourceServerAutoConfiguration.class, SecurityBeanDefinitionRegistrar.class})\npublic @interface EnableBootResourceServer {\n}\n\n\n```\n\nBootResourceServerAutoConfiguration主要是配置了包扫描 ComponentScan","slug":"spring-security-ignore-url","published":1,"updated":"2019-09-03T03:40:46.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketgi004c0vfarfzgiu04","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>Spring Security 资源服务器配置免登录链接如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        http.csrf().disable()</span><br><span class=\"line\">                .authorizeRequests()</span><br><span class=\"line\">                .antMatchers(<span class=\"string\">\"/actuator/**\"</span>).permitAll()</span><br><span class=\"line\">                .anyRequest().authenticated();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>多个项目时，为了方便配置，现在将配置从Java Config中提取yml中。<br>主要原理是借用 ImportBeanDefinitionRegistrar 接口实现动态注入 ResourceServerConfigurerAdapter<br><a id=\"more\"></a></p><h2 id=\"获取需要拦截的URL\"><a href=\"#获取需要拦截的URL\" class=\"headerlink\" title=\"获取需要拦截的URL\"></a><strong>获取需要拦截的URL</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@RefreshScope</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnExpression</span>(<span class=\"string\">\"!'$&#123;security.oauth2.client.ignore-urls&#125;'.isEmpty()\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"security.oauth2.client\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PermitAllUrlProperties</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; ignoreUrls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"重写ResourceServerConfigurerAdapter\"><a href=\"#重写ResourceServerConfigurerAdapter\" class=\"headerlink\" title=\"重写ResourceServerConfigurerAdapter\"></a><strong>重写ResourceServerConfigurerAdapter</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootResourceServerConfigurerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PermitAllUrlProperties permitAllUrlProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SneakyThrows</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//允许使用iframe 嵌套，避免swagger-ui 不被加载的问题</span></span><br><span class=\"line\">        http.headers().frameOptions().disable();</span><br><span class=\"line\">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;</span><br><span class=\"line\">            .ExpressionInterceptUrlRegistry registry = http</span><br><span class=\"line\">            .authorizeRequests();</span><br><span class=\"line\">        permitAllUrlProperties.getIgnoreUrls().forEach(url-&gt; registry.antMatchers(url).permitAll());</span><br><span class=\"line\">        registry.anyRequest().authenticated()</span><br><span class=\"line\">                .and().csrf().disable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"动态注入资源服务器配置\"><a href=\"#动态注入资源服务器配置\" class=\"headerlink\" title=\"动态注入资源服务器配置\"></a><strong>动态注入资源服务器配置</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registry.isBeanNameInUse(SecurityConstants.RESOURCE_SERVER_CONFIGURER)) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"本地存在资源服务器配置，覆盖默认配置:\"</span> + SecurityConstants.RESOURCE_SERVER_CONFIGURER);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        GenericBeanDefinition beanDefinition = <span class=\"keyword\">new</span> GenericBeanDefinition();</span><br><span class=\"line\">        beanDefinition.setBeanClass(BootResourceServerConfigurerAdapter.class);</span><br><span class=\"line\">        registry.registerBeanDefinition(SecurityConstants.RESOURCE_SERVER_CONFIGURER,beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>自定义EnableResourceServer注解</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;BootResourceServerAutoConfiguration.class, SecurityBeanDefinitionRegistrar.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableBootResourceServer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>BootResourceServerAutoConfiguration主要是配置了包扫描 ComponentScan</p><!-- rebuild by neat -->","site":{"data":{}},"length":2736,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p>Spring Security 资源服务器配置免登录链接如下：</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSecurityConfigurer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        http.csrf().disable()</span><br><span class=\"line\">                .authorizeRequests()</span><br><span class=\"line\">                .antMatchers(<span class=\"string\">\"/actuator/**\"</span>).permitAll()</span><br><span class=\"line\">                .anyRequest().authenticated();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>多个项目时，为了方便配置，现在将配置从Java Config中提取yml中。<br>主要原理是借用 ImportBeanDefinitionRegistrar 接口实现动态注入 ResourceServerConfigurerAdapter<br>","more":"</p><h2 id=\"获取需要拦截的URL\"><a href=\"#获取需要拦截的URL\" class=\"headerlink\" title=\"获取需要拦截的URL\"></a><strong>获取需要拦截的URL</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@RefreshScope</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnExpression</span>(<span class=\"string\">\"!'$&#123;security.oauth2.client.ignore-urls&#125;'.isEmpty()\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"security.oauth2.client\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PermitAllUrlProperties</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; ignoreUrls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"重写ResourceServerConfigurerAdapter\"><a href=\"#重写ResourceServerConfigurerAdapter\" class=\"headerlink\" title=\"重写ResourceServerConfigurerAdapter\"></a><strong>重写ResourceServerConfigurerAdapter</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BootResourceServerConfigurerAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PermitAllUrlProperties permitAllUrlProperties;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SneakyThrows</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//允许使用iframe 嵌套，避免swagger-ui 不被加载的问题</span></span><br><span class=\"line\">        http.headers().frameOptions().disable();</span><br><span class=\"line\">        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;</span><br><span class=\"line\">            .ExpressionInterceptUrlRegistry registry = http</span><br><span class=\"line\">            .authorizeRequests();</span><br><span class=\"line\">        permitAllUrlProperties.getIgnoreUrls().forEach(url-&gt; registry.antMatchers(url).permitAll());</span><br><span class=\"line\">        registry.anyRequest().authenticated()</span><br><span class=\"line\">                .and().csrf().disable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"动态注入资源服务器配置\"><a href=\"#动态注入资源服务器配置\" class=\"headerlink\" title=\"动态注入资源服务器配置\"></a><strong>动态注入资源服务器配置</strong></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityBeanDefinitionRegistrar</span> <span class=\"keyword\">implements</span> <span class=\"title\">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registry.isBeanNameInUse(SecurityConstants.RESOURCE_SERVER_CONFIGURER)) &#123;</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"本地存在资源服务器配置，覆盖默认配置:\"</span> + SecurityConstants.RESOURCE_SERVER_CONFIGURER);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        GenericBeanDefinition beanDefinition = <span class=\"keyword\">new</span> GenericBeanDefinition();</span><br><span class=\"line\">        beanDefinition.setBeanClass(BootResourceServerConfigurerAdapter.class);</span><br><span class=\"line\">        registry.registerBeanDefinition(SecurityConstants.RESOURCE_SERVER_CONFIGURER,beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>自定义EnableResourceServer注解</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span></span><br><span class=\"line\"><span class=\"meta\">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"meta\">@Import</span>(&#123;BootResourceServerAutoConfiguration.class, SecurityBeanDefinitionRegistrar.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableBootResourceServer &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>BootResourceServerAutoConfiguration主要是配置了包扫描 ComponentScan</p><!-- rebuild by neat -->"},{"title":"薛定谔的年 1.1 -1.7","abbrlink":"bbd430bc","date":"2017-10-20T01:50:18.000Z","_content":"> 转载： http://litten.me/2017/01/08/diary-2017-0101-0107/\n\n\n![](/uploads/diary-18.jpg)\n\n传说中，现在这段元旦到除夕的时间\n由于不知该称之“今年”或“明年”\n有人就说，叫薛定谔的年好了！\n这么一想，好像许多东西都可以跟薛定谔扯上关系了。\n\n比如这周，每天醒来第一件事\n就是到12306查一下有没有薛定谔的票\n有了，就输入那个神才知道对不对的薛定谔验证码\n去完成这笔鬼才知道成不成功的薛定谔订单\n\n这世道，上半年的代码，到下半年能不能编译都要打个问号\n就不要试想真切地看清这繁华世界啦。\nMr.Big不断重复着：Oh baby baby it's a wild world ....\n有时候发现我等的就是这几个字。\n\n<!-- more -->\n\n***\n这周把kindle的书摘和笔记导了出来，是时候整理一下了。\n不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。\n\n以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？\n但批判一件事，就得先完成它。\n等到真正看完，你又突然明白了喜爱的理由。\n这种奇妙感觉已经太久没遇到了。\n\n然后友谊书城变得越来越吵\n而且很会调果茶的那个漂亮姐姐也走了\n不知道这两回事有没有必然联系…\n反正我是很少再去。\n\n不过看着笔记还是能想起很多事情。\n有些摘录根本不知所以，但模糊不清反而会更有意思\n仿佛一种梦境的延伸。\n它们的存在，证明时光的缝隙里\n出现过一瞬间薛定谔式的触动与喜欢\n\n仅此而已，就可知足，就能圆满。\n因为有时候，一瞬间的心有灵犀\n比一万年的细水长流要隽永得多。","source":"_posts/xuedinge.md","raw":"---\ntitle: 薛定谔的年 1.1 -1.7\ntags: 旧事\ncategories: 转载\nabbrlink: bbd430bc\ndate: 2017-10-20 09:50:18\n---\n> 转载： http://litten.me/2017/01/08/diary-2017-0101-0107/\n\n\n![](/uploads/diary-18.jpg)\n\n传说中，现在这段元旦到除夕的时间\n由于不知该称之“今年”或“明年”\n有人就说，叫薛定谔的年好了！\n这么一想，好像许多东西都可以跟薛定谔扯上关系了。\n\n比如这周，每天醒来第一件事\n就是到12306查一下有没有薛定谔的票\n有了，就输入那个神才知道对不对的薛定谔验证码\n去完成这笔鬼才知道成不成功的薛定谔订单\n\n这世道，上半年的代码，到下半年能不能编译都要打个问号\n就不要试想真切地看清这繁华世界啦。\nMr.Big不断重复着：Oh baby baby it's a wild world ....\n有时候发现我等的就是这几个字。\n\n<!-- more -->\n\n***\n这周把kindle的书摘和笔记导了出来，是时候整理一下了。\n不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。\n\n以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？\n但批判一件事，就得先完成它。\n等到真正看完，你又突然明白了喜爱的理由。\n这种奇妙感觉已经太久没遇到了。\n\n然后友谊书城变得越来越吵\n而且很会调果茶的那个漂亮姐姐也走了\n不知道这两回事有没有必然联系…\n反正我是很少再去。\n\n不过看着笔记还是能想起很多事情。\n有些摘录根本不知所以，但模糊不清反而会更有意思\n仿佛一种梦境的延伸。\n它们的存在，证明时光的缝隙里\n出现过一瞬间薛定谔式的触动与喜欢\n\n仅此而已，就可知足，就能圆满。\n因为有时候，一瞬间的心有灵犀\n比一万年的细水长流要隽永得多。","slug":"xuedinge","published":1,"updated":"2019-09-03T03:40:46.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketgq004g0vfa4lvx9exe","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2017/01/08/diary-2017-0101-0107/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2017/01/08/diary-2017-0101-0107/</a></p></blockquote><p><img src=\"/uploads/diary-18.jpg\" alt></p><p>传说中，现在这段元旦到除夕的时间<br>由于不知该称之“今年”或“明年”<br>有人就说，叫薛定谔的年好了！<br>这么一想，好像许多东西都可以跟薛定谔扯上关系了。</p><p>比如这周，每天醒来第一件事<br>就是到12306查一下有没有薛定谔的票<br>有了，就输入那个神才知道对不对的薛定谔验证码<br>去完成这笔鬼才知道成不成功的薛定谔订单</p><p>这世道，上半年的代码，到下半年能不能编译都要打个问号<br>就不要试想真切地看清这繁华世界啦。<br>Mr.Big不断重复着：Oh baby baby it’s a wild world ….<br>有时候发现我等的就是这几个字。</p><a id=\"more\"></a><hr><p>这周把kindle的书摘和笔记导了出来，是时候整理一下了。<br>不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。</p><p>以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？<br>但批判一件事，就得先完成它。<br>等到真正看完，你又突然明白了喜爱的理由。<br>这种奇妙感觉已经太久没遇到了。</p><p>然后友谊书城变得越来越吵<br>而且很会调果茶的那个漂亮姐姐也走了<br>不知道这两回事有没有必然联系…<br>反正我是很少再去。</p><p>不过看着笔记还是能想起很多事情。<br>有些摘录根本不知所以，但模糊不清反而会更有意思<br>仿佛一种梦境的延伸。<br>它们的存在，证明时光的缝隙里<br>出现过一瞬间薛定谔式的触动与喜欢</p><p>仅此而已，就可知足，就能圆满。<br>因为有时候，一瞬间的心有灵犀<br>比一万年的细水长流要隽永得多。</p><!-- rebuild by neat -->","site":{"data":{}},"length":613,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><blockquote><p>转载： <a href=\"http://litten.me/2017/01/08/diary-2017-0101-0107/\" target=\"_blank\" rel=\"noopener\">http://litten.me/2017/01/08/diary-2017-0101-0107/</a></p></blockquote><p><img src=\"/uploads/diary-18.jpg\" alt></p><p>传说中，现在这段元旦到除夕的时间<br>由于不知该称之“今年”或“明年”<br>有人就说，叫薛定谔的年好了！<br>这么一想，好像许多东西都可以跟薛定谔扯上关系了。</p><p>比如这周，每天醒来第一件事<br>就是到12306查一下有没有薛定谔的票<br>有了，就输入那个神才知道对不对的薛定谔验证码<br>去完成这笔鬼才知道成不成功的薛定谔订单</p><p>这世道，上半年的代码，到下半年能不能编译都要打个问号<br>就不要试想真切地看清这繁华世界啦。<br>Mr.Big不断重复着：Oh baby baby it’s a wild world ….<br>有时候发现我等的就是这几个字。</p>","more":"<hr><p>这周把kindle的书摘和笔记导了出来，是时候整理一下了。<br>不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。</p><p>以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？<br>但批判一件事，就得先完成它。<br>等到真正看完，你又突然明白了喜爱的理由。<br>这种奇妙感觉已经太久没遇到了。</p><p>然后友谊书城变得越来越吵<br>而且很会调果茶的那个漂亮姐姐也走了<br>不知道这两回事有没有必然联系…<br>反正我是很少再去。</p><p>不过看着笔记还是能想起很多事情。<br>有些摘录根本不知所以，但模糊不清反而会更有意思<br>仿佛一种梦境的延伸。<br>它们的存在，证明时光的缝隙里<br>出现过一瞬间薛定谔式的触动与喜欢</p><p>仅此而已，就可知足，就能圆满。<br>因为有时候，一瞬间的心有灵犀<br>比一万年的细水长流要隽永得多。</p><!-- rebuild by neat -->"},{"title":"冒泡排序","author":"Carlos","abbrlink":"14e6f1eb","date":"2019-08-23T02:06:00.000Z","_content":"## 图示\n\n![](/uploads/maopao2.gif)\n\n## 原理\n冒泡排序的主要原理，每次比较相邻两个元素，如果满足条件，就将这两个元素进行交换，一次冒泡结束至少让一个元素移动到它应该排列的位置\n```java\n int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};\n```\n\n\n![](/uploads/maopao3.png)\n\n<!-- more -->\n\n\n## Java代码实现\n\n```java\n\tpublic static void main(String[] args) {\n        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};\n        bubbSort(array);\n    }\n\n    public static void bubbSort(int[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n        \t//因为冒泡是把每轮循环中较大的数飘到后面，\n            // 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少\n            for (int j = 0; j < array.length - 1 - i; j++) {\n                if(array[j] > array[j+1]) {\n                    int temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                }\n            }\n        }\n        System.out.println(Arrays.toString(array));\n    }\n\n```\n\n## 运行结果\n\n```java\n\t[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n## 优化\n根据每次排序打印的结果，我们可以看到程序执行了多次没用的排序，我们对bubbSort简单的改造一下：\n```java\n\tpublic static void bubbSort(int[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n            boolean flag = true;\n            for (int j = 0; j < array.length - 1 - i; j++) {\n                if(array[j] > array[j+1]) {\n                    int temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                    flag = false;\n                }\n            }\n            //本次排序没有做任何交换，说明该数组已经是有序\n            if(flag) {\n                break;\n            }\n            System.out.println(\"第\"+(i+1)+\"次排序，排序结果为：\"+Arrays.toString(array));\n        }\n        System.out.println(Arrays.toString(array));\n    }\n```\n\n运行结果：\n```java\n  第1次排序，排序结果为：[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50]\n  第2次排序，排序结果为：[3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50]\n  第3次排序，排序结果为：[3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50]\n  第4次排序，排序结果为：[3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50]\n  第5次排序，排序结果为：[3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50]\n  第6次排序，排序结果为：[3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50]\n  第7次排序，排序结果为：[3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  第8次排序，排序结果为：[3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  第9次排序，排序结果为：[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n\n","source":"_posts/冒泡算法.md","raw":"---\ntitle: 冒泡排序\nauthor: Carlos\ntags:\n  - 算法\ncategories:\n  - 算法\nabbrlink: 14e6f1eb\ndate: 2019-08-23 10:06:00\n---\n## 图示\n\n![](/uploads/maopao2.gif)\n\n## 原理\n冒泡排序的主要原理，每次比较相邻两个元素，如果满足条件，就将这两个元素进行交换，一次冒泡结束至少让一个元素移动到它应该排列的位置\n```java\n int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};\n```\n\n\n![](/uploads/maopao3.png)\n\n<!-- more -->\n\n\n## Java代码实现\n\n```java\n\tpublic static void main(String[] args) {\n        int[] array = {3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};\n        bubbSort(array);\n    }\n\n    public static void bubbSort(int[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n        \t//因为冒泡是把每轮循环中较大的数飘到后面，\n            // 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少\n            for (int j = 0; j < array.length - 1 - i; j++) {\n                if(array[j] > array[j+1]) {\n                    int temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                }\n            }\n        }\n        System.out.println(Arrays.toString(array));\n    }\n\n```\n\n## 运行结果\n\n```java\n\t[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n## 优化\n根据每次排序打印的结果，我们可以看到程序执行了多次没用的排序，我们对bubbSort简单的改造一下：\n```java\n\tpublic static void bubbSort(int[] array) {\n        for (int i = 0; i < array.length - 1; i++) {\n            boolean flag = true;\n            for (int j = 0; j < array.length - 1 - i; j++) {\n                if(array[j] > array[j+1]) {\n                    int temp = array[j];\n                    array[j] = array[j+1];\n                    array[j+1] = temp;\n                    flag = false;\n                }\n            }\n            //本次排序没有做任何交换，说明该数组已经是有序\n            if(flag) {\n                break;\n            }\n            System.out.println(\"第\"+(i+1)+\"次排序，排序结果为：\"+Arrays.toString(array));\n        }\n        System.out.println(Arrays.toString(array));\n    }\n```\n\n运行结果：\n```java\n  第1次排序，排序结果为：[3, 38, 5, 44, 15, 36, 26, 27, 2, 46, 4, 19, 47, 48, 50]\n  第2次排序，排序结果为：[3, 5, 38, 15, 36, 26, 27, 2, 44, 4, 19, 46, 47, 48, 50]\n  第3次排序，排序结果为：[3, 5, 15, 36, 26, 27, 2, 38, 4, 19, 44, 46, 47, 48, 50]\n  第4次排序，排序结果为：[3, 5, 15, 26, 27, 2, 36, 4, 19, 38, 44, 46, 47, 48, 50]\n  第5次排序，排序结果为：[3, 5, 15, 26, 2, 27, 4, 19, 36, 38, 44, 46, 47, 48, 50]\n  第6次排序，排序结果为：[3, 5, 15, 2, 26, 4, 19, 27, 36, 38, 44, 46, 47, 48, 50]\n  第7次排序，排序结果为：[3, 5, 2, 15, 4, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  第8次排序，排序结果为：[3, 2, 5, 4, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  第9次排序，排序结果为：[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n  [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n\n","slug":"冒泡算法","published":1,"updated":"2019-09-03T03:40:46.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07ketgz004j0vfa9vyeb12k","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p><img src=\"/uploads/maopao2.gif\" alt></p><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>冒泡排序的主要原理，每次比较相邻两个元素，如果满足条件，就将这两个元素进行交换，一次冒泡结束至少让一个元素移动到它应该排列的位置<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] array = &#123;<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>&#125;;</span><br></pre></td></tr></table></figure><p></p><p><img src=\"/uploads/maopao3.png\" alt></p><a id=\"more\"></a><h2 id=\"Java代码实现\"><a href=\"#Java代码实现\" class=\"headerlink\" title=\"Java代码实现\"></a>Java代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] array = &#123;<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>&#125;;</span><br><span class=\"line\">       bubbSort(array);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">       \t<span class=\"comment\">//因为冒泡是把每轮循环中较大的数飘到后面，</span></span><br><span class=\"line\">           <span class=\"comment\">// 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少</span></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                   array[j] = array[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                   array[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(Arrays.toString(array));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br></pre></td></tr></table></figure><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>根据每次排序打印的结果，我们可以看到程序执行了多次没用的排序，我们对bubbSort简单的改造一下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                   array[j] = array[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                   array[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                   flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//本次排序没有做任何交换，说明该数组已经是有序</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"第\"</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">\"次排序，排序结果为：\"</span>+Arrays.toString(array));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(Arrays.toString(array));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第<span class=\"number\">1</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">38</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">44</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">38</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">36</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">26</span>, <span class=\"number\">2</span>, <span class=\"number\">27</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">2</span>, <span class=\"number\">26</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">15</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">8</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">9</span>次排序，排序结果为：[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->","site":{"data":{}},"length":2384,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p><img src=\"/uploads/maopao2.gif\" alt></p><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>冒泡排序的主要原理，每次比较相邻两个元素，如果满足条件，就将这两个元素进行交换，一次冒泡结束至少让一个元素移动到它应该排列的位置<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] array = &#123;<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>&#125;;</span><br></pre></td></tr></table></figure><p></p><p><img src=\"/uploads/maopao3.png\" alt></p>","more":"<h2 id=\"Java代码实现\"><a href=\"#Java代码实现\" class=\"headerlink\" title=\"Java代码实现\"></a>Java代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">int</span>[] array = &#123;<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">38</span>,<span class=\"number\">5</span>,<span class=\"number\">47</span>,<span class=\"number\">15</span>,<span class=\"number\">36</span>,<span class=\"number\">26</span>,<span class=\"number\">27</span>,<span class=\"number\">2</span>,<span class=\"number\">46</span>,<span class=\"number\">4</span>,<span class=\"number\">19</span>,<span class=\"number\">50</span>,<span class=\"number\">48</span>&#125;;</span><br><span class=\"line\">       bubbSort(array);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">       \t<span class=\"comment\">//因为冒泡是把每轮循环中较大的数飘到后面，</span></span><br><span class=\"line\">           <span class=\"comment\">// 数组下标又是从0开始的，i下标后面已经排序的个数就得多减1，总结就是i增多少，j的循环位置减多少</span></span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                   array[j] = array[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                   array[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(Arrays.toString(array));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br></pre></td></tr></table></figure><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>根据每次排序打印的结果，我们可以看到程序执行了多次没用的排序，我们对bubbSort简单的改造一下：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(array[j] &gt; array[j+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                   array[j] = array[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                   array[j+<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                   flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">//本次排序没有做任何交换，说明该数组已经是有序</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"第\"</span>+(i+<span class=\"number\">1</span>)+<span class=\"string\">\"次排序，排序结果为：\"</span>+Arrays.toString(array));</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(Arrays.toString(array));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第<span class=\"number\">1</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">38</span>, <span class=\"number\">5</span>, <span class=\"number\">44</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">46</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">2</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">38</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">44</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">3</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">36</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">38</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">4</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">2</span>, <span class=\"number\">36</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">5</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">26</span>, <span class=\"number\">2</span>, <span class=\"number\">27</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">6</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">2</span>, <span class=\"number\">26</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">7</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">15</span>, <span class=\"number\">4</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">8</span>次排序，排序结果为：[<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">第<span class=\"number\">9</span>次排序，排序结果为：[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">15</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">27</span>, <span class=\"number\">36</span>, <span class=\"number\">38</span>, <span class=\"number\">44</span>, <span class=\"number\">46</span>, <span class=\"number\">47</span>, <span class=\"number\">48</span>, <span class=\"number\">50</span>]</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->"},{"title":"归并排序","author":"Carlos","abbrlink":"1599bffe","date":"2019-09-04T02:12:00.000Z","_content":"<a href=\"https://www.jianshu.com/p/33cffa1ce613\" class=\"LinkCard\"> 归并排序</a>\n\n## 图示过程\n\n### 归并排序流程\n\n![](/uploads/guibing1.png)\n\n<!-- more -->\n\n### 合并两个有序数组的流程\n\n![](/uploads/guibing2.png)\n\n\n\n## 动图展示\n\n![](/uploads/guibing3.gif)\n\n## 代码实现\n\t\n```java\npublic static void mergeSort(int[] arr) {\n    sort(arr, 0, arr.length - 1);\n}\n\npublic static void sort(int[] arr, int L, int R) {\n    if(L == R) {\n        return;\n    }\n    int mid = L + ((R - L) >> 1);\n    sort(arr, L, mid);\n    sort(arr, mid + 1, R);\n    merge(arr, L, mid, R);\n}\n\npublic static void merge(int[] arr, int L, int mid, int R) {\n    int[] temp = new int[R - L + 1];\n    int i = 0;\n    int p1 = L;\n    int p2 = mid + 1;\n    // 比较左右两部分的元素，哪个小，把那个元素填入temp中\n    while(p1 <= mid && p2 <= R) {\n        temp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n    }\n    // 上面的循环退出后，把剩余的元素依次填入到temp中\n    // 以下两个while只有一个会执行\n    while(p1 <= mid) {\n        temp[i++] = arr[p1++];\n    }\n    while(p2 <= R) {\n        temp[i++] = arr[p2++];\n    }\n    // 把最终的排序的结果复制给原数组\n    for(i = 0; i < temp.length; i++) {\n        arr[L + i] = temp[i];\n    }\n}\n\n```\n\n## 复杂度\n\n+ 时间复杂度: $O(n\\log n)$\n+ 空间复杂度: $O(N)$,归并排序需要一个与原数组相同长度的数组做辅助来排序\n+ 稳定性:归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。","source":"_posts/归并排序.md","raw":"title: 归并排序\nauthor: Carlos\nabbrlink: 1599bffe\ntags:\n  - 算法\ncategories: []\ndate: 2019-09-04 10:12:00\n---\n<a href=\"https://www.jianshu.com/p/33cffa1ce613\" class=\"LinkCard\"> 归并排序</a>\n\n## 图示过程\n\n### 归并排序流程\n\n![](/uploads/guibing1.png)\n\n<!-- more -->\n\n### 合并两个有序数组的流程\n\n![](/uploads/guibing2.png)\n\n\n\n## 动图展示\n\n![](/uploads/guibing3.gif)\n\n## 代码实现\n\t\n```java\npublic static void mergeSort(int[] arr) {\n    sort(arr, 0, arr.length - 1);\n}\n\npublic static void sort(int[] arr, int L, int R) {\n    if(L == R) {\n        return;\n    }\n    int mid = L + ((R - L) >> 1);\n    sort(arr, L, mid);\n    sort(arr, mid + 1, R);\n    merge(arr, L, mid, R);\n}\n\npublic static void merge(int[] arr, int L, int mid, int R) {\n    int[] temp = new int[R - L + 1];\n    int i = 0;\n    int p1 = L;\n    int p2 = mid + 1;\n    // 比较左右两部分的元素，哪个小，把那个元素填入temp中\n    while(p1 <= mid && p2 <= R) {\n        temp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];\n    }\n    // 上面的循环退出后，把剩余的元素依次填入到temp中\n    // 以下两个while只有一个会执行\n    while(p1 <= mid) {\n        temp[i++] = arr[p1++];\n    }\n    while(p2 <= R) {\n        temp[i++] = arr[p2++];\n    }\n    // 把最终的排序的结果复制给原数组\n    for(i = 0; i < temp.length; i++) {\n        arr[L + i] = temp[i];\n    }\n}\n\n```\n\n## 复杂度\n\n+ 时间复杂度: $O(n\\log n)$\n+ 空间复杂度: $O(N)$,归并排序需要一个与原数组相同长度的数组做辅助来排序\n+ 稳定性:归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。","slug":"归并排序","published":1,"updated":"2019-09-05T06:20:18.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keth1004o0vfa7zydmq1c","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p><a href=\"https://www.jianshu.com/p/33cffa1ce613\" class=\"LinkCard\" target=\"_blank\" rel=\"noopener\">归并排序</a></p><h2 id=\"图示过程\"><a href=\"#图示过程\" class=\"headerlink\" title=\"图示过程\"></a>图示过程</h2><h3 id=\"归并排序流程\"><a href=\"#归并排序流程\" class=\"headerlink\" title=\"归并排序流程\"></a>归并排序流程</h3><p><img src=\"/uploads/guibing1.png\" alt></p><a id=\"more\"></a><h3 id=\"合并两个有序数组的流程\"><a href=\"#合并两个有序数组的流程\" class=\"headerlink\" title=\"合并两个有序数组的流程\"></a>合并两个有序数组的流程</h3><p><img src=\"/uploads/guibing2.png\" alt></p><h2 id=\"动图展示\"><a href=\"#动图展示\" class=\"headerlink\" title=\"动图展示\"></a>动图展示</h2><p><img src=\"/uploads/guibing3.gif\" alt></p><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    sort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L == R) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = L + ((R - L) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    sort(arr, L, mid);</span><br><span class=\"line\">    sort(arr, mid + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">    merge(arr, L, mid, R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R - L + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p1 = L;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 上面的循环退出后，把剩余的元素依次填入到temp中</span></span><br><span class=\"line\">    <span class=\"comment\">// 以下两个while只有一个会执行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &lt;= mid) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p1++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p2 &lt;= R) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把最终的排序的结果复制给原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class=\"line\">        arr[L + i] = temp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><ul><li>时间复杂度: $O(n\\log n)$</li><li>空间复杂度: $O(N)$,归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li>稳定性:归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</li></ul><!-- rebuild by neat -->","site":{"data":{}},"length":1209,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><p><a href=\"https://www.jianshu.com/p/33cffa1ce613\" class=\"LinkCard\" target=\"_blank\" rel=\"noopener\">归并排序</a></p><h2 id=\"图示过程\"><a href=\"#图示过程\" class=\"headerlink\" title=\"图示过程\"></a>图示过程</h2><h3 id=\"归并排序流程\"><a href=\"#归并排序流程\" class=\"headerlink\" title=\"归并排序流程\"></a>归并排序流程</h3><p><img src=\"/uploads/guibing1.png\" alt></p>","more":"<h3 id=\"合并两个有序数组的流程\"><a href=\"#合并两个有序数组的流程\" class=\"headerlink\" title=\"合并两个有序数组的流程\"></a>合并两个有序数组的流程</h3><p><img src=\"/uploads/guibing2.png\" alt></p><h2 id=\"动图展示\"><a href=\"#动图展示\" class=\"headerlink\" title=\"动图展示\"></a>动图展示</h2><p><img src=\"/uploads/guibing3.gif\" alt></p><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    sort(arr, <span class=\"number\">0</span>, arr.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(L == R) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = L + ((R - L) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    sort(arr, L, mid);</span><br><span class=\"line\">    sort(arr, mid + <span class=\"number\">1</span>, R);</span><br><span class=\"line\">    merge(arr, L, mid, R);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr, <span class=\"keyword\">int</span> L, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> R)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[R - L + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p1 = L;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p2 = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 比较左右两部分的元素，哪个小，把那个元素填入temp中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= R) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 上面的循环退出后，把剩余的元素依次填入到temp中</span></span><br><span class=\"line\">    <span class=\"comment\">// 以下两个while只有一个会执行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p1 &lt;= mid) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p1++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p2 &lt;= R) &#123;</span><br><span class=\"line\">        temp[i++] = arr[p2++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把最终的排序的结果复制给原数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class=\"line\">        arr[L + i] = temp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><ul><li>时间复杂度: $O(n\\log n)$</li><li>空间复杂度: $O(N)$,归并排序需要一个与原数组相同长度的数组做辅助来排序</li><li>稳定性:归并排序是稳定的排序算法，<code>temp[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</code>这行代码可以保证当左右两部分的值相等的时候，先复制左边的值，这样可以保证值相等的时候两个元素的相对位置不变。</li></ul><!-- rebuild by neat -->"},{"title":"测试管理博客","author":"Carlos","abbrlink":"ba3a5e99","date":"2019-07-04T01:35:00.000Z","_content":"## **测试HEXO-ADMIN管理是不是有用**\n\n\nhello \n\n\n![](/uploads/hexo-uploads.png)\n\n<!-- more -->","source":"_posts/测试管理博客.md","raw":"---\ntitle: 测试管理博客\nauthor: Carlos\ntags:\n  - hexo\n  - hexo-admin\ncategories:\n  - Hexo\nabbrlink: ba3a5e99\ndate: 2019-07-04 09:35:00\n---\n## **测试HEXO-ADMIN管理是不是有用**\n\n\nhello \n\n\n![](/uploads/hexo-uploads.png)\n\n<!-- more -->","slug":"测试管理博客","published":1,"updated":"2019-09-03T03:40:46.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck07keth3004r0vfavbfaw1gj","content":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"测试HEXO-ADMIN管理是不是有用\"><a href=\"#测试HEXO-ADMIN管理是不是有用\" class=\"headerlink\" title=\"测试HEXO-ADMIN管理是不是有用\"></a><strong>测试HEXO-ADMIN管理是不是有用</strong></h2><p>hello</p><p><img src=\"/uploads/hexo-uploads.png\" alt></p><a id=\"more\"></a><!-- rebuild by neat -->","site":{"data":{}},"length":24,"excerpt":"<!-- build time:Fri Sep 06 2019 11:33:50 GMT+0800 (中国标准时间) --><h2 id=\"测试HEXO-ADMIN管理是不是有用\"><a href=\"#测试HEXO-ADMIN管理是不是有用\" class=\"headerlink\" title=\"测试HEXO-ADMIN管理是不是有用\"></a><strong>测试HEXO-ADMIN管理是不是有用</strong></h2><p>hello</p><p><img src=\"/uploads/hexo-uploads.png\" alt></p>","more":"<!-- rebuild by neat -->"}],"PostAsset":[],"PostCategory":[{"post_id":"ck07ketd000000vfavknk96ro","category_id":"ck07ketda00040vfa5f704cr0","_id":"ck07ketdr000g0vfae0dofw4s"},{"post_id":"ck07ketd500020vfaonvct7w2","category_id":"ck07ketdj000b0vfaidgyyo3v","_id":"ck07ketdx000m0vfamp5gg4so"},{"post_id":"ck07ketdd00060vfa3u2apjsl","category_id":"ck07ketdj000b0vfaidgyyo3v","_id":"ck07ketdz000r0vfa6gawn8d6"},{"post_id":"ck07ketdh000a0vfapq5nbcuw","category_id":"ck07ketdx000l0vfauj4s25g2","_id":"ck07kete2000y0vfas8ep62di"},{"post_id":"ck07ketdl000e0vfae57us6n9","category_id":"ck07kete0000t0vfaquydi5h4","_id":"ck07kete700150vfaiq4y0med"},{"post_id":"ck07ketdu000j0vfav2dl0z5j","category_id":"ck07kete0000t0vfaquydi5h4","_id":"ck07keteb001a0vfa68siwsmr"},{"post_id":"ck07ketea00190vfaz6p12m6y","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketef001h0vfar9m7zpwa"},{"post_id":"ck07ketdw000k0vfayg713jnw","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keteh001m0vfal5tkm1ck"},{"post_id":"ck07keteb001b0vfaexos2ert","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketej001p0vfasrg21kug"},{"post_id":"ck07keted001e0vfauzpk2pl0","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keteo001t0vfac0watk79"},{"post_id":"ck07ketdx000o0vfap2v3aefg","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keteq001w0vfaazv7wr8s"},{"post_id":"ck07ketee001g0vfadlxntzr0","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketet00200vfa8plpflz8"},{"post_id":"ck07keteg001l0vfag8jb848f","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keteu00230vfa8s5s2387"},{"post_id":"ck07ketdy000q0vfa2hrmtjye","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketev00260vfaalfl7g4h"},{"post_id":"ck07ketei001o0vfa6rqmqofn","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketew00290vfajzsgjlz0"},{"post_id":"ck07keten001s0vfaqckc43r1","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketey002c0vfav85lvu9h"},{"post_id":"ck07kete0000v0vfa7uk0zkdj","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketf0002g0vfaerta2bpx"},{"post_id":"ck07ketep001v0vfa0885y3h5","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketf4002k0vfal4heqm0r"},{"post_id":"ck07ketes001z0vfasr9c7ii3","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketf5002o0vfa8t85393g"},{"post_id":"ck07kete2000x0vfa8tt34ter","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketf9002r0vfatjqtt5on"},{"post_id":"ck07ketet00220vfaxalzdmrv","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfd002v0vfa2jh8j8y5"},{"post_id":"ck07keteu00250vfav0vjarl1","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketff002y0vfamo6co51w"},{"post_id":"ck07kete300100vfab5t9a5gb","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfg00320vfaoftl1hkn"},{"post_id":"ck07ketew00280vfagvk4v0nf","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfj00350vfab3lyuo7n"},{"post_id":"ck07ketex002b0vfag6qgti4o","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfm00390vfa2w1gg9b5"},{"post_id":"ck07kete600130vfabvoq11le","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfo003c0vfajkg7snp0"},{"post_id":"ck07ketf0002f0vfahuyv4say","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfq003g0vfaamguxhq2"},{"post_id":"ck07ketf3002j0vfa78a5zqlt","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfr003j0vfa27n8veop"},{"post_id":"ck07kete800170vfa6buh7kws","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfv003o0vfaasudmnlm"},{"post_id":"ck07ketf5002n0vfa2ekk5qpi","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketfx003r0vfaqktwugft"},{"post_id":"ck07ketf8002q0vfae1f3k4jj","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketg2003v0vfal3qjagz1"},{"post_id":"ck07ketfc002u0vfarff3wzp1","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketg3003y0vfah5qnmeb9"},{"post_id":"ck07ketfe002x0vfa93snap34","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketg800420vfaehpe7hav"},{"post_id":"ck07ketfg00310vfa5868xxv7","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketgb00450vfamyaanu32"},{"post_id":"ck07ketfh00340vfax8i52rc1","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketgd00490vfamuo11svd"},{"post_id":"ck07ketfl00380vfaab1htujq","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketgm004d0vfaa5csji0y"},{"post_id":"ck07ketfm003b0vfanch9tlls","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07ketgv004h0vfa4sy2lgw2"},{"post_id":"ck07ketfr003i0vfa4s5nh0ym","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keth0004l0vfa9paovkdv"},{"post_id":"ck07ketfu003n0vfajz4514b6","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keth1004p0vfaapo6met0"},{"post_id":"ck07ketfw003q0vfa7xbgi56h","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keth4004s0vfa6rpiqwwx"},{"post_id":"ck07ketfq003f0vfaew2w6tky","category_id":"ck07ketfu003l0vfaag182q77","_id":"ck07keth5004w0vfa657tialy"},{"post_id":"ck07ketfy003u0vfa13g220u6","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keth5004y0vfajl3gxrlr"},{"post_id":"ck07ketg2003x0vfa4s7syn6g","category_id":"ck07kete700140vfaorg4zcia","_id":"ck07keth600520vfa58m4jwc4"},{"post_id":"ck07ketg700410vfamchpl6zu","category_id":"ck07ketfu003l0vfaag182q77","_id":"ck07keth600540vfaad9314pj"},{"post_id":"ck07ketgd00480vfalo1ffudk","category_id":"ck07ketfu003l0vfaag182q77","_id":"ck07keth700570vfa0iasyaps"},{"post_id":"ck07ketgq004g0vfa4lvx9exe","category_id":"ck07ketfu003l0vfaag182q77","_id":"ck07keth700590vfa5wsgkg1i"},{"post_id":"ck07ketg900440vfafu9p3np3","category_id":"ck07ketge004a0vfas2qqk5dl","_id":"ck07keth7005c0vfatt41hi3o"},{"post_id":"ck07ketgi004c0vfarfzgiu04","category_id":"ck07keth0004k0vfaw3palo1u","_id":"ck07keth7005e0vfahu6wwo54"},{"post_id":"ck07ketgz004j0vfa9vyeb12k","category_id":"ck07keth4004t0vfatnjamq5y","_id":"ck07keth9005h0vfavitun158"},{"post_id":"ck07keth3004r0vfavbfaw1gj","category_id":"ck07keth500500vfasnfw70gw","_id":"ck07keth9005j0vfa39mqpcp4"}],"PostTag":[{"post_id":"ck07ketd000000vfavknk96ro","tag_id":"ck07ketdd00050vfaxojvc5ie","_id":"ck07ketdy000p0vfawq4liza5"},{"post_id":"ck07ketd000000vfavknk96ro","tag_id":"ck07ketdj000c0vfabxdrq0o5","_id":"ck07kete0000s0vfa2a51dizn"},{"post_id":"ck07ketd000000vfavknk96ro","tag_id":"ck07ketdr000i0vfakxa59wff","_id":"ck07kete1000w0vfaghqjy43w"},{"post_id":"ck07ketd500020vfaonvct7w2","tag_id":"ck07ketdx000n0vfa3jbfw31u","_id":"ck07kete600120vfavh6ctzsy"},{"post_id":"ck07ketd500020vfaonvct7w2","tag_id":"ck07kete0000u0vfadmrasxth","_id":"ck07kete700160vfaze5y5dnp"},{"post_id":"ck07ketdd00060vfa3u2apjsl","tag_id":"ck07ketdx000n0vfa3jbfw31u","_id":"ck07keted001f0vfajxfpxu3e"},{"post_id":"ck07ketdd00060vfa3u2apjsl","tag_id":"ck07kete800180vfat3p9n899","_id":"ck07ketef001j0vfacen039y8"},{"post_id":"ck07ketdf00080vfaliaatc5j","tag_id":"ck07ketdx000n0vfa3jbfw31u","_id":"ck07keteh001n0vfacw9cc7za"},{"post_id":"ck07ketdh000a0vfapq5nbcuw","tag_id":"ck07ketef001k0vfauniacmve","_id":"ck07keteo001u0vfa1xx4qtjx"},{"post_id":"ck07ketdo000f0vfaload3se9","tag_id":"ck07keten001r0vfapadrwsjv","_id":"ck07ketet00210vfasvgqsidm"},{"post_id":"ck07ketew00280vfagvk4v0nf","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketez002e0vfazynvzfpi"},{"post_id":"ck07ketew00280vfagvk4v0nf","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketf3002i0vfa3qc22nu0"},{"post_id":"ck07ketdw000k0vfayg713jnw","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketf5002m0vfalmik81jt"},{"post_id":"ck07ketdw000k0vfayg713jnw","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketf7002p0vfa9k99i5mh"},{"post_id":"ck07ketex002b0vfag6qgti4o","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfb002t0vfa32y83z5z"},{"post_id":"ck07ketex002b0vfag6qgti4o","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketfe002w0vfacj67lfur"},{"post_id":"ck07ketf0002f0vfahuyv4say","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfg00300vfajnbbm13w"},{"post_id":"ck07ketf0002f0vfahuyv4say","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketfh00330vfavljzzfad"},{"post_id":"ck07ketf3002j0vfa78a5zqlt","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfk00370vfav3mt98m0"},{"post_id":"ck07ketf3002j0vfa78a5zqlt","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketfm003a0vfax4jsl5y1"},{"post_id":"ck07ketf5002n0vfa2ekk5qpi","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfq003e0vfarcl784r8"},{"post_id":"ck07ketf5002n0vfa2ekk5qpi","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketfr003h0vfagu6nmuki"},{"post_id":"ck07ketdx000o0vfap2v3aefg","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfu003m0vfahhp1jqhs"},{"post_id":"ck07ketdx000o0vfap2v3aefg","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketfw003p0vfaipuav6mj"},{"post_id":"ck07ketf8002q0vfae1f3k4jj","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketfy003t0vfaf0nudxyh"},{"post_id":"ck07ketf8002q0vfae1f3k4jj","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketg2003w0vfalbhvv9jj"},{"post_id":"ck07ketfc002u0vfarff3wzp1","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketg400400vfaa4wtwuxj"},{"post_id":"ck07ketfc002u0vfarff3wzp1","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketg900430vfaxy2ngv98"},{"post_id":"ck07ketfe002x0vfa93snap34","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketgd00470vfaen3z8xwe"},{"post_id":"ck07ketfe002x0vfa93snap34","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketge004b0vfaxhp7ddx4"},{"post_id":"ck07ketfg00310vfa5868xxv7","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketgn004f0vfavcownzr6"},{"post_id":"ck07ketfg00310vfa5868xxv7","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketgw004i0vfa08qejwqr"},{"post_id":"ck07ketdy000q0vfa2hrmtjye","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth1004n0vfabba0nnfl"},{"post_id":"ck07ketdy000q0vfa2hrmtjye","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth2004q0vfapfdr10zy"},{"post_id":"ck07ketfh00340vfax8i52rc1","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth4004v0vfat35fys87"},{"post_id":"ck07ketfh00340vfax8i52rc1","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth5004x0vfavw9xcu7b"},{"post_id":"ck07ketfl00380vfaab1htujq","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth600510vfakuxtwsgd"},{"post_id":"ck07ketfl00380vfaab1htujq","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth600530vfaz9ltxzq2"},{"post_id":"ck07ketfm003b0vfanch9tlls","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth600560vfarqs85h60"},{"post_id":"ck07ketfm003b0vfanch9tlls","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth700580vfak8csrpms"},{"post_id":"ck07kete0000v0vfa7uk0zkdj","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth7005b0vfaytyxgegx"},{"post_id":"ck07kete0000v0vfa7uk0zkdj","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth7005d0vfan2nfyn01"},{"post_id":"ck07ketfr003i0vfa4s5nh0ym","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth8005g0vfaj45air5m"},{"post_id":"ck07ketfr003i0vfa4s5nh0ym","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth9005i0vfaaxapnt4k"},{"post_id":"ck07ketfu003n0vfajz4514b6","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keth9005l0vfaw7v5001f"},{"post_id":"ck07ketfu003n0vfajz4514b6","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keth9005m0vfackr4mpfr"},{"post_id":"ck07ketfw003q0vfa7xbgi56h","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketha005o0vfa6modnbqu"},{"post_id":"ck07ketfw003q0vfa7xbgi56h","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketha005p0vfayg8yv82c"},{"post_id":"ck07ketfy003u0vfa13g220u6","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketha005r0vfa48vurj7c"},{"post_id":"ck07ketfy003u0vfa13g220u6","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07ketha005s0vfapwn6ta63"},{"post_id":"ck07kete2000x0vfa8tt34ter","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethc005u0vfaly3rv2hd"},{"post_id":"ck07kete2000x0vfa8tt34ter","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethf005v0vfacstvm27n"},{"post_id":"ck07ketg2003x0vfa4s7syn6g","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethh005x0vfa5hdun1cy"},{"post_id":"ck07ketg2003x0vfa4s7syn6g","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethh005y0vfartsy50oz"},{"post_id":"ck07kete300100vfab5t9a5gb","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethi00600vfa9wdrv8fo"},{"post_id":"ck07kete300100vfab5t9a5gb","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethj00610vfac9w8rtdg"},{"post_id":"ck07kete600130vfabvoq11le","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethm00630vfaci89n931"},{"post_id":"ck07kete600130vfabvoq11le","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethm00640vfak4bk612e"},{"post_id":"ck07kete800170vfa6buh7kws","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethn00660vfaoc72xrb2"},{"post_id":"ck07kete800170vfa6buh7kws","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethn00670vfanwc2v1ic"},{"post_id":"ck07ketea00190vfaz6p12m6y","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketho00690vfauwgg8e3j"},{"post_id":"ck07ketea00190vfaz6p12m6y","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethp006a0vfapklvothk"},{"post_id":"ck07keteb001b0vfaexos2ert","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethp006c0vfa3da4xibk"},{"post_id":"ck07keteb001b0vfaexos2ert","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethp006d0vfa48cb6xwu"},{"post_id":"ck07keted001e0vfauzpk2pl0","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethq006f0vfa4c7oxsj5"},{"post_id":"ck07keted001e0vfauzpk2pl0","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethq006g0vfanx1tn8km"},{"post_id":"ck07ketee001g0vfadlxntzr0","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethq006i0vfaodnblpbp"},{"post_id":"ck07ketee001g0vfadlxntzr0","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethq006j0vfa1qdhst9z"},{"post_id":"ck07keteg001l0vfag8jb848f","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethr006l0vfao1ztu5xm"},{"post_id":"ck07keteg001l0vfag8jb848f","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethr006m0vfam9vqh1yy"},{"post_id":"ck07ketei001o0vfa6rqmqofn","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethr006o0vfa6nqe0gja"},{"post_id":"ck07ketei001o0vfa6rqmqofn","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keths006p0vfat2h0ftla"},{"post_id":"ck07keten001s0vfaqckc43r1","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07keths006r0vfaqy80xr4r"},{"post_id":"ck07keten001s0vfaqckc43r1","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07keths006s0vfaygqondr1"},{"post_id":"ck07ketep001v0vfa0885y3h5","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07ketht006u0vfa85y9incw"},{"post_id":"ck07ketep001v0vfa0885y3h5","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethv006v0vfa4gl30116"},{"post_id":"ck07ketes001z0vfasr9c7ii3","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethw006x0vfaljce58r0"},{"post_id":"ck07ketes001z0vfasr9c7ii3","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethw006y0vfa2o8mawed"},{"post_id":"ck07ketet00220vfaxalzdmrv","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethw00700vfap0ro8vra"},{"post_id":"ck07ketet00220vfaxalzdmrv","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethw00710vfat1vwprhh"},{"post_id":"ck07keteu00250vfav0vjarl1","tag_id":"ck07ketes001y0vfab4n44lvo","_id":"ck07kethx00730vfandzvatsj"},{"post_id":"ck07keteu00250vfav0vjarl1","tag_id":"ck07ketev00270vfa7k8wj4p2","_id":"ck07kethx00740vfahsmpz18y"},{"post_id":"ck07ketfq003f0vfaew2w6tky","tag_id":"ck07kethw006z0vfaewux3163","_id":"ck07kethx00750vfa9kmxfxvn"},{"post_id":"ck07ketg700410vfamchpl6zu","tag_id":"ck07kethw00720vfaz0v23uwy","_id":"ck07kethx00780vfa1qnl96v9"},{"post_id":"ck07ketg700410vfamchpl6zu","tag_id":"ck07kethx00760vfassmqdl4w","_id":"ck07kethx00790vfa4rhktsls"},{"post_id":"ck07ketg900440vfafu9p3np3","tag_id":"ck07kethx00770vfaq6gg7ey1","_id":"ck07kethy007b0vfaach0hhsd"},{"post_id":"ck07ketgd00480vfalo1ffudk","tag_id":"ck07kethx007a0vfaon2iadek","_id":"ck07kethz007e0vfadfkv2qih"},{"post_id":"ck07ketgd00480vfalo1ffudk","tag_id":"ck07kethy007c0vfaj1mtt20c","_id":"ck07kethz007f0vfazls5g0rj"},{"post_id":"ck07ketgi004c0vfarfzgiu04","tag_id":"ck07kethz007d0vfa87lizocm","_id":"ck07keti0007h0vfay3g63h39"},{"post_id":"ck07ketgq004g0vfa4lvx9exe","tag_id":"ck07kethx00760vfassmqdl4w","_id":"ck07keti0007j0vfase9t1wr0"},{"post_id":"ck07ketgz004j0vfa9vyeb12k","tag_id":"ck07keti0007i0vfarmngok3i","_id":"ck07keti1007l0vfaygyyotgp"},{"post_id":"ck07keth1004o0vfa7zydmq1c","tag_id":"ck07keti0007i0vfarmngok3i","_id":"ck07keti1007n0vfayd7kksha"},{"post_id":"ck07keth3004r0vfavbfaw1gj","tag_id":"ck07keti1007m0vfabqn47kx0","_id":"ck07keti1007p0vfadixgd3xw"},{"post_id":"ck07keth3004r0vfavbfaw1gj","tag_id":"ck07keti1007o0vfav6agwtwr","_id":"ck07keti2007q0vfax5x4r7gh"}],"Tag":[{"name":"软件调试","_id":"ck07ketdd00050vfaxojvc5ie"},{"name":"IDEA","_id":"ck07ketdj000c0vfabxdrq0o5"},{"name":"插件","_id":"ck07ketdr000i0vfakxa59wff"},{"name":"LettCode","_id":"ck07ketdx000n0vfa3jbfw31u"},{"name":"哈希","_id":"ck07kete0000u0vfadmrasxth"},{"name":"动态规划","_id":"ck07kete800180vfat3p9n899"},{"name":"Spring Boot","_id":"ck07ketef001k0vfauniacmve"},{"name":"数据库","_id":"ck07keten001r0vfapadrwsjv"},{"name":"java","_id":"ck07ketes001y0vfab4n44lvo"},{"name":"转载","_id":"ck07ketev00270vfa7k8wj4p2"},{"name":"随笔","_id":"ck07kethw006z0vfaewux3163"},{"name":"游戏","_id":"ck07kethw00720vfaz0v23uwy"},{"name":"旧事","_id":"ck07kethx00760vfassmqdl4w"},{"name":"Mysql","_id":"ck07kethx00770vfaq6gg7ey1"},{"name":"前端","_id":"ck07kethx007a0vfaon2iadek"},{"name":"nginx","_id":"ck07kethy007c0vfaj1mtt20c"},{"name":"软件配置","_id":"ck07kethz007d0vfa87lizocm"},{"name":"算法","_id":"ck07keti0007i0vfarmngok3i"},{"name":"hexo","_id":"ck07keti1007m0vfabqn47kx0"},{"name":"hexo-admin","_id":"ck07keti1007o0vfav6agwtwr"}]}}