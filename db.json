{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":0},{"_id":"source/uploads/brand.jpg","path":"uploads/brand.jpg","modified":1,"renderable":0},{"_id":"source/uploads/java3-2.png","path":"uploads/java3-2.png","modified":1,"renderable":0},{"_id":"source/uploads/java4-1.png","path":"uploads/java4-1.png","modified":1,"renderable":0},{"_id":"source/uploads/nginx0.jpg","path":"uploads/nginx0.jpg","modified":1,"renderable":0},{"_id":"source/uploads/nginx1.jpg","path":"uploads/nginx1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/nginx2.jpg","path":"uploads/nginx2.jpg","modified":1,"renderable":0},{"_id":"source/uploads/string.png","path":"uploads/string.png","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/uploads/ckxt3.jpg","path":"uploads/ckxt3.jpg","modified":1,"renderable":0},{"_id":"source/uploads/diary-18.jpg","path":"uploads/diary-18.jpg","modified":1,"renderable":0},{"_id":"source/uploads/java3-1.png","path":"uploads/java3-1.png","modified":1,"renderable":0},{"_id":"source/uploads/ckxt0.jpg","path":"uploads/ckxt0.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt1.jpg","path":"uploads/ckxt1.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt2.jpg","path":"uploads/ckxt2.jpg","modified":1,"renderable":0},{"_id":"source/uploads/ckxt4.jpg","path":"uploads/ckxt4.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay-reward-image.png","path":"images/alipay-reward-image.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/brand.jpg","path":"images/brand.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat-reward-image.png","path":"images/wechat-reward-image.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay-reward-image.jpg","path":"images/alipay-reward-image.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechat-reward-image.jpg","path":"images/wechat-reward-image.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1508404379471},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1508404379471},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1508404379472},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1508404379474},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1508404379474},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1508404379475},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1508404379475},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1508404379475},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1508766013026},{"_id":"themes/next/README.cn.md","hash":"59e323ce21535d561507c9ecc984b7c4dcb61514","modified":1508404379476},{"_id":"themes/next/README.md","hash":"7423256d6e7622434bbfe20c467819687e8e1b27","modified":1508404379476},{"_id":"themes/next/_config.yml","hash":"57bc7ec056f7703b0503afa1d2047122673e34d0","modified":1508770218869},{"_id":"themes/next/bower.json","hash":"47471a8f13528dc4052b746db5b4be2375682173","modified":1508404379479},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1508404379480},{"_id":"themes/next/package.json","hash":"39370e2aadf1f9a7c105edff064c6e47682b3932","modified":1508404379524},{"_id":"themes/next/package-lock.json","hash":"cc3e9b232005f824a73555ad6568d566b8aae554","modified":1508404379524},{"_id":"source/_posts/java-toup1.md","hash":"1ac5c1233ea85fd4dc7c53ee887de46a89538c99","modified":1508765014766},{"_id":"source/_posts/java-toup10.md","hash":"1c4095c4ffd74e1ee1fa39808e9186b2e29dfcb5","modified":1508769434941},{"_id":"source/_posts/java-toup11.md","hash":"fee6e136f4485f89cfb5031265d2ae4946c29bab","modified":1508769690809},{"_id":"source/_posts/java-toup12.md","hash":"4ce409bd1fb92bcb1993327bed726ebe71cae07d","modified":1508769880064},{"_id":"source/_posts/java-toup13.md","hash":"473e3c28d45dd94fc42d72adf36a6599567c3015","modified":1508770639882},{"_id":"source/_posts/java-toup14.md","hash":"2c706a19004485267ae105b728e9631b473173df","modified":1508771379790},{"_id":"source/_posts/java-toup15.md","hash":"cde57ee198c5ea51606c672acf9615e41813cce9","modified":1508769519995},{"_id":"source/_posts/java-toup16.md","hash":"e9050422c3f60aba161a3d7a7618f10252a3724c","modified":1508769523695},{"_id":"source/_posts/java-toup17.md","hash":"5ef8e0dcfd5d1733e29533102767dda82e7b9531","modified":1508769527848},{"_id":"source/_posts/java-toup18.md","hash":"047f4dc7749f29f91fd445645d2c01373b7b823a","modified":1508769532078},{"_id":"source/_posts/java-toup19.md","hash":"f3800f6c99d2c5adea8610df72ec91045d5cdc63","modified":1508769535593},{"_id":"source/_posts/java-toup2.md","hash":"cf9cc05f750ed3f5f328722fed3d0a8174db8950","modified":1508765014767},{"_id":"source/_posts/java-toup20.md","hash":"2cda81fa534806a5a2566976bb71a1f733f97a3a","modified":1508769539914},{"_id":"source/_posts/java-toup3.md","hash":"6e46193d04e259e7c8a14df6f33dd3373e9f2e01","modified":1508765014768},{"_id":"source/_posts/java-toup4.md","hash":"da41bcab86fffc276eb4be08dc073ba0fba1e503","modified":1508765014768},{"_id":"source/_posts/java-toup5.md","hash":"61e0775e170c366c172a513934da88fdd1da8278","modified":1508765014769},{"_id":"source/_posts/java-toup6.md","hash":"91a36d052cf53fd1b985698f16a255ae44492bf8","modified":1508765014769},{"_id":"source/_posts/java-toup7.md","hash":"ac4e592fcd827c4a448eab4159438709b1aec77d","modified":1508765014769},{"_id":"source/_posts/java-toup8.md","hash":"2190fb12f7982802a6db381d779c0fffe9f97bed","modified":1508765014770},{"_id":"source/_posts/java-toup9.1.md","hash":"bc09dc189a3c649185b562f5d3d480ab296fcbfc","modified":1508769564482},{"_id":"source/_posts/java-toup9.md","hash":"bc09dc189a3c649185b562f5d3d480ab296fcbfc","modified":1508765014770},{"_id":"source/_posts/myFirstBlog.md","hash":"7af5d9fdc49bc7cd1d7b51cb7c72829d21f8bcf9","modified":1508765014771},{"_id":"source/_posts/nginx.md","hash":"6873d26fd6a9752714cfc8b9555e236249042485","modified":1508765014771},{"_id":"source/_posts/xuedinge.md","hash":"b06b2aab448a991161a70c397cebde5364fe99bf","modified":1508765014771},{"_id":"source/about/index.md","hash":"6a214a086dd6ab900f67255937d48a17dfcc96b6","modified":1508765014772},{"_id":"source/archives/index.md","hash":"b0d1824e90a467834b23507c4ecad979e1e6a82c","modified":1508765014772},{"_id":"source/categories/index.md","hash":"361ba1728773749e4b55b4505ca346898ab0b06d","modified":1508765014773},{"_id":"source/schedule/index.md","hash":"1d1274bf8b1837ac7280c3c7c8446ad3a956d8ec","modified":1508765014773},{"_id":"source/tags/index.md","hash":"9501fb98a61a523cf459cabdc98d74ad999bce0c","modified":1508765014774},{"_id":"source/uploads/avatar.jpg","hash":"83a9adfaf2096c5a48cf150e8133d63daee287c4","modified":1508765014775},{"_id":"source/uploads/brand.jpg","hash":"53226933a5b2351eba14c4f23e00052632269479","modified":1508765014775},{"_id":"source/uploads/java3-2.png","hash":"bea2ffd4d77637ce7f7621d24df2b4c89504191d","modified":1508765014783},{"_id":"source/uploads/java4-1.png","hash":"554406c6c89e72554ba0af3b69fec91798b9298c","modified":1508765014784},{"_id":"source/uploads/nginx0.jpg","hash":"b119e75f9634059bc249b15663d38a36f5247a83","modified":1508765014784},{"_id":"source/uploads/nginx1.jpg","hash":"7acada8f9e0c8ddf9177d83f3c726c42e9e8ed7f","modified":1508765014785},{"_id":"source/uploads/nginx2.jpg","hash":"a9bdbb38876347527dd254bbe5fc9293b95681a4","modified":1508765014785},{"_id":"source/uploads/string.png","hash":"28e88a5d62fa56925cb8a9183ae6f44b7704bfb6","modified":1508770773675},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1508766012992},{"_id":"themes/next/.git/config","hash":"8e94cc015a498d35202e9fd57e44b3c51e1e5634","modified":1508766012999},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1508765586148},{"_id":"themes/next/.git/index","hash":"e6a04ca209bc6c385c414e647aaf039daa76431e","modified":1508766307321},{"_id":"themes/next/.git/packed-refs","hash":"425e174d2c3bae63eb78f8cab723791547083ef1","modified":1508766012986},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1508766013020},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b1ec000babd42bb7ffd26f5ad8aac9b5bec79ae5","modified":1508766013021},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1508766013021},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1508766013022},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1508404379481},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1508404379481},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1508404379481},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1508404379482},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1508404379482},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1508404379483},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1508404379483},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1508404379483},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1508766013043},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1508404379484},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1508404379484},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1508404379484},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1508404379485},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1508404379485},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1508404379486},{"_id":"themes/next/layout/_layout.swig","hash":"7d91c9ca571067a3548d0f3c132b480cd3beb823","modified":1508404379488},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1508404379521},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1508404379521},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1508404379522},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1508404379522},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1508404379522},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1508404379523},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1508404379523},{"_id":"themes/next/scripts/merge-configs.js","hash":"5758f8f3f12d17bc80da65bb808a20b3a8aae186","modified":1508404379525},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1508404379526},{"_id":"themes/next/source/404.html","hash":"9eb955271b03c72a4bb23a06b60e4ecb4070a880","modified":1508423463560},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1508404379857},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1508404379857},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1508404379858},{"_id":"source/uploads/ckxt3.jpg","hash":"5cc1b96e85d3d2a8364232fbf85795e4ababe5a6","modified":1508765014780},{"_id":"source/uploads/diary-18.jpg","hash":"e8e9f7e7e336e81416af225e26870b56509b9d68","modified":1508765014782},{"_id":"source/uploads/java3-1.png","hash":"e98d1f2eda99ec521e292bb4cd7bc5b1f25a8704","modified":1508765014783},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379778},{"_id":"source/uploads/ckxt0.jpg","hash":"980ebd08b10b0f3b9bf2603dc38d45842cc50d15","modified":1508765014776},{"_id":"source/uploads/ckxt1.jpg","hash":"a184ba933c5757d9dc200b3c056759387242d1cf","modified":1508765014777},{"_id":"source/uploads/ckxt2.jpg","hash":"f52cfe91b2918bc7d48bcf8dd10f68ea780d29c0","modified":1508765014779},{"_id":"source/uploads/ckxt4.jpg","hash":"ca93f86e826eaaabe375a5b9d0bf4ad79762f558","modified":1508765014781},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1508765586148},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1508765586149},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1508765586150},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1508765586150},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1508765586151},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1508765586151},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1508765586152},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1508765586152},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1508765586153},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1508765586153},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1508765586154},{"_id":"themes/next/.git/logs/HEAD","hash":"94d0339446bd1ab7483f2bb11c73532c0500001b","modified":1508766012995},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1508404379486},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1508404379487},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1508404379488},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1508404379488},{"_id":"themes/next/layout/_macro/post.swig","hash":"a710e4837fa98db4a83254b21e9c9c55f0afc7f1","modified":1508506930086},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1508404379490},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b9f9959225876fb56fb3fba96306d19396e704d4","modified":1508404379490},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1508404379491},{"_id":"themes/next/layout/_partials/comments.swig","hash":"0f6fed60181b6c46798dfdda213c2f022b71d65d","modified":1508505457120},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1508404379492},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1508404379492},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1508404379494},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1508404379494},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1508404379495},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1508404379495},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1508404379498},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1508404379499},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1508404379505},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1508404379516},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1508404379516},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1508404379516},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1508404379517},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1508404379517},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1508404379517},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1508404379518},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1508404379527},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1508404379527},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1508404379528},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1508404379528},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1508404379529},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1508404379530},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1508404379530},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1508404379531},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1508404379531},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1508404379777},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1508404379778},{"_id":"themes/next/source/images/alipay-reward-image.png","hash":"6862303cad806748ab963c3ce89efc7f479ab8d9","modified":1508489387245},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1508404379779},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1508404379779},{"_id":"themes/next/source/images/brand.jpg","hash":"53226933a5b2351eba14c4f23e00052632269479","modified":1508481952810},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1508404379780},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1508404379780},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1508404379781},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1508404379781},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1508404379782},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1508404379782},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1508404379782},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1508404379783},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1508404379783},{"_id":"themes/next/source/images/favicon.ico","hash":"6bfec58ad0950e0d792bc453010291a922ed19dc","modified":1508488181753},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508404379783},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1508404379783},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508404379784},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1508404379784},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1508404379784},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1508404379785},{"_id":"themes/next/source/images/wechat-reward-image.png","hash":"e94249344d9477a69cd3710903ac566b27c289cc","modified":1508489440433},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379500},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379500},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379760},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379760},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379762},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1508404379775},{"_id":"themes/next/source/images/alipay-reward-image.jpg","hash":"1916205e62981d063e0111ffb6702c3505ca5ead","modified":1508488934922},{"_id":"themes/next/.git/objects/48/9977c78b244050381d23d2c401377dc9c5ca87","hash":"c7b05b6c409dc17896c6ccfe9268bac5a31dbfc2","modified":1508766172409},{"_id":"themes/next/.git/objects/52/45dcc46f98c66b389ba410b3bdbb1c5cb5dda7","hash":"4006cdc52dc3095aba5ba80f981aac659d40c072","modified":1508766172379},{"_id":"themes/next/.git/objects/9f/e86aafcde7f6e3821ccbd50f2ba7e4c0e01528","hash":"f4bb9cb3ddbebaba1b8a663f486c60e44486b512","modified":1508766172270},{"_id":"themes/next/.git/objects/c7/ff04edf92ea8a9a423f4ce05bdc1a727e53da1","hash":"8eef3c5c97409256ef57a8a0b1903654cd2585db","modified":1508766172363},{"_id":"themes/next/.git/objects/f3/59a3aa4d3623636b04a8ca8d7b61844e8b4afe","hash":"e26d1330a9cce0ddff99bae95efea5d826a496f3","modified":1508766172465},{"_id":"themes/next/.git/refs/heads/master","hash":"937b536c15b6134493bbae8ae43a1d5387c863d8","modified":1508766012995},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1508404379493},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1508404379493},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1508404379495},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1508404379496},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1508404379496},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1508404379496},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1508404379497},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1508404379497},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1508404379498},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1508404379499},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1508404379500},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1508404379504},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1508404379506},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1508404379506},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1508404379507},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1508404379507},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1508404379508},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1508404379508},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1508404379508},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1508404379509},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1508404379509},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1508404379510},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1508404379510},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1508404379510},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1508404379511},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1508404379511},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1508404379513},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1508404379513},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1508404379514},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1508404379514},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1508404379515},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"1e47f2196a7cb3482c7a6c66de00a6dc7d403e92","modified":1508404379515},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1508404379515},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1508404379521},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1508404379519},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1508404379519},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1508404379520},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1508404379759},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1508404379760},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"4cf6f141767c2a41179e0c4b2b370df83424ad89","modified":1508487333890},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1508404379761},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"2a4bae653e90697ad92767794d0bf1da179d45bd","modified":1508516773401},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1508404379775},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1508404379776},{"_id":"themes/next/source/css/_variables/base.styl","hash":"40bfa21fbca14dd81959dc4715d235ac7885e756","modified":1508480019873},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"22371a064f6dc29c3a206d69773d2fd44a27ecef","modified":1508516482518},{"_id":"themes/next/source/images/wechat-reward-image.jpg","hash":"e0a529ff4b2dd9878a5bca64b122d426f71b5dd0","modified":1508488916184},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1508404379785},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1508404379786},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1508404379786},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1508404379787},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1508404379787},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1508404379788},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1508404379788},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1508404379789},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1508404379790},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1508404379790},{"_id":"themes/next/source/js/src/utils.js","hash":"b7ddc240208d57596a67c78a04a11b0f0bdecc97","modified":1508404379791},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1508404379798},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1508404379803},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1508404379804},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1508404379804},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1508404379805},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1508404379812},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1508404379813},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1508404379813},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1508404379814},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1508404379816},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1508404379816},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1508404379817},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1508404379817},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1508404379817},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1508404379833},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1508404379835},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1508404379835},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1508404379836},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1508404379836},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1508404379837},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1508404379837},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1508404379838},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1508404379838},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1508404379839},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1508404379840},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1508404379840},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1508404379841},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1508404379841},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1508404379841},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1508404379842},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1508404379842},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1508404379842},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1508404379842},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1508404379843},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1508404379843},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1508404379844},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1508404379844},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1508404379844},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1508404379845},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1508404379845},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1508404379846},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1508404379852},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1508404379852},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1508404379855},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1508404379856},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1508404379856},{"_id":"themes/next/.git/objects/3b/1f2e5fb5cab54fbf7127f792c4b2926522f937","hash":"403717400560ebd878945b997e17a4563147b9ed","modified":1508766172318},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1508404379834},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"94d0339446bd1ab7483f2bb11c73532c0500001b","modified":1508766012996},{"_id":"themes/next/.git/objects/a2/25589c7f9be547004e8a4fba86cc1da8da4e89","hash":"b281219fd52bf4bdbf19f0c33481afe8fdae126e","modified":1508766172436},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1508766012991},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1508404379518},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1508404379519},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1508404379533},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1508404379533},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1508404379533},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1508404379534},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1508404379534},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1508404379543},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1508404379647},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1508404379733},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"66028eacccd35b7c363bff966cff86149e06a966","modified":1508485375505},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1508404379734},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1508404379757},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1508404379757},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1508404379758},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1508404379758},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1508404379763},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1508404379764},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1508404379764},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1508404379765},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1508404379766},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1508404379767},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1508404379767},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1508404379768},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1508404379769},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1508404379770},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"f23ac53ab901c48859dd29eee6e386b60ff956ba","modified":1508404379770},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1508404379771},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1508404379771},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"05646a84c01673075e8e24e8ff71d47c4130bd19","modified":1508482617448},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1508404379772},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"b980e290bb7fa262a65b7d7d93b33908cdd45993","modified":1508480141573},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1508404379773},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"7507750680cab3530f14af4b1fb604fe2330bf86","modified":1508487406972},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1508404379774},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1508404379789},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1508404379795},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1508404379797},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1508404379798},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1508404379805},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1508404379806},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1508404379806},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1508404379807},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1508404379807},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1508404379807},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1508404379810},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1508404379811},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1508404379812},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1508404379815},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1508404379815},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1508404379818},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1508404379819},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1508404379820},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1508404379851},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1508404379851},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1508404379796},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1508404379832},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1508404379833},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1508404379854},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"94d0339446bd1ab7483f2bb11c73532c0500001b","modified":1508766012991},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1508404379535},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1508404379535},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1508404379535},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1508404379536},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1508404379536},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1508404379537},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1508404379538},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1508404379539},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1508404379540},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1508404379541},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1508404379542},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1508404379542},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1508404379543},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1508404379543},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1508404379546},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1508404379547},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1508404379548},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1508404379548},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1508404379548},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1508404379549},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1508404379549},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1508404379549},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1508404379550},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1508404379550},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1508404379550},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1508404379551},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1508404379551},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1508404379551},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1508404379552},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1508404379552},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1508404379553},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1508404379640},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1508404379641},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1508404379642},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1508404379642},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"28a8737c090fbffd188d73a00b42e90b9ee57df2","modified":1508404379642},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1508404379646},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1508404379643},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1508404379647},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1508404379648},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1508404379648},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"3159b55f35c40bd08e55b00148c523760a708c51","modified":1508404379649},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1508404379686},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1508404379687},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1508404379687},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1508404379688},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1508404379688},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1508404379689},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1508404379689},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1508404379689},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1508404379729},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1508404379730},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1508404379730},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1508404379730},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1508404379731},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1508404379731},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1508404379732},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1508404379732},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1508404379768},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1508404379769},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1508404379771},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1508404379792},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1508404379793},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1508404379793},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1508404379794},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1508404379794},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1508404379808},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1508404379808},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1508404379809},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1508404379809},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1508404379810},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1508404379810},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1508404379823},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1508404379825},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1508404379831},{"_id":"themes/next/.git/objects/pack/pack-b24c222227e118e2973c20bf99f4b824f4c9cfae.idx","hash":"4d4f807a3068cccda3f24a4224980135e8642350","modified":1508766012828},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1508404379802},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1508404379850},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1508404379829},{"_id":"themes/next/.git/objects/pack/pack-b24c222227e118e2973c20bf99f4b824f4c9cfae.pack","hash":"b42162ca236e466dfa1f6c31ca2738f961adfd50","modified":1508766012888},{"_id":"public/baidusitemap.xml","hash":"e61172bd635553c1183572e6e8b8ff2b49b617de","modified":1508771519769},{"_id":"public/atom.xml","hash":"eab73ec439e623a5364f5bb82240b0ed962219d7","modified":1508771519799},{"_id":"public/search.xml","hash":"b794f0040be38836fdd5fa669ace6d4722584c80","modified":1508771519799},{"_id":"public/sitemap.xml","hash":"4be4e2da8b85d50603169b6a4f119beb200873ec","modified":1508771519800},{"_id":"public/about/index.html","hash":"db4c9f9dc62397ce4f4d7bc8853b9d5db6d6060c","modified":1508771519816},{"_id":"public/archives/index.html","hash":"240e54602419163586da5b3af8f4bcb772900307","modified":1508771519816},{"_id":"public/categories/index.html","hash":"18587e0896848fae62c824e39b01470b38cdacfd","modified":1508771519816},{"_id":"public/schedule/index.html","hash":"462c8786c7d38fcd87b8eeea27fc03a54cbc5866","modified":1508771519816},{"_id":"public/tags/index.html","hash":"0403b90244f8a73cd486720fcd5789ea4a3efe92","modified":1508771519817},{"_id":"public/2017/10/23/java-toup20/index.html","hash":"0a55e92363af9c00af71942a614e3a32fb3868b5","modified":1508771519817},{"_id":"public/2017/10/23/java-toup19/index.html","hash":"e519f531b38978e5b52fdbeebcb18cbf8375a923","modified":1508771519817},{"_id":"public/2017/10/23/java-toup18/index.html","hash":"4e90846892d5083b37eba06d955eee9cf26f0370","modified":1508771519817},{"_id":"public/2017/10/23/java-toup17/index.html","hash":"61d56d70edce5d807cb6cf3a5bb97a4177868431","modified":1508771519817},{"_id":"public/2017/10/23/java-toup16/index.html","hash":"88a08e613276caf133bb6408e3afd14b5986aa3d","modified":1508771519817},{"_id":"public/2017/10/23/java-toup15/index.html","hash":"1f33ca1411ffe6720a2675000bf883b6c1030630","modified":1508771519817},{"_id":"public/2017/10/23/java-toup14/index.html","hash":"6886ed7c95529740fec3639fc0be07e41e4fab1c","modified":1508771519817},{"_id":"public/2017/10/23/java-toup13/index.html","hash":"50d2eb913a2d035ad0227598862c8238d01dd21b","modified":1508771519817},{"_id":"public/2017/10/23/java-toup12/index.html","hash":"b195170edbf0a80cecf050e8ec6153a9c9c1665e","modified":1508771519818},{"_id":"public/2017/10/23/java-toup11/index.html","hash":"81fd49f5e40cffb23f64ee6be917644d83eb0439","modified":1508771519818},{"_id":"public/2017/10/23/java-toup10/index.html","hash":"1aeb8cad89f04f671a309f64a093e6991f2dcbcf","modified":1508771519818},{"_id":"public/2017/10/23/java-toup9/index.html","hash":"30098a0ba8bea92051b99b3a48592ccc7e738999","modified":1508771519818},{"_id":"public/2017/10/23/java-toup9.1/index.html","hash":"0f783afac0d2e5110305b070207f3a76d68a2a9c","modified":1508771519818},{"_id":"public/2017/10/23/java-toup8/index.html","hash":"53aeb48c68d0f508b0f86e4507a3044ee025dc62","modified":1508771519818},{"_id":"public/2017/10/23/java-toup7/index.html","hash":"1395a2703787a90f6b889936b350deb42d31cbfb","modified":1508771519818},{"_id":"public/2017/10/23/java-toup6/index.html","hash":"c8f0f259d0aef5efbc26a5a59ba8aa9c1f6c0881","modified":1508771519819},{"_id":"public/2017/10/23/java-toup5/index.html","hash":"dd0164d09d47cd2367965b52a426b4fb5d7dc0b1","modified":1508771519819},{"_id":"public/2017/10/23/java-toup4/index.html","hash":"b738d0b29ac55b9e520384e158298bd3573cc993","modified":1508771519819},{"_id":"public/2017/10/23/java-toup3/index.html","hash":"639d4b673ca76051ef4fb6b66630f32da52bacba","modified":1508771519819},{"_id":"public/2017/10/21/java-toup2/index.html","hash":"c7f9de31d67d49700f3454e53e7a2f36fadad0e4","modified":1508771519819},{"_id":"public/2017/10/20/java-toup1/index.html","hash":"667aff22c49eda8c848a4a0f8702afe5c3354f08","modified":1508771519819},{"_id":"public/2017/10/20/nginx/index.html","hash":"1623a5e1dfe9578e21aa2bc30ba1517df380520e","modified":1508771519819},{"_id":"public/2017/10/20/xuedinge/index.html","hash":"d77e56e134d48cecc1029e4f64550a97439a4104","modified":1508771519820},{"_id":"public/2017/10/19/myFirstBlog/index.html","hash":"07aef0acac5df642d7ea205753d1edcda45296c9","modified":1508771519820},{"_id":"public/archives/page/2/index.html","hash":"6a3977edb729cf5a4896a5041bc762a534fd3402","modified":1508771519820},{"_id":"public/archives/page/3/index.html","hash":"1de90da620279acc97a6ddc45cb8e34a863f23ad","modified":1508771519820},{"_id":"public/archives/2017/index.html","hash":"84d90abb6158a65c46436a24f388fbfd6433bf2f","modified":1508771519820},{"_id":"public/archives/2017/page/2/index.html","hash":"06ec4f6f1518d7066c9becdbac737b5d55555b57","modified":1508771519820},{"_id":"public/archives/2017/page/3/index.html","hash":"6397c57b20955678f296e53d5527181fb168e510","modified":1508771519821},{"_id":"public/archives/2017/10/index.html","hash":"77d623f6c9dc7c280b80e81c03814ee4a0e592ec","modified":1508771519821},{"_id":"public/archives/2017/10/page/2/index.html","hash":"0b938b445a6dc5f7f9bfde007a0d736f80493394","modified":1508771519821},{"_id":"public/archives/2017/10/page/3/index.html","hash":"9788e24da9475bff95ce28e718271714df800e10","modified":1508771519821},{"_id":"public/categories/java开发/index.html","hash":"81d5d0fdfe438440d80094b4c21149be3024009e","modified":1508771519821},{"_id":"public/categories/java开发/page/2/index.html","hash":"81eff5a3395a43d07f39466cbbaca904a5d62bb3","modified":1508771519821},{"_id":"public/categories/转载/index.html","hash":"0efb1391775765f09cf05e867622c106108f543f","modified":1508771519821},{"_id":"public/index.html","hash":"338842ae5da6c9b1c135e02a31b3f3110b1d1f62","modified":1508771519821},{"_id":"public/page/2/index.html","hash":"e82fe45a62cceb2b71e6ef70167d7dc4930c7b4d","modified":1508771519821},{"_id":"public/page/3/index.html","hash":"ca583102eab12f6e2d0ee597b94e3730b8461a08","modified":1508771519822},{"_id":"public/tags/java/index.html","hash":"f592d09bae2f333743d3f5bf5b8517675ced2fc9","modified":1508771519822},{"_id":"public/tags/java/page/2/index.html","hash":"354f49590ec46d7b1603cddcd63d737b8cc16ca9","modified":1508771519822},{"_id":"public/tags/转载/index.html","hash":"855a1675740f8127c4ad1928081051f523231091","modified":1508771519822},{"_id":"public/tags/转载/page/2/index.html","hash":"f2bc42b55fa01298a8bbbd54b9965c8122183911","modified":1508771519822},{"_id":"public/tags/游戏/index.html","hash":"f66cbd64e1c0aaae51ca4b26c4a7de655d1383e5","modified":1508771519822},{"_id":"public/tags/旧事/index.html","hash":"f99157a9e8ab540c6ab1026bdd511109806f5f61","modified":1508771519822},{"_id":"public/tags/前端/index.html","hash":"7a0efa6fc42d17e3ff40e2953b1d2603afbd31b1","modified":1508771519822},{"_id":"public/tags/nginx/index.html","hash":"b98b1376980b348d1fa7bcae54d31bdd5bc18120","modified":1508771519822},{"_id":"public/uploads/avatar.jpg","hash":"83a9adfaf2096c5a48cf150e8133d63daee287c4","modified":1508771519864},{"_id":"public/uploads/brand.jpg","hash":"53226933a5b2351eba14c4f23e00052632269479","modified":1508771519864},{"_id":"public/uploads/java3-2.png","hash":"bea2ffd4d77637ce7f7621d24df2b4c89504191d","modified":1508771519865},{"_id":"public/uploads/java4-1.png","hash":"554406c6c89e72554ba0af3b69fec91798b9298c","modified":1508771519865},{"_id":"public/uploads/nginx0.jpg","hash":"b119e75f9634059bc249b15663d38a36f5247a83","modified":1508771519865},{"_id":"public/uploads/nginx1.jpg","hash":"7acada8f9e0c8ddf9177d83f3c726c42e9e8ed7f","modified":1508771519865},{"_id":"public/uploads/nginx2.jpg","hash":"a9bdbb38876347527dd254bbe5fc9293b95681a4","modified":1508771519865},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1508771519865},{"_id":"public/images/alipay-reward-image.png","hash":"6862303cad806748ab963c3ce89efc7f479ab8d9","modified":1508771519865},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1508771519865},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1508771519865},{"_id":"public/images/brand.jpg","hash":"53226933a5b2351eba14c4f23e00052632269479","modified":1508771519865},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1508771519866},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1508771519866},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1508771519866},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1508771519866},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1508771519866},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1508771519866},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1508771519866},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1508771519866},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1508771519866},{"_id":"public/images/favicon.ico","hash":"6bfec58ad0950e0d792bc453010291a922ed19dc","modified":1508771519866},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508771519867},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1508771519867},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1508771519867},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1508771519867},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1508771519868},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1508771519868},{"_id":"public/images/wechat-reward-image.png","hash":"e94249344d9477a69cd3710903ac566b27c289cc","modified":1508771519868},{"_id":"public/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1508771519868},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1508771519868},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1508771519868},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1508771519868},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1508771519868},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1508771519868},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1508771519868},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1508771519869},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1508771519869},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1508771519869},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1508771519869},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1508771519869},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1508771519869},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1508771519870},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1508771519870},{"_id":"public/uploads/string.png","hash":"28e88a5d62fa56925cb8a9183ae6f44b7704bfb6","modified":1508771519870},{"_id":"public/uploads/ckxt3.jpg","hash":"5cc1b96e85d3d2a8364232fbf85795e4ababe5a6","modified":1508771521500},{"_id":"public/uploads/diary-18.jpg","hash":"e8e9f7e7e336e81416af225e26870b56509b9d68","modified":1508771521504},{"_id":"public/uploads/java3-1.png","hash":"e98d1f2eda99ec521e292bb4cd7bc5b1f25a8704","modified":1508771521536},{"_id":"public/images/alipay-reward-image.jpg","hash":"1916205e62981d063e0111ffb6702c3505ca5ead","modified":1508771521537},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1508771521537},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1508771521537},{"_id":"public/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1508771521680},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1508771521680},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1508771521680},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1508771521680},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1508771521680},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1508771521681},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1508771521681},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1508771521681},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1508771521682},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1508771521682},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1508771521682},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1508771521682},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1508771521682},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1508771521682},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1508771521682},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1508771521682},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1508771521682},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1508771521682},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1508771521683},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1508771521683},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1508771521683},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1508771521683},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1508771521683},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1508771521684},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1508771521685},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1508771521685},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1508771521685},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1508771521686},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1508771521696},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1508771521697},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1508771521697},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1508771521698},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1508771521698},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1508771521699},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1508771521699},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1508771521699},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1508771521699},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1508771521699},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1508771521699},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1508771521699},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1508771521700},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1508771521700},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1508771521701},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1508771521701},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1508771521701},{"_id":"public/css/main.css","hash":"2e3effc489c2a7c433bd2350d915c46e76715e5b","modified":1508771521701},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1508771521701},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1508771521702},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1508771521702},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1508771521702},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1508771521702},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1508771521702},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1508771521702},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1508771521704},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1508771521704},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1508771521704},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1508771521704},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1508771521704},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1508771521704},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1508771521705},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1508771521705},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1508771521705},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1508771521706},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1508771521706},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1508771521706},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1508771521707},{"_id":"public/uploads/ckxt0.jpg","hash":"980ebd08b10b0f3b9bf2603dc38d45842cc50d15","modified":1508771521707},{"_id":"public/uploads/ckxt1.jpg","hash":"a184ba933c5757d9dc200b3c056759387242d1cf","modified":1508771521708},{"_id":"public/uploads/ckxt2.jpg","hash":"f52cfe91b2918bc7d48bcf8dd10f68ea780d29c0","modified":1508771521709},{"_id":"public/uploads/ckxt4.jpg","hash":"ca93f86e826eaaabe375a5b9d0bf4ad79762f558","modified":1508771521711},{"_id":"public/images/wechat-reward-image.jpg","hash":"e0a529ff4b2dd9878a5bca64b122d426f71b5dd0","modified":1508771521712},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1508771521712},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1508771521712},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1508771521713},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1508771522312}],"Category":[{"name":"java开发","_id":"cj94blp480004v0v5hiz7917y"},{"name":"-转载","_id":"cj94blp6k001xv0v5se7095ec"}],"Data":[],"Page":[{"title":"关于","date":"2017-10-19T14:29:44.000Z","_content":"\n\n### 关于我\n\n一只敲代码的程序猿，欢迎分享知识。\n\n### 联系方式\nEmail: 158199521@qq.com","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-10-19 22:29:44\n---\n\n\n### 关于我\n\n一只敲代码的程序猿，欢迎分享知识。\n\n### 联系方式\nEmail: 158199521@qq.com","updated":"2017-10-23T13:23:34.772Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj94blp430001v0v5dq7g4sgw","content":"<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>一只敲代码的程序猿，欢迎分享知识。</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p>Email: 158199521@qq.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h3><p>一只敲代码的程序猿，欢迎分享知识。</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p>Email: 158199521@qq.com</p>\n"},{"title":"archives","date":"2017-10-19T14:30:04.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2017-10-19 22:30:04\n---\n","updated":"2017-10-23T13:23:34.772Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cj94blp460003v0v5tzb82671","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-10-19T14:28:54.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-10-19 22:28:54\ntype: \"categories\"\n---\n","updated":"2017-10-23T13:23:34.773Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj94blp4e0007v0v533uqkigw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2017-10-19T14:30:18.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2017-10-19 22:30:18\ntype: \"schedule\"\n---\n","updated":"2017-10-23T13:23:34.773Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"cj94blp4g0009v0v5d4vsxdix","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-10-19T14:26:28.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-10-19 22:26:28\ntype: \"tags\"\n---\n","updated":"2017-10-23T13:23:34.774Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj94blp4i000dv0v5b3pdclao","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"java提高篇-----详解java的四舍五入与保留位","date":"2017-10-20T15:34:10.000Z","_content":"\n> 转载：[http://blog.csdn.net/chenssy/article/details/12719811](http://blog.csdn.net/chenssy/article/details/12719811)\n\n四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。\n在讲解之前，我们先看一个经典的案例：\n\n```java\n    public static void main(String[] args){\n        System.out.println(\"12.5的四舍五入值：\"+Math.round(12.5));\n          System.out.println(\"-12.5的四舍五入值：\" + Math.round(-12.5));  \n    }  \n    Output:  \n    12.5的四舍五入值：13  \n    -12.5的四舍五入值：-12  \n```\n<!-- more -->\n\n这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。\n      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：\n      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。\n      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。\n      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：\n      舍去位的数值小于5时，直接舍去。\n      舍去位的数值大于5时，进位后舍去。\n      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。\n      对于上面的规则我们举例说明\n         11.556 = 11.56 ------六入\n         11.554 = 11.55 -----四舍\n         11.5551 = 11.56 -----五后有数进位\n         11.545 = 11.54 -----五后无数，若前位为偶数应舍去\n         11.555 = 11.56 -----五后无数，若前位为奇数应进位\n      下面实例是使用银行家舍入法：\n\n```java\n    public static void main(String[] args) {  \n        BigDecimal d = new BigDecimal(100000);      //存款  \n        BigDecimal r = new BigDecimal(0.001875*3);   //利息  \n        //使用银行家算法   \n        BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN);\n        \n        System.out.println(\"季利息是：\"+i);  \n        }  \nOutput:  \n季利息是：562.50  \n```\n在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：\n         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。\n         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。\n         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。\n         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。\n         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。\n         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。\n         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。\n      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。\n\n## 保留位\n\n### 方法一：四舍五入 \n```java\n    double   f   =   111231.5585;  \n    BigDecimal   b   =   new   BigDecimal(f);  \n    double   f1   =   b.setScale(2,   RoundingMode.HALF_UP).doubleValue();\n```\n在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。\n\n### 方法二：\n```java\n    java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  \n    df.format(你要格式化的数字);  \n```\n例：new java.text.DecimalFormat(”#.00″).format(3.1415926)\n      #.00 表示两位小数 #.0000四位小数 以此类推…\n\n### 方法三：\n\n```java\n    double d = 3.1415926;  \n  \n    String result = String .format(”%.2f”);  \n  \n    %.2f %. 表示 小数点前任意位数   2 表示两位小数 格式后的结果为f 表示浮点型。\n```\n\n### 方法四：\n\n此外如果使用struts标签做输出的话，有个format属性,设置为format=\"0.00\"就是保留两位小数\n      例如：\n```java\n    <bean:write name=\"entity\" property=\"dkhAFSumPl\"  format=\"0.00\" />  \n    \n    或者  \n    \n    <fmt:formatNumber type=\"number\" value=\"${10000.22/100}\" \n                                maxFractionDigits=\"0\"/>  \n    \n    maxFractionDigits表示保留的位数  \n\n```","source":"_posts/java-toup1.md","raw":"---\ntitle: java提高篇-----详解java的四舍五入与保留位\ndate: 2017-10-20 23:34:10\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载：[http://blog.csdn.net/chenssy/article/details/12719811](http://blog.csdn.net/chenssy/article/details/12719811)\n\n四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。\n在讲解之前，我们先看一个经典的案例：\n\n```java\n    public static void main(String[] args){\n        System.out.println(\"12.5的四舍五入值：\"+Math.round(12.5));\n          System.out.println(\"-12.5的四舍五入值：\" + Math.round(-12.5));  \n    }  \n    Output:  \n    12.5的四舍五入值：13  \n    -12.5的四舍五入值：-12  \n```\n<!-- more -->\n\n这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。\n      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：\n      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。\n      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。\n      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：\n      舍去位的数值小于5时，直接舍去。\n      舍去位的数值大于5时，进位后舍去。\n      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。\n      对于上面的规则我们举例说明\n         11.556 = 11.56 ------六入\n         11.554 = 11.55 -----四舍\n         11.5551 = 11.56 -----五后有数进位\n         11.545 = 11.54 -----五后无数，若前位为偶数应舍去\n         11.555 = 11.56 -----五后无数，若前位为奇数应进位\n      下面实例是使用银行家舍入法：\n\n```java\n    public static void main(String[] args) {  \n        BigDecimal d = new BigDecimal(100000);      //存款  \n        BigDecimal r = new BigDecimal(0.001875*3);   //利息  \n        //使用银行家算法   \n        BigDecimal i = d.multiply(r).setScale(2,RoundingMode.HALF_EVEN);\n        \n        System.out.println(\"季利息是：\"+i);  \n        }  \nOutput:  \n季利息是：562.50  \n```\n在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：\n         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。\n         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。\n         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。\n         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。\n         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。\n         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。\n         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。\n      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。\n\n## 保留位\n\n### 方法一：四舍五入 \n```java\n    double   f   =   111231.5585;  \n    BigDecimal   b   =   new   BigDecimal(f);  \n    double   f1   =   b.setScale(2,   RoundingMode.HALF_UP).doubleValue();\n```\n在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。\n\n### 方法二：\n```java\n    java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  \n    df.format(你要格式化的数字);  \n```\n例：new java.text.DecimalFormat(”#.00″).format(3.1415926)\n      #.00 表示两位小数 #.0000四位小数 以此类推…\n\n### 方法三：\n\n```java\n    double d = 3.1415926;  \n  \n    String result = String .format(”%.2f”);  \n  \n    %.2f %. 表示 小数点前任意位数   2 表示两位小数 格式后的结果为f 表示浮点型。\n```\n\n### 方法四：\n\n此外如果使用struts标签做输出的话，有个format属性,设置为format=\"0.00\"就是保留两位小数\n      例如：\n```java\n    <bean:write name=\"entity\" property=\"dkhAFSumPl\"  format=\"0.00\" />  \n    \n    或者  \n    \n    <fmt:formatNumber type=\"number\" value=\"${10000.22/100}\" \n                                maxFractionDigits=\"0\"/>  \n    \n    maxFractionDigits表示保留的位数  \n\n```","slug":"java-toup1","published":1,"updated":"2017-10-23T13:23:34.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp3s0000v0v5256o27nn","content":"<blockquote>\n<p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/12719811\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12719811</a></p>\n</blockquote>\n<p>四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。<br>在讲解之前，我们先看一个经典的案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"12.5的四舍五入值：\"</span>+Math.round(<span class=\"number\">12.5</span>));</div><div class=\"line\">      System.out.println(<span class=\"string\">\"-12.5的四舍五入值：\"</span> + Math.round(-<span class=\"number\">12.5</span>));  </div><div class=\"line\">&#125;  </div><div class=\"line\">Output:  </div><div class=\"line\"><span class=\"number\">12.5</span>的四舍五入值：<span class=\"number\">13</span>  </div><div class=\"line\">-<span class=\"number\">12.5</span>的四舍五入值：-<span class=\"number\">12</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。<br>      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：<br>      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。<br>      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。<br>      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：<br>      舍去位的数值小于5时，直接舍去。<br>      舍去位的数值大于5时，进位后舍去。<br>      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。<br>      对于上面的规则我们举例说明<br>         11.556 = 11.56 ——六入<br>         11.554 = 11.55 —–四舍<br>         11.5551 = 11.56 —–五后有数进位<br>         11.545 = 11.54 —–五后无数，若前位为偶数应舍去<br>         11.555 = 11.56 —–五后无数，若前位为奇数应进位<br>      下面实例是使用银行家舍入法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        BigDecimal d = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>);      <span class=\"comment\">//存款  </span></div><div class=\"line\">        BigDecimal r = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">0.001875</span>*<span class=\"number\">3</span>);   <span class=\"comment\">//利息  </span></div><div class=\"line\">        <span class=\"comment\">//使用银行家算法   </span></div><div class=\"line\">        BigDecimal i = d.multiply(r).setScale(<span class=\"number\">2</span>,RoundingMode.HALF_EVEN);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"季利息是：\"</span>+i);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">Output:  </div><div class=\"line\">季利息是：<span class=\"number\">562.50</span></div></pre></td></tr></table></figure>\n<p>在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：<br>         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。<br>         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。<br>         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。<br>         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。<br>         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。<br>         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。<br>         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。<br>      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。</p>\n<h2 id=\"保留位\"><a href=\"#保留位\" class=\"headerlink\" title=\"保留位\"></a>保留位</h2><h3 id=\"方法一：四舍五入\"><a href=\"#方法一：四舍五入\" class=\"headerlink\" title=\"方法一：四舍五入\"></a>方法一：四舍五入</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span>   f   =   <span class=\"number\">111231.5585</span>;  </div><div class=\"line\">BigDecimal   b   =   <span class=\"keyword\">new</span>   BigDecimal(f);  </div><div class=\"line\"><span class=\"keyword\">double</span>   f1   =   b.setScale(<span class=\"number\">2</span>,   RoundingMode.HALF_UP).doubleValue();</div></pre></td></tr></table></figure>\n<p>在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。</p>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  </div><div class=\"line\">df.format(你要格式化的数字);</div></pre></td></tr></table></figure>\n<p>例：new java.text.DecimalFormat(”#.00″).format(3.1415926)</p>\n<pre><code>#.00 表示两位小数 #.0000四位小数 以此类推…\n</code></pre><h3 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> d = <span class=\"number\">3.1415926</span>;  </div><div class=\"line\">  </div><div class=\"line\">String result = String .format(”%.<span class=\"number\">2f</span>”);  </div><div class=\"line\">  </div><div class=\"line\">%.<span class=\"number\">2f</span> %. 表示 小数点前任意位数   <span class=\"number\">2</span> 表示两位小数 格式后的结果为f 表示浮点型。</div></pre></td></tr></table></figure>\n<h3 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h3><p>此外如果使用struts标签做输出的话，有个format属性,设置为format=”0.00”就是保留两位小数<br>      例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean:write name=<span class=\"string\">\"entity\"</span> property=<span class=\"string\">\"dkhAFSumPl\"</span>  format=<span class=\"string\">\"0.00\"</span> /&gt;  </div><div class=\"line\"></div><div class=\"line\">或者  </div><div class=\"line\"></div><div class=\"line\">&lt;fmt:formatNumber type=<span class=\"string\">\"number\"</span> value=<span class=\"string\">\"$&#123;10000.22/100&#125;\"</span> </div><div class=\"line\">                            maxFractionDigits=<span class=\"string\">\"0\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">maxFractionDigits表示保留的位数</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/12719811\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12719811</a></p>\n</blockquote>\n<p>四舍五入是我们小学的数学问题，这个问题对于我们程序猿来说就类似于1到10加减乘除那么简单了。<br>在讲解之前，我们先看一个经典的案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">    System.out.println(<span class=\"string\">\"12.5的四舍五入值：\"</span>+Math.round(<span class=\"number\">12.5</span>));</div><div class=\"line\">      System.out.println(<span class=\"string\">\"-12.5的四舍五入值：\"</span> + Math.round(-<span class=\"number\">12.5</span>));  </div><div class=\"line\">&#125;  </div><div class=\"line\">Output:  </div><div class=\"line\"><span class=\"number\">12.5</span>的四舍五入值：<span class=\"number\">13</span>  </div><div class=\"line\">-<span class=\"number\">12.5</span>的四舍五入值：-<span class=\"number\">12</span></div></pre></td></tr></table></figure>","more":"<p>这是四舍五入的经典案例，也是我们参加校招时候经常会遇到的(貌似我参加笔试的时候遇到过好多次)。从这儿结果中我们发现这两个绝对值相同的数字，为何近似值会不同呢？其实这与Math.round采用的四舍五入规则来决定。<br>      四舍五入其实在金融方面运用的非常多，尤其是银行的利息。我们都知道银行的盈利渠道主要是利息差，它从储户手里收集资金，然后放贷出去，期间产生的利息差就是银行所获得的利润。如果我们采用平常四舍五入的规则话，这里采用每10笔存款利息计算作为模型，如下：<br>      四舍：0.000、0.001、0.002、0.003、0.004。这些舍的都是银行赚的钱。<br>      五入：0.005、0.006、0.007、0.008、0.009。这些入的都是银行亏的钱，分别为：0.005、0.004、.003、0.002、0.001。<br>      所以对于银行来说它的盈利应该是0.000 + 0.001 + 0.002 + 0.003 + 0.004 - 0.005 - 0.004 - 0.003 - 0.002 - 0.001 = -0.005。从结果中可以看出每10笔的利息银行可能就会损失0.005元，千万别小看这个数字，这对于银行来说就是一笔非常大的损失。面对这个问题就产生了如下的银行家涉入法了。该算法是由美国银行家提出了，主要用于修正采用上面四舍五入规则而产生的误差。如下：<br>      舍去位的数值小于5时，直接舍去。<br>      舍去位的数值大于5时，进位后舍去。<br>      当舍去位的数值等于5时，若5后面还有其他非0数值，则进位后舍去，若5后面是0时，则根据5前一位数的奇偶性来判断，奇数进位，偶数舍去。<br>      对于上面的规则我们举例说明<br>         11.556 = 11.56 ——六入<br>         11.554 = 11.55 —–四舍<br>         11.5551 = 11.56 —–五后有数进位<br>         11.545 = 11.54 —–五后无数，若前位为偶数应舍去<br>         11.555 = 11.56 —–五后无数，若前位为奇数应进位<br>      下面实例是使用银行家舍入法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        BigDecimal d = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>);      <span class=\"comment\">//存款  </span></div><div class=\"line\">        BigDecimal r = <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">0.001875</span>*<span class=\"number\">3</span>);   <span class=\"comment\">//利息  </span></div><div class=\"line\">        <span class=\"comment\">//使用银行家算法   </span></div><div class=\"line\">        BigDecimal i = d.multiply(r).setScale(<span class=\"number\">2</span>,RoundingMode.HALF_EVEN);</div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"季利息是：\"</span>+i);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">Output:  </div><div class=\"line\">季利息是：<span class=\"number\">562.50</span></div></pre></td></tr></table></figure>\n<p>在上面简单地介绍了银行家舍入法，目前java支持7中舍入法：<br>         <font color=\"#0099ff\">1、 ROUND_UP</font>：远离零方向舍入。向绝对值最大的方向舍入，只要舍弃位非0即进位。<br>         <font color=\"#0099ff\">2、 ROUND_DOWN</font>：趋向零方向舍入。向绝对值最小的方向输入，所有的位都要舍弃，不存在进位情况。<br>         <font color=\"#0099ff\">3、 ROUND_CEILING</font>：向正无穷方向舍入。向正最大方向靠拢。若是正数，舍入行为类似于ROUND_UP，若为负数，舍入行为类似于ROUND_DOWN。Math.round()方法就是使用的此模式。<br>         <font color=\"#0099ff\">4、 ROUND_FLOOR</font>：向负无穷方向舍入。向负无穷方向靠拢。若是正数，舍入行为类似于ROUND_DOWN；若为负数，舍入行为类似于ROUND_UP。<br>         <font color=\"#0099ff\">5、 HALF_UP</font>：最近数字舍入(5进)。这是我们最经典的四舍五入。<br>         <font color=\"#0099ff\">6、 HALF_DOWN</font>：最近数字舍入(5舍)。在这里5是要舍弃的。<br>         <font color=\"#0099ff\">7、 HAIL_EVEN</font>：银行家舍入法。<br>      提到四舍五入那么保留位就必不可少了，在java运算中我们可以使用多种方式来实现保留位。</p>\n<h2 id=\"保留位\"><a href=\"#保留位\" class=\"headerlink\" title=\"保留位\"></a>保留位</h2><h3 id=\"方法一：四舍五入\"><a href=\"#方法一：四舍五入\" class=\"headerlink\" title=\"方法一：四舍五入\"></a>方法一：四舍五入</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span>   f   =   <span class=\"number\">111231.5585</span>;  </div><div class=\"line\">BigDecimal   b   =   <span class=\"keyword\">new</span>   BigDecimal(f);  </div><div class=\"line\"><span class=\"keyword\">double</span>   f1   =   b.setScale(<span class=\"number\">2</span>,   RoundingMode.HALF_UP).doubleValue();</div></pre></td></tr></table></figure>\n<p>在这里使用BigDecimal ，并且采用setScale方法来设置精确度，同时使用RoundingMode.HALF_UP表示使用最近数字舍入法则来近似计算。在这里我们可以看出BigDecimal和四舍五入是绝妙的搭配。</p>\n<h3 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">java.text.DecimalFormat   df   =new   java.text.DecimalFormat(”#.00″);  </div><div class=\"line\">df.format(你要格式化的数字);</div></pre></td></tr></table></figure>\n<p>例：new java.text.DecimalFormat(”#.00″).format(3.1415926)</p>\n<pre><code>#.00 表示两位小数 #.0000四位小数 以此类推…\n</code></pre><h3 id=\"方法三：\"><a href=\"#方法三：\" class=\"headerlink\" title=\"方法三：\"></a>方法三：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">double</span> d = <span class=\"number\">3.1415926</span>;  </div><div class=\"line\">  </div><div class=\"line\">String result = String .format(”%.<span class=\"number\">2f</span>”);  </div><div class=\"line\">  </div><div class=\"line\">%.<span class=\"number\">2f</span> %. 表示 小数点前任意位数   <span class=\"number\">2</span> 表示两位小数 格式后的结果为f 表示浮点型。</div></pre></td></tr></table></figure>\n<h3 id=\"方法四：\"><a href=\"#方法四：\" class=\"headerlink\" title=\"方法四：\"></a>方法四：</h3><p>此外如果使用struts标签做输出的话，有个format属性,设置为format=”0.00”就是保留两位小数<br>      例如：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;bean:write name=<span class=\"string\">\"entity\"</span> property=<span class=\"string\">\"dkhAFSumPl\"</span>  format=<span class=\"string\">\"0.00\"</span> /&gt;  </div><div class=\"line\"></div><div class=\"line\">或者  </div><div class=\"line\"></div><div class=\"line\">&lt;fmt:formatNumber type=<span class=\"string\">\"number\"</span> value=<span class=\"string\">\"$&#123;10000.22/100&#125;\"</span> </div><div class=\"line\">                            maxFractionDigits=<span class=\"string\">\"0\"</span>/&gt;  </div><div class=\"line\"></div><div class=\"line\">maxFractionDigits表示保留的位数</div></pre></td></tr></table></figure></p>"},{"title":"java提高篇（九）-----详解匿名内部类","date":"2017-10-23T05:38:35.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/13170015\n\n在java提高篇-----详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。\n\n## 使用匿名内部类内部类\n匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：\n```java\n    new 父类构造器（参数列表）|实现接口（）    \n        {    \n        //匿名内部类的类体部分    \n        }  \n```\n<!-- more -->\n在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。\n```java\n    public abstract class Bird {  \n        private String name;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n        \n        public abstract int fly();  \n    }  \n    \n    public class Test {  \n        \n        public void test(Bird bird){  \n            System.out.println(bird.getName() + \"能够飞 \" + bird.fly() + \"米\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Test test = new Test();  \n            test.test(new Bird() {  \n                \n                public int fly() {  \n                    return 10000;  \n                }  \n                \n                public String getName() {  \n                    return \"大雁\";  \n                }  \n            });  \n        }  \n    }  \n    ------------------  \n    Output：  \n    大雁能够飞 10000米  \n```\n在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。\n由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。\n对于这段匿名内部类代码其实是可以拆分为如下形式：\n```java\n    public class WildGoose extends Bird{  \n        public int fly() {  \n            return 10000;  \n        }  \n        \n        public String getName() {  \n            return \"大雁\";  \n        }  \n    }  \n    \n    WildGoose wildGoose = new WildGoose();  \n    test.test(wildGoose);  \n\n```\n在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。\n对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。\n\n## 注意事项\n在使用匿名内部类的过程中，我们需要注意如下几点：\n\n      1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n      2、匿名内部类中是不能定义构造函数的。\n      3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n      5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n\n## 使用的形参为何要为final\n参考文件：http://android.blog.51cto.com/268543/384844\n我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：**当所在的方法的形参需要被内部类里面使用时，该形参必须为final**。\n\n为什么必须要为final呢？\n首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：\n```java\n    public class OuterClass {  \n        public void display(final String name,String age){  \n            class InnerClass{  \n                void display(){  \n                    System.out.println(name);  \n                }  \n            }  \n        }  \n    }  \n```\n从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：\n\n```java\n    public class OuterClass$InnerClass {  \n        public InnerClass(String name,String age){  \n            this.InnerClass$name = name;  \n            this.InnerClass$age = age;  \n        }  \n        \n        \n        public void display(){  \n            System.out.println(this.InnerClass$name + \"----\" + this.InnerClass$age );  \n        }  \n    }  \n```\n所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。\n直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。\n\n<font color=\"#3366ff\">**简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的**</font>。\n\n## 匿名内部类初始化\n我们一般都是利用构造器来完成某个实例的``初始化``工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。\n\n```java\n    public class OutClass {  \n        public InnerClass getInnerClass(final int age,final String name){  \n            return new InnerClass() {  \n                int age_ ;  \n                String name_;  \n                //构造代码块完成初始化工作  \n                {  \n                    if(0 < age && age < 200){  \n                        age_ = age;  \n                        name_ = name;  \n                    }  \n                }  \n                public String getName() {  \n                    return name_;  \n                }  \n                \n                public int getAge() {  \n                    return age_;  \n                }  \n            };  \n        }  \n        \n        public static void main(String[] args) {  \n            OutClass out = new OutClass();  \n            \n            InnerClass inner_1 = out.getInnerClass(201, \"chenssy\");  \n            System.out.println(inner_1.getName());  \n            \n            InnerClass inner_2 = out.getInnerClass(23, \"chenssy\");  \n            System.out.println(inner_2.getName());  \n        }  \n    }  \n\n```","source":"_posts/java-toup10.md","raw":"---\ntitle:  java提高篇（九）-----详解匿名内部类\ndate: 2017-10-23 13:38:35\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/13170015\n\n在java提高篇-----详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。\n\n## 使用匿名内部类内部类\n匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：\n```java\n    new 父类构造器（参数列表）|实现接口（）    \n        {    \n        //匿名内部类的类体部分    \n        }  \n```\n<!-- more -->\n在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。\n```java\n    public abstract class Bird {  \n        private String name;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n        \n        public abstract int fly();  \n    }  \n    \n    public class Test {  \n        \n        public void test(Bird bird){  \n            System.out.println(bird.getName() + \"能够飞 \" + bird.fly() + \"米\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Test test = new Test();  \n            test.test(new Bird() {  \n                \n                public int fly() {  \n                    return 10000;  \n                }  \n                \n                public String getName() {  \n                    return \"大雁\";  \n                }  \n            });  \n        }  \n    }  \n    ------------------  \n    Output：  \n    大雁能够飞 10000米  \n```\n在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。\n由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。\n对于这段匿名内部类代码其实是可以拆分为如下形式：\n```java\n    public class WildGoose extends Bird{  \n        public int fly() {  \n            return 10000;  \n        }  \n        \n        public String getName() {  \n            return \"大雁\";  \n        }  \n    }  \n    \n    WildGoose wildGoose = new WildGoose();  \n    test.test(wildGoose);  \n\n```\n在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。\n对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。\n\n## 注意事项\n在使用匿名内部类的过程中，我们需要注意如下几点：\n\n      1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n      2、匿名内部类中是不能定义构造函数的。\n      3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n      5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n\n## 使用的形参为何要为final\n参考文件：http://android.blog.51cto.com/268543/384844\n我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：**当所在的方法的形参需要被内部类里面使用时，该形参必须为final**。\n\n为什么必须要为final呢？\n首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：\n```java\n    public class OuterClass {  \n        public void display(final String name,String age){  \n            class InnerClass{  \n                void display(){  \n                    System.out.println(name);  \n                }  \n            }  \n        }  \n    }  \n```\n从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：\n\n```java\n    public class OuterClass$InnerClass {  \n        public InnerClass(String name,String age){  \n            this.InnerClass$name = name;  \n            this.InnerClass$age = age;  \n        }  \n        \n        \n        public void display(){  \n            System.out.println(this.InnerClass$name + \"----\" + this.InnerClass$age );  \n        }  \n    }  \n```\n所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。\n直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。\n\n<font color=\"#3366ff\">**简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的**</font>。\n\n## 匿名内部类初始化\n我们一般都是利用构造器来完成某个实例的``初始化``工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。\n\n```java\n    public class OutClass {  \n        public InnerClass getInnerClass(final int age,final String name){  \n            return new InnerClass() {  \n                int age_ ;  \n                String name_;  \n                //构造代码块完成初始化工作  \n                {  \n                    if(0 < age && age < 200){  \n                        age_ = age;  \n                        name_ = name;  \n                    }  \n                }  \n                public String getName() {  \n                    return name_;  \n                }  \n                \n                public int getAge() {  \n                    return age_;  \n                }  \n            };  \n        }  \n        \n        public static void main(String[] args) {  \n            OutClass out = new OutClass();  \n            \n            InnerClass inner_1 = out.getInnerClass(201, \"chenssy\");  \n            System.out.println(inner_1.getName());  \n            \n            InnerClass inner_2 = out.getInnerClass(23, \"chenssy\");  \n            System.out.println(inner_2.getName());  \n        }  \n    }  \n\n```","slug":"java-toup10","published":1,"updated":"2017-10-23T14:37:14.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp440002v0v5jqg9blbg","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13170015\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13170015</a></p>\n</blockquote>\n<p>在java提高篇—–详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。</p>\n<h2 id=\"使用匿名内部类内部类\"><a href=\"#使用匿名内部类内部类\" class=\"headerlink\" title=\"使用匿名内部类内部类\"></a>使用匿名内部类内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> 父类构造器（参数列表）|实现接口（）    </div><div class=\"line\">    &#123;    </div><div class=\"line\">    <span class=\"comment\">//匿名内部类的类体部分    </span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Bird bird)</span></span>&#123;  </div><div class=\"line\">        System.out.println(bird.getName() + <span class=\"string\">\"能够飞 \"</span> + bird.fly() + <span class=\"string\">\"米\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        test.test(<span class=\"keyword\">new</span> Bird() &#123;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">------------------  </div><div class=\"line\">Output：  </div><div class=\"line\">大雁能够飞 <span class=\"number\">10000</span>米</div></pre></td></tr></table></figure></p>\n<p>在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。<br>由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。<br>对于这段匿名内部类代码其实是可以拆分为如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildGoose</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">WildGoose wildGoose = <span class=\"keyword\">new</span> WildGoose();  </div><div class=\"line\">test.test(wildGoose);</div></pre></td></tr></table></figure></p>\n<p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p>\n<pre><code>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n2、匿名内部类中是不能定义构造函数的。\n3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n</code></pre><h2 id=\"使用的形参为何要为final\"><a href=\"#使用的形参为何要为final\" class=\"headerlink\" title=\"使用的形参为何要为final\"></a>使用的形参为何要为final</h2><p>参考文件：<a href=\"http://android.blog.51cto.com/268543/384844\" target=\"_blank\" rel=\"external\">http://android.blog.51cto.com/268543/384844</a><br>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：<strong>当所在的方法的形参需要被内部类里面使用时，该形参必须为final</strong>。</p>\n<p>为什么必须要为final呢？<br>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">final</span> String name,String age)</span></span>&#123;  </div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                System.out.println(name);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span>$<span class=\"title\">InnerClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">(String name,String age)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$name = name;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.InnerClass$name + <span class=\"string\">\"----\"</span> + <span class=\"keyword\">this</span>.InnerClass$age );  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>\n<p><font color=\"#3366ff\"><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的</strong></font>。</p>\n<h2 id=\"匿名内部类初始化\"><a href=\"#匿名内部类初始化\" class=\"headerlink\" title=\"匿名内部类初始化\"></a>匿名内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的<code>初始化</code>工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age,<span class=\"keyword\">final</span> String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass() &#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> age_ ;  </div><div class=\"line\">            String name_;  </div><div class=\"line\">            <span class=\"comment\">//构造代码块完成初始化工作  </span></div><div class=\"line\">            &#123;  </div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt; age &amp;&amp; age &lt; <span class=\"number\">200</span>)&#123;  </div><div class=\"line\">                    age_ = age;  </div><div class=\"line\">                    name_ = name;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> name_;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> age_;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OutClass out = <span class=\"keyword\">new</span> OutClass();  </div><div class=\"line\">        </div><div class=\"line\">        InnerClass inner_1 = out.getInnerClass(<span class=\"number\">201</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner_1.getName());  </div><div class=\"line\">        </div><div class=\"line\">        InnerClass inner_2 = out.getInnerClass(<span class=\"number\">23</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner_2.getName());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13170015\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13170015</a></p>\n</blockquote>\n<p>在java提高篇—–详解内部类中对匿名内部类做了一个简单的介绍，但是内部类还存在很多其他细节问题，所以就衍生出这篇博客。在这篇博客中你可以了解到匿名内部类的使用、匿名内部类要注意的事项、如何初始化匿名内部类、匿名内部类使用的形参为何要为final。</p>\n<h2 id=\"使用匿名内部类内部类\"><a href=\"#使用匿名内部类内部类\" class=\"headerlink\" title=\"使用匿名内部类内部类\"></a>使用匿名内部类内部类</h2><p>匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> 父类构造器（参数列表）|实现接口（）    </div><div class=\"line\">    &#123;    </div><div class=\"line\">    <span class=\"comment\">//匿名内部类的类体部分    </span></div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>","more":"<p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Bird bird)</span></span>&#123;  </div><div class=\"line\">        System.out.println(bird.getName() + <span class=\"string\">\"能够飞 \"</span> + bird.fly() + <span class=\"string\">\"米\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Test test = <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        test.test(<span class=\"keyword\">new</span> Bird() &#123;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">------------------  </div><div class=\"line\">Output：  </div><div class=\"line\">大雁能够飞 <span class=\"number\">10000</span>米</div></pre></td></tr></table></figure></p>\n<p>在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。<br>由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。<br>对于这段匿名内部类代码其实是可以拆分为如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WildGoose</span> <span class=\"keyword\">extends</span> <span class=\"title\">Bird</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">10000</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"大雁\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">WildGoose wildGoose = <span class=\"keyword\">new</span> WildGoose();  </div><div class=\"line\">test.test(wildGoose);</div></pre></td></tr></table></figure></p>\n<p>在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。<br>对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p>\n<pre><code>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。\n2、匿名内部类中是不能定义构造函数的。\n3、匿名内部类中不能存在任何的静态成员变量和静态方法。\n4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。\n5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n</code></pre><h2 id=\"使用的形参为何要为final\"><a href=\"#使用的形参为何要为final\" class=\"headerlink\" title=\"使用的形参为何要为final\"></a>使用的形参为何要为final</h2><p>参考文件：<a href=\"http://android.blog.51cto.com/268543/384844\" target=\"_blank\" rel=\"external\">http://android.blog.51cto.com/268543/384844</a><br>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：<strong>当所在的方法的形参需要被内部类里面使用时，该形参必须为final</strong>。</p>\n<p>为什么必须要为final呢？<br>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">final</span> String name,String age)</span></span>&#123;  </div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                System.out.println(name);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>从上面代码中看好像name参数应该是被内部类直接调用？其实不然，在java编译之后实际的操作如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span>$<span class=\"title\">InnerClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">(String name,String age)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$name = name;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.InnerClass$age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.InnerClass$name + <span class=\"string\">\"----\"</span> + <span class=\"keyword\">this</span>.InnerClass$age );  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p>\n<p><font color=\"#3366ff\"><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的</strong></font>。</p>\n<h2 id=\"匿名内部类初始化\"><a href=\"#匿名内部类初始化\" class=\"headerlink\" title=\"匿名内部类初始化\"></a>匿名内部类初始化</h2><p>我们一般都是利用构造器来完成某个实例的<code>初始化</code>工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> age,<span class=\"keyword\">final</span> String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass() &#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> age_ ;  </div><div class=\"line\">            String name_;  </div><div class=\"line\">            <span class=\"comment\">//构造代码块完成初始化工作  </span></div><div class=\"line\">            &#123;  </div><div class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"number\">0</span> &lt; age &amp;&amp; age &lt; <span class=\"number\">200</span>)&#123;  </div><div class=\"line\">                    age_ = age;  </div><div class=\"line\">                    name_ = name;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> name_;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> age_;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OutClass out = <span class=\"keyword\">new</span> OutClass();  </div><div class=\"line\">        </div><div class=\"line\">        InnerClass inner_1 = out.getInnerClass(<span class=\"number\">201</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner_1.getName());  </div><div class=\"line\">        </div><div class=\"line\">        InnerClass inner_2 = out.getInnerClass(<span class=\"number\">23</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner_2.getName());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"java提高篇（十）-----强制类型转换","date":"2017-10-23T14:38:15.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14111307\n\n\n在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。\n在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。\n当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。\n<!-- more -->\n举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：\nFather father = new Son();\n在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！\nSon son = (Son)father;\n这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。\n前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？\n当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：\nFather father = new Father();\nSon son = (Son) father;\n这个系统会抛出ClassCastException异常信息。\n所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。\n所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。\n","source":"_posts/java-toup11.md","raw":"---\ntitle: java提高篇（十）-----强制类型转换\ndate: 2017-10-23 22:38:15\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14111307\n\n\n在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。\n在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。\n当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。\n<!-- more -->\n举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：\nFather father = new Son();\n在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！\nSon son = (Son)father;\n这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。\n前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？\n当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：\nFather father = new Father();\nSon son = (Son) father;\n这个系统会抛出ClassCastException异常信息。\n所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。\n所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。\n","slug":"java-toup11","published":1,"updated":"2017-10-23T14:41:30.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4c0006v0v5e05q9jej","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14111307\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14111307</a></p>\n</blockquote>\n<p>在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。<br>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。<br>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。<br><a id=\"more\"></a><br>举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：<br>Father father = new Son();<br>在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！<br>Son son = (Son)father;<br>这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。<br>前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？<br>当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：<br>Father father = new Father();<br>Son son = (Son) father;<br>这个系统会抛出ClassCastException异常信息。<br>所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。<br>所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14111307\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14111307</a></p>\n</blockquote>\n<p>在java中强制类型转换分为基本数据类型和引用数据类型两种，这里我们讨论的后者，也就是引用数据类型的强制类型转换。<br>在Java中由于继承和向上转型，子类可以非常自然地转换成父类，但是父类转换成子类则需要强制转换。因为子类拥有比父类更多的属性、更强的功能，所以父类转换为子类需要强制。那么，是不是只要是父类转换为子类就会成功呢？其实不然，他们之间的强制类型转换是有条件的。<br>当我们用一个类型的构造器构造出一个对象时，这个对象的类型就已经确定的，也就说它的本质是不会再发生变化了。在Java中我们可以通过继承、向上转型的关系使用父类类型来引用它，这个时候我们是使用功能较弱的类型引用功能较强的对象，这是可行的。但是将功能较弱的类型强制转功能较强的对象时，就不一定可以行了。<br>","more":"<br>举个例子来说明。比如系统中存在Father、Son两个对象。首先我们先构造一个Son对象，然后用一个Father类型变量引用它：<br>Father father = new Son();<br>在这里Son 对象实例被向上转型为father了，但是请注意这个Son对象实例在内存中的本质还是Son类型的，只不过它的能力临时被消弱了而已，如果我们想变强怎么办？将其对象类型还原！<br>Son son = (Son)father;<br>这条语句是可行的，其实father引用仍然是Father类型的，只不过是将它的能力加强了，将其加强后转交给son引用了，Son对象实例在son的变量的引用下，恢复真身，可以使用全部功能了。<br>前面提到父类强制转换成子类并不是总是成功，那么在什么情况下它会失效呢？<br>当引用类型的真实身份是父类本身的类型时，强制类型转换就会产生错误。例如：<br>Father father = new Father();<br>Son son = (Son) father;<br>这个系统会抛出ClassCastException异常信息。<br>所以编译器在编译时只会检查类型之间是否存在继承关系，有则通过；而在运行时就会检查它的真实类型，是则通过，否则抛出ClassCastException异常。<br>所以在继承中，子类可以自动转型为父类，但是父类强制转换为子类时只有当引用类型真正的身份为子类时才会强制转换成功，否则失败。</p>"},{"title":"java提高篇（十一）-----代码块","date":"2017-10-23T14:38:24.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14486833\n\n\n在编程过程中我们可能会遇到如下这种形式的程序：\n```java\npublic class Test {  \n    {  \n        ////  \n    }  \n}  \n```\n这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：\n<!-- more -->\n## 普通代码块\n普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。\n```java\npublic class Test {  \n    public void test(){  \n        System.out.println(\"普通代码块\");  \n    }  \n}  \n```\n## 静态代码块\n想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。\n```java\npublic class Test {  \n    static{  \n        System.out.println(\"静态代码块\");  \n    }  \n}  \n```\n## 同步代码块\n使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。\n## 构造代码块\n在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：\n```java\n    public class Test {  \n        /** \n        * 构造代码 \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    }  \n```\n上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：\n```java\n    public class Test {  \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    \n    }  \n    \n        运行结果  \n    \n    public static void main(String[] args) {  \n            new Test();  \n            System.out.println(\"----------------\");  \n            new Test(\"1\");  \n        }  \n    ------------  \n    Output:  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```\n从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：\n1、 初始化实例变量\n如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。\n2、 初始化实例环境\n一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。\n上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。\n五、 静态代码块、构造代码块、构造函数执行顺序\n从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。\n1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。\n2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。\n3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。\n通过上面的分析，他们三者的执行顺序应该为：静态代码块 > 构造代码块 > 构造函数。\n```java\n    public class Test {  \n        /**  \n        * 静态代码块  \n        */  \n        static{  \n            System.out.println(\"执行静态代码块...\");  \n        }  \n        \n        /**  \n        * 构造代码块  \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /**  \n        * 无参构造函数  \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /**  \n        * 有参构造函数  \n        * @param id  \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            System.out.println(\"----------------------\");  \n            new Test();  \n            System.out.println(\"----------------------\");  \n            new Test(\"1\");  \n        }  \n    }  \n    -----------  \n    Output:  \n    执行静态代码块...  \n    ----------------------  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```","source":"_posts/java-toup12.md","raw":"---\ntitle: java提高篇（十一）-----代码块\ndate: 2017-10-23 22:38:24\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14486833\n\n\n在编程过程中我们可能会遇到如下这种形式的程序：\n```java\npublic class Test {  \n    {  \n        ////  \n    }  \n}  \n```\n这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：\n<!-- more -->\n## 普通代码块\n普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。\n```java\npublic class Test {  \n    public void test(){  \n        System.out.println(\"普通代码块\");  \n    }  \n}  \n```\n## 静态代码块\n想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。\n```java\npublic class Test {  \n    static{  \n        System.out.println(\"静态代码块\");  \n    }  \n}  \n```\n## 同步代码块\n使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。\n## 构造代码块\n在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：\n```java\n    public class Test {  \n        /** \n        * 构造代码 \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    }  \n```\n上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：\n```java\n    public class Test {  \n        /** \n        * 无参构造函数 \n        */  \n        public Test(){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /** \n        * 有参构造函数 \n        * @param id  id \n        */  \n        public Test(String id){  \n            System.out.println(\"执行构造代码块...\");  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n    \n    }  \n    \n        运行结果  \n    \n    public static void main(String[] args) {  \n            new Test();  \n            System.out.println(\"----------------\");  \n            new Test(\"1\");  \n        }  \n    ------------  \n    Output:  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```\n从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：\n1、 初始化实例变量\n如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。\n2、 初始化实例环境\n一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。\n上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。\n五、 静态代码块、构造代码块、构造函数执行顺序\n从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。\n1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。\n2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。\n3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。\n通过上面的分析，他们三者的执行顺序应该为：静态代码块 > 构造代码块 > 构造函数。\n```java\n    public class Test {  \n        /**  \n        * 静态代码块  \n        */  \n        static{  \n            System.out.println(\"执行静态代码块...\");  \n        }  \n        \n        /**  \n        * 构造代码块  \n        */  \n        {  \n            System.out.println(\"执行构造代码块...\");  \n        }  \n        \n        /**  \n        * 无参构造函数  \n        */  \n        public Test(){  \n            System.out.println(\"执行无参构造函数...\");  \n        }  \n        \n        /**  \n        * 有参构造函数  \n        * @param id  \n        */  \n        public Test(String id){  \n            System.out.println(\"执行有参构造函数...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            System.out.println(\"----------------------\");  \n            new Test();  \n            System.out.println(\"----------------------\");  \n            new Test(\"1\");  \n        }  \n    }  \n    -----------  \n    Output:  \n    执行静态代码块...  \n    ----------------------  \n    执行构造代码块...  \n    执行无参构造函数...  \n    ----------------------  \n    执行构造代码块...  \n    执行有参构造函数...  \n```","slug":"java-toup12","published":1,"updated":"2017-10-23T14:44:40.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4f0008v0v5kkh326ot","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14486833\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14486833</a></p>\n</blockquote>\n<p>在编程过程中我们可能会遇到如下这种形式的程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        <span class=\"comment\">////  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：<br><a id=\"more\"></a></p>\n<h2 id=\"普通代码块\"><a href=\"#普通代码块\" class=\"headerlink\" title=\"普通代码块\"></a>普通代码块</h2><p>普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"普通代码块\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><p>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">static</span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p>\n<h2 id=\"构造代码块\"><a href=\"#构造代码块\" class=\"headerlink\" title=\"构造代码块\"></a>构造代码块</h2><p>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 构造代码 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">    运行结果  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行无参构造函数...  </div><div class=\"line\">----------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行有参构造函数...</div></pre></td></tr></table></figure></p>\n<p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：<br>1、 初始化实例变量<br>如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。<br>2、 初始化实例环境<br>一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。<br>上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。<br>五、 静态代码块、构造代码块、构造函数执行顺序<br>从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。<br>1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。<br>2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。<br>3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。<br>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 静态代码块  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">static</span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行静态代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 构造代码块  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数  </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-----------  </div><div class=\"line\">Output:  </div><div class=\"line\">执行静态代码块...  </div><div class=\"line\">----------------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行无参构造函数...  </div><div class=\"line\">----------------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行有参构造函数...</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14486833\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14486833</a></p>\n</blockquote>\n<p>在编程过程中我们可能会遇到如下这种形式的程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        <span class=\"comment\">////  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这种形式的程序段我们将其称之为代码块，所谓代码块就是用大括号({})将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在Java中代码块主要分为四种：<br>","more":"</p>\n<h2 id=\"普通代码块\"><a href=\"#普通代码块\" class=\"headerlink\" title=\"普通代码块\"></a>普通代码块</h2><p>普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用{}括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"普通代码块\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><p>想到静态我们就会想到static，静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">static</span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"同步代码块\"><a href=\"#同步代码块\" class=\"headerlink\" title=\"同步代码块\"></a>同步代码块</h2><p>使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。</p>\n<h2 id=\"构造代码块\"><a href=\"#构造代码块\" class=\"headerlink\" title=\"构造代码块\"></a>构造代码块</h2><p>在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？看如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 构造代码 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。上面代码等同于如下形式：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  id </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">    运行结果  </div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行无参构造函数...  </div><div class=\"line\">----------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行有参构造函数...</div></pre></td></tr></table></figure></p>\n<p>从上面的运行结果可以看出在new一个对象的时候总是先执行构造代码，再执行构造函数，但是有一点需要注意构造代码不是在构造函数之前运行的，它是依托构造函数执行的。正是由于构造代码块有这几个特性，所以它常用于如下场景：<br>1、 初始化实例变量<br>如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。<br>2、 初始化实例环境<br>一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。<br>上面两个常用场景都充分利用构造代码块的特性，能够很好的解决在实例化对象时构造函数比较难解决的问题，利用构造代码不仅可以减少代码量，同时也是程序的可读性增强了。特别是当一个对象的创建过程比较复杂，需要实现一些复杂逻辑，这个时候如果在构造函数中实现逻辑，这是不推荐的，因为我们提倡构造函数要尽可能的简单易懂，所以我们可以使用构造代码封装这些逻辑实现部分。<br>五、 静态代码块、构造代码块、构造函数执行顺序<br>从词面上我们就可以看出他们的区别。静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。<br>1、 静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。<br>2、 构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。<br>3、 构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。<br>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 静态代码块  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">static</span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行静态代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 构造代码块  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行构造代码块...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 无参构造函数  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行无参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**  </span></div><div class=\"line\"><span class=\"comment\">    * 有参构造函数  </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> id  </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String id)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"执行有参构造函数...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"----------------------\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">new</span> Test(<span class=\"string\">\"1\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-----------  </div><div class=\"line\">Output:  </div><div class=\"line\">执行静态代码块...  </div><div class=\"line\">----------------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行无参构造函数...  </div><div class=\"line\">----------------------  </div><div class=\"line\">执行构造代码块...  </div><div class=\"line\">执行有参构造函数...</div></pre></td></tr></table></figure></p>"},{"title":"java提高篇（十二）-----equals()","date":"2017-10-23T14:38:32.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/14963073\n\n equals()\n       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：\n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n    }  \n```\n我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：\n<!-- more -->\n```java\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String)anObject;  \n        int n = count;  \n        if (n == anotherString.count) {  \n        char v1[] = value;  \n        char v2[] = anotherString.value;  \n        int i = offset;  \n        int j = anotherString.offset;  \n        while (n-- != 0) {  \n            if (v1[i++] != v2[j++])  \n            return false;  \n        }  \n        return true;  \n        }  \n    }  \n    return false;  \n    }  \n```\n对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。\n在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：\nequals 方法在非空对象引用上实现相等关系：\n      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。\n       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。\n       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：\n      1) 对象域，使用equals方法 。 \n       2) 类型安全的枚举，使用equals或== 。\n       3) 可能为null的对象域 : 使用 == 和 equals 。\n       4) 数组域 : 使用 Arrays.equals 。\n       5) 除float和double外的原始数据类型 : 使用 == 。\n       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。\n       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。\n       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：\n```java\npublic boolean equals(Object obj) {  \n    return (obj instanceof Float)  \n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  \n    }  \n```\n原因嘛，里面提到了两点：\n```java\nHowever, there are two exceptions:  \nIf f1 and f2 both represent  \nFloat.NaN, then the equals method returns  \ntrue, even though Float.NaN==Float.NaN  \nhas the value false.  \nIf <code>f1 represents +0.0f while  \nf2 represents -0.0f, or vice  \nversa, the equal test has the value  \nfalse, even though 0.0f==-0.0f  \nhas the value true.  \n```\n在equals()中使用getClass进行类型判断\n我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。\n父类：Person\n```java\npublic class Person {  \n    protected String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n      \n    public Person(String name){  \n        this.name = name;  \n    }  \n      \n    public boolean equals(Object object){  \n        if(object instanceof Person){  \n            Person p = (Person) object;  \n            if(p.getName() == null || name == null){  \n                return false;  \n            }  \n            else{  \n                return name.equalsIgnoreCase(p.getName());  \n            }  \n        }  \n        return false;  \n    }  \n} \n```\n子类：Employee\n```java\npublic class Employee extends Person{  \n    private int id;  \n      \n    public int getId() {  \n        return id;  \n    }  \n  \n    public void setId(int id) {  \n        this.id = id;  \n    }  \n  \n    public Employee(String name,int id){  \n        super(name);  \n        this.id = id;  \n    }  \n      \n    /** \n     * 重写equals()方法 \n     */  \n    public boolean equals(Object object){  \n        if(object instanceof Employee){  \n            Employee e = (Employee) object;  \n            return super.equals(object) && e.getId() == id;  \n        }  \n        return false;  \n    }  \n}  \n```\n上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        Employee e1 = new Employee(\"chenssy\", 23);  \n        Employee e2 = new Employee(\"chenssy\", 24);  \n        Person p1 = new Person(\"chenssy\");  \n          \n        System.out.println(p1.equals(e1));  \n        System.out.println(p1.equals(e2));  \n        System.out.println(e1.equals(e2));  \n    }  \n}  \n```\n上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。\n对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。\n所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。","source":"_posts/java-toup13.md","raw":"---\ntitle:  java提高篇（十二）-----equals()\ndate: 2017-10-23 22:38:32\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/14963073\n\n equals()\n       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：\n```\npublic boolean equals(Object obj) {  \n    return (this == obj);  \n    }  \n```\n我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：\n<!-- more -->\n```java\npublic boolean equals(Object anObject) {  \n    if (this == anObject) {  \n        return true;  \n    }  \n    if (anObject instanceof String) {  \n        String anotherString = (String)anObject;  \n        int n = count;  \n        if (n == anotherString.count) {  \n        char v1[] = value;  \n        char v2[] = anotherString.value;  \n        int i = offset;  \n        int j = anotherString.offset;  \n        while (n-- != 0) {  \n            if (v1[i++] != v2[j++])  \n            return false;  \n        }  \n        return true;  \n        }  \n    }  \n    return false;  \n    }  \n```\n对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。\n在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：\nequals 方法在非空对象引用上实现相等关系：\n      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。\n      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。\n      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。\n      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。\n      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。\n       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。\n       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：\n      1) 对象域，使用equals方法 。 \n       2) 类型安全的枚举，使用equals或== 。\n       3) 可能为null的对象域 : 使用 == 和 equals 。\n       4) 数组域 : 使用 Arrays.equals 。\n       5) 除float和double外的原始数据类型 : 使用 == 。\n       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。\n       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。\n       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：\n```java\npublic boolean equals(Object obj) {  \n    return (obj instanceof Float)  \n           && (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  \n    }  \n```\n原因嘛，里面提到了两点：\n```java\nHowever, there are two exceptions:  \nIf f1 and f2 both represent  \nFloat.NaN, then the equals method returns  \ntrue, even though Float.NaN==Float.NaN  \nhas the value false.  \nIf <code>f1 represents +0.0f while  \nf2 represents -0.0f, or vice  \nversa, the equal test has the value  \nfalse, even though 0.0f==-0.0f  \nhas the value true.  \n```\n在equals()中使用getClass进行类型判断\n我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。\n父类：Person\n```java\npublic class Person {  \n    protected String name;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n      \n    public Person(String name){  \n        this.name = name;  \n    }  \n      \n    public boolean equals(Object object){  \n        if(object instanceof Person){  \n            Person p = (Person) object;  \n            if(p.getName() == null || name == null){  \n                return false;  \n            }  \n            else{  \n                return name.equalsIgnoreCase(p.getName());  \n            }  \n        }  \n        return false;  \n    }  \n} \n```\n子类：Employee\n```java\npublic class Employee extends Person{  \n    private int id;  \n      \n    public int getId() {  \n        return id;  \n    }  \n  \n    public void setId(int id) {  \n        this.id = id;  \n    }  \n  \n    public Employee(String name,int id){  \n        super(name);  \n        this.id = id;  \n    }  \n      \n    /** \n     * 重写equals()方法 \n     */  \n    public boolean equals(Object object){  \n        if(object instanceof Employee){  \n            Employee e = (Employee) object;  \n            return super.equals(object) && e.getId() == id;  \n        }  \n        return false;  \n    }  \n}  \n```\n上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：\n```java\npublic class Test {  \n    public static void main(String[] args) {  \n        Employee e1 = new Employee(\"chenssy\", 23);  \n        Employee e2 = new Employee(\"chenssy\", 24);  \n        Person p1 = new Person(\"chenssy\");  \n          \n        System.out.println(p1.equals(e1));  \n        System.out.println(p1.equals(e2));  \n        System.out.println(e1.equals(e2));  \n    }  \n}  \n```\n上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。\n对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。\n所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。","slug":"java-toup13","published":1,"updated":"2017-10-23T14:57:19.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4g000av0v56t4liyh6","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14963073\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14963073</a></p>\n</blockquote>\n<p> equals()<br>       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean equals(Object obj) &#123;  </div><div class=\"line\">    return (this == obj);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;  </div><div class=\"line\">        String anotherString = (String)anObject;  </div><div class=\"line\">        <span class=\"keyword\">int</span> n = count;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.count) &#123;  </div><div class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;  </div><div class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;  </div><div class=\"line\">        <span class=\"keyword\">int</span> i = offset;  </div><div class=\"line\">        <span class=\"keyword\">int</span> j = anotherString.offset;  </div><div class=\"line\">        <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (v1[i++] != v2[j++])  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。<br>在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：<br>equals 方法在非空对象引用上实现相等关系：<br>      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。<br>       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。<br>       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：<br>      1) 对象域，使用equals方法 。<br>       2) 类型安全的枚举，使用equals或== 。<br>       3) 可能为null的对象域 : 使用 == 和 equals 。<br>       4) 数组域 : 使用 Arrays.equals 。<br>       5) 除float和double外的原始数据类型 : 使用 == 。<br>       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。<br>       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。<br>       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)  </div><div class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>原因嘛，里面提到了两点：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">However, there are two exceptions:  </div><div class=\"line\">If f1 and f2 both represent  </div><div class=\"line\">Float.NaN, then the equals method returns  </div><div class=\"line\"><span class=\"keyword\">true</span>, even though Float.NaN==Float.NaN  </div><div class=\"line\">has the value <span class=\"keyword\">false</span>.  </div><div class=\"line\">If &lt;code&gt;f1 represents +<span class=\"number\">0.0f</span> <span class=\"keyword\">while</span>  </div><div class=\"line\">f2 represents -<span class=\"number\">0.0f</span>, or vice  </div><div class=\"line\">versa, the equal test has the value  </div><div class=\"line\"><span class=\"keyword\">false</span>, even though <span class=\"number\">0.0f</span>==-<span class=\"number\">0.0f</span>  </div><div class=\"line\">has the value <span class=\"keyword\">true</span>.</div></pre></td></tr></table></figure></p>\n<p>在equals()中使用getClass进行类型判断<br>我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。<br>父类：Person<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Person)&#123;  </div><div class=\"line\">            Person p = (Person) object;  </div><div class=\"line\">            <span class=\"keyword\">if</span>(p.getName() == <span class=\"keyword\">null</span> || name == <span class=\"keyword\">null</span>)&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> name.equalsIgnoreCase(p.getName());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>子类：Employee<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> id)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(name);  </div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">     * 重写equals()方法 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Employee)&#123;  </div><div class=\"line\">            Employee e = (Employee) object;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(object) &amp;&amp; e.getId() == id;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Employee e1 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">23</span>);  </div><div class=\"line\">        Employee e2 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">24</span>);  </div><div class=\"line\">        Person p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">          </div><div class=\"line\">        System.out.println(p1.equals(e1));  </div><div class=\"line\">        System.out.println(p1.equals(e2));  </div><div class=\"line\">        System.out.println(e1.equals(e2));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。<br>对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。<br>所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/14963073\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/14963073</a></p>\n</blockquote>\n<p> equals()<br>       超类Object中有这个equals()方法，该方法主要用于比较两个对象是否相等。该方法的源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean equals(Object obj) &#123;  </div><div class=\"line\">    return (this == obj);  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>我们知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，实际上JDk中，String、Math等封装类都对equals()方法进行了重写。下面是String的equals()方法：<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;  </div><div class=\"line\">        String anotherString = (String)anObject;  </div><div class=\"line\">        <span class=\"keyword\">int</span> n = count;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.count) &#123;  </div><div class=\"line\">        <span class=\"keyword\">char</span> v1[] = value;  </div><div class=\"line\">        <span class=\"keyword\">char</span> v2[] = anotherString.value;  </div><div class=\"line\">        <span class=\"keyword\">int</span> i = offset;  </div><div class=\"line\">        <span class=\"keyword\">int</span> j = anotherString.offset;  </div><div class=\"line\">        <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">if</span> (v1[i++] != v2[j++])  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>对于这个代码段:if (v1[i++] != v2[j++])return false;我们可以非常清晰的看到String的equals()方法是进行内容比较，而不是引用比较。至于其他的封装类都差不多。<br>在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：<br>equals 方法在非空对象引用上实现相等关系：<br>      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br>      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br>      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br>      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br>      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。<br>       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。<br>       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：<br>      1) 对象域，使用equals方法 。<br>       2) 类型安全的枚举，使用equals或== 。<br>       3) 可能为null的对象域 : 使用 == 和 equals 。<br>       4) 数组域 : 使用 Arrays.equals 。<br>       5) 除float和double外的原始数据类型 : 使用 == 。<br>       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。<br>       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。<br>       至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，下面的是Float类的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">return</span> (obj <span class=\"keyword\">instanceof</span> Float)  </div><div class=\"line\">           &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));  </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>原因嘛，里面提到了两点：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">However, there are two exceptions:  </div><div class=\"line\">If f1 and f2 both represent  </div><div class=\"line\">Float.NaN, then the equals method returns  </div><div class=\"line\"><span class=\"keyword\">true</span>, even though Float.NaN==Float.NaN  </div><div class=\"line\">has the value <span class=\"keyword\">false</span>.  </div><div class=\"line\">If &lt;code&gt;f1 represents +<span class=\"number\">0.0f</span> <span class=\"keyword\">while</span>  </div><div class=\"line\">f2 represents -<span class=\"number\">0.0f</span>, or vice  </div><div class=\"line\">versa, the equal test has the value  </div><div class=\"line\"><span class=\"keyword\">false</span>, even though <span class=\"number\">0.0f</span>==-<span class=\"number\">0.0f</span>  </div><div class=\"line\">has the value <span class=\"keyword\">true</span>.</div></pre></td></tr></table></figure></p>\n<p>在equals()中使用getClass进行类型判断<br>我们在覆写equals()方法时，一般都是推荐使用getClass来进行类型判断，不是使用instanceof。我们都清楚instanceof的作用是判断其左边对象是否为其右边类的实例，返回boolean类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。注意后面这句话：可以用来判断继承中的子类的实例是否为父类的实现，正是这句话在作怪。我们先看如下实例(摘自《高质量代码 改善java程序的151个建议》)。<br>父类：Person<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Person)&#123;  </div><div class=\"line\">            Person p = (Person) object;  </div><div class=\"line\">            <span class=\"keyword\">if</span>(p.getName() == <span class=\"keyword\">null</span> || name == <span class=\"keyword\">null</span>)&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> name.equalsIgnoreCase(p.getName());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>子类：Employee<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Employee</span><span class=\"params\">(String name,<span class=\"keyword\">int</span> id)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(name);  </div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">     * 重写equals()方法 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object object)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(object <span class=\"keyword\">instanceof</span> Employee)&#123;  </div><div class=\"line\">            Employee e = (Employee) object;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.equals(object) &amp;&amp; e.getId() == id;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面父类Person和子类Employee都重写了equals(),不过Employee比父类多了一个id属性。测试程序如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Employee e1 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">23</span>);  </div><div class=\"line\">        Employee e2 = <span class=\"keyword\">new</span> Employee(<span class=\"string\">\"chenssy\"</span>, <span class=\"number\">24</span>);  </div><div class=\"line\">        Person p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">          </div><div class=\"line\">        System.out.println(p1.equals(e1));  </div><div class=\"line\">        System.out.println(p1.equals(e2));  </div><div class=\"line\">        System.out.println(e1.equals(e2));  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面定义了两个员工和一个普通人，虽然他们同名，但是他们肯定不是同一人，所以按理来说输出结果应该全部都是false，但是事与愿违，结果是：true、true、false。<br>对于那e1!=e2我们非常容易理解，因为他们不仅需要比较name,还需要比较id。但是p1即等于e1也等于e2，这是非常奇怪的，因为e1、e2明明是两个不同的类，但为什么会出现这个情况？首先p1.equals(e1)，是调用p1的equals方法，该方法使用instanceof关键字来检查e1是否为Person类，这里我们再看看instanceof：判断其左边对象是否为其右边类的实例，也可以用来判断继承中的子类的实例是否为父类的实现。他们两者存在继承关系，肯定会返回true了，而两者name又相同，所以结果肯定是true。<br>所以出现上面的情况就是使用了关键字instanceof，这是非常容易“专空子”的。故在覆写equals时推荐使用getClass进行类型判断。而不是使用instanceof。</p>"},{"title":"java提高篇（十三）-----字符串","date":"2017-10-23T14:38:36.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/17591363\n\n可以证明，字符串操作是计算机程序设计中最常见的行为。\n\n## String\n首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。\n字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与\" \"、new String()的区别就象真空与空气一样。\n<!-- more -->\n在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。\n对于字符串的使用无非就是这几个方面：\n ### 字符串比较\n         equals() ------判断内容是否相同。\n         compareTo() ------判断字符串的大小关系。\n         compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n         == ------判断内容与地址是否相同。\n         equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n         reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n### 字符串查找\n         charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n         indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n         indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n         lastIndexOf(String str)------查找最后一次出现的位置。\n         lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n         starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n         starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n         endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n### 字符串截取\n        ------返回一个新的字符串，它是此字符串的一个子字符串。\n        public String subString(int beginIndex)\n        ------返回的字符串是从beginIndex开始到endIndex-1的串。\n        public String subString(int beginIndex，int endIndex)\n### 字符串替换\n         public String replace(char oldChar，char newChar)。\n         public String replace(CharSequence target，CharSequence replacement)\n         ------把原来的etarget子序列替换为replacement序列，返回新串。\n         public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n         注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n### 更多方法请参考API\n\n## StringBuffer\nStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。\n其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。\n同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。\n在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：\n\n      1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n      2、insert：该类方法主要是在StringBuffer对象中插入内容。\n      3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n\n## StringBuilder\nStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。\n上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。\n\n## 正确使用String、StringBuffer、StringBuilder\n我们先看如下表格：\n    ![](/uploads/string.png)\n\n这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。\n      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。\n      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：\n      String name = ”I ” + ”am ” + ”chenssy ” ;\n      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);\n      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。\n      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：\n         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。\n         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。\n         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。\n      更多有关于他们之间区别，请参考：http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\n## 字符串拼接方式\n对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：\n\n```java\n    public class StringTest {  \n        \n        /** \n        * @desc 使用+、concat()、append()方法循环10W次 \n        * @author chenssy \n        * @data 2013-11-16 \n        * @param args \n        * @return void \n        */  \n        public static void main(String[] args) {  \n            //+  \n            long start_01 = System.currentTimeMillis();  \n            String a = \"a\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                a += \"b\";  \n            }  \n            long end_01 = System.currentTimeMillis();  \n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");  \n            \n            //concat()  \n            long start_02 = System.currentTimeMillis();  \n            String c = \"c\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                c = c.concat(\"d\");  \n            }  \n            long end_02 = System.currentTimeMillis();  \n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");  \n            \n            //append  \n            long start_03 = System.currentTimeMillis();  \n            StringBuffer e = new StringBuffer(\"e\");  \n            for(int i = 0 ; i < 100000 ; i++){  \n                e.append(\"d\");  \n            }  \n            long end_03 = System.currentTimeMillis();  \n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");  \n        }  \n    }  \n    \n    ------------  \n    Output:  \n    +   所消耗的时间：19080毫米  \n    concat所消耗的时间：9089毫米  \n    append所消耗的时间：10毫米 \n```\n\n```java\n    public class StringTest {\n        \n        /**\n        * @desc 使用+、concat()、append()方法循环10W次\n        * @author chenssy\n        * @data 2013-11-16\n        * @param args\n        * @return void\n        */\n        public static void main(String[] args) {\n            //+\n            long start_01 = System.currentTimeMillis();\n            String a = \"a\";\n            for(int i = 0 ; i < 100000 ; i++){\n                a += \"b\";\n            }\n            long end_01 = System.currentTimeMillis();\n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");\n            \n            //concat()\n            long start_02 = System.currentTimeMillis();\n            String c = \"c\";\n            for(int i = 0 ; i < 100000 ; i++){\n                c = c.concat(\"d\");\n            }\n            long end_02 = System.currentTimeMillis();\n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");\n            \n            //append\n            long start_03 = System.currentTimeMillis();\n            StringBuffer e = new StringBuffer(\"e\");\n            for(int i = 0 ; i < 100000 ; i++){\n                e.append(\"d\");\n            }\n            long end_03 = System.currentTimeMillis();\n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");\n        }\n    }\n\n    ------------\n    Output:\n    +   所消耗的时间：19080毫米\n    concat所消耗的时间：9089毫米\n    append所消耗的时间：10毫米\n```\n从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:\n\n### +方式拼接字符串\n在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于\nstr = new StringBuilder(str).append(\"b\").toString();\n它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？\n### concat()方法拼接字符串\n```java\n    public String concat(String str) {  \n        int otherLen = str.length();  \n        if (otherLen == 0) {  \n            return this;  \n        }  \n        char buf[] = new char[count + otherLen];  \n        getChars(0, count, buf, 0);  \n        str.getChars(0, otherLen, buf, count);  \n        return new String(0, count + otherLen, buf);  \n    }  \n```\n 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。\n\n ### append()方法拼接字符串\n ```java\n    public synchronized StringBuffer append(String str) {\n        super.append(str);\n        return this;\n    }\n\n ```\nStringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：\n```java\n    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = \"null\";  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount > value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    } \n``` \n与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。","source":"_posts/java-toup14.md","raw":"---\ntitle: java提高篇（十三）-----字符串\ndate: 2017-10-23 22:38:36\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/17591363\n\n可以证明，字符串操作是计算机程序设计中最常见的行为。\n\n## String\n首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。\n字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与\" \"、new String()的区别就象真空与空气一样。\n<!-- more -->\n在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。\n对于字符串的使用无非就是这几个方面：\n ### 字符串比较\n         equals() ------判断内容是否相同。\n         compareTo() ------判断字符串的大小关系。\n         compareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n         == ------判断内容与地址是否相同。\n         equalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\n         reagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n### 字符串查找\n         charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\n         indexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\n         indexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\n         lastIndexOf(String str)------查找最后一次出现的位置。\n         lastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\n         starWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\n         starWith(String prefix)------测试此字符串是否以指定的前缀开始。\n         endsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n### 字符串截取\n        ------返回一个新的字符串，它是此字符串的一个子字符串。\n        public String subString(int beginIndex)\n        ------返回的字符串是从beginIndex开始到endIndex-1的串。\n        public String subString(int beginIndex，int endIndex)\n### 字符串替换\n         public String replace(char oldChar，char newChar)。\n         public String replace(CharSequence target，CharSequence replacement)\n         ------把原来的etarget子序列替换为replacement序列，返回新串。\n         public String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n         注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n### 更多方法请参考API\n\n## StringBuffer\nStringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。\n其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。\n同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。\n在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：\n\n      1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n      2、insert：该类方法主要是在StringBuffer对象中插入内容。\n      3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n\n## StringBuilder\nStringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。\n上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。\n\n## 正确使用String、StringBuffer、StringBuilder\n我们先看如下表格：\n    ![](/uploads/string.png)\n\n这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。\n      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。\n      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：\n      String name = ”I ” + ”am ” + ”chenssy ” ;\n      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);\n      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。\n      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：\n         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。\n         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。\n         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。\n      更多有关于他们之间区别，请参考：http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\n## 字符串拼接方式\n对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：\n\n```java\n    public class StringTest {  \n        \n        /** \n        * @desc 使用+、concat()、append()方法循环10W次 \n        * @author chenssy \n        * @data 2013-11-16 \n        * @param args \n        * @return void \n        */  \n        public static void main(String[] args) {  \n            //+  \n            long start_01 = System.currentTimeMillis();  \n            String a = \"a\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                a += \"b\";  \n            }  \n            long end_01 = System.currentTimeMillis();  \n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");  \n            \n            //concat()  \n            long start_02 = System.currentTimeMillis();  \n            String c = \"c\";  \n            for(int i = 0 ; i < 100000 ; i++){  \n                c = c.concat(\"d\");  \n            }  \n            long end_02 = System.currentTimeMillis();  \n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");  \n            \n            //append  \n            long start_03 = System.currentTimeMillis();  \n            StringBuffer e = new StringBuffer(\"e\");  \n            for(int i = 0 ; i < 100000 ; i++){  \n                e.append(\"d\");  \n            }  \n            long end_03 = System.currentTimeMillis();  \n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");  \n        }  \n    }  \n    \n    ------------  \n    Output:  \n    +   所消耗的时间：19080毫米  \n    concat所消耗的时间：9089毫米  \n    append所消耗的时间：10毫米 \n```\n\n```java\n    public class StringTest {\n        \n        /**\n        * @desc 使用+、concat()、append()方法循环10W次\n        * @author chenssy\n        * @data 2013-11-16\n        * @param args\n        * @return void\n        */\n        public static void main(String[] args) {\n            //+\n            long start_01 = System.currentTimeMillis();\n            String a = \"a\";\n            for(int i = 0 ; i < 100000 ; i++){\n                a += \"b\";\n            }\n            long end_01 = System.currentTimeMillis();\n            System.out.println(\"  +   所消耗的时间：\" + (end_01 - start_01) + \"毫米\");\n            \n            //concat()\n            long start_02 = System.currentTimeMillis();\n            String c = \"c\";\n            for(int i = 0 ; i < 100000 ; i++){\n                c = c.concat(\"d\");\n            }\n            long end_02 = System.currentTimeMillis();\n            System.out.println(\"concat所消耗的时间：\" + (end_02 - start_02) + \"毫米\");\n            \n            //append\n            long start_03 = System.currentTimeMillis();\n            StringBuffer e = new StringBuffer(\"e\");\n            for(int i = 0 ; i < 100000 ; i++){\n                e.append(\"d\");\n            }\n            long end_03 = System.currentTimeMillis();\n            System.out.println(\"append所消耗的时间：\" + (end_03 - start_03) + \"毫米\");\n        }\n    }\n\n    ------------\n    Output:\n    +   所消耗的时间：19080毫米\n    concat所消耗的时间：9089毫米\n    append所消耗的时间：10毫米\n```\n从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:\n\n### +方式拼接字符串\n在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于\nstr = new StringBuilder(str).append(\"b\").toString();\n它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？\n### concat()方法拼接字符串\n```java\n    public String concat(String str) {  \n        int otherLen = str.length();  \n        if (otherLen == 0) {  \n            return this;  \n        }  \n        char buf[] = new char[count + otherLen];  \n        getChars(0, count, buf, 0);  \n        str.getChars(0, otherLen, buf, count);  \n        return new String(0, count + otherLen, buf);  \n    }  \n```\n 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。\n\n ### append()方法拼接字符串\n ```java\n    public synchronized StringBuffer append(String str) {\n        super.append(str);\n        return this;\n    }\n\n ```\nStringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：\n```java\n    public AbstractStringBuilder append(String str) {  \n        if (str == null) str = \"null\";  \n            int len = str.length();  \n        if (len == 0) return this;  \n        int newCount = count + len;  \n        if (newCount > value.length)  \n            expandCapacity(newCount);  \n        str.getChars(0, len, value, count);  \n        count = newCount;  \n        return this;  \n    } \n``` \n与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。","slug":"java-toup14","published":1,"updated":"2017-10-23T15:09:39.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4n000ev0v5c3cdsqxe","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591363\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/17591363</a></p>\n</blockquote>\n<p>可以证明，字符串操作是计算机程序设计中最常见的行为。</p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。<br>字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。<br><a id=\"more\"></a><br>在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。<br>对于字符串的使用无非就是这几个方面：</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><pre><code>equals() ------判断内容是否相同。\ncompareTo() ------判断字符串的大小关系。\ncompareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n== ------判断内容与地址是否相同。\nequalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\nreagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n</code></pre><h3 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h3><pre><code>charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\nindexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\nindexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\nlastIndexOf(String str)------查找最后一次出现的位置。\nlastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\nstarWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\nstarWith(String prefix)------测试此字符串是否以指定的前缀开始。\nendsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n</code></pre><h3 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h3><pre><code>------返回一个新的字符串，它是此字符串的一个子字符串。\npublic String subString(int beginIndex)\n------返回的字符串是从beginIndex开始到endIndex-1的串。\npublic String subString(int beginIndex，int endIndex)\n</code></pre><h3 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h3><pre><code>public String replace(char oldChar，char newChar)。\npublic String replace(CharSequence target，CharSequence replacement)\n------把原来的etarget子序列替换为replacement序列，返回新串。\npublic String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n</code></pre><h3 id=\"更多方法请参考API\"><a href=\"#更多方法请参考API\" class=\"headerlink\" title=\"更多方法请参考API\"></a>更多方法请参考API</h3><h2 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h2><p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。<br>其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。<br>同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。<br>在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：</p>\n<pre><code>1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n2、insert：该类方法主要是在StringBuffer对象中插入内容。\n3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n</code></pre><h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。<br>上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。</p>\n<h2 id=\"正确使用String、StringBuffer、StringBuilder\"><a href=\"#正确使用String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"正确使用String、StringBuffer、StringBuilder\"></a>正确使用String、StringBuffer、StringBuilder</h2><p>我们先看如下表格：<br>    <img src=\"/uploads/string.png\" alt=\"\"></p>\n<p>这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。<br>      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。<br>      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：<br>      String name = ”I ” + ”am ” + ”chenssy ” ;<br>      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);<br>      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。<br>      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：<br>         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。<br>         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。<br>         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。<br>      更多有关于他们之间区别，请参考：<a href=\"http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。</a></p>\n<h2 id=\"字符串拼接方式\"><a href=\"#字符串拼接方式\" class=\"headerlink\" title=\"字符串拼接方式\"></a>字符串拼接方式</h2><p>对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//+  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();  </div><div class=\"line\">        String a = <span class=\"string\">\"a\"</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            a += <span class=\"string\">\"b\"</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//concat()  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();  </div><div class=\"line\">        String c = <span class=\"string\">\"c\"</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//append  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();  </div><div class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米  </div><div class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米  </div><div class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void</span></div><div class=\"line\"><span class=\"comment\">    */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//+</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();</div><div class=\"line\">        String a = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            a += <span class=\"string\">\"b\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//concat()</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();</div><div class=\"line\">        String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//append</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();</div><div class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">------------</div><div class=\"line\">Output:</div><div class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米</div><div class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米</div><div class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</div></pre></td></tr></table></figure>\n<p>从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:</p>\n<h3 id=\"方式拼接字符串\"><a href=\"#方式拼接字符串\" class=\"headerlink\" title=\"+方式拼接字符串\"></a>+方式拼接字符串</h3><p>在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<br>str = new StringBuilder(str).append(“b”).toString();<br>它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？</p>\n<h3 id=\"concat-方法拼接字符串\"><a href=\"#concat-方法拼接字符串\" class=\"headerlink\" title=\"concat()方法拼接字符串\"></a>concat()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> otherLen = str.length();  </div><div class=\"line\">    <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">char</span> buf[] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[count + otherLen];  </div><div class=\"line\">    getChars(<span class=\"number\">0</span>, count, buf, <span class=\"number\">0</span>);  </div><div class=\"line\">    str.getChars(<span class=\"number\">0</span>, otherLen, buf, count);  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(<span class=\"number\">0</span>, count + otherLen, buf);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。</p>\n<h3 id=\"append-方法拼接字符串\"><a href=\"#append-方法拼接字符串\" class=\"headerlink\" title=\"append()方法拼接字符串\"></a>append()方法拼接字符串</h3> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.append(str);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：</p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>{  \n    <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>) str = <span class=\"string\">\"null\"</span>;  \n        <span class=\"keyword\">int</span> len = str.length();  \n    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  \n    <span class=\"keyword\">int</span> newCount = count + len;  \n    <span class=\"keyword\">if</span> (newCount &gt; value.length)  \n        expandCapacity(newCount);  \n    str.getChars(<span class=\"number\">0</span>, len, value, count);  \n    count = newCount;  \n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  \n}\n</code></pre>\n<p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/17591363\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/17591363</a></p>\n</blockquote>\n<p>可以证明，字符串操作是计算机程序设计中最常见的行为。</p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>首先我们要明确，String并不是基本数据类型，而是一个对象，并且是不可变的对象。查看源码就会发现String类为final型的（当然也不可被继承），而且通过查看JDK文档会发现几乎每一个修改String对象的操作，实际上都是创建了一个全新的String对象。<br>字符串为对象，那么在初始化之前，它的值为null，到这里就有必要提下””、null、new String()三者的区别。null 表示string还没有new ，也就是说对象的引用还没有创建，也没有分配内存空间给他，而””、new String()则说明了已经new了，只不过内部为空，但是它创建了对象的引用，是需要分配内存空间的。打个比方：一个空玻璃杯，你不能说它里面什么都没有，因为里面有空气，当然也可以把它弄成真空，null与” “、new String()的区别就象真空与空气一样。<br>","more":"<br>在字符串中存在一个非常特殊的地方，那就是字符串池。每当我们创建一个字符串对象时，首先就会检查字符串池中是否存在面值相等的字符串，如果有，则不再创建，直接放回字符串池中对该对象的引用，若没有则创建然后放入到字符串池中并且返回新建对象的引用。这个机制是非常有用的，因为可以提高效率，减少了内存空间的占用。所以在使用字符串的过程中，推荐使用直接赋值（即String s=”aa”），除非有必要才会新建一个String对象（即String s = new String(”aa”)）。<br>对于字符串的使用无非就是这几个方面：</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><pre><code>equals() ------判断内容是否相同。\ncompareTo() ------判断字符串的大小关系。\ncompareToIgnoreCase(String int) ------在比较时忽略字母大小写。\n== ------判断内容与地址是否相同。\nequalsIgnoreCase() ------忽略大小写的情况下判断内容是否相同。\nreagionMatches() ------对字符串中的部分内容是否相同进行比较（详情请参考API）。\n</code></pre><h3 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a>字符串查找</h3><pre><code>charAt(int index) ------返回指定索引index位置上的字符，索引范围从0开始。\nindexOf(String str)------从字符串开始检索str，并返回第一次出现的位置，未出现返回-1。\nindexOf(String str，int fromIndex);------从字符串的第fromIndex个字符开始检索str。\nlastIndexOf(String str)------查找最后一次出现的位置。\nlastIndexOf(String str，int fromIndex)----从字符串的第fromIndex个字符查找最后一次出现的位置。\nstarWith(String prefix，int toffset)-----测试此字符串从指定索引开始的子字符串是否以指定前缀开始。\nstarWith(String prefix)------测试此字符串是否以指定的前缀开始。\nendsWith(String suffix)------测试此字符串是否以指定的后缀结束。\n</code></pre><h3 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a>字符串截取</h3><pre><code>------返回一个新的字符串，它是此字符串的一个子字符串。\npublic String subString(int beginIndex)\n------返回的字符串是从beginIndex开始到endIndex-1的串。\npublic String subString(int beginIndex，int endIndex)\n</code></pre><h3 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a>字符串替换</h3><pre><code>public String replace(char oldChar，char newChar)。\npublic String replace(CharSequence target，CharSequence replacement)\n------把原来的etarget子序列替换为replacement序列，返回新串。\npublic String replaceAll(String regex，String replacement)------用正则表达式实现对字符串的匹配。\n注意replaceAll第一个参数为正则表达式，鄙人曾经深受其害。\n</code></pre><h3 id=\"更多方法请参考API\"><a href=\"#更多方法请参考API\" class=\"headerlink\" title=\"更多方法请参考API\"></a>更多方法请参考API</h3><h2 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h2><p>StringBuffer和String一样都是用来存储字符串的，只不过由于他们内部的实现方式不同，导致他们所使用的范围不同，对于StringBuffer而言，他在处理字符串时，若是对其进行修改操作，它并不会产生一个新的字符串对象，所以说在内存使用方面它是优于String的。<br>其实在使用方法，StringBuffer的许多方法和String类都差不多，所表示的功能几乎一模一样，只不过在修改时StringBuffer都是修改自身，而String类则是产生一个新的对象，这是他们之间最大的区别。<br>同时StringBuffer是不能使用=进行初始化的，它必须要产生StringBuffer实例，也就是说你必须通过它的构造方法进行初始化。<br>在StringBuffer的使用方面，它更加侧重于对字符串的变化，例如追加、修改、删除，相对应的方法：</p>\n<pre><code>1、append()：追加指定内容到当前StringBuffer对象的末尾，类似于字符串的连接，这里StringBuffer对象的内容会发生改变。\n2、insert：该类方法主要是在StringBuffer对象中插入内容。\n3、delete：该类方法主要用于移除StringBuffer对象中的内容。\n</code></pre><h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>StringBuilder也是一个可变的字符串对象，他与StringBuffer不同之处就在于它是线程不安全的，基于这点，它的速度一般都比StringBuffer快。与StringBuffer一样，StringBuider的主要操作也是append与insert方法。这两个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符添加或插入到字符串生成器中。<br>上面只是简单的介绍了String、StringBuffer、StringBuilder，其实对于这三者我们应该更加侧重于他们只见到的区别，只有理清楚他们之间的区别才能够更好的使用他们。</p>\n<h2 id=\"正确使用String、StringBuffer、StringBuilder\"><a href=\"#正确使用String、StringBuffer、StringBuilder\" class=\"headerlink\" title=\"正确使用String、StringBuffer、StringBuilder\"></a>正确使用String、StringBuffer、StringBuilder</h2><p>我们先看如下表格：<br>    <img src=\"/uploads/string.png\" alt=\"\"></p>\n<p>这里对于String是否为线程安全，鄙人也不是很清楚，原因：String不可变，所有的操作都是不可能改变其值的，是否存在线程安全一说还真不好说？但是如果硬要说线程是否安全的话，因为内容不可变，永远都是安全的。<br>      在使用方面由于String每次修改都需要产生一个新的对象，所以对于经常需要改变内容的字符串最好选择StringBuffer或者StringBuilder.而对于StringBuffer，每次操作都是对StringBuffer对象本身，它不会生成新的对象，所以StringBuffer特别适用于字符串内容经常改变的情况下。<br>      但是并不是所有的String字符串操作都会比StringBuffer慢，在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：<br>      String name = ”I ” + ”am ” + ”chenssy ” ;<br>      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);<br>      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。<br>      对于这三者使用的场景做如下概括（参考：《编写搞质量代码：改善java程序的151个建议》）：<br>         1、String：在字符串不经常变化的场景中可以使用String类，如：常量的声明、少量的变量运算等。<br>         2、StringBuffer：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。<br>         3、StringBuilder：在频繁进行字符串的运算（拼接、替换、删除等），并且运行在多线程的环境中，则可以考虑使用StringBuffer，如SQL语句的拼装、JSON封装等（貌似这两个我也是使用|StringBuffer）。<br>      更多有关于他们之间区别，请参考：<a href=\"http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/zuoxiaolong/p/lang1.html。鄙人就不画蛇添足了。</a></p>\n<h2 id=\"字符串拼接方式\"><a href=\"#字符串拼接方式\" class=\"headerlink\" title=\"字符串拼接方式\"></a>字符串拼接方式</h2><p>对于字符串而言我们经常是要对其进行拼装处理的，在java中提高了三种拼装的方法：+、concat()以及append()方法。这三者之间存在什么区别呢？先看如下示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//+  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();  </div><div class=\"line\">        String a = <span class=\"string\">\"a\"</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            a += <span class=\"string\">\"b\"</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//concat()  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();  </div><div class=\"line\">        String c = <span class=\"string\">\"c\"</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//append  </span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();  </div><div class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);  </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;  </div><div class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米  </div><div class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米  </div><div class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringTest</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 使用+、concat()、append()方法循环10W次</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-11-16</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> args</span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void</span></div><div class=\"line\"><span class=\"comment\">    */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//+</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_01 = System.currentTimeMillis();</div><div class=\"line\">        String a = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            a += <span class=\"string\">\"b\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_01 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"  +   所消耗的时间：\"</span> + (end_01 - start_01) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//concat()</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_02 = System.currentTimeMillis();</div><div class=\"line\">        String c = <span class=\"string\">\"c\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            c = c.concat(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_02 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"concat所消耗的时间：\"</span> + (end_02 - start_02) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//append</span></div><div class=\"line\">        <span class=\"keyword\">long</span> start_03 = System.currentTimeMillis();</div><div class=\"line\">        StringBuffer e = <span class=\"keyword\">new</span> StringBuffer(<span class=\"string\">\"e\"</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">100000</span> ; i++)&#123;</div><div class=\"line\">            e.append(<span class=\"string\">\"d\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">long</span> end_03 = System.currentTimeMillis();</div><div class=\"line\">        System.out.println(<span class=\"string\">\"append所消耗的时间：\"</span> + (end_03 - start_03) + <span class=\"string\">\"毫米\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">------------</div><div class=\"line\">Output:</div><div class=\"line\">+   所消耗的时间：<span class=\"number\">19080</span>毫米</div><div class=\"line\">concat所消耗的时间：<span class=\"number\">9089</span>毫米</div><div class=\"line\">append所消耗的时间：<span class=\"number\">10</span>毫米</div></pre></td></tr></table></figure>\n<p>从上面的运行结果可以看出，append()速度最快，concat()次之，+最慢。原因请看下面分解:</p>\n<h3 id=\"方式拼接字符串\"><a href=\"#方式拼接字符串\" class=\"headerlink\" title=\"+方式拼接字符串\"></a>+方式拼接字符串</h3><p>在前面我们知道编译器对+进行了优化，它是使用StringBuilder的append()方法来进行处理的，我们知道StringBuilder的速度比StringBuffer的速度更加快，但是为何运行速度还是那样呢？主要是因为编译器使用append()方法追加后要同toString()转换成String字符串，也就说 str +=”b”等同于<br>str = new StringBuilder(str).append(“b”).toString();<br>它变慢的关键原因就在于new StringBuilder()和toString()，这里可是创建了10W个StringBuilder对象，而且每次还需要将其转换成String，速度能不慢么？</p>\n<h3 id=\"concat-方法拼接字符串\"><a href=\"#concat-方法拼接字符串\" class=\"headerlink\" title=\"concat()方法拼接字符串\"></a>concat()方法拼接字符串</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">concat</span><span class=\"params\">(String str)</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">int</span> otherLen = str.length();  </div><div class=\"line\">    <span class=\"keyword\">if</span> (otherLen == <span class=\"number\">0</span>) &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">char</span> buf[] = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[count + otherLen];  </div><div class=\"line\">    getChars(<span class=\"number\">0</span>, count, buf, <span class=\"number\">0</span>);  </div><div class=\"line\">    str.getChars(<span class=\"number\">0</span>, otherLen, buf, count);  </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(<span class=\"number\">0</span>, count + otherLen, buf);  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这是concat()的源码，它看上去就是一个数字拷贝形式，我们知道数组的处理速度是非常快的，但是由于该方法最后是这样的：return new String(0, count + otherLen, buf);这同样也创建了10W个字符串对象，这是它变慢的根本原因。</p>\n<h3 id=\"append-方法拼接字符串\"><a href=\"#append-方法拼接字符串\" class=\"headerlink\" title=\"append()方法拼接字符串\"></a>append()方法拼接字符串</h3> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> StringBuffer <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.append(str);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>StringBuffer的append()方法是直接使用父类AbstractStringBuilder的append()方法，该方法的源码如下：</p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> AbstractStringBuilder <span class=\"title\">append</span><span class=\"params\">(String str)</span> </span>{  \n    <span class=\"keyword\">if</span> (str == <span class=\"keyword\">null</span>) str = <span class=\"string\">\"null\"</span>;  \n        <span class=\"keyword\">int</span> len = str.length();  \n    <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  \n    <span class=\"keyword\">int</span> newCount = count + len;  \n    <span class=\"keyword\">if</span> (newCount &gt; value.length)  \n        expandCapacity(newCount);  \n    str.getChars(<span class=\"number\">0</span>, len, value, count);  \n    count = newCount;  \n    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  \n}\n</code></pre>\n<p>与concat()方法相似，它也是进行字符数组处理的，加长，然后拷贝，但是请注意它最后是返回并没有返回一个新串，而是返回本身，也就说这这个10W次的循环过程中，它并没有产生新的字符串对象。</p>"},{"title":"java-toup15","date":"2017-10-23T14:38:39.000Z","_content":"","source":"_posts/java-toup15.md","raw":"---\ntitle: java-toup15\ndate: 2017-10-23 22:38:39\ntags:\n---\n","slug":"java-toup15","published":1,"updated":"2017-10-23T14:38:39.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4r000fv0v5yvq3kzmn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java-toup16","date":"2017-10-23T14:38:43.000Z","_content":"","source":"_posts/java-toup16.md","raw":"---\ntitle: java-toup16\ndate: 2017-10-23 22:38:43\ntags:\n---\n","slug":"java-toup16","published":1,"updated":"2017-10-23T14:38:43.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4v000kv0v5cs83998x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java-toup17","date":"2017-10-23T14:38:47.000Z","_content":"","source":"_posts/java-toup17.md","raw":"---\ntitle: java-toup17\ndate: 2017-10-23 22:38:47\ntags:\n---\n","slug":"java-toup17","published":1,"updated":"2017-10-23T14:38:47.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp4z000nv0v5eg5yx3ko","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java-toup18","date":"2017-10-23T14:38:52.000Z","_content":"","source":"_posts/java-toup18.md","raw":"---\ntitle: java-toup18\ndate: 2017-10-23 22:38:52\ntags:\n---\n","slug":"java-toup18","published":1,"updated":"2017-10-23T14:38:52.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp53000rv0v55i956gin","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java-toup19","date":"2017-10-23T14:38:55.000Z","_content":"","source":"_posts/java-toup19.md","raw":"---\ntitle: java-toup19\ndate: 2017-10-23 22:38:55\ntags:\n---\n","slug":"java-toup19","published":1,"updated":"2017-10-23T14:38:55.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp56000uv0v53ul83vg2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java提高篇(一)-----理解java的三大特性之封装","date":"2017-10-20T16:06:18.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12757911](http://blog.csdn.net/chenssy/article/details/12757911)\n\n从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！\n闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始---封装!!!!!!\n\n<!-- more -->\n\n## 三大特性之---封装\n\n封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\n使用封装有三大好处：\n1、良好的封装能够减少耦合。\n2、类内部的结构可以自由修改。\n3、可以对成员进行更精确的控制。\n4、隐藏信息，实现细节。\n首先我们先来看两个类：Husband.java、Wife.java\n\n```java\n    public class Husband {  \n      \n    /* \n     * 对属性的封装 \n     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n     */  \n    private String name ;  \n    private String sex ;  \n    private int age ;  \n    private Wife wife;  \n      \n    /* \n     * setter()、getter()是该对象对外开发的接口 \n     */  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public int getAge() {  \n        return age;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setWife(Wife wife) {  \n        this.wife = wife;  \n    }  \n}  \n\n```\n\n``` java\n    public class Wife {  \n    private String name;  \n    private int age;  \n    private String sex;  \n    private Husband husband;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setHusband(Husband husband) {  \n        this.husband = husband;  \n    }  \n  \n    public Husband getHusband() {  \n        return husband;  \n    }  \n      \n}  \n```\n\n从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。\n所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。\n通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：\n\n```java\n    public class Husband {  \n        public String name ;  \n        public String sex ;  \n        public int age ;  \n        public Wife wife;  \n    }  \n```\n\n我们应该这样来使用它：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 30;  \n    husband.name = \"张三\";  \n    husband.sex = \"男\";    //貌似有点儿多余  \n```\n\n但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。\n\n```java\n    public class Husband {  \n      \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private String age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n        \n        public String getAge() {  \n            return age;  \n        }  \n        \n        public void setAge(int age) {  \n            //转换即可  \n            this.age = String.valueOf(age);  \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n    }\n```\n\n其他的地方依然那样引用(husband.setAge(22))保持不变。\n到了这里我们确实可以看出，**封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。**\n我们在看这个好处：**可以对成员变量进行更精确的控制**。\n\n还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 300;  \n```\n\n也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！\n但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：\n\n```java\n    public class Husband {  \n        \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private int age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            if(age > 120){  \n                //提示錯誤信息  \n                System.out.println(\"ERROR：error age input....\");    \n            }else{  \n                this.age = age;  \n            }  \n            \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n        \n    }  \n```\n\n上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。\n\n```java\n    public String getSexName() {  \n        if(\"0\".equals(sex)){  \n            sexName = \"女\";  \n        }  \n        else if(\"1\".equals(sex)){  \n            sexName = \"男\";  \n        }  \n        else{  \n            sexName = \"人妖???\";  \n        }  \n        return sexName;  \n    }  \n```\n 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。\n\n ```java\n    public String getCzHTML(){  \n        if(\"1\".equals(zt)){  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='qy(\"+id+\")'>启用</a>\";  \n        }  \n        else{  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='jy(\"+id+\")'>禁用</a>\";  \n        }  \n        return czHTML;  \n    } \n ```","source":"_posts/java-toup2.md","raw":"---\ntitle: java提高篇(一)-----理解java的三大特性之封装\ndate: 2017-10-21 00:06:18\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12757911](http://blog.csdn.net/chenssy/article/details/12757911)\n\n从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！\n闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始---封装!!!!!!\n\n<!-- more -->\n\n## 三大特性之---封装\n\n封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\n使用封装有三大好处：\n1、良好的封装能够减少耦合。\n2、类内部的结构可以自由修改。\n3、可以对成员进行更精确的控制。\n4、隐藏信息，实现细节。\n首先我们先来看两个类：Husband.java、Wife.java\n\n```java\n    public class Husband {  \n      \n    /* \n     * 对属性的封装 \n     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n     */  \n    private String name ;  \n    private String sex ;  \n    private int age ;  \n    private Wife wife;  \n      \n    /* \n     * setter()、getter()是该对象对外开发的接口 \n     */  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public int getAge() {  \n        return age;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setWife(Wife wife) {  \n        this.wife = wife;  \n    }  \n}  \n\n```\n\n``` java\n    public class Wife {  \n    private String name;  \n    private int age;  \n    private String sex;  \n    private Husband husband;  \n  \n    public String getName() {  \n        return name;  \n    }  \n  \n    public void setName(String name) {  \n        this.name = name;  \n    }  \n  \n    public String getSex() {  \n        return sex;  \n    }  \n  \n    public void setSex(String sex) {  \n        this.sex = sex;  \n    }  \n  \n    public void setAge(int age) {  \n        this.age = age;  \n    }  \n  \n    public void setHusband(Husband husband) {  \n        this.husband = husband;  \n    }  \n  \n    public Husband getHusband() {  \n        return husband;  \n    }  \n      \n}  \n```\n\n从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。\n所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。\n通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：\n\n```java\n    public class Husband {  \n        public String name ;  \n        public String sex ;  \n        public int age ;  \n        public Wife wife;  \n    }  \n```\n\n我们应该这样来使用它：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 30;  \n    husband.name = \"张三\";  \n    husband.sex = \"男\";    //貌似有点儿多余  \n```\n\n但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。\n\n```java\n    public class Husband {  \n      \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private String age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n        \n        public String getAge() {  \n            return age;  \n        }  \n        \n        public void setAge(int age) {  \n            //转换即可  \n            this.age = String.valueOf(age);  \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n    }\n```\n\n其他的地方依然那样引用(husband.setAge(22))保持不变。\n到了这里我们确实可以看出，**封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。**\n我们在看这个好处：**可以对成员变量进行更精确的控制**。\n\n还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：\n\n```java\n    Husband husband = new Husband();  \n    husband.age = 300;  \n```\n\n也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！\n但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：\n\n```java\n    public class Husband {  \n        \n        /* \n        * 对属性的封装 \n        * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 \n        */  \n        private String name ;  \n        private String sex ;  \n        private int age ;    /* 改成 String类型的*/  \n        private Wife wife;  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            if(age > 120){  \n                //提示錯誤信息  \n                System.out.println(\"ERROR：error age input....\");    \n            }else{  \n                this.age = age;  \n            }  \n            \n        }  \n        \n        /** 省略其他属性的setter、getter **/  \n        \n    }  \n```\n\n上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。\n\n```java\n    public String getSexName() {  \n        if(\"0\".equals(sex)){  \n            sexName = \"女\";  \n        }  \n        else if(\"1\".equals(sex)){  \n            sexName = \"男\";  \n        }  \n        else{  \n            sexName = \"人妖???\";  \n        }  \n        return sexName;  \n    }  \n```\n 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。\n\n ```java\n    public String getCzHTML(){  \n        if(\"1\".equals(zt)){  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='qy(\"+id+\")'>启用</a>\";  \n        }  \n        else{  \n            czHTML = \"<a href='javascript:void(0)'\"\n                + \" onclick='jy(\"+id+\")'>禁用</a>\";  \n        }  \n        return czHTML;  \n    } \n ```","slug":"java-toup2","published":1,"updated":"2017-10-23T13:23:34.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp59000xv0v5a7u9d764","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12757911\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12757911</a></p>\n</blockquote>\n<p>从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！<br>闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—封装!!!!!!</p>\n<a id=\"more\"></a>\n<h2 id=\"三大特性之—封装\"><a href=\"#三大特性之—封装\" class=\"headerlink\" title=\"三大特性之—封装\"></a>三大特性之—封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。<br>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。<br>使用封装有三大好处：<br>1、良好的封装能够减少耦合。<br>2、类内部的结构可以自由修改。<br>3、可以对成员进行更精确的控制。<br>4、隐藏信息，实现细节。<br>首先我们先来看两个类：Husband.java、Wife.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">     * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">     * setter()、getter()是该对象对外开发的接口 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWife</span><span class=\"params\">(Wife wife)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = wife;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wife</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Husband husband;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHusband</span><span class=\"params\">(Husband husband)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = husband;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Husband <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> husband;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。<br>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。<br>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">public</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> Wife wife;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们应该这样来使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">husband.age = <span class=\"number\">30</span>;  </div><div class=\"line\">husband.name = <span class=\"string\">\"张三\"</span>;  </div><div class=\"line\">husband.sex = <span class=\"string\">\"男\"</span>;    <span class=\"comment\">//貌似有点儿多余</span></div></pre></td></tr></table></figure>\n<p>但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//转换即可  </span></div><div class=\"line\">        <span class=\"keyword\">this</span>.age = String.valueOf(age);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其他的地方依然那样引用(husband.setAge(22))保持不变。<br>到了这里我们确实可以看出，<strong>封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</strong><br>我们在看这个好处：<strong>可以对成员变量进行更精确的控制</strong>。</p>\n<p>还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">husband.age = <span class=\"number\">300</span>;</div></pre></td></tr></table></figure>\n<p>也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！<br>但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(age &gt; <span class=\"number\">120</span>)&#123;  </div><div class=\"line\">            <span class=\"comment\">//提示錯誤信息  </span></div><div class=\"line\">            System.out.println(<span class=\"string\">\"ERROR：error age input....\"</span>);    </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"0\"</span>.equals(sex))&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"女\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(sex))&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"男\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"人妖???\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> sexName;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCzHTML</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(zt))&#123;  </div><div class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></div><div class=\"line\">            + <span class=\"string\">\" onclick='qy(\"</span>+id+<span class=\"string\">\")'&gt;启用&lt;/a&gt;\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></div><div class=\"line\">            + <span class=\"string\">\" onclick='jy(\"</span>+id+<span class=\"string\">\")'&gt;禁用&lt;/a&gt;\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> czHTML;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12757911\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12757911</a></p>\n</blockquote>\n<p>从大二接触java开始，到现在也差不多三个年头了。从最基础的HTML、CSS到最后的SSH自己都是一步一个脚印走出来的，其中开心过、失落过、寂寞过。虽然是半道出家但是经过自己的努力也算是完成了“学业”。期间参加过培训机构，但是极其不喜欢那种培训方式，于是毅然的放弃了选择自学(可怜我出了6000块钱啊)，虽然自学途中苦很多，但是乐更多，当中的付出和收获只有自己知道。黄天不负有心人，鄙人愚钝，在大四第一学期终于自学完成java(其中走了弯路，荒废半年)，并且凭借它得到了一份不错的工作，不胜感激！<br>闲话过多！进入正题，LZ最近刚刚看完设计模式，感触良多。而且在工作过程中深感java基础不够扎实，例如IO不熟、垃圾回收不知所云、多态七窍通五窍、反射不知、甚至连最基本的三大特性都搞得我迷糊了！所以我发狠心一定要好好弥补java基础！从第一课开始—封装!!!!!!</p>","more":"<h2 id=\"三大特性之—封装\"><a href=\"#三大特性之—封装\" class=\"headerlink\" title=\"三大特性之—封装\"></a>三大特性之—封装</h2><p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。<br>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。<br>使用封装有三大好处：<br>1、良好的封装能够减少耦合。<br>2、类内部的结构可以自由修改。<br>3、可以对成员进行更精确的控制。<br>4、隐藏信息，实现细节。<br>首先我们先来看两个类：Husband.java、Wife.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">     * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">     * setter()、getter()是该对象对外开发的接口 </span></div><div class=\"line\"><span class=\"comment\">     */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWife</span><span class=\"params\">(Wife wife)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.wife = wife;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wife</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Husband husband;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSex</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSex</span><span class=\"params\">(String sex)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.sex = sex;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHusband</span><span class=\"params\">(Husband husband)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.husband = husband;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Husband <span class=\"title\">getHusband</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> husband;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">      </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从上面两个实例我们可以看出Husband里面wife引用是没有getter()的，同时wife的age也是没有getter()方法的。至于理由我想各位都懂的，男人嘛深屋藏娇妻嘛，没有那个女人愿意别人知道她的年龄。<br>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。<br>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有setter()和getter()，那么Husband类应该这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">public</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> age ;  </div><div class=\"line\">    <span class=\"keyword\">public</span> Wife wife;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们应该这样来使用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">husband.age = <span class=\"number\">30</span>;  </div><div class=\"line\">husband.name = <span class=\"string\">\"张三\"</span>;  </div><div class=\"line\">husband.sex = <span class=\"string\">\"男\"</span>;    <span class=\"comment\">//貌似有点儿多余</span></div></pre></td></tr></table></figure>\n<p>但是那天如果我们需要修改Husband，例如将age修改为String类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下Husband类的setAge()方法即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//转换即可  </span></div><div class=\"line\">        <span class=\"keyword\">this</span>.age = String.valueOf(age);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其他的地方依然那样引用(husband.setAge(22))保持不变。<br>到了这里我们确实可以看出，<strong>封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。</strong><br>我们在看这个好处：<strong>可以对成员变量进行更精确的控制</strong>。</p>\n<p>还是那个Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">husband.age = <span class=\"number\">300</span>;</div></pre></td></tr></table></figure>\n<p>也许你是因为粗心写成了，你发现了还好，如果没有发现那就麻烦大了，逼近谁见过300岁的老妖怪啊！<br>但是使用封装我们就可以避免这个问题，我们对age的访问入口做一些控制(setter)如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* </span></div><div class=\"line\"><span class=\"comment\">    * 对属性的封装 </span></div><div class=\"line\"><span class=\"comment\">    * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age ;    <span class=\"comment\">/* 改成 String类型的*/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(age &gt; <span class=\"number\">120</span>)&#123;  </div><div class=\"line\">            <span class=\"comment\">//提示錯誤信息  </span></div><div class=\"line\">            System.out.println(<span class=\"string\">\"ERROR：error age input....\"</span>);    </div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他属性的setter、getter **/</span>  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面都是对setter方法的控制，其实通过使用封装我们也能够对对象的出口做出很好的控制。例如性别我们在数据库中一般都是已1、0方式来存储的，但是在前台我们又不能展示1、0，这里我们只需要在getter()方法里面做一些转换即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getSexName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"0\"</span>.equals(sex))&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"女\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(sex))&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"男\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        sexName = <span class=\"string\">\"人妖???\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> sexName;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 在使用的时候我们只需要使用sexName即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCzHTML</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"1\"</span>.equals(zt))&#123;  </div><div class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></div><div class=\"line\">            + <span class=\"string\">\" onclick='qy(\"</span>+id+<span class=\"string\">\")'&gt;启用&lt;/a&gt;\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">else</span>&#123;  </div><div class=\"line\">        czHTML = <span class=\"string\">\"&lt;a href='javascript:void(0)'\"</span></div><div class=\"line\">            + <span class=\"string\">\" onclick='jy(\"</span>+id+<span class=\"string\">\")'&gt;禁用&lt;/a&gt;\"</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">return</span> czHTML;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"java-toup20","date":"2017-10-23T14:38:59.000Z","_content":"","source":"_posts/java-toup20.md","raw":"---\ntitle: java-toup20\ndate: 2017-10-23 22:38:59\ntags:\n---\n","slug":"java-toup20","published":1,"updated":"2017-10-23T14:38:59.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5c0010v0v5o8ygxdpc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java提高篇（二）-----理解java的三大特性之继承","date":"2017-10-23T02:54:46.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12785831](http://blog.csdn.net/chenssy/article/details/12785831)\n\n在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一---继承。\n\n## 继承\n在讲解之前我们先看一个例子，该例子是前篇博文（[java提高篇-----理解java的三大特性之封装](https://itqhy.github.io/2017/10/21/java-toup2/)）的。\n![](/uploads/java3-1.png) \n\n<!-- more -->\n\n 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？**利用继承！！**\n首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。\n从上面我们就可以基本了解了继承的概念了，**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。\n![](/uploads/java3-2.png) \n 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。\n继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。\n实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。\n诚然，**继承定义了类如何相互关联，共享特性**。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。\n同时在使用继承时需要记住三句话：\n\n         1、子类拥有父类非private的属性和方法。\n         2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n         3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。\n诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。\n## 构造器\n 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的---构造器。**对于构造器而言，它只能够被调用，而不能被继承**。 调用父类的构造方法我们使用super()即可。\n对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(){  \n            System.out.println(\"Person Constrctor...\");  \n        }  \n    }  \n  \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n  \nOutput:  \nPerson Constrctor...  \nHusband Constructor... \n```\n通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。\n但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(String name){  \n            System.out.println(\"Person Constrctor-----\" + name);  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            super(\"chenssy\");  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n    \n    Output:  \n    Person Constrctor-----chenssy  \n    Husband Constructor... \n```\n 所以综上所述：**对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。**\n## protected关键字\n private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。    \n**对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。**\n```java\n    public class Person {  \n        private String name;  \n        private int age;  \n        private String sex;  \n    \n        protected String getName() {  \n            return name;  \n        }  \n    \n        protected void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public String toString(){  \n            return \"this name is \" + name;  \n        }  \n        \n        /** 省略其他setter、getter方法 **/  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        public  String toString(){  \n            setName(\"chenssy\");    //调用父类的setName();  \n            return  super.toString();    //调用父类的toString()方法  \n        }  \n    \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            \n            System.out.println(husband.toString());  \n        }  \n    }  \n    \n    Output：  \n    this name is chenssy  \n```\n从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。\n诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是**将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限**。\n## 向上转型\n在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：\n```java\n    public class Person {  \n        public void display(){  \n            System.out.println(\"Play Person...\");  \n        }  \n        \n        static void display(Person person){  \n            person.display();  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            Person.display(husband);      //向上转型  \n        }  \n    }  \n```\n在这我们通过Person.display(husband)。这句话可以看出husband是person类型。\n将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。\n## 谨慎继承\n上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。\n首先我们需要明确，继承存在如下缺陷：\n\n         1、父类变，子类就必须变。\n         2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n         3、继承是一种强耦合关系。\n 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。\n      <font color=\"red\">**慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！**</font>","source":"_posts/java-toup3.md","raw":"---\ntitle: java提高篇（二）-----理解java的三大特性之继承\ndate: 2017-10-23 10:54:46\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12785831](http://blog.csdn.net/chenssy/article/details/12785831)\n\n在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一---继承。\n\n## 继承\n在讲解之前我们先看一个例子，该例子是前篇博文（[java提高篇-----理解java的三大特性之封装](https://itqhy.github.io/2017/10/21/java-toup2/)）的。\n![](/uploads/java3-1.png) \n\n<!-- more -->\n\n 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？**利用继承！！**\n首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。\n从上面我们就可以基本了解了继承的概念了，**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。\n![](/uploads/java3-2.png) \n 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。\n继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。\n实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。\n诚然，**继承定义了类如何相互关联，共享特性**。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。\n同时在使用继承时需要记住三句话：\n\n         1、子类拥有父类非private的属性和方法。\n         2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n         3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。\n诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。\n## 构造器\n 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的---构造器。**对于构造器而言，它只能够被调用，而不能被继承**。 调用父类的构造方法我们使用super()即可。\n对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(){  \n            System.out.println(\"Person Constrctor...\");  \n        }  \n    }  \n  \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n  \nOutput:  \nPerson Constrctor...  \nHusband Constructor... \n```\n通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。\n但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。\n\n```java\n    public class Person {  \n        protected String name;  \n        protected int age;  \n        protected String sex;  \n        \n        Person(String name){  \n            System.out.println(\"Person Constrctor-----\" + name);  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        Husband(){  \n            super(\"chenssy\");  \n            System.out.println(\"Husband Constructor...\");  \n        }  \n        \n        public static void main(String[] args) {  \n            Husband husband  = new Husband();  \n        }  \n    }  \n    \n    Output:  \n    Person Constrctor-----chenssy  \n    Husband Constructor... \n```\n 所以综上所述：**对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。**\n## protected关键字\n private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。    \n**对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。**\n```java\n    public class Person {  \n        private String name;  \n        private int age;  \n        private String sex;  \n    \n        protected String getName() {  \n            return name;  \n        }  \n    \n        protected void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public String toString(){  \n            return \"this name is \" + name;  \n        }  \n        \n        /** 省略其他setter、getter方法 **/  \n    }  \n    \n    public class Husband extends Person{  \n        private Wife wife;  \n    \n        public  String toString(){  \n            setName(\"chenssy\");    //调用父类的setName();  \n            return  super.toString();    //调用父类的toString()方法  \n        }  \n    \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            \n            System.out.println(husband.toString());  \n        }  \n    }  \n    \n    Output：  \n    this name is chenssy  \n```\n从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。\n诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是**将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限**。\n## 向上转型\n在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：\n```java\n    public class Person {  \n        public void display(){  \n            System.out.println(\"Play Person...\");  \n        }  \n        \n        static void display(Person person){  \n            person.display();  \n        }  \n    }  \n    \n    public class Husband extends Person{  \n        public static void main(String[] args) {  \n            Husband husband = new Husband();  \n            Person.display(husband);      //向上转型  \n        }  \n    }  \n```\n在这我们通过Person.display(husband)。这句话可以看出husband是person类型。\n将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。\n## 谨慎继承\n上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。\n首先我们需要明确，继承存在如下缺陷：\n\n         1、父类变，子类就必须变。\n         2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n         3、继承是一种强耦合关系。\n 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。\n      <font color=\"red\">**慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！**</font>","slug":"java-toup3","published":1,"updated":"2017-10-23T13:23:34.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5f0013v0v5nzpbgnat","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12785831\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12785831</a></p>\n</blockquote>\n<p>在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—继承。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在讲解之前我们先看一个例子，该例子是前篇博文（<a href=\"https://itqhy.github.io/2017/10/21/java-toup2/\" target=\"_blank\" rel=\"external\">java提高篇—–理解java的三大特性之封装</a>）的。<br><img src=\"/uploads/java3-1.png\" alt=\"\"> </p>\n<a id=\"more\"></a>\n<p> 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？<strong>利用继承！！</strong><br>首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。<br>从上面我们就可以基本了解了继承的概念了，<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。<br><img src=\"/uploads/java3-2.png\" alt=\"\"><br> 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。<br>继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。<br>实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。<br>诚然，<strong>继承定义了类如何相互关联，共享特性</strong>。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br>同时在使用继承时需要记住三句话：</p>\n<pre><code>1、子类拥有父类非private的属性和方法。\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n</code></pre><p> 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。<br>诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p> 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。<strong>对于构造器而言，它只能够被调用，而不能被继承</strong>。 调用父类的构造方法我们使用super()即可。<br>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> String sex;  </div><div class=\"line\">        </div><div class=\"line\">        Person()&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"Person Constrctor...\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">    </div><div class=\"line\">        Husband()&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">            Husband husband  = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">Output:  </div><div class=\"line\">Person Constrctor...  </div><div class=\"line\">Husband Constructor...</div></pre></td></tr></table></figure>\n<p>通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。<br>但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String sex;  </div><div class=\"line\">    </div><div class=\"line\">    Person(String name)&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Person Constrctor-----\"</span> + name);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    Husband()&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband  = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">Output:  </div><div class=\"line\">Person Constrctor-----chenssy  </div><div class=\"line\">Husband Constructor...</div></pre></td></tr></table></figure>\n<p> 所以综上所述：<strong>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</strong></p>\n<h2 id=\"protected关键字\"><a href=\"#protected关键字\" class=\"headerlink\" title=\"protected关键字\"></a>protected关键字</h2><p> private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。<br><strong>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"this name is \"</span> + name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他setter、getter方法 **/</span>  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"chenssy\"</span>);    <span class=\"comment\">//调用父类的setName();  </span></div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"keyword\">super</span>.toString();    <span class=\"comment\">//调用父类的toString()方法  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(husband.toString());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">Output：  </div><div class=\"line\"><span class=\"keyword\">this</span> name is chenssy</div></pre></td></tr></table></figure></p>\n<p>从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。<br>诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是<strong>将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限</strong>。</p>\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Play Person...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person person)</span></span>&#123;  </div><div class=\"line\">        person.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        Person.display(husband);      <span class=\"comment\">//向上转型  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这我们通过Person.display(husband)。这句话可以看出husband是person类型。<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p>\n<h2 id=\"谨慎继承\"><a href=\"#谨慎继承\" class=\"headerlink\" title=\"谨慎继承\"></a>谨慎继承</h2><p>上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。<br>首先我们需要明确，继承存在如下缺陷：</p>\n<pre><code>1、父类变，子类就必须变。\n2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n3、继承是一种强耦合关系。\n</code></pre><p> 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。<br>      <font color=\"red\"><strong>慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></font></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12785831\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12785831</a></p>\n</blockquote>\n<p>在《Think in java》中有这样一句话：复用代码是Java众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对加以改变是不够的，它还必须能够做更多的事情。在这句话中最引人注目的是“复用代码”,尽可能的复用代码使我们程序员一直在追求的，现在我来介绍一种复用代码的方式，也是java三大特性之一—继承。</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在讲解之前我们先看一个例子，该例子是前篇博文（<a href=\"https://itqhy.github.io/2017/10/21/java-toup2/\" target=\"_blank\" rel=\"external\">java提高篇—–理解java的三大特性之封装</a>）的。<br><img src=\"/uploads/java3-1.png\" alt=\"\"> </p>","more":"<p> 从这里我们可以看出，Wife、Husband两个类除了各自的husband、wife外其余部分全部相同，作为一个想最大限度实现复用代码的我们是不能够忍受这样的重复代码，如果再来一个小三、小四、小五……（扯远了大笑）我们是不是也要这样写呢？那么我们如何来实现这些类的可复用呢？<strong>利用继承！！</strong><br>首先我们先离开软件编程的世界，从常识中我们知道丈夫、妻子、小三、小四…，他们都是人，而且都有一些共性，有名字、年龄、性别、头等等，而且他们都能够吃东西、走路、说话等等共同的行为，所以从这里我们可以发现他们都拥有人的属性和行为，同时也是从人那里继承来的这些属性和行为的。<br>从上面我们就可以基本了解了继承的概念了，<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</strong>通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。<br><img src=\"/uploads/java3-2.png\" alt=\"\"><br> 对于Wife、Husband使用继承后，除了代码量的减少我们还能够非常明显的看到他们的关系。<br>继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。<br>实际上继承者是被继承者的特殊化，它除了拥有被继承者的特性外，还拥有自己独有得特性。例如猫有抓老鼠、爬树等其他动物没有的特性。同时在继承关系中，继承者完全可以替换被继承者，反之则不可以，例如我们可以说猫是动物，但不能说动物是猫就是这个道理，其实对于这个我们将其称之为“向上转型”，下面介绍。<br>诚然，<strong>继承定义了类如何相互关联，共享特性</strong>。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。<br>同时在使用继承时需要记住三句话：</p>\n<pre><code>1、子类拥有父类非private的属性和方法。\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n3、子类可以用自己的方式实现父类的方法。（以后介绍）。\n</code></pre><p> 综上所述，使用继承确实有许多的优点，除了将所有子类的共同属性放入父类，实现代码共享，避免重复外，还可以使得修改扩展继承而来的实现比较简单。<br>诚然，讲到继承一定少不了这三个东西：构造器、protected关键字、向上转型。</p>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><p> 通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。<strong>对于构造器而言，它只能够被调用，而不能被继承</strong>。 调用父类的构造方法我们使用super()即可。<br>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">        <span class=\"keyword\">protected</span> String sex;  </div><div class=\"line\">        </div><div class=\"line\">        Person()&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"Person Constrctor...\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\">    </div><div class=\"line\">        Husband()&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">            Husband husband  = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">Output:  </div><div class=\"line\">Person Constrctor...  </div><div class=\"line\">Husband Constructor...</div></pre></td></tr></table></figure>\n<p>通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。<br>但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">protected</span> String sex;  </div><div class=\"line\">    </div><div class=\"line\">    Person(String name)&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Person Constrctor-----\"</span> + name);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    Husband()&#123;  </div><div class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Husband Constructor...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband  = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">Output:  </div><div class=\"line\">Person Constrctor-----chenssy  </div><div class=\"line\">Husband Constructor...</div></pre></td></tr></table></figure>\n<p> 所以综上所述：<strong>对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</strong></p>\n<h2 id=\"protected关键字\"><a href=\"#protected关键字\" class=\"headerlink\" title=\"protected关键字\"></a>protected关键字</h2><p> private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。<br><strong>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"this name is \"</span> + name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 省略其他setter、getter方法 **/</span>  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> Wife wife;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"chenssy\"</span>);    <span class=\"comment\">//调用父类的setName();  </span></div><div class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"keyword\">super</span>.toString();    <span class=\"comment\">//调用父类的toString()方法  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(husband.toString());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">Output：  </div><div class=\"line\"><span class=\"keyword\">this</span> name is chenssy</div></pre></td></tr></table></figure></p>\n<p>从上面示例可以看书子类Husband可以明显地调用父类Person的setName()。<br>诚然尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是<strong>将属性保持为private(我们应当一致保留更改底层实现)，通过protected方法来控制类的继承者的访问权限</strong>。</p>\n<h2 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h2><p>在上面的继承中我们谈到继承是is-a的相互关系，猫继承与动物，所以我们可以说猫是动物，或者说猫是动物的一种。这样将猫看做动物就是向上转型。如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Play Person...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(Person person)</span></span>&#123;  </div><div class=\"line\">        person.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Husband</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Husband husband = <span class=\"keyword\">new</span> Husband();  </div><div class=\"line\">        Person.display(husband);      <span class=\"comment\">//向上转型  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这我们通过Person.display(husband)。这句话可以看出husband是person类型。<br>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。</p>\n<h2 id=\"谨慎继承\"><a href=\"#谨慎继承\" class=\"headerlink\" title=\"谨慎继承\"></a>谨慎继承</h2><p>上面讲了继承所带来的诸多好处，那我们是不是就可以大肆地使用继承呢？送你一句话：慎用继承。<br>首先我们需要明确，继承存在如下缺陷：</p>\n<pre><code>1、父类变，子类就必须变。\n2、继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。\n3、继承是一种强耦合关系。\n</code></pre><p> 所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。<br>      <font color=\"red\"><strong>慎用继承！！！！！！！！！！！！！！！！！！！！！！！！！！！</strong></font></p>"},{"title":"java提高篇（三）-----理解java的三大特性之多态","date":"2017-10-23T03:23:01.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12786385](http://blog.csdn.net/chenssy/article/details/12786385)\n\n\n面向对象编程有三大特性：封装、继承、多态。\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：\n <font color=\"#0000ff\">**所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。**</font>\n <!-- more -->\n       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：\n       酒 a = 剑南春\n       酒 b = 五粮液\n       酒 c = 酒鬼酒\n       …\n       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。\n       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：\n       JNC a = new JNC();\n       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？\n       Wine a = new JNC();\n       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。\n       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了---1。\n\n```java\n    public class Wine {  \n        public void fun1(){  \n            System.out.println(\"Wine 的Fun.....\");  \n            fun2();  \n        }  \n        \n        public void fun2(){  \n            System.out.println(\"Wine 的Fun2...\");  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        /** \n        * @desc 子类重写父类方法 \n        *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 \n        * @param a \n        * @return void \n        */  \n        public void fun1(String a){  \n            System.out.println(\"JNC 的 Fun1...\");  \n            fun2();  \n        }  \n        \n        /** \n        * 子类重写父类方法 \n        * 指向子类的父类引用调用fun2时，必定是调用该方法 \n        */  \n        public void fun2(){  \n            System.out.println(\"JNC 的Fun2...\");  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            Wine a = new JNC();  \n            a.fun1();  \n        }  \n    }  \n    -------------------------------------------------  \n    Output:  \n    Wine 的Fun.....  \n    JNC 的Fun2... \n```\n从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。\n      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。\n      所以对于多态我们可以总结如下：\n      <font color=\"#0000ff\">**指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。**</font>\n      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n\n## 多态的实现\n\n### 实现条件\n在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。\n\n<font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font>\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font>\n\n### 实现形式\n在Java中有两种形式可以实现多态。继承和接口。\n\n#### 基于继承实现的多态\n基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。\n```java\n    public class Wine {  \n        private String name;  \n        \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Wine(){  \n        }  \n        \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return null;  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        public JNC(){  \n            setName(\"JNC\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class JGJ extends Wine{  \n        public JGJ(){  \n            setName(\"JGJ\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            //定义父类数组  \n            Wine[] wines = new Wine[2];  \n            //定义两个子类  \n            JNC jnc = new JNC();  \n            JGJ jgj = new JGJ();  \n            \n            //父类引用子类对象  \n            wines[0] = jnc;  \n            wines[1] = jgj;  \n            \n            for(int i = 0 ; i < 2 ; i++){  \n                System.out.println(wines[i].toString() + \"--\" + wines[i].drink());  \n            }  \n            System.out.println(\"-------------------------------\");  \n    \n        }  \n    }  \n    OUTPUT:  \n    Wine : JNC--喝的是 JNC  \n    Wine : JGJ--喝的是 JGJ  \n    -------------------------------  \n```\n在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。\n我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：\n```html\n    Object o = new JGJ();  \n    System.out.println(o.toString()); \n```\n输出的结果是Wine : JGJ。\n      Object、Wine、JGJ三者继承链关系是：JGJ—>Wine—>Object。所以我们可以这样说：<font color=\"#0000ff\">**当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用**</font>。但是注意如果这样写：\n```java\n    Object o = new Wine();  \n    System.out.println(o.toString()); \n```\n 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。\n所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\">**对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。**</font>\n如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。\n\n#### 基于接口实现的多态\n继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。\n在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。\n继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。\n\n## 经典实例\n\n通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：[http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx](http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx)。\n\n```java\n    public class A {  \n        public String show(D obj) {  \n            return (\"A and D\");  \n        }  \n    \n        public String show(A obj) {  \n            return (\"A and A\");  \n        }   \n    \n    }  \n    \n    public class B extends A{  \n        public String show(B obj){  \n            return (\"B and B\");  \n        }  \n        \n        public String show(A obj){  \n            return (\"B and A\");  \n        }   \n    }  \n    \n    public class C extends B{  \n    \n    }  \n    \n    public class D extends B{  \n    \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            A a1 = new A();  \n            A a2 = new B();  \n            B b = new B();  \n            C c = new C();  \n            D d = new D();  \n            \n            System.out.println(\"1--\" + a1.show(b));  \n            System.out.println(\"2--\" + a1.show(c));  \n            System.out.println(\"3--\" + a1.show(d));  \n            System.out.println(\"4--\" + a2.show(b));  \n            System.out.println(\"5--\" + a2.show(c));  \n            System.out.println(\"6--\" + a2.show(d));  \n            System.out.println(\"7--\" + b.show(b));  \n            System.out.println(\"8--\" + b.show(c));  \n            System.out.println(\"9--\" + b.show(d));        \n        }  \n    }  \n\n```\n\n 运行结果：\n\n ```java\n    1--A and A  \n    2--A and A  \n    3--A and D  \n    4--B and A  \n    5--B and A  \n    6--A and D  \n    7--B and B  \n    8--B and B  \n    9--A and D \n ````\n\n 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？\n首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\">**其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)**</font>。\n分析：\n从上面的程序中我们可以看出A、B、C、D存在如下关系。\n![](/uploads/java4-1.png)\n\n首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。\n      按照同样的方法我也可以确认其他的答案。\n      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；\n      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。\n      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。\n      参考资料：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\n      百度文库：http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\n","source":"_posts/java-toup4.md","raw":"---\ntitle:  java提高篇（三）-----理解java的三大特性之多态\ndate: 2017-10-23 11:23:01\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12786385](http://blog.csdn.net/chenssy/article/details/12786385)\n\n\n面向对象编程有三大特性：封装、继承、多态。\n封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。\n继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：\n <font color=\"#0000ff\">**所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。**</font>\n <!-- more -->\n       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：\n       酒 a = 剑南春\n       酒 b = 五粮液\n       酒 c = 酒鬼酒\n       …\n       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。\n       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：\n       JNC a = new JNC();\n       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？\n       Wine a = new JNC();\n       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。\n       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了---1。\n\n```java\n    public class Wine {  \n        public void fun1(){  \n            System.out.println(\"Wine 的Fun.....\");  \n            fun2();  \n        }  \n        \n        public void fun2(){  \n            System.out.println(\"Wine 的Fun2...\");  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        /** \n        * @desc 子类重写父类方法 \n        *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 \n        * @param a \n        * @return void \n        */  \n        public void fun1(String a){  \n            System.out.println(\"JNC 的 Fun1...\");  \n            fun2();  \n        }  \n        \n        /** \n        * 子类重写父类方法 \n        * 指向子类的父类引用调用fun2时，必定是调用该方法 \n        */  \n        public void fun2(){  \n            System.out.println(\"JNC 的Fun2...\");  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            Wine a = new JNC();  \n            a.fun1();  \n        }  \n    }  \n    -------------------------------------------------  \n    Output:  \n    Wine 的Fun.....  \n    JNC 的Fun2... \n```\n从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。\n      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。\n      所以对于多态我们可以总结如下：\n      <font color=\"#0000ff\">**指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。**</font>\n      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。\n\n## 多态的实现\n\n### 实现条件\n在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。\n\n<font color=\"#0000ff\">**Java实现多态有三个必要条件：继承、重写、向上转型。**</font>\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。\n对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\">**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。**</font>\n\n### 实现形式\n在Java中有两种形式可以实现多态。继承和接口。\n\n#### 基于继承实现的多态\n基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。\n```java\n    public class Wine {  \n        private String name;  \n        \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Wine(){  \n        }  \n        \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return null;  \n        }  \n    }  \n    \n    public class JNC extends Wine{  \n        public JNC(){  \n            setName(\"JNC\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class JGJ extends Wine{  \n        public JGJ(){  \n            setName(\"JGJ\");  \n        }  \n        \n        /** \n        * 重写父类方法，实现多态 \n        */  \n        public String drink(){  \n            return \"喝的是 \" + getName();  \n        }  \n        \n        /** \n        * 重写toString() \n        */  \n        public String toString(){  \n            return \"Wine : \" + getName();  \n        }  \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            //定义父类数组  \n            Wine[] wines = new Wine[2];  \n            //定义两个子类  \n            JNC jnc = new JNC();  \n            JGJ jgj = new JGJ();  \n            \n            //父类引用子类对象  \n            wines[0] = jnc;  \n            wines[1] = jgj;  \n            \n            for(int i = 0 ; i < 2 ; i++){  \n                System.out.println(wines[i].toString() + \"--\" + wines[i].drink());  \n            }  \n            System.out.println(\"-------------------------------\");  \n    \n        }  \n    }  \n    OUTPUT:  \n    Wine : JNC--喝的是 JNC  \n    Wine : JGJ--喝的是 JGJ  \n    -------------------------------  \n```\n在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。\n我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：\n```html\n    Object o = new JGJ();  \n    System.out.println(o.toString()); \n```\n输出的结果是Wine : JGJ。\n      Object、Wine、JGJ三者继承链关系是：JGJ—>Wine—>Object。所以我们可以这样说：<font color=\"#0000ff\">**当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用**</font>。但是注意如果这样写：\n```java\n    Object o = new Wine();  \n    System.out.println(o.toString()); \n```\n 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。\n所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\">**对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。**</font>\n如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。\n\n#### 基于接口实现的多态\n继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。\n在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。\n继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。\n\n## 经典实例\n\n通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：[http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx](http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx)。\n\n```java\n    public class A {  \n        public String show(D obj) {  \n            return (\"A and D\");  \n        }  \n    \n        public String show(A obj) {  \n            return (\"A and A\");  \n        }   \n    \n    }  \n    \n    public class B extends A{  \n        public String show(B obj){  \n            return (\"B and B\");  \n        }  \n        \n        public String show(A obj){  \n            return (\"B and A\");  \n        }   \n    }  \n    \n    public class C extends B{  \n    \n    }  \n    \n    public class D extends B{  \n    \n    }  \n    \n    public class Test {  \n        public static void main(String[] args) {  \n            A a1 = new A();  \n            A a2 = new B();  \n            B b = new B();  \n            C c = new C();  \n            D d = new D();  \n            \n            System.out.println(\"1--\" + a1.show(b));  \n            System.out.println(\"2--\" + a1.show(c));  \n            System.out.println(\"3--\" + a1.show(d));  \n            System.out.println(\"4--\" + a2.show(b));  \n            System.out.println(\"5--\" + a2.show(c));  \n            System.out.println(\"6--\" + a2.show(d));  \n            System.out.println(\"7--\" + b.show(b));  \n            System.out.println(\"8--\" + b.show(c));  \n            System.out.println(\"9--\" + b.show(d));        \n        }  \n    }  \n\n```\n\n 运行结果：\n\n ```java\n    1--A and A  \n    2--A and A  \n    3--A and D  \n    4--B and A  \n    5--B and A  \n    6--A and D  \n    7--B and B  \n    8--B and B  \n    9--A and D \n ````\n\n 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？\n首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\">**其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)**</font>。\n分析：\n从上面的程序中我们可以看出A、B、C、D存在如下关系。\n![](/uploads/java4-1.png)\n\n首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。\n      按照同样的方法我也可以确认其他的答案。\n      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；\n      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。\n      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。\n      参考资料：http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\n      百度文库：http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\n","slug":"java-toup4","published":1,"updated":"2017-10-23T13:23:34.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5i0015v0v54zgspsjz","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12786385\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12786385</a></p>\n</blockquote>\n<p>面向对象编程有三大特性：封装、继承、多态。<br>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。<br>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：<br> <font color=\"#0000ff\"><strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></font><br> <a id=\"more\"></a><br>       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：<br>       酒 a = 剑南春<br>       酒 b = 五粮液<br>       酒 c = 酒鬼酒<br>       …<br>       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。<br>       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：<br>       JNC a = new JNC();<br>       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？<br>       Wine a = new JNC();<br>       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun.....\"</span>);  </div><div class=\"line\">        fun2();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun2...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 子类重写父类方法 </span></div><div class=\"line\"><span class=\"comment\">    *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> a </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(String a)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的 Fun1...\"</span>);  </div><div class=\"line\">        fun2();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 子类重写父类方法 </span></div><div class=\"line\"><span class=\"comment\">    * 指向子类的父类引用调用fun2时，必定是调用该方法 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的Fun2...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Wine a = <span class=\"keyword\">new</span> JNC();  </div><div class=\"line\">        a.fun1();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Wine 的Fun.....  </div><div class=\"line\">JNC 的Fun2...</div></pre></td></tr></table></figure>\n<p>从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。<br>      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>      所以对于多态我们可以总结如下：<br>      <font color=\"#0000ff\"><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</strong></font><br>      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>\n<h2 id=\"多态的实现\"><a href=\"#多态的实现\" class=\"headerlink\" title=\"多态的实现\"></a>多态的实现</h2><h3 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h3><p>在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。</p>\n<font color=\"#0000ff\"><strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong></font><br>继承：在多态中必须存在有继承关系的子类和父类。<br>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。<br>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。<br>对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\"><strong>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</strong></font>\n\n<h3 id=\"实现形式\"><a href=\"#实现形式\" class=\"headerlink\" title=\"实现形式\"></a>实现形式</h3><p>在Java中有两种形式可以实现多态。继承和接口。</p>\n<h4 id=\"基于继承实现的多态\"><a href=\"#基于继承实现的多态\" class=\"headerlink\" title=\"基于继承实现的多态\"></a>基于继承实现的多态</h4><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Wine</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JNC</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"JNC\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JGJ</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JGJ</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"JGJ\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//定义父类数组  </span></div><div class=\"line\">        Wine[] wines = <span class=\"keyword\">new</span> Wine[<span class=\"number\">2</span>];  </div><div class=\"line\">        <span class=\"comment\">//定义两个子类  </span></div><div class=\"line\">        JNC jnc = <span class=\"keyword\">new</span> JNC();  </div><div class=\"line\">        JGJ jgj = <span class=\"keyword\">new</span> JGJ();  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//父类引用子类对象  </span></div><div class=\"line\">        wines[<span class=\"number\">0</span>] = jnc;  </div><div class=\"line\">        wines[<span class=\"number\">1</span>] = jgj;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++)&#123;  </div><div class=\"line\">            System.out.println(wines[i].toString() + <span class=\"string\">\"--\"</span> + wines[i].drink());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"-------------------------------\"</span>);  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">OUTPUT:  </div><div class=\"line\">Wine : JNC--喝的是 JNC  </div><div class=\"line\">Wine : JGJ--喝的是 JGJ  </div><div class=\"line\">-------------------------------</div></pre></td></tr></table></figure></p>\n<p>在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。<br>我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o = new JGJ();  </div><div class=\"line\">System.out.println(o.toString());</div></pre></td></tr></table></figure></p>\n<p>输出的结果是Wine : JGJ。<br>      Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：<font color=\"#0000ff\"><strong>当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用</strong></font>。但是注意如果这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o = <span class=\"keyword\">new</span> Wine();  </div><div class=\"line\">System.out.println(o.toString());</div></pre></td></tr></table></figure></p>\n<p> 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。<br>所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\"><strong>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</strong></font><br>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</p>\n<h4 id=\"基于接口实现的多态\"><a href=\"#基于接口实现的多态\" class=\"headerlink\" title=\"基于接口实现的多态\"></a>基于接口实现的多态</h4><p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p>\n<h2 id=\"经典实例\"><a href=\"#经典实例\" class=\"headerlink\" title=\"经典实例\"></a>经典实例</h2><p>通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(D obj)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and D\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and A\"</span>);  </div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(B obj)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and B\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and A\"</span>);  </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        A a1 = <span class=\"keyword\">new</span> A();  </div><div class=\"line\">        A a2 = <span class=\"keyword\">new</span> B();  </div><div class=\"line\">        B b = <span class=\"keyword\">new</span> B();  </div><div class=\"line\">        C c = <span class=\"keyword\">new</span> C();  </div><div class=\"line\">        D d = <span class=\"keyword\">new</span> D();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"1--\"</span> + a1.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"2--\"</span> + a1.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"3--\"</span> + a1.show(d));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"4--\"</span> + a2.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"5--\"</span> + a2.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"6--\"</span> + a2.show(d));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"7--\"</span> + b.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"8--\"</span> + b.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"9--\"</span> + b.show(d));        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 运行结果：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"number\">1</span>--A and A  </div><div class=\"line\">   <span class=\"number\">2</span>--A and A  </div><div class=\"line\">   <span class=\"number\">3</span>--A and D  </div><div class=\"line\">   <span class=\"number\">4</span>--B and A  </div><div class=\"line\">   <span class=\"number\">5</span>--B and A  </div><div class=\"line\">   <span class=\"number\">6</span>--A and D  </div><div class=\"line\">   <span class=\"number\">7</span>--B and B  </div><div class=\"line\">   <span class=\"number\">8</span>--B and B  </div><div class=\"line\">   <span class=\"number\">9</span>--A and D </div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p> 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？<br>首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\"><strong>其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></font>。<br>分析：<br>从上面的程序中我们可以看出A、B、C、D存在如下关系。<br><img src=\"/uploads/java4-1.png\" alt=\"\"></p>\n<p>首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。<br>      按照同样的方法我也可以确认其他的答案。<br>      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；<br>      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。<br>      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。<br>      参考资料：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a><br>      百度文库：<a href=\"http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12786385\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12786385</a></p>\n</blockquote>\n<p>面向对象编程有三大特性：封装、继承、多态。<br>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。<br>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。，同时继承也为实现多态做了铺垫。那么什么是多态呢？多态的实现机制又是什么？请看我一一为你揭开：<br> <font color=\"#0000ff\"><strong>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</strong></font><br>","more":"<br>       比如你是一个酒神，对酒情有独钟。某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。你一喝，这是剑南春、再喝这是五粮液、再喝这是酒鬼酒….在这里我们可以描述成如下：<br>       酒 a = 剑南春<br>       酒 b = 五粮液<br>       酒 c = 酒鬼酒<br>       …<br>       这里所表现的的就是多态。剑南春、五粮液、酒鬼酒都是酒的子类，我们只是通过酒这一个父类就能够引用不同的子类，这就是多态——我们只有在运行的时候才会知道引用变量所指向的具体实例对象。<br>       诚然，要理解多态我们就必须要明白什么是“向上转型”。在继承中我们简单介绍了向上转型，这里就在啰嗦下：在上面的喝酒例子中，酒（Win）是父类，剑南春（JNC）、五粮液（WLY）、酒鬼酒（JGJ）是子类。我们定义如下代码：<br>       JNC a = new JNC();<br>       对于这个代码我们非常容易理解无非就是实例化了一个剑南春的对象嘛！但是这样呢？<br>       Wine a = new JNC();<br>       在这里我们这样理解，这里定义了一个Wine 类型的a，它指向JNC对象实例。由于JNC是继承与Wine，所以JNC可以自动向上转型为Wine，所以a是可以指向JNC实例对象的。这样做存在一个非常大的好处，在继承中我们知道子类是父类的扩展，它可以提供比父类更加强大的功能，如果我们定义了一个指向子类的父类引用类型，那么它除了能够引用父类的共性外，还可以使用子类强大的功能。<br>       但是向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了—1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun.....\"</span>);  </div><div class=\"line\">        fun2();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Wine 的Fun2...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 子类重写父类方法 </span></div><div class=\"line\"><span class=\"comment\">    *        父类中不存在该方法，向上转型后，父类是不能引用该方法的 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> a </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">(String a)</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的 Fun1...\"</span>);  </div><div class=\"line\">        fun2();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 子类重写父类方法 </span></div><div class=\"line\"><span class=\"comment\">    * 指向子类的父类引用调用fun2时，必定是调用该方法 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"JNC 的Fun2...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Wine a = <span class=\"keyword\">new</span> JNC();  </div><div class=\"line\">        a.fun1();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Wine 的Fun.....  </div><div class=\"line\">JNC 的Fun2...</div></pre></td></tr></table></figure>\n<p>从程序的运行结果中我们发现，a.fun1()首先是运行父类Wine中的fun1().然后再运行子类JNC中的fun2()。<br>      分析：在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>      所以对于多态我们可以总结如下：<br>      <font color=\"#0000ff\"><strong>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</strong></font><br>      对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>\n<h2 id=\"多态的实现\"><a href=\"#多态的实现\" class=\"headerlink\" title=\"多态的实现\"></a>多态的实现</h2><h3 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h3><p>在刚刚开始就提到了继承在为多态的实现做了准备。子类Child继承父类Father，我们可以编写一个指向子类的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态性就是相同的消息使得不同的类做出不同的响应。</p>\n<font color=\"#0000ff\"><strong>Java实现多态有三个必要条件：继承、重写、向上转型。</strong></font><br>继承：在多态中必须存在有继承关系的子类和父类。<br>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。<br>只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。<br>对于Java而言，它多态的实现机制遵循一个原则：<font color=\"#0000ff\"><strong>当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</strong></font>\n\n<h3 id=\"实现形式\"><a href=\"#实现形式\" class=\"headerlink\" title=\"实现形式\"></a>实现形式</h3><p>在Java中有两种形式可以实现多态。继承和接口。</p>\n<h4 id=\"基于继承实现的多态\"><a href=\"#基于继承实现的多态\" class=\"headerlink\" title=\"基于继承实现的多态\"></a>基于继承实现的多态</h4><p>基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wine</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Wine</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JNC</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JNC</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"JNC\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JGJ</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wine</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JGJ</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        setName(<span class=\"string\">\"JGJ\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写父类方法，实现多态 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">drink</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"喝的是 \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 重写toString() </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Wine : \"</span> + getName();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//定义父类数组  </span></div><div class=\"line\">        Wine[] wines = <span class=\"keyword\">new</span> Wine[<span class=\"number\">2</span>];  </div><div class=\"line\">        <span class=\"comment\">//定义两个子类  </span></div><div class=\"line\">        JNC jnc = <span class=\"keyword\">new</span> JNC();  </div><div class=\"line\">        JGJ jgj = <span class=\"keyword\">new</span> JGJ();  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//父类引用子类对象  </span></div><div class=\"line\">        wines[<span class=\"number\">0</span>] = jnc;  </div><div class=\"line\">        wines[<span class=\"number\">1</span>] = jgj;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">2</span> ; i++)&#123;  </div><div class=\"line\">            System.out.println(wines[i].toString() + <span class=\"string\">\"--\"</span> + wines[i].drink());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"-------------------------------\"</span>);  </div><div class=\"line\"></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">OUTPUT:  </div><div class=\"line\">Wine : JNC--喝的是 JNC  </div><div class=\"line\">Wine : JGJ--喝的是 JGJ  </div><div class=\"line\">-------------------------------</div></pre></td></tr></table></figure></p>\n<p>在上面的代码中JNC、JGJ继承Wine，并且重写了drink()、toString()方法，程序运行结果是调用子类中方法，输出JNC、JGJ的名称，这就是多态的表现。不同的对象可以执行相同的行为，但是他们都需要通过自己的实现方式来执行，这就要得益于向上转型了。<br>我们都知道所有的类都继承自超类Object，toString()方法也是Object中方法，当我们这样写时：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o = new JGJ();  </div><div class=\"line\">System.out.println(o.toString());</div></pre></td></tr></table></figure></p>\n<p>输出的结果是Wine : JGJ。<br>      Object、Wine、JGJ三者继承链关系是：JGJ—&gt;Wine—&gt;Object。所以我们可以这样说：<font color=\"#0000ff\"><strong>当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用</strong></font>。但是注意如果这样写：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object o = <span class=\"keyword\">new</span> Wine();  </div><div class=\"line\">System.out.println(o.toString());</div></pre></td></tr></table></figure></p>\n<p> 输出的结果应该是Null，因为JGJ并不存在于该对象继承链中。<br>所以基于继承实现的多态可以总结如下：<font color=\"#0000ff\"><strong>对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</strong></font><br>如果父类是抽象类，那么子类必须要实现父类中所有的抽象方法，这样该父类所有的子类一定存在统一的对外接口，但其内部的具体实现可以各异。这样我们就可以使用顶层类提供的统一接口来处理该层次的方法。</p>\n<h4 id=\"基于接口实现的多态\"><a href=\"#基于接口实现的多态\" class=\"headerlink\" title=\"基于接口实现的多态\"></a>基于接口实现的多态</h4><p>继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。<br>在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。<br>继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p>\n<h2 id=\"经典实例\"><a href=\"#经典实例\" class=\"headerlink\" title=\"经典实例\"></a>经典实例</h2><p>通过上面的讲述，可以说是对多态有了一定的了解。现在趁热打铁，看一个实例。该实例是有关多态的经典例子，摘自：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(D obj)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and D\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"A and A\"</span>);  </div><div class=\"line\">    &#125;   </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(B obj)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and B\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">show</span><span class=\"params\">(A obj)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"string\">\"B and A\"</span>);  </div><div class=\"line\">    &#125;   </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> <span class=\"keyword\">extends</span> <span class=\"title\">B</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        A a1 = <span class=\"keyword\">new</span> A();  </div><div class=\"line\">        A a2 = <span class=\"keyword\">new</span> B();  </div><div class=\"line\">        B b = <span class=\"keyword\">new</span> B();  </div><div class=\"line\">        C c = <span class=\"keyword\">new</span> C();  </div><div class=\"line\">        D d = <span class=\"keyword\">new</span> D();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"1--\"</span> + a1.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"2--\"</span> + a1.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"3--\"</span> + a1.show(d));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"4--\"</span> + a2.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"5--\"</span> + a2.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"6--\"</span> + a2.show(d));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"7--\"</span> + b.show(b));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"8--\"</span> + b.show(c));  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"9--\"</span> + b.show(d));        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 运行结果：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"number\">1</span>--A and A  </div><div class=\"line\">   <span class=\"number\">2</span>--A and A  </div><div class=\"line\">   <span class=\"number\">3</span>--A and D  </div><div class=\"line\">   <span class=\"number\">4</span>--B and A  </div><div class=\"line\">   <span class=\"number\">5</span>--B and A  </div><div class=\"line\">   <span class=\"number\">6</span>--A and D  </div><div class=\"line\">   <span class=\"number\">7</span>--B and B  </div><div class=\"line\">   <span class=\"number\">8</span>--B and B  </div><div class=\"line\">   <span class=\"number\">9</span>--A and D </div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p> 在这里看结果1、2、3还好理解，从4开始就开始糊涂了，对于4来说为什么输出不是“B and B”呢？<br>首先我们先看一句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这句话对多态进行了一个概括。<font color=\"#0000ff\"><strong>其实在继承链中对象方法的调用存在一个优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></font>。<br>分析：<br>从上面的程序中我们可以看出A、B、C、D存在如下关系。<br><img src=\"/uploads/java4-1.png\" alt=\"\"></p>\n<p>首先我们分析5，a2.show(c)，a2是A类型的引用变量，所以this就代表了A，a2.show(c),它在A类中找发现没有找到，于是到A的超类中找(super)，由于A没有超类（Object除外），所以跳到第三级，也就是this.show((super)O)，C的超类有B、A，所以(super)O为B、A，this同样是A，这里在A中找到了show(A obj)，同时由于a2是B类的一个引用且B类重写了show(A obj)，因此最终会调用子类B类的show(A obj)方法，结果也就是B and A。<br>      按照同样的方法我也可以确认其他的答案。<br>      方法已经找到了但是我们这里还是存在一点疑问，我们还是来看这句话：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。这我们用一个例子来说明这句话所代表的含义：a2.show(b)；<br>      这里a2是引用变量，为A类型，它引用的是B对象，因此按照上面那句话的意思是说有B来决定调用谁的方法,所以a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是为什么会与前面的运行结果产生差异呢？这里我们忽略了后面那句话“但是这儿被调用的方法必须是在超类中定义过的”，那么show(B obj)在A类中存在吗？根本就不存在！所以这句话在这里不适用？那么难道是这句话错误了？非也！其实这句话还隐含这这句话：它仍然要按照继承链中调用方法的优先级来确认。所以它才会在A类中找到show(A obj)，同时由于B重写了该方法所以才会调用B类中的方法，否则就会调用A类中的方法。<br>      所以多态机制遵循的原则概括为：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。<br>      参考资料：<a href=\"http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/thinkGhoster/archive/2008/04/19/2307001.aspx</a><br>      百度文库：<a href=\"http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html\" target=\"_blank\" rel=\"external\">http://wenku.baidu.com/view/73f66f92daef5ef7ba0d3c03.html</a></p>"},{"title":"java提高篇（四）-----抽象类与接口","date":"2017-10-23T05:04:03.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12858267](http://blog.csdn.net/chenssy/article/details/12858267)\n\n接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。\n       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。\n\n## 抽象类\n我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。\n<!-- more -->\n在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。\n同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）\n在使用抽象类时需要注意几点：\n\n        1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n        2、抽象方法必须由子类来进行重写。\n        3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n        4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n        5、子类中的抽象方法不能与父类的抽象方法同名。\n        6、abstract不能与final并列修饰同一个类。\n        7、abstract 不能与private、static、final或native并列修饰同一个方法。\n\n实例：\n定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：\n\n```java\n    public abstract class Animal {  \n        public abstract void cry();  \n    }  \n    \n    public class Cat extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"猫叫：喵喵...\");  \n        }  \n    }  \n    \n    public class Dog extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"狗叫:汪汪...\");  \n        }  \n    \n    }  \n    \n    public class Test {  \n    \n        public static void main(String[] args) {  \n            Animal a1 = new Cat();  \n            Animal a2 = new Dog();  \n            \n            a1.cry();  \n            a2.cry();  \n        }  \n    }  \n    \n    --------------------------------------------------------------------  \n    Output:  \n    猫叫：喵喵...  \n    狗叫:汪汪...  \n```\n 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）\n\n ## 接口\n\n接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。\n接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。\n接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。\n在使用接口过程中需要注意如下几个问题：\n\n         1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n         3、接口中不存在实现的方法。\n         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n         5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n         例如：if(anObject instanceof Comparable){}。\n         6、在实现多接口的时候一定要避免方法名的重复。\n\n## 抽象类与接口的区别\n\n 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。\n ### 语法层次\n   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。\n      使用抽象类来实现:\n\n```java\n    public abstract class Demo {  \n        abstract void method1();  \n        \n        \n        void method2(){  \n            //实现  \n        }  \n    }  \n```\n\n 使用接口来实现\n ```java\n    interface Demo {  \n        void method1();  \n        void method2();  \n    }  \n ```\n抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。\n对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。\n\n### 设计层次\n上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：\n\n        1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n        2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n        但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n        这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，\n        即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n        3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n        至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n        猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n        我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n**（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）**\n为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：http://blog.csdn.net/ttgjz/article/details/2960451\n我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n抽象类：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close()；  \n    }  \n```\n接口：\n```java\n    interface Door{  \n        void open();  \n        void close();  \n    }  \n```\n\n至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。\n但是现在如果我们需要门具有报警的功能，那么该如何实现呢？\n\n**解决方案一**：给Door增加一个报警方法:clarm();\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n        abstract void alarm();  \n    } \n```\n或者\n\n```java\n    interface Door{  \n        void open();  \n        void close();  \n        void alarm();  \n    }  \n```\n这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念\"报警器\"的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为\"报警器\"这个概念的改变而改变，反之依然。\n\n**解决方案二**\n      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：\n       1、两个都使用抽象类来定义。\n      2、两个都使用接口来定义。\n      3、一个使用抽象类定义，一个是用接口定义。\n      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。\n      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。\n     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n    }  \n    \n    interface Alarm{  \n        void alarm();  \n    }  \n    \n    class AlarmDoor extends Door implements Alarm{  \n        void open(){}  \n        void close(){}  \n        void alarm(){}  \n    }  \n```\n\n 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是\"is-a\"关系，接口表示的是\"like-a\"关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。\n\n **批注：**\n>  <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。\n>   一个类对另外一个类的依赖性应当是建立在最小的接口上的。\n>   一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n## 总结\n\n      1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n      抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n      只有对问题域的本质有良好的理解，才能做出正确、合理的设计。","source":"_posts/java-toup5.md","raw":"---\ntitle: java提高篇（四）-----抽象类与接口\ndate: 2017-10-23 13:04:03\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12858267](http://blog.csdn.net/chenssy/article/details/12858267)\n\n接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。\n       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。\n\n## 抽象类\n我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。\n<!-- more -->\n在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。\n同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）\n在使用抽象类时需要注意几点：\n\n        1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n        2、抽象方法必须由子类来进行重写。\n        3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n        4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n        5、子类中的抽象方法不能与父类的抽象方法同名。\n        6、abstract不能与final并列修饰同一个类。\n        7、abstract 不能与private、static、final或native并列修饰同一个方法。\n\n实例：\n定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：\n\n```java\n    public abstract class Animal {  \n        public abstract void cry();  \n    }  \n    \n    public class Cat extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"猫叫：喵喵...\");  \n        }  \n    }  \n    \n    public class Dog extends Animal{  \n    \n        @Override  \n        public void cry() {  \n            System.out.println(\"狗叫:汪汪...\");  \n        }  \n    \n    }  \n    \n    public class Test {  \n    \n        public static void main(String[] args) {  \n            Animal a1 = new Cat();  \n            Animal a2 = new Dog();  \n            \n            a1.cry();  \n            a2.cry();  \n        }  \n    }  \n    \n    --------------------------------------------------------------------  \n    Output:  \n    猫叫：喵喵...  \n    狗叫:汪汪...  \n```\n 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）\n\n ## 接口\n\n接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。\n接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。\n接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。\n在使用接口过程中需要注意如下几个问题：\n\n         1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n         2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n         3、接口中不存在实现的方法。\n         4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n         5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n         例如：if(anObject instanceof Comparable){}。\n         6、在实现多接口的时候一定要避免方法名的重复。\n\n## 抽象类与接口的区别\n\n 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。\n ### 语法层次\n   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。\n      使用抽象类来实现:\n\n```java\n    public abstract class Demo {  \n        abstract void method1();  \n        \n        \n        void method2(){  \n            //实现  \n        }  \n    }  \n```\n\n 使用接口来实现\n ```java\n    interface Demo {  \n        void method1();  \n        void method2();  \n    }  \n ```\n抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。\n对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。\n\n### 设计层次\n上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：\n\n        1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n        2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n        但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n        这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在\"is-a\" 关系，\n        即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n        3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n        至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n        猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n        我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n**（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）**\n为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：http://blog.csdn.net/ttgjz/article/details/2960451\n我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：\n抽象类：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close()；  \n    }  \n```\n接口：\n```java\n    interface Door{  \n        void open();  \n        void close();  \n    }  \n```\n\n至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。\n但是现在如果我们需要门具有报警的功能，那么该如何实现呢？\n\n**解决方案一**：给Door增加一个报警方法:clarm();\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n        abstract void alarm();  \n    } \n```\n或者\n\n```java\n    interface Door{  \n        void open();  \n        void close();  \n        void alarm();  \n    }  \n```\n这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念\"报警器\"的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为\"报警器\"这个概念的改变而改变，反之依然。\n\n**解决方案二**\n      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：\n       1、两个都使用抽象类来定义。\n      2、两个都使用接口来定义。\n      3、一个使用抽象类定义，一个是用接口定义。\n      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。\n      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。\n     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：\n\n```java\n    abstract class Door{  \n        abstract void open();  \n        abstract void close();  \n    }  \n    \n    interface Alarm{  \n        void alarm();  \n    }  \n    \n    class AlarmDoor extends Door implements Alarm{  \n        void open(){}  \n        void close(){}  \n        void alarm(){}  \n    }  \n```\n\n 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是\"is-a\"关系，接口表示的是\"like-a\"关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。\n\n **批注：**\n>  <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。\n>   一个类对另外一个类的依赖性应当是建立在最小的接口上的。\n>   一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n## 总结\n\n      1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n      2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n      3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n      抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n      只有对问题域的本质有良好的理解，才能做出正确、合理的设计。","slug":"java-toup5","published":1,"updated":"2017-10-23T13:23:34.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5o0019v0v5olek0tq7","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12858267</a></p>\n</blockquote>\n<p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。<br>       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。<br><a id=\"more\"></a><br>在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。<br>同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）<br>在使用抽象类时需要注意几点：</p>\n<pre><code>1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n2、抽象方法必须由子类来进行重写。\n3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n5、子类中的抽象方法不能与父类的抽象方法同名。\n6、abstract不能与final并列修饰同一个类。\n7、abstract 不能与private、static、final或native并列修饰同一个方法。\n</code></pre><p>实例：<br>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"猫叫：喵喵...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"狗叫:汪汪...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Animal a1 = <span class=\"keyword\">new</span> Cat();  </div><div class=\"line\">        Animal a2 = <span class=\"keyword\">new</span> Dog();  </div><div class=\"line\">        </div><div class=\"line\">        a1.cry();  </div><div class=\"line\">        a2.cry();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">--------------------------------------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">猫叫：喵喵...  </div><div class=\"line\">狗叫:汪汪...</div></pre></td></tr></table></figure>\n<p> 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。<br>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。<br>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。<br>在使用接口过程中需要注意如下几个问题：</p>\n<pre><code>1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n3、接口中不存在实现的方法。\n4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n例如：if(anObject instanceof Comparable){}。\n6、在实现多接口的时候一定要避免方法名的重复。\n</code></pre><h2 id=\"抽象类与接口的区别\"><a href=\"#抽象类与接口的区别\" class=\"headerlink\" title=\"抽象类与接口的区别\"></a>抽象类与接口的区别</h2><p> 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p>\n<h3 id=\"语法层次\"><a href=\"#语法层次\" class=\"headerlink\" title=\"语法层次\"></a>语法层次</h3><p>   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>      使用抽象类来实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//实现  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 使用接口来实现<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Demo</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p>\n<h3 id=\"设计层次\"><a href=\"#设计层次\" class=\"headerlink\" title=\"设计层次\"></a>设计层次</h3><p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p>\n<pre><code>1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系，\n即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n</code></pre><p><strong>（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）</strong><br>为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：<a href=\"http://blog.csdn.net/ttgjz/article/details/2960451\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ttgjz/article/details/2960451</a><br>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>抽象类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span>；  </span></div><div class=\"line\"><span class=\"function\">&#125;</span></div></pre></td></tr></table></figure>\n<p>接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。<br>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p>\n<p><strong>解决方案一</strong>：给Door增加一个报警方法:clarm();<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p>\n<p><strong>解决方案二</strong><br>      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：<br>       1、两个都使用抽象类来定义。<br>      2、两个都使用接口来定义。<br>      3、一个使用抽象类定义，一个是用接口定义。<br>      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。<br>      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。<br>     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p>\n<p> <strong>批注：</strong></p>\n<blockquote>\n <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。<br>  一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>  一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code>1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n只有对问题域的本质有良好的理解，才能做出正确、合理的设计。\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12858267\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12858267</a></p>\n</blockquote>\n<p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。<br>       抽象类与接口是java语言中对抽象概念进行定义的两种机制，正是由于他们的存在才赋予java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>我们都知道在面向对象的领域一切都是对象，同时所有的对象都是通过类来描述的，但是并不是所有的类都是来描述对象的。如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。比如new Animal()，我们都知道这个是产生一个动物Animal对象，但是这个Animal具体长成什么样子我们并不知道，它没有一个具体动物的概念，所以他就是一个抽象类，需要一个具体的动物，如狗、猫来对它进行特定的描述，我们才知道它长成啥样。<br>","more":"<br>在面向对象领域由于抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能实例化的。<br>同时，抽象类体现了数据抽象的思想，是实现多态的一种机制。它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。（不知这样理解是否有错!!!高手指点….）<br>在使用抽象类时需要注意几点：</p>\n<pre><code>1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。\n2、抽象方法必须由子类来进行重写。\n3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。\n4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。\n5、子类中的抽象方法不能与父类的抽象方法同名。\n6、abstract不能与final并列修饰同一个类。\n7、abstract 不能与private、static、final或native并列修饰同一个方法。\n</code></pre><p>实例：<br>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类，由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"猫叫：喵喵...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cry</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"狗叫:汪汪...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Animal a1 = <span class=\"keyword\">new</span> Cat();  </div><div class=\"line\">        Animal a2 = <span class=\"keyword\">new</span> Dog();  </div><div class=\"line\">        </div><div class=\"line\">        a1.cry();  </div><div class=\"line\">        a2.cry();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">--------------------------------------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">猫叫：喵喵...  </div><div class=\"line\">狗叫:汪汪...</div></pre></td></tr></table></figure>\n<p> 创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。（From:Think in java ）</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。<br>接口是用来建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。同时实现该接口的实现类必须要实现该接口的所有方法，通过使用implements关键字，他表示该类在遵循某个或某组特定的接口，同时也表示着“interface只是它的外貌，但是现在需要声明它是如何工作的”。<br>接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。<br>在使用接口过程中需要注意如下几个问题：</p>\n<pre><code>1、Interface的所有方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！\n2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。\n3、接口中不存在实现的方法。\n4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。\n5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。\n例如：if(anObject instanceof Comparable){}。\n6、在实现多接口的时候一定要避免方法名的重复。\n</code></pre><h2 id=\"抽象类与接口的区别\"><a href=\"#抽象类与接口的区别\" class=\"headerlink\" title=\"抽象类与接口的区别\"></a>抽象类与接口的区别</h2><p> 尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p>\n<h3 id=\"语法层次\"><a href=\"#语法层次\" class=\"headerlink\" title=\"语法层次\"></a>语法层次</h3><p>   在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>      使用抽象类来实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//实现  </span></div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 使用接口来实现<br> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Demo</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p>\n<h3 id=\"设计层次\"><a href=\"#设计层次\" class=\"headerlink\" title=\"设计层次\"></a>设计层次</h3><p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p>\n<pre><code>1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。\n2、 跨域不同。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，\n但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，\n这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is-a&quot; 关系，\n即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。\n3、 设计层次不同。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，\n至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，\n猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，\n我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。\n</code></pre><p><strong>（上面纯属个人见解，如有出入、错误之处，望各位指点！！！！）</strong><br>为了更好的阐述他们之间的区别，下面将使用一个例子来说明。该例子引自：<a href=\"http://blog.csdn.net/ttgjz/article/details/2960451\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ttgjz/article/details/2960451</a><br>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>抽象类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span>；  </span></div><div class=\"line\"><span class=\"function\">&#125;</span></div></pre></td></tr></table></figure>\n<p>接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。<br>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p>\n<p><strong>解决方案一</strong>：给Door增加一个报警方法:clarm();<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p>\n<p><strong>解决方案二</strong><br>      既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：<br>       1、两个都使用抽象类来定义。<br>      2、两个都使用接口来定义。<br>      3、一个使用抽象类定义，一个是用接口定义。<br>      由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。<br>      如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。<br>     第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Door</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Alarm</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlarmDoor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Door</span> <span class=\"keyword\">implements</span> <span class=\"title\">Alarm</span></span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">open</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">alarm</span><span class=\"params\">()</span></span>&#123;&#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实抽象类表示的是”is-a”关系，接口表示的是”like-a”关系，大家在选择时可以作为一个依据，当然这是建立在对问题领域的理解上的，比如：如果我们认为AlarmDoor在概念本质上是报警器，同时又具有Door的功能，那么上述的定义方式就要反过来了。</p>\n<p> <strong>批注：</strong></p>\n<blockquote>\n <font color=\"#3366FF\">ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。<br>  一个类对另外一个类的依赖性应当是建立在最小的接口上的。<br>  一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</font>\n\n\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><pre><code>1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。\n2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。\n3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。\n抽象类和接口是java语言中两种不同的抽象概念，他们的存在对多态提供了非常好的支持，虽然他们之间存在很大的相似性。但是对于他们的选择往往反应了您对问题域的理解。\n只有对问题域的本质有良好的理解，才能做出正确、合理的设计。\n</code></pre>"},{"title":"java提高篇（六）-----关键字static","date":"2017-10-23T05:38:04.000Z","_content":"\n> 转载： http://blog.csdn.net/chenssy/article/details/13004291\n\n## static代表着什么\n在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。\nJava把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。\n同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。\n<!-- more -->\n```java\n    public class User {  \n        private static int userNumber  = 0 ;  \n        \n        public User(){  \n            userNumber ++;  \n        }  \n        \n        public static void main(String[] args) {  \n            User user1 = new User();  \n            User user2 = new User();  \n            \n            System.out.println(\"user1 userNumber：\" + User.userNumber);  \n            System.out.println(\"user2 userNumber：\" + User.userNumber);  \n        }  \n    }      \n    ------------  \n    Output:  \n    user1 userNumber：2  \n    user2 userNumber：2  \n```\n\n##  怎么使用static\nstatic可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。\nClassName..propertyName\nClassName.methodName(……)\nStatic修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）\n\n### static变量\nstatic修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：\n静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。\n但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。\n### static方法\nstatic修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。\nStatic方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。\n### static代码块\n被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。\n\n## Static的局限\nStatic确实是存在诸多的作用，但是它也存在一些缺陷。\n\n        1、它只能调用static变量。\n        2、它只能调用static方法。\n        3、不能以任何形式引用this、super。\n        4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经\"准备好了\",也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font>","source":"_posts/java-toup7.md","raw":"---\ntitle:  java提高篇（六）-----关键字static\ndate: 2017-10-23 13:38:04\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： http://blog.csdn.net/chenssy/article/details/13004291\n\n## static代表着什么\n在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。\nJava把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。\n同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。\n<!-- more -->\n```java\n    public class User {  \n        private static int userNumber  = 0 ;  \n        \n        public User(){  \n            userNumber ++;  \n        }  \n        \n        public static void main(String[] args) {  \n            User user1 = new User();  \n            User user2 = new User();  \n            \n            System.out.println(\"user1 userNumber：\" + User.userNumber);  \n            System.out.println(\"user2 userNumber：\" + User.userNumber);  \n        }  \n    }      \n    ------------  \n    Output:  \n    user1 userNumber：2  \n    user2 userNumber：2  \n```\n\n##  怎么使用static\nstatic可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。\nClassName..propertyName\nClassName.methodName(……)\nStatic修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）\n\n### static变量\nstatic修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：\n静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。\n但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。\n所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。\n### static方法\nstatic修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。\nStatic方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。\n### static代码块\n被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。\n\n## Static的局限\nStatic确实是存在诸多的作用，但是它也存在一些缺陷。\n\n        1、它只能调用static变量。\n        2、它只能调用static方法。\n        3、不能以任何形式引用this、super。\n        4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经\"准备好了\",也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font>","slug":"java-toup7","published":1,"updated":"2017-10-23T13:23:34.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5r001bv0v5zdjrz3s9","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13004291\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13004291</a></p>\n</blockquote>\n<h2 id=\"static代表着什么\"><a href=\"#static代表着什么\" class=\"headerlink\" title=\"static代表着什么\"></a>static代表着什么</h2><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。<br>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。<br><a id=\"more\"></a><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> userNumber  = <span class=\"number\">0</span> ;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        userNumber ++;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"user1 userNumber：\"</span> + User.userNumber);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"user2 userNumber：\"</span> + User.userNumber);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;      </div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">user1 userNumber：<span class=\"number\">2</span>  </div><div class=\"line\">user2 userNumber：<span class=\"number\">2</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"怎么使用static\"><a href=\"#怎么使用static\" class=\"headerlink\" title=\"怎么使用static\"></a>怎么使用static</h2><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。<br>ClassName..propertyName<br>ClassName.methodName(……)<br>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）</p>\n<h3 id=\"static变量\"><a href=\"#static变量\" class=\"headerlink\" title=\"static变量\"></a>static变量</h3><p>static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。<br>但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。<br>所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。</p>\n<h3 id=\"static方法\"><a href=\"#static方法\" class=\"headerlink\" title=\"static方法\"></a>static方法</h3><p>static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。<br>Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p>\n<h3 id=\"static代码块\"><a href=\"#static代码块\" class=\"headerlink\" title=\"static代码块\"></a>static代码块</h3><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。</p>\n<h2 id=\"Static的局限\"><a href=\"#Static的局限\" class=\"headerlink\" title=\"Static的局限\"></a>Static的局限</h2><p>Static确实是存在诸多的作用，但是它也存在一些缺陷。</p>\n<pre><code>1、它只能调用static变量。\n2、它只能调用static方法。\n3、不能以任何形式引用this、super。\n4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n</code></pre><p>总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13004291\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13004291</a></p>\n</blockquote>\n<h2 id=\"static代表着什么\"><a href=\"#static代表着什么\" class=\"headerlink\" title=\"static代表着什么\"></a>static代表着什么</h2><p>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。<br>Java把内存分为栈内存和堆内存，其中栈内存用来存放一些基本类型的变量、数组和对象的引用，堆内存主要存放一些对象。在JVM加载一个类的时候，若该类存在static修饰的成员变量和成员方法，则会为这些成员变量和成员方法在固定的位置开辟一个固定大小的内存区域，有了这些“固定”的特性，那么JVM就可以非常方便地访问他们。同时如果静态的成员变量和成员方法不出作用域的话，它们的句柄都会保持不变。同时static所蕴含“静态”的概念表示着它是不可恢复的，即在那个地方，你修改了，他是不会变回原样的，你清理了，他就不会回来了。<br>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。<br>","more":"<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> userNumber  = <span class=\"number\">0</span> ;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        userNumber ++;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(<span class=\"string\">\"user1 userNumber：\"</span> + User.userNumber);  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"user2 userNumber：\"</span> + User.userNumber);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;      </div><div class=\"line\">------------  </div><div class=\"line\">Output:  </div><div class=\"line\">user1 userNumber：<span class=\"number\">2</span>  </div><div class=\"line\">user2 userNumber：<span class=\"number\">2</span></div></pre></td></tr></table></figure></p>\n<h2 id=\"怎么使用static\"><a href=\"#怎么使用static\" class=\"headerlink\" title=\"怎么使用static\"></a>怎么使用static</h2><p>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。<br>ClassName..propertyName<br>ClassName.methodName(……)<br>Static修饰的代码块表示静态代码块，当JVM装载类的时候，就会执行这块代码，其用处非常大。（对于代码块的使用这几天介绍，敬请关注）</p>\n<h3 id=\"static变量\"><a href=\"#static变量\" class=\"headerlink\" title=\"static变量\"></a>static变量</h3><p>static修饰的变量我们称之为静态变量，没有用static修饰的变量称之为实例变量，他们两者的区别是：<br>静态变量是随着类加载时被完成初始化的，它在内存中仅有一个，且JVM也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。<br>但是实例变量则不同，它是伴随着实例的，每创建一个实例就会产生一个实例变量，它与该实例同生共死。<br>所以我们一般在这两种情况下使用静态变量：对象之间共享数据、访问方便。</p>\n<h3 id=\"static方法\"><a href=\"#static方法\" class=\"headerlink\" title=\"static方法\"></a>static方法</h3><p>static修饰的方法我们称之为静态方法，我们通过类名对其进行直接调用。由于他在类加载的时候就存在了，它不依赖于任何实例，所以static方法必须实现，也就是说他不能是抽象方法abstract。<br>Static方法是类中的一种特殊方法，我们只有在真正需要他们的时候才会将方法声明为static。如Math类的所有方法都是静态static的。</p>\n<h3 id=\"static代码块\"><a href=\"#static代码块\" class=\"headerlink\" title=\"static代码块\"></a>static代码块</h3><p>被static修饰的代码块，我们称之为静态代码块，静态代码块会随着类的加载一块执行，而且他可以随意放，可以存在于该了的任何地方。</p>\n<h2 id=\"Static的局限\"><a href=\"#Static的局限\" class=\"headerlink\" title=\"Static的局限\"></a>Static的局限</h2><p>Static确实是存在诸多的作用，但是它也存在一些缺陷。</p>\n<pre><code>1、它只能调用static变量。\n2、它只能调用static方法。\n3、不能以任何形式引用this、super。\n4、static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。\n</code></pre><p>总结：<font color=\"#3366ff\">无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</font></p>"},{"title":"java提高篇（五）-----使用序列化实现对象的拷贝","date":"2017-10-23T05:22:02.000Z","_content":"\n> 转载： [http://blog.csdn.net/chenssy/article/details/12952063](http://blog.csdn.net/chenssy/article/details/12952063)\n\n我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝\n## 浅拷贝问题\n我们先看如下代码：\n```java\n    public class Person implements Cloneable{  \n        /** 姓名 **/  \n        private String name;  \n        \n        /** 电子邮件 **/  \n        private Email email;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Email getEmail() {  \n            return email;  \n        }  \n    \n        public void setEmail(Email email) {  \n            this.email = email;  \n        }  \n        \n        public Person(String name,Email email){  \n            this.name  = name;  \n            this.email = email;  \n        }  \n        \n        public Person(String name){  \n            this.name = name;  \n        }  \n    \n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        }  \n    }  \n    \n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    --------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:30到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议...  \n```\n\n<!-- more -->\n\n在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n```\n在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议...。但是结果是：\n```java\n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:00到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:00到二会议室参加会议...  \n```\n这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！\n其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：\n1、 基本类型\n    如果变量是基本很类型，则拷贝其值，比如int、float等。\n2、 对象\n    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。\n3、 String字符串\n    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。\n对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：\n```java\n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n                person.setEmail(new Email(person.getEmail().getObject(),person.getEmail().getContent()));  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        } \n```\n所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。\n对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。\n## 利用序列化实现对象的拷贝\n如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```java\n    public class CloneUtils {  \n        @SuppressWarnings(\"unchecked\")  \n        public static <T extends Serializable> T clone(T obj){  \n            T cloneObj = null;  \n            try {  \n                //写入字节流  \n                ByteArrayOutputStream out = new ByteArrayOutputStream();  \n                ObjectOutputStream obs = new ObjectOutputStream(out);  \n                obs.writeObject(obj);  \n                obs.close();  \n                \n                //分配内存，写入原始对象，生成新对象  \n                ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());  \n                ObjectInputStream ois = new ObjectInputStream(ios);  \n                //返回生成的新对象  \n                cloneObj = (T) ois.readObject();  \n                ois.close();  \n            } catch (Exception e) {  \n                e.printStackTrace();  \n            }  \n            return cloneObj;  \n        }  \n    }  \n```\n使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。\n```java\n    public class Person implements Serializable{  \n        private static final long serialVersionUID = 2631590509760908280L;  \n    \n        ..................  \n        //去除clone()方法  \n    \n    }  \n    \n    public class Email implements Serializable{  \n        private static final long serialVersionUID = 1267293988171991494L;  \n        \n        ....................  \n    }  \n```\n所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  CloneUtils.clone(person1);  \n            person2.setName(\"李四\");  \n            Person person3 =  CloneUtils.clone(person1);  \n            person3.setName(\"王五\");  \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    -------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议... \n```","source":"_posts/java-toup6.md","raw":"---\ntitle: java提高篇（五）-----使用序列化实现对象的拷贝\ndate: 2017-10-23 13:22:02\ntags: [java,转载]\ncategories: java开发\n---\n\n> 转载： [http://blog.csdn.net/chenssy/article/details/12952063](http://blog.csdn.net/chenssy/article/details/12952063)\n\n我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝\n## 浅拷贝问题\n我们先看如下代码：\n```java\n    public class Person implements Cloneable{  \n        /** 姓名 **/  \n        private String name;  \n        \n        /** 电子邮件 **/  \n        private Email email;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public Email getEmail() {  \n            return email;  \n        }  \n    \n        public void setEmail(Email email) {  \n            this.email = email;  \n        }  \n        \n        public Person(String name,Email email){  \n            this.name  = name;  \n            this.email = email;  \n        }  \n        \n        public Person(String name){  \n            this.name = name;  \n        }  \n    \n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        }  \n    }  \n    \n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    --------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:30到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议...  \n```\n\n<!-- more -->\n\n在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  person1.clone();  \n            person2.setName(\"李四\");  \n            Person person3 =  person1.clone();  \n            person3.setName(\"王五\");  \n            \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n```\n在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议...。但是结果是：\n```java\n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:00到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:00到二会议室参加会议...  \n```\n这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！\n其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：\n1、 基本类型\n    如果变量是基本很类型，则拷贝其值，比如int、float等。\n2、 对象\n    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。\n3、 String字符串\n    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。\n对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：\n```java\n        protected Person clone() {  \n            Person person = null;  \n            try {  \n                person = (Person) super.clone();  \n                person.setEmail(new Email(person.getEmail().getObject(),person.getEmail().getContent()));  \n            } catch (CloneNotSupportedException e) {  \n                e.printStackTrace();  \n            }  \n            \n            return person;  \n        } \n```\n所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。\n对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。\n## 利用序列化实现对象的拷贝\n如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。\n```java\n    public class CloneUtils {  \n        @SuppressWarnings(\"unchecked\")  \n        public static <T extends Serializable> T clone(T obj){  \n            T cloneObj = null;  \n            try {  \n                //写入字节流  \n                ByteArrayOutputStream out = new ByteArrayOutputStream();  \n                ObjectOutputStream obs = new ObjectOutputStream(out);  \n                obs.writeObject(obj);  \n                obs.close();  \n                \n                //分配内存，写入原始对象，生成新对象  \n                ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());  \n                ObjectInputStream ois = new ObjectInputStream(ios);  \n                //返回生成的新对象  \n                cloneObj = (T) ois.readObject();  \n                ois.close();  \n            } catch (Exception e) {  \n                e.printStackTrace();  \n            }  \n            return cloneObj;  \n        }  \n    }  \n```\n使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。\n```java\n    public class Person implements Serializable{  \n        private static final long serialVersionUID = 2631590509760908280L;  \n    \n        ..................  \n        //去除clone()方法  \n    \n    }  \n    \n    public class Email implements Serializable{  \n        private static final long serialVersionUID = 1267293988171991494L;  \n        \n        ....................  \n    }  \n```\n所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。\n```java\n    public class Client {  \n        public static void main(String[] args) {  \n            //写封邮件  \n            Email email = new Email(\"请参加会议\",\"请与今天12:30到二会议室参加会议...\");  \n            \n            Person person1 =  new Person(\"张三\",email);  \n            \n            Person person2 =  CloneUtils.clone(person1);  \n            person2.setName(\"李四\");  \n            Person person3 =  CloneUtils.clone(person1);  \n            person3.setName(\"王五\");  \n            person1.getEmail().setContent(\"请与今天12:00到二会议室参加会议...\");  \n            \n            System.out.println(person1.getName() + \"的邮件内容是：\" + person1.getEmail().getContent());  \n            System.out.println(person2.getName() + \"的邮件内容是：\" + person2.getEmail().getContent());  \n            System.out.println(person3.getName() + \"的邮件内容是：\" + person3.getEmail().getContent());  \n        }  \n    }  \n    -------------------  \n    Output:  \n    张三的邮件内容是：请与今天12:00到二会议室参加会议...  \n    李四的邮件内容是：请与今天12:30到二会议室参加会议...  \n    王五的邮件内容是：请与今天12:30到二会议室参加会议... \n```","slug":"java-toup6","published":1,"updated":"2017-10-23T13:23:34.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5u001fv0v54uqquedl","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12952063</a></p>\n</blockquote>\n<p>我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝</p>\n<h2 id=\"浅拷贝问题\"><a href=\"#浅拷贝问题\" class=\"headerlink\" title=\"浅拷贝问题\"></a>浅拷贝问题</h2><p>我们先看如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** 姓名 **/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 电子邮件 **/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Email email;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Email <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(Email email)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name,Email email)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name  = name;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        Person person = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            person = (Person) <span class=\"keyword\">super</span>.clone();  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> person;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  person1.clone();  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  person1.clone();  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  person1.clone();  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  person1.clone();  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>\n<p>这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！<br>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：<br>1、 基本类型<br>    如果变量是基本很类型，则拷贝其值，比如int、float等。<br>2、 对象<br>    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。<br>3、 String字符串<br>    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。<br>对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    Person person = <span class=\"keyword\">null</span>;  </div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">        person = (Person) <span class=\"keyword\">super</span>.clone();  </div><div class=\"line\">        person.setEmail(<span class=\"keyword\">new</span> Email(person.getEmail().getObject(),person.getEmail().getContent()));  </div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </div><div class=\"line\">        e.printStackTrace();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> person;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。<br>对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。</p>\n<h2 id=\"利用序列化实现对象的拷贝\"><a href=\"#利用序列化实现对象的拷贝\" class=\"headerlink\" title=\"利用序列化实现对象的拷贝\"></a>利用序列化实现对象的拷贝</h2><p>如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneUtils</span> </span>&#123;  </div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Serializable&gt; <span class=\"function\">T <span class=\"title\">clone</span><span class=\"params\">(T obj)</span></span>&#123;  </div><div class=\"line\">        T cloneObj = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            <span class=\"comment\">//写入字节流  </span></div><div class=\"line\">            ByteArrayOutputStream out = <span class=\"keyword\">new</span> ByteArrayOutputStream();  </div><div class=\"line\">            ObjectOutputStream obs = <span class=\"keyword\">new</span> ObjectOutputStream(out);  </div><div class=\"line\">            obs.writeObject(obj);  </div><div class=\"line\">            obs.close();  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">//分配内存，写入原始对象，生成新对象  </span></div><div class=\"line\">            ByteArrayInputStream ios = <span class=\"keyword\">new</span> ByteArrayInputStream(out.toByteArray());  </div><div class=\"line\">            ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(ios);  </div><div class=\"line\">            <span class=\"comment\">//返回生成的新对象  </span></div><div class=\"line\">            cloneObj = (T) ois.readObject();  </div><div class=\"line\">            ois.close();  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> cloneObj;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2631590509760908280L</span>;  </div><div class=\"line\"></div><div class=\"line\">    ..................  </div><div class=\"line\">    <span class=\"comment\">//去除clone()方法  </span></div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1267293988171991494L</span>;  </div><div class=\"line\">    </div><div class=\"line\">    ....................  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  CloneUtils.clone(person1);  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  CloneUtils.clone(person1);  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/12952063\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/12952063</a></p>\n</blockquote>\n<p>我们知道在Java中存在这个接口Cloneable，实现该接口的类都会具备被拷贝的能力，同时拷贝是在内存中进行，在性能方面比我们直接通过new生成对象来的快，特别是在大对象的生成上，使得性能的提升非常明显。然而我们知道拷贝分为深拷贝和浅拷贝之分，但是浅拷贝存在对象属性拷贝不彻底问题。关于深拷贝、浅拷贝的请参考这里：渐析java的浅拷贝和深拷贝</p>\n<h2 id=\"浅拷贝问题\"><a href=\"#浅拷贝问题\" class=\"headerlink\" title=\"浅拷贝问题\"></a>浅拷贝问题</h2><p>我们先看如下代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;  </div><div class=\"line\">    <span class=\"comment\">/** 姓名 **/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** 电子邮件 **/</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> Email email;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Email <span class=\"title\">getEmail</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setEmail</span><span class=\"params\">(Email email)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name,Email email)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name  = name;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.email = email;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(String name)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        Person person = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            person = (Person) <span class=\"keyword\">super</span>.clone();  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> person;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  person1.clone();  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  person1.clone();  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>","more":"<p>在该应用程序中，首先定义一封邮件，然后将该邮件发给张三、李四、王五三个人，由于他们是使用相同的邮件，并且仅有名字不同，所以使用张三该对象类拷贝李四、王五对象然后更改下名字即可。程序一直到这里都没有错，但是如果我们需要张三提前30分钟到，即把邮件的内容修改下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  person1.clone();  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  person1.clone();  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里同样是使用张三该对象实现对李四、王五拷贝，最后将张三的邮件内容改变为：请与今天12:00到二会议室参加会议…。但是结果是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>\n<p>这里我们就疑惑了为什么李四和王五的邮件内容也发送了改变呢？让他们提前30分钟到人家会有意见的！<br>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：<br>1、 基本类型<br>    如果变量是基本很类型，则拷贝其值，比如int、float等。<br>2、 对象<br>    如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。<br>3、 String字符串<br>    若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有紫都城对象保持不变。基于上面上面的规则，我们很容易发现问题的所在，他们三者公用一个对象，张三修改了该邮件内容，则李四和王五也会修改，所以才会出现上面的情况。<br>对于这种情况我们还是可以解决的，只需要在clone()方法里面新建一个对象，然后张三引用该对象即可：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Person <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    Person person = <span class=\"keyword\">null</span>;  </div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">        person = (Person) <span class=\"keyword\">super</span>.clone();  </div><div class=\"line\">        person.setEmail(<span class=\"keyword\">new</span> Email(person.getEmail().getObject(),person.getEmail().getContent()));  </div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;  </div><div class=\"line\">        e.printStackTrace();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> person;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以：浅拷贝只是Java提供的一种简单的拷贝机制，不便于直接使用。<br>对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用序列化来实现对象的拷贝。</p>\n<h2 id=\"利用序列化实现对象的拷贝\"><a href=\"#利用序列化实现对象的拷贝\" class=\"headerlink\" title=\"利用序列化实现对象的拷贝\"></a>利用序列化实现对象的拷贝</h2><p>如何利用序列化来完成对象的拷贝呢？在内存中通过字节流的拷贝是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneUtils</span> </span>&#123;  </div><div class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T extends Serializable&gt; <span class=\"function\">T <span class=\"title\">clone</span><span class=\"params\">(T obj)</span></span>&#123;  </div><div class=\"line\">        T cloneObj = <span class=\"keyword\">null</span>;  </div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;  </div><div class=\"line\">            <span class=\"comment\">//写入字节流  </span></div><div class=\"line\">            ByteArrayOutputStream out = <span class=\"keyword\">new</span> ByteArrayOutputStream();  </div><div class=\"line\">            ObjectOutputStream obs = <span class=\"keyword\">new</span> ObjectOutputStream(out);  </div><div class=\"line\">            obs.writeObject(obj);  </div><div class=\"line\">            obs.close();  </div><div class=\"line\">            </div><div class=\"line\">            <span class=\"comment\">//分配内存，写入原始对象，生成新对象  </span></div><div class=\"line\">            ByteArrayInputStream ios = <span class=\"keyword\">new</span> ByteArrayInputStream(out.toByteArray());  </div><div class=\"line\">            ObjectInputStream ois = <span class=\"keyword\">new</span> ObjectInputStream(ios);  </div><div class=\"line\">            <span class=\"comment\">//返回生成的新对象  </span></div><div class=\"line\">            cloneObj = (T) ois.readObject();  </div><div class=\"line\">            ois.close();  </div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> cloneObj;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2631590509760908280L</span>;  </div><div class=\"line\"></div><div class=\"line\">    ..................  </div><div class=\"line\">    <span class=\"comment\">//去除clone()方法  </span></div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span></span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1267293988171991494L</span>;  </div><div class=\"line\">    </div><div class=\"line\">    ....................  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"comment\">//写封邮件  </span></div><div class=\"line\">        Email email = <span class=\"keyword\">new</span> Email(<span class=\"string\">\"请参加会议\"</span>,<span class=\"string\">\"请与今天12:30到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        Person person1 =  <span class=\"keyword\">new</span> Person(<span class=\"string\">\"张三\"</span>,email);  </div><div class=\"line\">        </div><div class=\"line\">        Person person2 =  CloneUtils.clone(person1);  </div><div class=\"line\">        person2.setName(<span class=\"string\">\"李四\"</span>);  </div><div class=\"line\">        Person person3 =  CloneUtils.clone(person1);  </div><div class=\"line\">        person3.setName(<span class=\"string\">\"王五\"</span>);  </div><div class=\"line\">        person1.getEmail().setContent(<span class=\"string\">\"请与今天12:00到二会议室参加会议...\"</span>);  </div><div class=\"line\">        </div><div class=\"line\">        System.out.println(person1.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person1.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person2.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person2.getEmail().getContent());  </div><div class=\"line\">        System.out.println(person3.getName() + <span class=\"string\">\"的邮件内容是：\"</span> + person3.getEmail().getContent());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">张三的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">00</span>到二会议室参加会议...  </div><div class=\"line\">李四的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...  </div><div class=\"line\">王五的邮件内容是：请与今天<span class=\"number\">12</span>:<span class=\"number\">30</span>到二会议室参加会议...</div></pre></td></tr></table></figure></p>"},{"title":"java提高篇（七）-----详解内部类","date":"2017-10-23T05:38:12.000Z","_content":"> 转载：http://blog.csdn.net/chenssy/article/details/13024951\n\n可以将一个类的定义放在另一个类的定义内部，这就是内部类。\n内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。\n第一次见面\n内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。\n```java\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            this.age = age;  \n        }  \n        \n        class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n        }  \n    }  \n```\n在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。\n<!-- more -->\n\n## 为什么要使用内部类\n为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n```java\n\n    public interface Father {  \n    \n    }  \n    \n    public interface Mother {  \n    \n    }  \n    \n    public class Son implements Father, Mother {  \n    \n    }  \n    \n    public class Daughter implements Father{  \n    \n        class Mother_ implements Mother{  \n            \n        }  \n    }  \n```\n\n其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。\n其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n   \n    1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n    2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n    3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n    4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n    5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 内部类基础\n在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。\n当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。\n```java\n\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        /**省略getter和setter方法**/  \n        \n        public class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n            \n            public void display(){  \n                System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.display();  \n        }  \n    }  \n    --------------  \n    Output：  \n    name：chenssy   ;age：23  \n```\n\n在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。\n其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。\n同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。\n```java\n    public class OuterClass {  \n        public void display(){  \n            System.out.println(\"OuterClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public OuterClass getOuterClass(){  \n                return OuterClass.this;  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.getOuterClass().display();  \n        }  \n    }  \n    -------------  \n    Output:  \n    OuterClass...  \n```\n到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。\n在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。\n\n## 成员内部类\n成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n```java\n    public class OuterClass {  \n        private String str;  \n        \n        public void outerDisplay(){  \n            System.out.println(\"outerClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public void innerDisplay(){  \n                //使用外围内的属性  \n                str = \"chenssy...\";  \n                System.out.println(str);  \n                //使用外围内的方法  \n                outerDisplay();  \n            }  \n        }  \n        \n        /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */  \n        public InnerClass getInnerClass(){  \n            return new InnerClass();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            OuterClass.InnerClass inner = outer.getInnerClass();  \n            inner.innerDisplay();  \n        }  \n    }  \n    --------------------  \n    chenssy...  \n    outerClass...  \n```\n推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。\n\n## 局部内部类\n有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\n对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。\n定义在方法里：\n```java\n    public class Parcel5 {  \n        public Destionation destionation(String str){  \n            class PDestionation implements Destionation{  \n                private String label;  \n                private PDestionation(String whereTo){  \n                    label = whereTo;  \n                }  \n                public String readLabel(){  \n                    return label;  \n                }  \n            }  \n            return new PDestionation(str);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel5 parcel5 = new Parcel5();  \n            Destionation d = parcel5.destionation(\"chenssy\");  \n        }  \n    }  \n```\n定义在作用域内:\n```java\n    public class Parcel6 {  \n        private void internalTracking(boolean b){  \n            if(b){  \n                class TrackingSlip{  \n                    private String id;  \n                    TrackingSlip(String s) {  \n                        id = s;  \n                    }  \n                    String getSlip(){  \n                        return id;  \n                    }  \n                }  \n                TrackingSlip ts = new TrackingSlip(\"chenssy\");  \n                String string = ts.getSlip();  \n            }  \n        }  \n        \n        public void track(){  \n            internalTracking(true);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel6 parcel6 = new Parcel6();  \n            parcel6.track();  \n        }  \n    }  \n```\n## 匿名内部类\n在做Swing编程中，我们经常使用这种方式来绑定事件\n```java\n    button2.addActionListener(    \n                    new ActionListener(){    \n                        public void actionPerformed(ActionEvent e) {    \n                            System.out.println(\"你按了按钮二\");    \n                        }    \n                    });  \n```\n        我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n```java\n    public class OuterClass {  \n        public InnerClass getInnerClass(final int num,String str2){  \n            return new InnerClass(){  \n                int number = num + 3;  \n                public int getNumber(){  \n                    return number;  \n                }  \n            };        /* 注意：分号不能省 */  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass out = new OuterClass();  \n            InnerClass inner = out.getInnerClass(2, \"chenssy\");  \n            System.out.println(inner.getNumber());  \n        }  \n    }  \n    \n    interface InnerClass {  \n        int getNumber();  \n    }  \n    \n    ----------------  \n    Output:  \n    5  \n```\n这里我们就需要看清几个地方\n1、 匿名内部类是没有访问修饰符的。\n2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\nPS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇-----详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……\n\n## 静态内部类\n在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：\n1、 它的创建是不需要依赖于外围类的。\n2、 它不能使用任何外围类的非static成员变量和方法。\n```java\n    public class OuterClass {  \n        private String sex;  \n        public static String name = \"chenssy\";  \n        \n        /** \n        *静态内部类 \n        */  \n        static class InnerClass1{  \n            /* 在静态内部类中可以存在静态成员 */  \n            public static String _name1 = \"chenssy_static\";  \n            \n            public void display(){  \n                /*  \n                * 静态内部类只能访问外围类的静态成员变量和方法 \n                * 不能访问外围类的非静态成员变量和方法 \n                */  \n                System.out.println(\"OutClass name :\" + name);  \n            }  \n        }  \n        \n        /** \n        * 非静态内部类 \n        */  \n        class InnerClass2{  \n            /* 非静态内部类中不能存在静态成员 */  \n            public String _name2 = \"chenssy_inner\";  \n            /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */  \n            public void display(){  \n                System.out.println(\"OuterClass name：\" + name);  \n            }  \n        }  \n        \n        /** \n        * @desc 外围类方法 \n        * @author chenssy \n        * @data 2013-10-25 \n        * @return void \n        */  \n        public void display(){  \n            /* 外围类访问静态内部类：内部类. */  \n            System.out.println(InnerClass1._name1);  \n            /* 静态内部类 可以直接创建实例不需要依赖于外围类 */  \n            new InnerClass1().display();  \n            \n            /* 非静态内部的创建需要依赖于外围类 */  \n            OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();  \n            /* 方位非静态内部类的成员需要使用非静态内部类的实例 */  \n            System.out.println(inner2._name2);  \n            inner2.display();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            outer.display();  \n        }  \n    }  \n    ----------------  \n    Output:  \n    chenssy_static  \n    OutClass name :chenssy  \n    chenssy_inner  \n    OuterClass name：chenssy  \n```\n上面这个例子充分展现了静态内部类和非静态内部类的区别。\n到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!\n","source":"_posts/java-toup8.md","raw":"---\ntitle: java提高篇（七）-----详解内部类\ndate: 2017-10-23 13:38:12\ntags: [java,转载]\ncategories: java开发\n---\n> 转载：http://blog.csdn.net/chenssy/article/details/13024951\n\n可以将一个类的定义放在另一个类的定义内部，这就是内部类。\n内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。\n第一次见面\n内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。\n```java\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        public String getName() {  \n            return name;  \n        }  \n    \n        public void setName(String name) {  \n            this.name = name;  \n        }  \n    \n        public int getAge() {  \n            return age;  \n        }  \n    \n        public void setAge(int age) {  \n            this.age = age;  \n        }  \n        \n        class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n        }  \n    }  \n```\n在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。\n<!-- more -->\n\n## 为什么要使用内部类\n为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。\n在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。\n```java\n\n    public interface Father {  \n    \n    }  \n    \n    public interface Mother {  \n    \n    }  \n    \n    public class Son implements Father, Mother {  \n    \n    }  \n    \n    public class Daughter implements Father{  \n    \n        class Mother_ implements Mother{  \n            \n        }  \n    }  \n```\n\n其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。\n其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：\n   \n    1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n    2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n    3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n    4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n    5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n\n## 内部类基础\n在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。\n当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。\n```java\n\n    public class OuterClass {  \n        private String name ;  \n        private int age;  \n    \n        /**省略getter和setter方法**/  \n        \n        public class InnerClass{  \n            public InnerClass(){  \n                name = \"chenssy\";  \n                age = 23;  \n            }  \n            \n            public void display(){  \n                System.out.println(\"name：\" + getName() +\"   ;age：\" + getAge());  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.display();  \n        }  \n    }  \n    --------------  \n    Output：  \n    name：chenssy   ;age：23  \n```\n\n在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。\n其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。\n同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。\n```java\n    public class OuterClass {  \n        public void display(){  \n            System.out.println(\"OuterClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public OuterClass getOuterClass(){  \n                return OuterClass.this;  \n            }  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outerClass = new OuterClass();  \n            OuterClass.InnerClass innerClass = outerClass.new InnerClass();  \n            innerClass.getOuterClass().display();  \n        }  \n    }  \n    -------------  \n    Output:  \n    OuterClass...  \n```\n到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。\n在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。\n\n## 成员内部类\n成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。\n在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。\n```java\n    public class OuterClass {  \n        private String str;  \n        \n        public void outerDisplay(){  \n            System.out.println(\"outerClass...\");  \n        }  \n        \n        public class InnerClass{  \n            public void innerDisplay(){  \n                //使用外围内的属性  \n                str = \"chenssy...\";  \n                System.out.println(str);  \n                //使用外围内的方法  \n                outerDisplay();  \n            }  \n        }  \n        \n        /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */  \n        public InnerClass getInnerClass(){  \n            return new InnerClass();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            OuterClass.InnerClass inner = outer.getInnerClass();  \n            inner.innerDisplay();  \n        }  \n    }  \n    --------------------  \n    chenssy...  \n    outerClass...  \n```\n推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。\n\n## 局部内部类\n有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。\n对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。\n定义在方法里：\n```java\n    public class Parcel5 {  \n        public Destionation destionation(String str){  \n            class PDestionation implements Destionation{  \n                private String label;  \n                private PDestionation(String whereTo){  \n                    label = whereTo;  \n                }  \n                public String readLabel(){  \n                    return label;  \n                }  \n            }  \n            return new PDestionation(str);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel5 parcel5 = new Parcel5();  \n            Destionation d = parcel5.destionation(\"chenssy\");  \n        }  \n    }  \n```\n定义在作用域内:\n```java\n    public class Parcel6 {  \n        private void internalTracking(boolean b){  \n            if(b){  \n                class TrackingSlip{  \n                    private String id;  \n                    TrackingSlip(String s) {  \n                        id = s;  \n                    }  \n                    String getSlip(){  \n                        return id;  \n                    }  \n                }  \n                TrackingSlip ts = new TrackingSlip(\"chenssy\");  \n                String string = ts.getSlip();  \n            }  \n        }  \n        \n        public void track(){  \n            internalTracking(true);  \n        }  \n        \n        public static void main(String[] args) {  \n            Parcel6 parcel6 = new Parcel6();  \n            parcel6.track();  \n        }  \n    }  \n```\n## 匿名内部类\n在做Swing编程中，我们经常使用这种方式来绑定事件\n```java\n    button2.addActionListener(    \n                    new ActionListener(){    \n                        public void actionPerformed(ActionEvent e) {    \n                            System.out.println(\"你按了按钮二\");    \n                        }    \n                    });  \n```\n        我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n```java\n    public class OuterClass {  \n        public InnerClass getInnerClass(final int num,String str2){  \n            return new InnerClass(){  \n                int number = num + 3;  \n                public int getNumber(){  \n                    return number;  \n                }  \n            };        /* 注意：分号不能省 */  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass out = new OuterClass();  \n            InnerClass inner = out.getInnerClass(2, \"chenssy\");  \n            System.out.println(inner.getNumber());  \n        }  \n    }  \n    \n    interface InnerClass {  \n        int getNumber();  \n    }  \n    \n    ----------------  \n    Output:  \n    5  \n```\n这里我们就需要看清几个地方\n1、 匿名内部类是没有访问修饰符的。\n2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。\n3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。\n4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。\nPS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇-----详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……\n\n## 静态内部类\n在java提高篇-----关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：\n1、 它的创建是不需要依赖于外围类的。\n2、 它不能使用任何外围类的非static成员变量和方法。\n```java\n    public class OuterClass {  \n        private String sex;  \n        public static String name = \"chenssy\";  \n        \n        /** \n        *静态内部类 \n        */  \n        static class InnerClass1{  \n            /* 在静态内部类中可以存在静态成员 */  \n            public static String _name1 = \"chenssy_static\";  \n            \n            public void display(){  \n                /*  \n                * 静态内部类只能访问外围类的静态成员变量和方法 \n                * 不能访问外围类的非静态成员变量和方法 \n                */  \n                System.out.println(\"OutClass name :\" + name);  \n            }  \n        }  \n        \n        /** \n        * 非静态内部类 \n        */  \n        class InnerClass2{  \n            /* 非静态内部类中不能存在静态成员 */  \n            public String _name2 = \"chenssy_inner\";  \n            /* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */  \n            public void display(){  \n                System.out.println(\"OuterClass name：\" + name);  \n            }  \n        }  \n        \n        /** \n        * @desc 外围类方法 \n        * @author chenssy \n        * @data 2013-10-25 \n        * @return void \n        */  \n        public void display(){  \n            /* 外围类访问静态内部类：内部类. */  \n            System.out.println(InnerClass1._name1);  \n            /* 静态内部类 可以直接创建实例不需要依赖于外围类 */  \n            new InnerClass1().display();  \n            \n            /* 非静态内部的创建需要依赖于外围类 */  \n            OuterClass.InnerClass2 inner2 = new OuterClass().new InnerClass2();  \n            /* 方位非静态内部类的成员需要使用非静态内部类的实例 */  \n            System.out.println(inner2._name2);  \n            inner2.display();  \n        }  \n        \n        public static void main(String[] args) {  \n            OuterClass outer = new OuterClass();  \n            outer.display();  \n        }  \n    }  \n    ----------------  \n    Output:  \n    chenssy_static  \n    OutClass name :chenssy  \n    chenssy_inner  \n    OuterClass name：chenssy  \n```\n上面这个例子充分展现了静态内部类和非静态内部类的区别。\n到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!\n","slug":"java-toup8","published":1,"updated":"2017-10-23T13:23:34.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp5y001iv0v5pyicvtn3","content":"<blockquote>\n<p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/13024951\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13024951</a></p>\n</blockquote>\n<p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。<br>内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。<br>第一次见面<br>内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">            age = <span class=\"number\">23</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。<br><a id=\"more\"></a></p>\n<h2 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h2><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p>\n<pre><code>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n</code></pre><h2 id=\"内部类基础\"><a href=\"#内部类基础\" class=\"headerlink\" title=\"内部类基础\"></a>内部类基础</h2><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**省略getter和setter方法**/</span>  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">            age = <span class=\"number\">23</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"name：\"</span> + getName() +<span class=\"string\">\"   ;age：\"</span> + getAge());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class=\"line\">        innerClass.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------  </div><div class=\"line\">Output：  </div><div class=\"line\">name：chenssy   ;age：<span class=\"number\">23</span></div></pre></td></tr></table></figure></p>\n<p>在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。<br>同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"OuterClass...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> OuterClass <span class=\"title\">getOuterClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> OuterClass.<span class=\"keyword\">this</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class=\"line\">        innerClass.getOuterClass().display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------  </div><div class=\"line\">Output:  </div><div class=\"line\">OuterClass...</div></pre></td></tr></table></figure></p>\n<p>到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String str;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">outerDisplay</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"outerClass...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerDisplay</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"comment\">//使用外围内的属性  </span></div><div class=\"line\">            str = <span class=\"string\">\"chenssy...\"</span>;  </div><div class=\"line\">            System.out.println(str);  </div><div class=\"line\">            <span class=\"comment\">//使用外围内的方法  </span></div><div class=\"line\">            outerDisplay();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass inner = outer.getInnerClass();  </div><div class=\"line\">        inner.innerDisplay();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------------  </div><div class=\"line\">chenssy...  </div><div class=\"line\">outerClass...</div></pre></td></tr></table></figure></p>\n<p>推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。<br>定义在方法里：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel5</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destionation <span class=\"title\">destionation</span><span class=\"params\">(String str)</span></span>&#123;  </div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PDestionation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Destionation</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">private</span> String label;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PDestionation</span><span class=\"params\">(String whereTo)</span></span>&#123;  </div><div class=\"line\">                label = whereTo;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> label;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PDestionation(str);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Parcel5 parcel5 = <span class=\"keyword\">new</span> Parcel5();  </div><div class=\"line\">        Destionation d = parcel5.destionation(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>定义在作用域内:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel6</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">internalTracking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(b)&#123;  </div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackingSlip</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">private</span> String id;  </div><div class=\"line\">                TrackingSlip(String s) &#123;  </div><div class=\"line\">                    id = s;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"function\">String <span class=\"title\">getSlip</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> id;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            TrackingSlip ts = <span class=\"keyword\">new</span> TrackingSlip(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">            String string = ts.getSlip();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">track</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        internalTracking(<span class=\"keyword\">true</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Parcel6 parcel6 = <span class=\"keyword\">new</span> Parcel6();  </div><div class=\"line\">        parcel6.track();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button2.addActionListener(    </div><div class=\"line\">                <span class=\"keyword\">new</span> ActionListener()&#123;    </div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent e)</span> </span>&#123;    </div><div class=\"line\">                        System.out.println(<span class=\"string\">\"你按了按钮二\"</span>);    </div><div class=\"line\">                    &#125;    </div><div class=\"line\">                &#125;);</div></pre></td></tr></table></figure></p>\n<pre><code>我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num,String str2)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass()&#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> number = num + <span class=\"number\">3</span>;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> number;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;;        <span class=\"comment\">/* 注意：分号不能省 */</span>  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass out = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        InnerClass inner = out.getInnerClass(<span class=\"number\">2</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner.getNumber());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InnerClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">----------------  </div><div class=\"line\">Output:  </div><div class=\"line\"><span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>这里我们就需要看清几个地方<br>1、 匿名内部类是没有访问修饰符的。<br>2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。<br>PS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇—–详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……</p>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>在java提高篇—–关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：<br>1、 它的创建是不需要依赖于外围类的。<br>2、 它不能使用任何外围类的非static成员变量和方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    *静态内部类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass1</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 在静态内部类中可以存在静态成员 */</span>  </div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String _name1 = <span class=\"string\">\"chenssy_static\"</span>;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"comment\">/*  </span></div><div class=\"line\"><span class=\"comment\">            * 静态内部类只能访问外围类的静态成员变量和方法 </span></div><div class=\"line\"><span class=\"comment\">            * 不能访问外围类的非静态成员变量和方法 </span></div><div class=\"line\"><span class=\"comment\">            */</span>  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"OutClass name :\"</span> + name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 非静态内部类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass2</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部类中不能存在静态成员 */</span>  </div><div class=\"line\">        <span class=\"keyword\">public</span> String _name2 = <span class=\"string\">\"chenssy_inner\"</span>;  </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"OuterClass name：\"</span> + name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 外围类方法 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-10-25 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 外围类访问静态内部类：内部类. */</span>  </div><div class=\"line\">        System.out.println(InnerClass1._name1);  </div><div class=\"line\">        <span class=\"comment\">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span>  </div><div class=\"line\">        <span class=\"keyword\">new</span> InnerClass1().display();  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部的创建需要依赖于外围类 */</span>  </div><div class=\"line\">        OuterClass.InnerClass2 inner2 = <span class=\"keyword\">new</span> OuterClass().new InnerClass2();  </div><div class=\"line\">        <span class=\"comment\">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span>  </div><div class=\"line\">        System.out.println(inner2._name2);  </div><div class=\"line\">        inner2.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        outer.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">----------------  </div><div class=\"line\">Output:  </div><div class=\"line\">chenssy_static  </div><div class=\"line\">OutClass name :chenssy  </div><div class=\"line\">chenssy_inner  </div><div class=\"line\">OuterClass name：chenssy</div></pre></td></tr></table></figure></p>\n<p>上面这个例子充分展现了静态内部类和非静态内部类的区别。<br>到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载：<a href=\"http://blog.csdn.net/chenssy/article/details/13024951\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13024951</a></p>\n</blockquote>\n<p>可以将一个类的定义放在另一个类的定义内部，这就是内部类。<br>内部类是一个非常有用的特性但又比较难理解使用的特性(鄙人到现在都没有怎么使用过内部类，对内部类也只是略知一二)。<br>第一次见面<br>内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">this</span>.age = age;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">            age = <span class=\"number\">23</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在这里InnerClass就是内部类，对于初学者来说内部类实在是使用的不多，鄙人菜鸟一个同样没有怎么使用过(貌似仅仅只在做swing 注册事件中使用过)，但是随着编程能力的提高，我们会领悟到它的魅力所在，它可以使用能够更加优雅的设计我们的程序结构。在使用内部类之间我们需要明白为什么要使用内部类，内部类能够为我们带来什么样的好处。<br>","more":"</p>\n<h2 id=\"为什么要使用内部类\"><a href=\"#为什么要使用内部类\" class=\"headerlink\" title=\"为什么要使用内部类\"></a>为什么要使用内部类</h2><p>为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。<br>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span>, <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Daughter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_</span> <span class=\"keyword\">implements</span> <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其实对于这个实例我们确实是看不出来使用内部类存在何种优点，但是如果Father、Mother不是接口，而是抽象类或者具体类呢？这个时候我们就只能使用内部类才能实现多重继承了。<br>其实使用内部类最大的优点就在于它能够非常好的解决多重继承的问题，但是如果我们不需要解决多重继承问题，那么我们自然可以使用其他的编码方式，但是使用内部类还能够为我们带来如下特性（摘自《Think in java》）：</p>\n<pre><code>1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。\n2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。\n3、创建内部类对象的时刻并不依赖于外围类对象的创建。\n4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。\n5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。\n</code></pre><h2 id=\"内部类基础\"><a href=\"#内部类基础\" class=\"headerlink\" title=\"内部类基础\"></a>内部类基础</h2><p>在这个部分主要介绍内部类如何使用外部类的属性和方法，以及使用.this与.new。<br>当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String name ;  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**省略getter和setter方法**/</span>  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">            age = <span class=\"number\">23</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"name：\"</span> + getName() +<span class=\"string\">\"   ;age：\"</span> + getAge());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class=\"line\">        innerClass.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------  </div><div class=\"line\">Output：  </div><div class=\"line\">name：chenssy   ;age：<span class=\"number\">23</span></div></pre></td></tr></table></figure></p>\n<p>在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。<br>其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类：OuterClass.InnerClass innerClass = outerClass.new InnerClass();。<br>同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"OuterClass...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> OuterClass <span class=\"title\">getOuterClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> OuterClass.<span class=\"keyword\">this</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outerClass = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();  </div><div class=\"line\">        innerClass.getOuterClass().display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">-------------  </div><div class=\"line\">Output:  </div><div class=\"line\">OuterClass...</div></pre></td></tr></table></figure></p>\n<p>到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。<br>在Java中内部类主要分为成员内部类、局部内部类、匿名内部类、静态内部类。</p>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2><p>成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。<br>在成员内部类中要注意两点，第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String str;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">outerDisplay</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"outerClass...\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">innerDisplay</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"comment\">//使用外围内的属性  </span></div><div class=\"line\">            str = <span class=\"string\">\"chenssy...\"</span>;  </div><div class=\"line\">            System.out.println(str);  </div><div class=\"line\">            <span class=\"comment\">//使用外围内的方法  </span></div><div class=\"line\">            outerDisplay();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        OuterClass.InnerClass inner = outer.getInnerClass();  </div><div class=\"line\">        inner.innerDisplay();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">--------------------  </div><div class=\"line\">chenssy...  </div><div class=\"line\">outerClass...</div></pre></td></tr></table></figure></p>\n<p>推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。<br>对于局部内部类实在是想不出什么好例子，所以就引用《Think in java》中的经典例子了。<br>定义在方法里：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel5</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Destionation <span class=\"title\">destionation</span><span class=\"params\">(String str)</span></span>&#123;  </div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PDestionation</span> <span class=\"keyword\">implements</span> <span class=\"title\">Destionation</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">private</span> String label;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">PDestionation</span><span class=\"params\">(String whereTo)</span></span>&#123;  </div><div class=\"line\">                label = whereTo;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">readLabel</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> label;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PDestionation(str);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Parcel5 parcel5 = <span class=\"keyword\">new</span> Parcel5();  </div><div class=\"line\">        Destionation d = parcel5.destionation(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>定义在作用域内:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parcel6</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">internalTracking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span>(b)&#123;  </div><div class=\"line\">            <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TrackingSlip</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">private</span> String id;  </div><div class=\"line\">                TrackingSlip(String s) &#123;  </div><div class=\"line\">                    id = s;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"function\">String <span class=\"title\">getSlip</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                    <span class=\"keyword\">return</span> id;  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            TrackingSlip ts = <span class=\"keyword\">new</span> TrackingSlip(<span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">            String string = ts.getSlip();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">track</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        internalTracking(<span class=\"keyword\">true</span>);  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Parcel6 parcel6 = <span class=\"keyword\">new</span> Parcel6();  </div><div class=\"line\">        parcel6.track();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>在做Swing编程中，我们经常使用这种方式来绑定事件<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button2.addActionListener(    </div><div class=\"line\">                <span class=\"keyword\">new</span> ActionListener()&#123;    </div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent e)</span> </span>&#123;    </div><div class=\"line\">                        System.out.println(<span class=\"string\">\"你按了按钮二\"</span>);    </div><div class=\"line\">                    &#125;    </div><div class=\"line\">                &#125;);</div></pre></td></tr></table></figure></p>\n<pre><code>我们咋一看可能觉得非常奇怪，因为这个内部类是没有名字的，在看如下这个例子：\n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> InnerClass <span class=\"title\">getInnerClass</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> num,String str2)</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass()&#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> number = num + <span class=\"number\">3</span>;  </div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">                <span class=\"keyword\">return</span> number;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;;        <span class=\"comment\">/* 注意：分号不能省 */</span>  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass out = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        InnerClass inner = out.getInnerClass(<span class=\"number\">2</span>, <span class=\"string\">\"chenssy\"</span>);  </div><div class=\"line\">        System.out.println(inner.getNumber());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InnerClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">----------------  </div><div class=\"line\">Output:  </div><div class=\"line\"><span class=\"number\">5</span></div></pre></td></tr></table></figure>\n<p>这里我们就需要看清几个地方<br>1、 匿名内部类是没有访问修饰符的。<br>2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。<br>3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。<br>4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法。<br>PS：由于篇幅有限，对匿名内部类就介绍到这里，有关更多关于匿名内部类的知识，我就会在下篇博客（java提高篇—–详解匿名内部类）做详细的介绍，包括为何形参要定义成final，怎么对匿名内部类进行初始化等等，敬请期待……</p>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><p>在java提高篇—–关键字static中提到Static可以修饰成员变量、方法、代码块，其他它还可以修饰内部类，使用static修饰的内部类我们称之为静态内部类，不过我们更喜欢称之为嵌套内部类。静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：<br>1、 它的创建是不需要依赖于外围类的。<br>2、 它不能使用任何外围类的非static成员变量和方法。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OuterClass</span> </span>&#123;  </div><div class=\"line\">    <span class=\"keyword\">private</span> String sex;  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String name = <span class=\"string\">\"chenssy\"</span>;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    *静态内部类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass1</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 在静态内部类中可以存在静态成员 */</span>  </div><div class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String _name1 = <span class=\"string\">\"chenssy_static\"</span>;  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"comment\">/*  </span></div><div class=\"line\"><span class=\"comment\">            * 静态内部类只能访问外围类的静态成员变量和方法 </span></div><div class=\"line\"><span class=\"comment\">            * 不能访问外围类的非静态成员变量和方法 </span></div><div class=\"line\"><span class=\"comment\">            */</span>  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"OutClass name :\"</span> + name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 非静态内部类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass2</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部类中不能存在静态成员 */</span>  </div><div class=\"line\">        <span class=\"keyword\">public</span> String _name2 = <span class=\"string\">\"chenssy_inner\"</span>;  </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部类中可以调用外围类的任何成员,不管是静态的还是非静态的 */</span>  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            System.out.println(<span class=\"string\">\"OuterClass name：\"</span> + name);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@desc</span> 外围类方法 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@author</span> chenssy </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@data</span> 2013-10-25 </span></div><div class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> void </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"comment\">/* 外围类访问静态内部类：内部类. */</span>  </div><div class=\"line\">        System.out.println(InnerClass1._name1);  </div><div class=\"line\">        <span class=\"comment\">/* 静态内部类 可以直接创建实例不需要依赖于外围类 */</span>  </div><div class=\"line\">        <span class=\"keyword\">new</span> InnerClass1().display();  </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">/* 非静态内部的创建需要依赖于外围类 */</span>  </div><div class=\"line\">        OuterClass.InnerClass2 inner2 = <span class=\"keyword\">new</span> OuterClass().new InnerClass2();  </div><div class=\"line\">        <span class=\"comment\">/* 方位非静态内部类的成员需要使用非静态内部类的实例 */</span>  </div><div class=\"line\">        System.out.println(inner2._name2);  </div><div class=\"line\">        inner2.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        OuterClass outer = <span class=\"keyword\">new</span> OuterClass();  </div><div class=\"line\">        outer.display();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">----------------  </div><div class=\"line\">Output:  </div><div class=\"line\">chenssy_static  </div><div class=\"line\">OutClass name :chenssy  </div><div class=\"line\">chenssy_inner  </div><div class=\"line\">OuterClass name：chenssy</div></pre></td></tr></table></figure></p>\n<p>上面这个例子充分展现了静态内部类和非静态内部类的区别。<br>到这里内部类的介绍就基本结束了！对于内部类其实本人认识也只是皮毛，逼近菜鸟一枚，认知有限！我会利用这几天时间好好研究内部类!</p>"},{"title":"java提高篇（八）-----实现多重继承","date":"2017-10-23T05:38:22.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","source":"_posts/java-toup9.1.md","raw":"---\ntitle: java提高篇（八）-----实现多重继承\ndate: 2017-10-23 13:38:22\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","slug":"java-toup9.1","published":1,"updated":"2017-10-23T14:39:24.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp62001lv0v50ahoweda","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13168265</a></p>\n</blockquote>\n<p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br><a id=\"more\"></a><br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重头戏在这里，儿子类Son：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\">----------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </div><div class=\"line\">Son 的kind：<span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13168265</a></p>\n</blockquote>\n<p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br>","more":"<br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重头戏在这里，儿子类Son：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\">----------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </div><div class=\"line\">Son 的kind：<span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>"},{"title":"java提高篇（八）-----实现多重继承","date":"2017-10-23T05:38:22.000Z","_content":"> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","source":"_posts/java-toup9.md","raw":"---\ntitle: java提高篇（八）-----实现多重继承\ndate: 2017-10-23 13:38:22\ntags: [java,转载]\ncategories: java开发\n---\n> 转载： http://blog.csdn.net/chenssy/article/details/13168265\n\n多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。\n\n## 接口\n在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。\n<!-- more -->\n对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。\n```java\n    interface CanFight {  \n        void fight();  \n    }  \n    \n    interface CanSwim {  \n        void swim();  \n    }  \n    \n    \n    interface CanFly {  \n        void fly();  \n    }  \n    \n    public class ActionCharacter {  \n        public void fight(){  \n            \n        }  \n    }  \n    \n    public class Hero extends ActionCharacter implements CanFight,CanFly,CanSwim{  \n    \n        public void fly() {  \n        }  \n    \n        public void swim() {  \n        }  \n    \n        /** \n        * 对于fight()方法，继承父类的，所以不需要显示声明 \n        */  \n    }  \n```\n## 内部类\n上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。\n首先是父亲Father和母亲Mother：\n```java\n    public class Father {  \n        public int strong(){  \n            return 9;  \n        }  \n    }  \n    \n    public class Mother {  \n        public int kind(){  \n            return 8;  \n        }  \n    }  \n```\n重头戏在这里，儿子类Son：\n```java\n    public class Son {  \n        \n        /** \n        * 内部类继承Father类 \n        */  \n        class Father_1 extends Father{  \n            public int strong(){  \n                return super.strong() + 1;  \n            }  \n        }  \n        \n        class Mother_1 extends  Mother{  \n            public int kind(){  \n                return super.kind() - 2;  \n            }  \n        }  \n        \n        public int getStrong(){  \n            return new Father_1().strong();  \n        }  \n        \n        public int getKind(){  \n            return new Mother_1().kind();  \n        }  \n    }  \n```\n测试程序：\n```java\n    public class Test1 {  \n    \n        public static void main(String[] args) {  \n            Son son = new Son();  \n            System.out.println(\"Son 的Strong：\" + son.getStrong());  \n            System.out.println(\"Son 的kind：\" + son.getKind());  \n        }  \n    \n    }  \n    ----------------------------------------  \n    Output:  \n    Son 的Strong：10  \n    Son 的kind：6  \n```\n儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。","slug":"java-toup9","published":1,"updated":"2017-10-23T13:23:34.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp65001ov0v5aj3cavhp","content":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13168265</a></p>\n</blockquote>\n<p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br><a id=\"more\"></a><br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重头戏在这里，儿子类Son：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\">----------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </div><div class=\"line\">Son 的kind：<span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载： <a href=\"http://blog.csdn.net/chenssy/article/details/13168265\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/chenssy/article/details/13168265</a></p>\n</blockquote>\n<p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征，然而我们知道Java为了保证数据安全，它只允许单继承。有些时候我们会认为如果系统中需要使用多重继承往往都是糟糕的设计,这个时候我们往往需要思考的不是怎么使用多重继承,而是您的设计是否存在问题.但有时候我们确实是需要实现多重继承，而且现实生活中也真正地存在这样的情况，比如遗传：我们即继承了父亲的行为和特征也继承了母亲的行为和特征。可幸的是Java是非常和善和理解我们的,它提供了两种方式让我们曲折来实现多重继承：接口和内部类。</p>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在介绍接口和抽象类的时候了解到子类只能继承一个父类，也就是说只能存在单一继承，但是却可以实现多个接口，这就为我们实现多重继承做了铺垫。<br>","more":"<br>对于接口而已，有时候它所表现的不仅仅只是一个更纯粹的抽象类，接口是没有任何具体实现的，也就是说，没有任何与接口相关的存储，因此也就无法阻止多个接口的组合了。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFight</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanSwim</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CanFly</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span></span>;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActionCharacter</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fight</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hero</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActionCharacter</span> <span class=\"keyword\">implements</span> <span class=\"title\">CanFight</span>,<span class=\"title\">CanFly</span>,<span class=\"title\">CanSwim</span></span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swim</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 对于fight()方法，继承父类的，所以不需要显示声明 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>上面使用接口实现多重继承是一种比较可行和普遍的方式，在介绍内部类的时候谈到内部类使的多继承的实现变得更加完美了，同时也明确了如果父类为抽象类或者具体类，那么我就仅能通过内部类来实现多重继承了。如何利用内部类实现多重继承，请看下面实例：儿子是如何利用多重继承来继承父亲和母亲的优良基因。<br>首先是父亲Father和母亲Mother：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">9</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother</span> </span>&#123;  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">8</span>;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>重头戏在这里，儿子类Son：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> </span>&#123;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/** </span></div><div class=\"line\"><span class=\"comment\">    * 内部类继承Father类 </span></div><div class=\"line\"><span class=\"comment\">    */</span>  </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father_1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">strong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.strong() + <span class=\"number\">1</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mother_1</span> <span class=\"keyword\">extends</span>  <span class=\"title\">Mother</span></span>&#123;  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.kind() - <span class=\"number\">2</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStrong</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Father_1().strong();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getKind</span><span class=\"params\">()</span></span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Mother_1().kind();  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测试程序：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span> </span>&#123;  </div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;  </div><div class=\"line\">        Son son = <span class=\"keyword\">new</span> Son();  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的Strong：\"</span> + son.getStrong());  </div><div class=\"line\">        System.out.println(<span class=\"string\">\"Son 的kind：\"</span> + son.getKind());  </div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">&#125;  </div><div class=\"line\">----------------------------------------  </div><div class=\"line\">Output:  </div><div class=\"line\">Son 的Strong：<span class=\"number\">10</span>  </div><div class=\"line\">Son 的kind：<span class=\"number\">6</span></div></pre></td></tr></table></figure></p>\n<p>儿子继承了父亲，变得比父亲更加强壮，同时也继承了母亲，只不过温柔指数下降了。这里定义了两个内部类，他们分别继承父亲Father类、母亲类Mother类，且都可以非常自然地获取各自父类的行为，这是内部类一个重要的特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能。</p>"},{"title":"记“刺客信条”三部曲：水月镜像，无心去来","date":"2017-10-19T14:40:46.000Z","comments":1,"brief":"第一次有冲动为一个游戏写文字","_content":"![刺客信条-兄弟会海报](/uploads/ckxt0.jpg)\n> Nothing is true,everything is permitted. 万事皆虚，万物皆允。\n\n*—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲*\n<!-- more -->\n实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。\n\n## **虚**\nEzio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。\n\n![奔波到威尼斯的Ezio](/uploads/ckxt1.jpg)\n以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。\n\nEzio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。\n\n![刺客从天而降](/uploads/ckxt2.jpg)\n\n因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。\n\n## **允**\n\n任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。\n\n![信仰之跃](/uploads/ckxt3.jpg)      \n\n他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。\n                 \n游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。\n![年迈的Ezio](/uploads/ckxt4.jpg)      \n\n到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。\n\nEzio最后的信：\n> When I was a young man,              \n> 当我还是个年轻的小伙子                \n> I had liberty, but I did not see it.                 \n> 我拥有自由，却从未认知                  \n> I had time, but I did not know it.                   \n> 我拥有时间，却毫不知情                   \n> And I had love, but I did not feel it.                   \n> 而我亦拥有爱，却从未感觉到                   \n> Many decades would pass before I understood the meaning of all three.                   \n> 直到数十年过去后，我才真正理解这三项的意义                   \n> And now, the twilight of my life, misunderstanding has past into contentment.                   \n> 而现在，垂暮之年的我，这领悟让我感到满足                   \n> Love, liberty, and time: once was so disposable, are the fuels that drive me forward.                   \n> 曾经能自由支配的爱，自由以及时间，是支持我前进的动力                   \n> And love, most especially, mia caro.                   \n> 而爱，是最特别的一个， 亲爱的                   \n> For you, our children, our brothers and sisters.                   \n> 为你，为我们的孩子以及为我们的兄弟姐妹们                   \n> And for the vast and wonderful world that gives us lives and keeps us guessing,                   \n> 为这赐予我们生命与惊奇的广阔，精彩的世界                   \n> endless affection，mio Sofia,                   \n> 至死不渝的挚爱， 我的索菲亚                   \n> Forever yours, Ezio Auditore                   \n> 永远属于你的， Ezio Auditore        \n\n\n","source":"_posts/myFirstBlog.md","raw":"---\ntitle: 记“刺客信条”三部曲：水月镜像，无心去来\ndate: 2017-10-19 22:40:46\ntags: [游戏, 旧事]\ncategories: -转载\ncomments: true \nbrief: \"第一次有冲动为一个游戏写文字\"\n---\n![刺客信条-兄弟会海报](/uploads/ckxt0.jpg)\n> Nothing is true,everything is permitted. 万事皆虚，万物皆允。\n\n*—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲*\n<!-- more -->\n实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。\n\n## **虚**\nEzio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。\n\n![奔波到威尼斯的Ezio](/uploads/ckxt1.jpg)\n以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。\n\nEzio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。\n\n![刺客从天而降](/uploads/ckxt2.jpg)\n\n因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。\n\n## **允**\n\n任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。\n\n![信仰之跃](/uploads/ckxt3.jpg)      \n\n他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。\n                 \n游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。\n![年迈的Ezio](/uploads/ckxt4.jpg)      \n\n到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。\n\nEzio最后的信：\n> When I was a young man,              \n> 当我还是个年轻的小伙子                \n> I had liberty, but I did not see it.                 \n> 我拥有自由，却从未认知                  \n> I had time, but I did not know it.                   \n> 我拥有时间，却毫不知情                   \n> And I had love, but I did not feel it.                   \n> 而我亦拥有爱，却从未感觉到                   \n> Many decades would pass before I understood the meaning of all three.                   \n> 直到数十年过去后，我才真正理解这三项的意义                   \n> And now, the twilight of my life, misunderstanding has past into contentment.                   \n> 而现在，垂暮之年的我，这领悟让我感到满足                   \n> Love, liberty, and time: once was so disposable, are the fuels that drive me forward.                   \n> 曾经能自由支配的爱，自由以及时间，是支持我前进的动力                   \n> And love, most especially, mia caro.                   \n> 而爱，是最特别的一个， 亲爱的                   \n> For you, our children, our brothers and sisters.                   \n> 为你，为我们的孩子以及为我们的兄弟姐妹们                   \n> And for the vast and wonderful world that gives us lives and keeps us guessing,                   \n> 为这赐予我们生命与惊奇的广阔，精彩的世界                   \n> endless affection，mio Sofia,                   \n> 至死不渝的挚爱， 我的索菲亚                   \n> Forever yours, Ezio Auditore                   \n> 永远属于你的， Ezio Auditore        \n\n\n","slug":"myFirstBlog","published":1,"updated":"2017-10-23T13:23:34.771Z","layout":"post","photos":[],"link":"","_id":"cj94blp6d001rv0v5tci6hcax","content":"<p><img src=\"/uploads/ckxt0.jpg\" alt=\"刺客信条-兄弟会海报\"></p>\n<blockquote>\n<p>Nothing is true,everything is permitted. 万事皆虚，万物皆允。</p>\n</blockquote>\n<p><em>—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲</em><br><a id=\"more\"></a><br>实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。</p>\n<h2 id=\"虚\"><a href=\"#虚\" class=\"headerlink\" title=\"虚\"></a><strong>虚</strong></h2><p>Ezio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。</p>\n<p><img src=\"/uploads/ckxt1.jpg\" alt=\"奔波到威尼斯的Ezio\"><br>以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。</p>\n<p>Ezio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。</p>\n<p><img src=\"/uploads/ckxt2.jpg\" alt=\"刺客从天而降\"></p>\n<p>因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。</p>\n<h2 id=\"允\"><a href=\"#允\" class=\"headerlink\" title=\"允\"></a><strong>允</strong></h2><p>任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。</p>\n<p><img src=\"/uploads/ckxt3.jpg\" alt=\"信仰之跃\">      </p>\n<p>他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。</p>\n<p>游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。<br><img src=\"/uploads/ckxt4.jpg\" alt=\"年迈的Ezio\">      </p>\n<p>到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。</p>\n<p>Ezio最后的信：</p>\n<blockquote>\n<p>When I was a young man,<br>当我还是个年轻的小伙子<br>I had liberty, but I did not see it.<br>我拥有自由，却从未认知<br>I had time, but I did not know it.<br>我拥有时间，却毫不知情<br>And I had love, but I did not feel it.<br>而我亦拥有爱，却从未感觉到<br>Many decades would pass before I understood the meaning of all three.<br>直到数十年过去后，我才真正理解这三项的意义<br>And now, the twilight of my life, misunderstanding has past into contentment.<br>而现在，垂暮之年的我，这领悟让我感到满足<br>Love, liberty, and time: once was so disposable, are the fuels that drive me forward.<br>曾经能自由支配的爱，自由以及时间，是支持我前进的动力<br>And love, most especially, mia caro.<br>而爱，是最特别的一个， 亲爱的<br>For you, our children, our brothers and sisters.<br>为你，为我们的孩子以及为我们的兄弟姐妹们<br>And for the vast and wonderful world that gives us lives and keeps us guessing,<br>为这赐予我们生命与惊奇的广阔，精彩的世界<br>endless affection，mio Sofia,<br>至死不渝的挚爱， 我的索菲亚<br>Forever yours, Ezio Auditore<br>永远属于你的， Ezio Auditore        </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><img src=\"/uploads/ckxt0.jpg\" alt=\"刺客信条-兄弟会海报\"></p>\n<blockquote>\n<p>Nothing is true,everything is permitted. 万事皆虚，万物皆允。</p>\n</blockquote>\n<p><em>—— 《刺客信条2》  《刺客信条：兄弟会》 《刺客信条：启示录》 -Ezio三部曲</em><br>","more":"<br>实习回来后，在朋友的推荐下玩了刺客信条这款游戏，感触挺深，后来想一定要为它写点文字。闭眼一想，还是那句话萦回脑中：我们为了服侍光明而耕耘于黑暗……万物皆虚，万事皆允。却不知道这句话该怎么翻译，被游戏寓意为“信条”的话语，相对于它的题材所包含的深度，好像任何翻译都会带来偏差。很难用几句话描述清楚这部作品，它展现了完全不同的世界与价值，过去与现在，生存与死亡，仇恨与宽容，这些宽泛弘毅的对立词相互交织，在刀刃与鲜血中重获新释，浓缩于主人公Ezio的一生。</p>\n<h2 id=\"虚\"><a href=\"#虚\" class=\"headerlink\" title=\"虚\"></a><strong>虚</strong></h2><p>Ezio诞生于文艺复兴时期的佛罗伦萨，作为银行家的富二代，每日就是游手好闲沾花惹草。还记得游戏的第一个任务就是去打架，然后爬上高楼跟姑娘幽会。生活波澜不惊，基调如翡翠般平和，蓝天白云之下的鲜花之城给予了Ezio太多纨绔子弟的气息。而至于后来，当他每次的任务都要手起刀落快意恩仇，然后安抚亡者的灵魂，当他对深爱的Sophia的请求无奈道出对不起我的时间很宝贵，当他在异乡的深夜给妹妹Claudia满怀深情地写信时，你才会发现，他动荡的内心深处，自有一个不曾惊扰的世界，一个不曾惊扰的翡冷翠。那些逝去的日子，在游戏开头略显无聊的情景，恰如一个简朴的别针，固定在心中最纯粹的角落。</p>\n<p><img src=\"/uploads/ckxt1.jpg\" alt=\"奔波到威尼斯的Ezio\"><br>以至于说，何以为正义，真理，信仰，自由？这都是些多么美好的词语，然而都不是Ezio最终想要的，又恰好是他，见过了太多为了这些美好而疯狂追逐，最终坠下深渊的人。好奇害死猫，人又何尝不是？因此，创世的神让人间有了死亡。刺客从天而降，帽檐遮住他的眉宇，和平鸽还不知晓下一刻的慌乱，风起风止间，优雅的袖刃已将迷乱的鲜红绽放。</p>\n<p>Ezio更像一个布道者，将“虚”的信条用死亡的方式传谕。而事物的真实与否，本来就无所谓人的好坏。朋友Leonardo是虚的，他花了很多心里发明战争机器，下一刻就想摧毁它们；叔叔Mario是虚的，一个质朴果敢的领路人，在庄园陷落时便虎落平阳；Niccolo也是虚的，一个满腹经纶兢兢业业的刺客首领，却一度被当作内奸。连Ezio本人也是虚的，从佛罗伦萨的起步，到威尼斯的追寻，再到罗马的复兴，最后到君士坦丁堡的迟暮，其实Ezio最终才认识到，自己不也是为所谓的复仇与荣耀努力了一辈子吗？原来那个最先坠入深渊的人，正是Ezio自己。</p>\n<p><img src=\"/uploads/ckxt2.jpg\" alt=\"刺客从天而降\"></p>\n<p>因此，Ezio最后在和害死了父兄的教皇Rodrigo对峙时，留下这句信条而放过了他（最终反被儿子Cesare毒死）。这一刻，不知手染太多鲜血的刺客大师是否想到了多年前的一尘不染的佛罗伦萨。抉择与变卦，过一分钟就不能再回头。Ezio的身后这座辉煌的城市，原本就是他想终结邪恶，获得荣耀的目的地。如今，城市更加辉煌，以往的日子，爱人，自由，却一并失去了踪影。相对于当下，他知道一切于事无补，反而有一种繁花落尽，悄然入土的随性。他赫然发现Nothing is true原来不是对别人的告诫，而是对自己内心深处最无奈的独白。</p>\n<h2 id=\"允\"><a href=\"#允\" class=\"headerlink\" title=\"允\"></a><strong>允</strong></h2><p>任何一个刺客，加入brotherhood时都要完成一个仪式。他们从城市最高的塔尖上俯瞰全城，然后向着塔底的草堆高高跃下。他们在跃下的那一刻伸展手臂，一种近乎疯狂的自由呼啸而来，将烦恼和恐惧抛诸脑后，你很容易联想到鹰的意象。我们总是可以将道理示于别人，却无法说服自己。这种仪式无疑是对自身的勇敢与自由最好的诠释，刺客们以这样的方式向城市宣告，他们的行为准则秉承信仰，允许他们在法律和道德中掌握邪恶者的生杀大权。他们称之为“信仰之跃”。</p>\n<p><img src=\"/uploads/ckxt3.jpg\" alt=\"信仰之跃\">      </p>\n<p>他们在塔尖飘飞消失，城市的风景情韵尽收眼底，背后是虚无的高塔，火焰，荣耀，前方是被允许的使命。而一个人的好与坏，生与死，无时不在拷问着Ezio的灵魂。是的，他也刺杀过好人，而他更多选择了沉默与忘却。允许，到底谁在允许？导师Altair在多次刺杀后终于有觉悟的说：“我所杀的人都对我说了些奇怪的话。他们都没有后悔。即使快死了，他们也看着对胜利很有自信。法律不是来自于神，而是理性。我现在明白了我们的信条不是要求我们去自由。是要求我们智慧。”一个允字，要么成为刺杀后不觉得罪恶的借口，要么成为超越假象的大智慧。</p>\n<p>游戏情节里有一幕我印象特别深，年迈的Ezio将地下城军火库的首领刺死，单膝跪地抱着他的尸体，缓缓的说：“杀戮是可耻的…”。你能否想象，这是一个手沾鲜血，以刺杀为荣的刺客大师，对着刚被自己刺杀的将亡人说出的一番话。人到了死神降临这一步，才会明白所谓是非成败转头空，才会明白权利和金钱都会在下一次眨眼中灰飞烟灭。而杀人者Ezio此时最想告诉对方的，就是对方杀戮的原罪，不是其他。Ezio此时的眼神不是锋利的，而是坚定如磐石，我想到这一步，头发灰白的Ezio是参透了信条何谓“万事皆允”。Ezio异常从容与坚定，他知道他的杀戮必将会带来救赎，这是上天的允许，也是内心的智慧。刀锋使处，字句溃逃，任何的道理都无法阻止手中将逝的灵魂。<br><img src=\"/uploads/ckxt4.jpg\" alt=\"年迈的Ezio\">      </p>\n<p>到了这个时候，才知道年过半百的Ezio为什么在君士坦丁堡受这么多人的尊重，才知道为什么他严厉指责因鲁莽而错杀他人的徒弟，不全是因为高明的刺杀艺术，更多的是他比更多年轻人知道内心一个允字的定夺。而最后，Ezio完成了对自己的救赎，英雄迟暮，卸甲归田。一颗颠簸的心，终于泡在村灯狗吠之中。在定夺了这么多人的命运之后，他终于想到了自己，想到了Sophia，想到了佛罗伦萨。如果世上有一个人能阻止他，那这个人肯定是Ezio自己，因而他允许了英雄的离去，从容的卸下袖剑，留下背影，自此，永不回头。而门前的花与阳光在岁月中偷偷窜出，似乎等了他几十年。</p>\n<p>Ezio最后的信：</p>\n<blockquote>\n<p>When I was a young man,<br>当我还是个年轻的小伙子<br>I had liberty, but I did not see it.<br>我拥有自由，却从未认知<br>I had time, but I did not know it.<br>我拥有时间，却毫不知情<br>And I had love, but I did not feel it.<br>而我亦拥有爱，却从未感觉到<br>Many decades would pass before I understood the meaning of all three.<br>直到数十年过去后，我才真正理解这三项的意义<br>And now, the twilight of my life, misunderstanding has past into contentment.<br>而现在，垂暮之年的我，这领悟让我感到满足<br>Love, liberty, and time: once was so disposable, are the fuels that drive me forward.<br>曾经能自由支配的爱，自由以及时间，是支持我前进的动力<br>And love, most especially, mia caro.<br>而爱，是最特别的一个， 亲爱的<br>For you, our children, our brothers and sisters.<br>为你，为我们的孩子以及为我们的兄弟姐妹们<br>And for the vast and wonderful world that gives us lives and keeps us guessing,<br>为这赐予我们生命与惊奇的广阔，精彩的世界<br>endless affection，mio Sofia,<br>至死不渝的挚爱， 我的索菲亚<br>Forever yours, Ezio Auditore<br>永远属于你的， Ezio Auditore        </p>\n</blockquote>"},{"title":"Nginx能为前端开发带来什么？","date":"2017-10-20T02:12:22.000Z","_content":"\nNginx那么好，我想去看看。\n接连逛了两个书城后，我发现并没有Nginx相关的书籍。\n这就很奇怪！\n\n![](/uploads/nginx0.jpg)\n\nNginx，一名**网红**（网络服务器红人...)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。\n\n后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。\n后来发现了原因，大概是因为“**使用太简单了，都不值得出书**“。\n是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。\n当它呈现到你面前时，感觉独具匠心。\n<!-- more -->\n\n### Nginx与NodeJs\n\n\n（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）\n\n有人说，作为一名前端，**我的真爱是NodeJs**。\n同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。\n\n这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。\n\n在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。\n\n合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。\n\n以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。\n\n### 场景一：环境切换\n\n前端开发中，经常面临多个部署环境切换的问题。\n我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。\n\n然而在拓展性和易用性方面，还不足够好。\n而Nginx作为反向代理，就很容易处理资源转发的问题。\n\n思路很简单：\n\n> 1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；\n> 2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;\n\n```javascript\n    set $env_id \"1.1.1.1\";\n    if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") {\n        set $env_id $1;\n    }\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass   http://$env_id:80;\n    }\n```\n```java\n    public boolean isPosupplier(String opacct) throws TException {\n\t\t\t\t\n\t\tString qrystr = \" e.cfgsct ='posper' and e.cfgval ='\"+opacct+\"'\";\n\t\tList<Appcfg> appcfgs = this.jdsdb.APPCFG().list(qrystr);\n\t\tif(appcfgs == null || appcfgs.size()<=0){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n那接下来的事情，**就是怎样用最简便的方式，把IP种在cookie里**？\n我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。\n\n这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。\n![](/uploads/nginx1.jpg)\n\n切换环境，如今只需点击一次。\n\n### 场景二：SourceMap\n\n\n在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。\n\n而SourceMap正好可以解决此问题。\n\n在最新的各版本浏览器里，如果满足：\n1. 压缩后的js文件后面有 `` //# sourceMappingURL=xxx.map``格式的注释\n2.浏览器能正常访问到sourceMappingURL\n那么，就能把压缩过的代码还原。\n要实现这样的功能，就必须：\n\n1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）\n2.测试环境带注释，能访问sourceMap\n\n这样的模型，用``反向代理+内容篡改``的思路再合适不过。\n每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加``.map后缀``。随后，使用Nginx，通过这几行配置就能把此功能实现：\n\n```\n    location  ~ \\.js${\n        footer \"\\n//# sourceMappingURL=$request_uri.map\";\n        footer_types \"*\";\n    }\n\n```\n只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。\n你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。\n![](/uploads/nginx2.jpg)\n\n### 场景三：内容纂改\n\n\n其实在以上两个场景里，都涉及了“内容纂改”。\n无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。\n\n统一介绍下，Nginx涉及纂改的模块有：\n\n* [nginx_http_footer_filter](https://m.oschina.net/blog/156826):往文件的底部添加文字，可包含Nginx的内置变量；\n* [nginx_http_addition_module](http://nginx.org/en/docs/http/ngx_http_addition_module.html)：从一个url去读取内容，将之添加到文件的头部或顶部；\n* [nginx_http_sub_module](http://nginx.org/en/docs/http/ngx_http_sub_module.html)：替换字符\n\n除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。            \n单单针对移动web前端开发，就可以实现：\n> 1. 将[weinre](http://people.apache.org/~pmuellr/weinre-docs/latest/)脚本插入到html里，让移动web调试更加便捷。\n> 2. 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。\n> 3. 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等\n\n\n### 场景四：本地映射\n\n在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。                \n而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   \n\n比如：**线上接口映射到本地文件**。            \n想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           \n\n而且，我们可以做得更灵活，比如：\n* 同时支持慢速调试\n* 同时支持目录层级映射\n* 同时支持正则匹配\n* JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据\n\n这些场景，只运用到Nginx里的“[rewrite规则](http://www.linuxidc.com/Linux/2014-01/95493.htm)”。                \n从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 \n\n最简单的模型中，我们把所有带``cgi-bin``路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，      \n仅需这三行配置即可：\n```\nlocation ~ /cgi-bin/* {\n    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;\n}\n```\n后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 \n\n### 场景五：移动侧调试\n\n`Fiddler` 有一个勾选项 `Allow remote computers to connect`，并可以指定 `listen port` 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 `hosts` 配合会很实用。\n\n这个功能，用Nginx也很容易做到。           \n通过 `default_server` 作为代理，手机终端通过设置网络代理为本机IP和相应的 `listen port`，从而可以访问本机的 Web 服务。\n\n其中也是用到了[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)模块的配置：\n```js\n server {\n    listen  80 default_server;\n    server_name  localhost;\n    resolver 8.8.8.8;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://$host;\n    }\n}\n\nserver {\n    listen  80;\n    server_name  ke.qq.com;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://127.0.0.1:9091/;\n    }\n}\n```\n\n### 边角料\n\n除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。\n\n1.[nginx_http_concat](https://github.com/alibaba/nginx-http-concat)               \n资源合并，处理CDN combo。例如通过这样的方式``http://example.com/??style1.css,style2.css,foo/style3.css``访问合并后的资源。\n\n2.[ngx_http_image_filter_module](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)                  \n图片处理。提供图片缩放，jpg压缩，旋转等特性。\n\n3.适配PC与移动web                              \n总体可运用[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)，去实现路径转发。判断平台类型的Nginx配置，在开源项目[detectmobilebrowsers](http://detectmobilebrowsers.com/)中可以找到。\n\n### 后记\n\n学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。   \n于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。    \n**但既然是工具，熟手就好**。 \n\n\n比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。\n\n\n\n话说回来，后来心情有些惆怅。            \n想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。            \n不过我又想，**既然我已经花了时间去写，为什么还要花时间去用？！** \n \n \n \n心情又好起来了。（等等有什么不对，管它呢…）\n______________","source":"_posts/nginx.md","raw":"---\ntitle: Nginx能为前端开发带来什么？\ndate: 2017-10-20 10:12:22\ntags: [前端,nginx]\ncategories: -转载\n---\n\nNginx那么好，我想去看看。\n接连逛了两个书城后，我发现并没有Nginx相关的书籍。\n这就很奇怪！\n\n![](/uploads/nginx0.jpg)\n\nNginx，一名**网红**（网络服务器红人...)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。\n\n后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。\n后来发现了原因，大概是因为“**使用太简单了，都不值得出书**“。\n是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。\n当它呈现到你面前时，感觉独具匠心。\n<!-- more -->\n\n### Nginx与NodeJs\n\n\n（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）\n\n有人说，作为一名前端，**我的真爱是NodeJs**。\n同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。\n\n这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。\n\n在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。\n\n合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。\n\n以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。\n\n### 场景一：环境切换\n\n前端开发中，经常面临多个部署环境切换的问题。\n我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。\n\n然而在拓展性和易用性方面，还不足够好。\n而Nginx作为反向代理，就很容易处理资源转发的问题。\n\n思路很简单：\n\n> 1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；\n> 2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;\n\n```javascript\n    set $env_id \"1.1.1.1\";\n    if ( $http_cookie ~* \"host_id=(\\S+)(;.*|$)\") {\n        set $env_id $1;\n    }\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass   http://$env_id:80;\n    }\n```\n```java\n    public boolean isPosupplier(String opacct) throws TException {\n\t\t\t\t\n\t\tString qrystr = \" e.cfgsct ='posper' and e.cfgval ='\"+opacct+\"'\";\n\t\tList<Appcfg> appcfgs = this.jdsdb.APPCFG().list(qrystr);\n\t\tif(appcfgs == null || appcfgs.size()<=0){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n那接下来的事情，**就是怎样用最简便的方式，把IP种在cookie里**？\n我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。\n\n这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。\n![](/uploads/nginx1.jpg)\n\n切换环境，如今只需点击一次。\n\n### 场景二：SourceMap\n\n\n在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。\n\n而SourceMap正好可以解决此问题。\n\n在最新的各版本浏览器里，如果满足：\n1. 压缩后的js文件后面有 `` //# sourceMappingURL=xxx.map``格式的注释\n2.浏览器能正常访问到sourceMappingURL\n那么，就能把压缩过的代码还原。\n要实现这样的功能，就必须：\n\n1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）\n2.测试环境带注释，能访问sourceMap\n\n这样的模型，用``反向代理+内容篡改``的思路再合适不过。\n每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加``.map后缀``。随后，使用Nginx，通过这几行配置就能把此功能实现：\n\n```\n    location  ~ \\.js${\n        footer \"\\n//# sourceMappingURL=$request_uri.map\";\n        footer_types \"*\";\n    }\n\n```\n只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。\n你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。\n![](/uploads/nginx2.jpg)\n\n### 场景三：内容纂改\n\n\n其实在以上两个场景里，都涉及了“内容纂改”。\n无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。\n\n统一介绍下，Nginx涉及纂改的模块有：\n\n* [nginx_http_footer_filter](https://m.oschina.net/blog/156826):往文件的底部添加文字，可包含Nginx的内置变量；\n* [nginx_http_addition_module](http://nginx.org/en/docs/http/ngx_http_addition_module.html)：从一个url去读取内容，将之添加到文件的头部或顶部；\n* [nginx_http_sub_module](http://nginx.org/en/docs/http/ngx_http_sub_module.html)：替换字符\n\n除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。            \n单单针对移动web前端开发，就可以实现：\n> 1. 将[weinre](http://people.apache.org/~pmuellr/weinre-docs/latest/)脚本插入到html里，让移动web调试更加便捷。\n> 2. 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。\n> 3. 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等\n\n\n### 场景四：本地映射\n\n在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。                \n而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   \n\n比如：**线上接口映射到本地文件**。            \n想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           \n\n而且，我们可以做得更灵活，比如：\n* 同时支持慢速调试\n* 同时支持目录层级映射\n* 同时支持正则匹配\n* JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据\n\n这些场景，只运用到Nginx里的“[rewrite规则](http://www.linuxidc.com/Linux/2014-01/95493.htm)”。                \n从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 \n\n最简单的模型中，我们把所有带``cgi-bin``路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，      \n仅需这三行配置即可：\n```\nlocation ~ /cgi-bin/* {\n    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;\n}\n```\n后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 \n\n### 场景五：移动侧调试\n\n`Fiddler` 有一个勾选项 `Allow remote computers to connect`，并可以指定 `listen port` 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 `hosts` 配合会很实用。\n\n这个功能，用Nginx也很容易做到。           \n通过 `default_server` 作为代理，手机终端通过设置网络代理为本机IP和相应的 `listen port`，从而可以访问本机的 Web 服务。\n\n其中也是用到了[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)模块的配置：\n```js\n server {\n    listen  80 default_server;\n    server_name  localhost;\n    resolver 8.8.8.8;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://$host;\n    }\n}\n\nserver {\n    listen  80;\n    server_name  ke.qq.com;\n    location / {\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-Ip $remote_addr;\n        proxy_set_header X-Forwarded-For $remote_addr;\n        proxy_pass http://127.0.0.1:9091/;\n    }\n}\n```\n\n### 边角料\n\n除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。\n\n1.[nginx_http_concat](https://github.com/alibaba/nginx-http-concat)               \n资源合并，处理CDN combo。例如通过这样的方式``http://example.com/??style1.css,style2.css,foo/style3.css``访问合并后的资源。\n\n2.[ngx_http_image_filter_module](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)                  \n图片处理。提供图片缩放，jpg压缩，旋转等特性。\n\n3.适配PC与移动web                              \n总体可运用[ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)，去实现路径转发。判断平台类型的Nginx配置，在开源项目[detectmobilebrowsers](http://detectmobilebrowsers.com/)中可以找到。\n\n### 后记\n\n学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。   \n于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。    \n**但既然是工具，熟手就好**。 \n\n\n比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。\n\n\n\n话说回来，后来心情有些惆怅。            \n想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。            \n不过我又想，**既然我已经花了时间去写，为什么还要花时间去用？！** \n \n \n \n心情又好起来了。（等等有什么不对，管它呢…）\n______________","slug":"nginx","published":1,"updated":"2017-10-23T13:23:34.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp6j001uv0v590sm3c84","content":"<p>Nginx那么好，我想去看看。<br>接连逛了两个书城后，我发现并没有Nginx相关的书籍。<br>这就很奇怪！</p>\n<p><img src=\"/uploads/nginx0.jpg\" alt=\"\"></p>\n<p>Nginx，一名<strong>网红</strong>（网络服务器红人…)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。</p>\n<p>后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为“<strong>使用太简单了，都不值得出书</strong>“。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。<br><a id=\"more\"></a></p>\n<h3 id=\"Nginx与NodeJs\"><a href=\"#Nginx与NodeJs\" class=\"headerlink\" title=\"Nginx与NodeJs\"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p>\n<p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。</p>\n<p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。</p>\n<p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。</p>\n<p>合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。</p>\n<p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。</p>\n<h3 id=\"场景一：环境切换\"><a href=\"#场景一：环境切换\" class=\"headerlink\" title=\"场景一：环境切换\"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。</p>\n<p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。</p>\n<p>思路很简单：</p>\n<blockquote>\n<p>1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；<br>2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">set $env_id <span class=\"string\">\"1.1.1.1\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> ( $http_cookie ~* <span class=\"string\">\"host_id=(\\S+)(;.*|$)\"</span>) &#123;</div><div class=\"line\">    set $env_id $<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">location / &#123;</div><div class=\"line\">    proxy_set_header Host $host;</div><div class=\"line\">    proxy_pass   http:<span class=\"comment\">//$env_id:80;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPosupplier</span><span class=\"params\">(String opacct)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\tString qrystr = <span class=\"string\">\" e.cfgsct ='posper' and e.cfgval ='\"</span>+opacct+<span class=\"string\">\"'\"</span>;</div><div class=\"line\">\tList&lt;Appcfg&gt; appcfgs = <span class=\"keyword\">this</span>.jdsdb.APPCFG().list(qrystr);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(appcfgs == <span class=\"keyword\">null</span> || appcfgs.size()&lt;=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那接下来的事情，<strong>就是怎样用最简便的方式，把IP种在cookie里</strong>？<br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p>\n<p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src=\"/uploads/nginx1.jpg\" alt=\"\"></p>\n<p>切换环境，如今只需点击一次。</p>\n<h3 id=\"场景二：SourceMap\"><a href=\"#场景二：SourceMap\" class=\"headerlink\" title=\"场景二：SourceMap\"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p>\n<p>而SourceMap正好可以解决此问题。</p>\n<p>在最新的各版本浏览器里，如果满足：</p>\n<ol>\n<li>压缩后的js文件后面有 <code>//# sourceMappingURL=xxx.map</code>格式的注释<br>2.浏览器能正常访问到sourceMappingURL<br>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</li>\n</ol>\n<p>1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）<br>2.测试环境带注释，能访问sourceMap</p>\n<p>这样的模型，用<code>反向代理+内容篡改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map后缀</code>。随后，使用Nginx，通过这几行配置就能把此功能实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">location  ~ \\.js$&#123;</div><div class=\"line\">    footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;;</div><div class=\"line\">    footer_types &quot;*&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src=\"/uploads/nginx2.jpg\" alt=\"\"></p>\n<h3 id=\"场景三：内容纂改\"><a href=\"#场景三：内容纂改\" class=\"headerlink\" title=\"场景三：内容纂改\"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p>\n<p>统一介绍下，Nginx涉及纂改的模块有：</p>\n<ul>\n<li><a href=\"https://m.oschina.net/blog/156826\" target=\"_blank\" rel=\"external\">nginx_http_footer_filter</a>:往文件的底部添加文字，可包含Nginx的内置变量；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html\" target=\"_blank\" rel=\"external\">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_sub_module.html\" target=\"_blank\" rel=\"external\">nginx_http_sub_module</a>：替换字符</li>\n</ul>\n<p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现：</p>\n<blockquote>\n<ol>\n<li>将<a href=\"http://people.apache.org/~pmuellr/weinre-docs/latest/\" target=\"_blank\" rel=\"external\">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li>\n<li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li>\n<li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li>\n</ol>\n</blockquote>\n<h3 id=\"场景四：本地映射\"><a href=\"#场景四：本地映射\" class=\"headerlink\" title=\"场景四：本地映射\"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   </p>\n<p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           </p>\n<p>而且，我们可以做得更灵活，比如：</p>\n<ul>\n<li>同时支持慢速调试</li>\n<li>同时支持目录层级映射</li>\n<li>同时支持正则匹配</li>\n<li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li>\n</ul>\n<p>这些场景，只运用到Nginx里的“<a href=\"http://www.linuxidc.com/Linux/2014-01/95493.htm\" target=\"_blank\" rel=\"external\">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 </p>\n<p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">location ~ /cgi-bin/* &#123;</div><div class=\"line\">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 </p>\n<h3 id=\"场景五：移动侧调试\"><a href=\"#场景五：移动侧调试\" class=\"headerlink\" title=\"场景五：移动侧调试\"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p>\n<p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p>\n<p>其中也是用到了<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"external\">ngx_http_proxy_module</a>模块的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> server &#123;</div><div class=\"line\">    listen  <span class=\"number\">80</span> default_server;</div><div class=\"line\">    server_name  localhost;</div><div class=\"line\">    resolver <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header Host $host;</div><div class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</div><div class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">        proxy_pass http:<span class=\"comment\">//$host;</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">server &#123;</div><div class=\"line\">    listen  <span class=\"number\">80</span>;</div><div class=\"line\">    server_name  ke.qq.com;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header Host $host;</div><div class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</div><div class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">        proxy_pass http:<span class=\"comment\">//127.0.0.1:9091/;</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"边角料\"><a href=\"#边角料\" class=\"headerlink\" title=\"边角料\"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p>\n<p>1.<a href=\"https://github.com/alibaba/nginx-http-concat\" target=\"_blank\" rel=\"external\">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p>\n<p>2.<a href=\"http://nginx.org/en/docs/http/ngx_http_image_filter_module.html\" target=\"_blank\" rel=\"external\">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p>\n<p>3.适配PC与移动web<br>总体可运用<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"external\">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href=\"http://detectmobilebrowsers.com/\" target=\"_blank\" rel=\"external\">detectmobilebrowsers</a>中可以找到。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。 </p>\n<p>比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p>\n<p>话说回来，后来心情有些惆怅。<br>想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。<br>不过我又想，<strong>既然我已经花了时间去写，为什么还要花时间去用？！</strong> </p>\n<p>心情又好起来了。（等等有什么不对，管它呢…）</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>Nginx那么好，我想去看看。<br>接连逛了两个书城后，我发现并没有Nginx相关的书籍。<br>这就很奇怪！</p>\n<p><img src=\"/uploads/nginx0.jpg\" alt=\"\"></p>\n<p>Nginx，一名<strong>网红</strong>（网络服务器红人…)，就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。</p>\n<p>后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。<br>后来发现了原因，大概是因为“<strong>使用太简单了，都不值得出书</strong>“。<br>是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。<br>当它呈现到你面前时，感觉独具匠心。<br>","more":"</p>\n<h3 id=\"Nginx与NodeJs\"><a href=\"#Nginx与NodeJs\" class=\"headerlink\" title=\"Nginx与NodeJs\"></a>Nginx与NodeJs</h3><p>（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。）</p>\n<p>有人说，作为一名前端，<strong>我的真爱是NodeJs</strong>。<br>同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。</p>\n<p>这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。</p>\n<p>在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。</p>\n<p>合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。</p>\n<p>以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。</p>\n<h3 id=\"场景一：环境切换\"><a href=\"#场景一：环境切换\" class=\"headerlink\" title=\"场景一：环境切换\"></a>场景一：环境切换</h3><p>前端开发中，经常面临多个部署环境切换的问题。<br>我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。</p>\n<p>然而在拓展性和易用性方面，还不足够好。<br>而Nginx作为反向代理，就很容易处理资源转发的问题。</p>\n<p>思路很简单：</p>\n<blockquote>\n<p>1.读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址；<br>2.如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）;</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">set $env_id <span class=\"string\">\"1.1.1.1\"</span>;</div><div class=\"line\"><span class=\"keyword\">if</span> ( $http_cookie ~* <span class=\"string\">\"host_id=(\\S+)(;.*|$)\"</span>) &#123;</div><div class=\"line\">    set $env_id $<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">location / &#123;</div><div class=\"line\">    proxy_set_header Host $host;</div><div class=\"line\">    proxy_pass   http:<span class=\"comment\">//$env_id:80;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPosupplier</span><span class=\"params\">(String opacct)</span> <span class=\"keyword\">throws</span> TException </span>&#123;</div><div class=\"line\">\t\t\t</div><div class=\"line\">\tString qrystr = <span class=\"string\">\" e.cfgsct ='posper' and e.cfgval ='\"</span>+opacct+<span class=\"string\">\"'\"</span>;</div><div class=\"line\">\tList&lt;Appcfg&gt; appcfgs = <span class=\"keyword\">this</span>.jdsdb.APPCFG().list(qrystr);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(appcfgs == <span class=\"keyword\">null</span> || appcfgs.size()&lt;=<span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>那接下来的事情，<strong>就是怎样用最简便的方式，把IP种在cookie里</strong>？<br>我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。</p>\n<p>这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。<br><img src=\"/uploads/nginx1.jpg\" alt=\"\"></p>\n<p>切换环境，如今只需点击一次。</p>\n<h3 id=\"场景二：SourceMap\"><a href=\"#场景二：SourceMap\" class=\"headerlink\" title=\"场景二：SourceMap\"></a>场景二：SourceMap</h3><p>在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。</p>\n<p>而SourceMap正好可以解决此问题。</p>\n<p>在最新的各版本浏览器里，如果满足：</p>\n<ol>\n<li>压缩后的js文件后面有 <code>//# sourceMappingURL=xxx.map</code>格式的注释<br>2.浏览器能正常访问到sourceMappingURL<br>那么，就能把压缩过的代码还原。<br>要实现这样的功能，就必须：</li>\n</ol>\n<p>1.现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑）<br>2.测试环境带注释，能访问sourceMap</p>\n<p>这样的模型，用<code>反向代理+内容篡改</code>的思路再合适不过。<br>每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加<code>.map后缀</code>。随后，使用Nginx，通过这几行配置就能把此功能实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">location  ~ \\.js$&#123;</div><div class=\"line\">    footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;;</div><div class=\"line\">    footer_types &quot;*&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。<br>你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。<br><img src=\"/uploads/nginx2.jpg\" alt=\"\"></p>\n<h3 id=\"场景三：内容纂改\"><a href=\"#场景三：内容纂改\" class=\"headerlink\" title=\"场景三：内容纂改\"></a>场景三：内容纂改</h3><p>其实在以上两个场景里，都涉及了“内容纂改”。<br>无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。</p>\n<p>统一介绍下，Nginx涉及纂改的模块有：</p>\n<ul>\n<li><a href=\"https://m.oschina.net/blog/156826\" target=\"_blank\" rel=\"external\">nginx_http_footer_filter</a>:往文件的底部添加文字，可包含Nginx的内置变量；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_addition_module.html\" target=\"_blank\" rel=\"external\">nginx_http_addition_module</a>：从一个url去读取内容，将之添加到文件的头部或顶部；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_sub_module.html\" target=\"_blank\" rel=\"external\">nginx_http_sub_module</a>：替换字符</li>\n</ul>\n<p>除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。<br>单单针对移动web前端开发，就可以实现：</p>\n<blockquote>\n<ol>\n<li>将<a href=\"http://people.apache.org/~pmuellr/weinre-docs/latest/\" target=\"_blank\" rel=\"external\">weinre</a>脚本插入到html里，让移动web调试更加便捷。</li>\n<li>移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。</li>\n<li>手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等</li>\n</ol>\n</blockquote>\n<h3 id=\"场景四：本地映射\"><a href=\"#场景四：本地映射\" class=\"headerlink\" title=\"场景四：本地映射\"></a>场景四：本地映射</h3><p>在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。<br>而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。   </p>\n<p>比如：<strong>线上接口映射到本地文件</strong>。<br>想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。           </p>\n<p>而且，我们可以做得更灵活，比如：</p>\n<ul>\n<li>同时支持慢速调试</li>\n<li>同时支持目录层级映射</li>\n<li>同时支持正则匹配</li>\n<li>JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据</li>\n</ul>\n<p>这些场景，只运用到Nginx里的“<a href=\"http://www.linuxidc.com/Linux/2014-01/95493.htm\" target=\"_blank\" rel=\"external\">rewrite规则</a>”。<br>从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 </p>\n<p>最简单的模型中，我们把所有带<code>cgi-bin</code>路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，<br>仅需这三行配置即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">location ~ /cgi-bin/* &#123;</div><div class=\"line\">    rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 </p>\n<h3 id=\"场景五：移动侧调试\"><a href=\"#场景五：移动侧调试\" class=\"headerlink\" title=\"场景五：移动侧调试\"></a>场景五：移动侧调试</h3><p><code>Fiddler</code> 有一个勾选项 <code>Allow remote computers to connect</code>，并可以指定 <code>listen port</code> 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 <code>hosts</code> 配合会很实用。</p>\n<p>这个功能，用Nginx也很容易做到。<br>通过 <code>default_server</code> 作为代理，手机终端通过设置网络代理为本机IP和相应的 <code>listen port</code>，从而可以访问本机的 Web 服务。</p>\n<p>其中也是用到了<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"external\">ngx_http_proxy_module</a>模块的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> server &#123;</div><div class=\"line\">    listen  <span class=\"number\">80</span> default_server;</div><div class=\"line\">    server_name  localhost;</div><div class=\"line\">    resolver <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span>;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header Host $host;</div><div class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</div><div class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">        proxy_pass http:<span class=\"comment\">//$host;</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">server &#123;</div><div class=\"line\">    listen  <span class=\"number\">80</span>;</div><div class=\"line\">    server_name  ke.qq.com;</div><div class=\"line\">    location / &#123;</div><div class=\"line\">        proxy_set_header Host $host;</div><div class=\"line\">        proxy_set_header X-Real-Ip $remote_addr;</div><div class=\"line\">        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">        proxy_pass http:<span class=\"comment\">//127.0.0.1:9091/;</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"边角料\"><a href=\"#边角料\" class=\"headerlink\" title=\"边角料\"></a>边角料</h3><p>除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。</p>\n<p>1.<a href=\"https://github.com/alibaba/nginx-http-concat\" target=\"_blank\" rel=\"external\">nginx_http_concat</a><br>资源合并，处理CDN combo。例如通过这样的方式<code>http://example.com/??style1.css,style2.css,foo/style3.css</code>访问合并后的资源。</p>\n<p>2.<a href=\"http://nginx.org/en/docs/http/ngx_http_image_filter_module.html\" target=\"_blank\" rel=\"external\">ngx_http_image_filter_module</a><br>图片处理。提供图片缩放，jpg压缩，旋转等特性。</p>\n<p>3.适配PC与移动web<br>总体可运用<a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" target=\"_blank\" rel=\"external\">ngx_http_proxy_module</a>，去实现路径转发。判断平台类型的Nginx配置，在开源项目<a href=\"http://detectmobilebrowsers.com/\" target=\"_blank\" rel=\"external\">detectmobilebrowsers</a>中可以找到。</p>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。<br>于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。<br><strong>但既然是工具，熟手就好</strong>。 </p>\n<p>比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。</p>\n<p>话说回来，后来心情有些惆怅。<br>想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。<br>不过我又想，<strong>既然我已经花了时间去写，为什么还要花时间去用？！</strong> </p>\n<p>心情又好起来了。（等等有什么不对，管它呢…）</p>\n<hr>"},{"title":"薛定谔的年 1.1 -1.7","date":"2017-10-20T01:50:18.000Z","_content":"\n![](/uploads/diary-18.jpg)\n\n传说中，现在这段元旦到除夕的时间\n由于不知该称之“今年”或“明年”\n有人就说，叫薛定谔的年好了！\n这么一想，好像许多东西都可以跟薛定谔扯上关系了。\n\n比如这周，每天醒来第一件事\n就是到12306查一下有没有薛定谔的票\n有了，就输入那个神才知道对不对的薛定谔验证码\n去完成这笔鬼才知道成不成功的薛定谔订单\n\n这世道，上半年的代码，到下半年能不能编译都要打个问号\n就不要试想真切地看清这繁华世界啦。\nMr.Big不断重复着：Oh baby baby it's a wild world ....\n有时候发现我等的就是这几个字。\n\n<!-- more -->\n\n***\n这周把kindle的书摘和笔记导了出来，是时候整理一下了。\n不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。\n\n以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？\n但批判一件事，就得先完成它。\n等到真正看完，你又突然明白了喜爱的理由。\n这种奇妙感觉已经太久没遇到了。\n\n然后友谊书城变得越来越吵\n而且很会调果茶的那个漂亮姐姐也走了\n不知道这两回事有没有必然联系…\n反正我是很少再去。\n\n不过看着笔记还是能想起很多事情。\n有些摘录根本不知所以，但模糊不清反而会更有意思\n仿佛一种梦境的延伸。\n它们的存在，证明时光的缝隙里\n出现过一瞬间薛定谔式的触动与喜欢\n\n仅此而已，就可知足，就能圆满。\n因为有时候，一瞬间的心有灵犀\n比一万年的细水长流要隽永得多。\n","source":"_posts/xuedinge.md","raw":"---\ntitle: 薛定谔的年 1.1 -1.7\ndate: 2017-10-20 09:50:18\ntags: 旧事\ncategories: -转载\n---\n\n![](/uploads/diary-18.jpg)\n\n传说中，现在这段元旦到除夕的时间\n由于不知该称之“今年”或“明年”\n有人就说，叫薛定谔的年好了！\n这么一想，好像许多东西都可以跟薛定谔扯上关系了。\n\n比如这周，每天醒来第一件事\n就是到12306查一下有没有薛定谔的票\n有了，就输入那个神才知道对不对的薛定谔验证码\n去完成这笔鬼才知道成不成功的薛定谔订单\n\n这世道，上半年的代码，到下半年能不能编译都要打个问号\n就不要试想真切地看清这繁华世界啦。\nMr.Big不断重复着：Oh baby baby it's a wild world ....\n有时候发现我等的就是这几个字。\n\n<!-- more -->\n\n***\n这周把kindle的书摘和笔记导了出来，是时候整理一下了。\n不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。\n\n以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？\n但批判一件事，就得先完成它。\n等到真正看完，你又突然明白了喜爱的理由。\n这种奇妙感觉已经太久没遇到了。\n\n然后友谊书城变得越来越吵\n而且很会调果茶的那个漂亮姐姐也走了\n不知道这两回事有没有必然联系…\n反正我是很少再去。\n\n不过看着笔记还是能想起很多事情。\n有些摘录根本不知所以，但模糊不清反而会更有意思\n仿佛一种梦境的延伸。\n它们的存在，证明时光的缝隙里\n出现过一瞬间薛定谔式的触动与喜欢\n\n仅此而已，就可知足，就能圆满。\n因为有时候，一瞬间的心有灵犀\n比一万年的细水长流要隽永得多。\n","slug":"xuedinge","published":1,"updated":"2017-10-23T13:23:34.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94blp6l001zv0v5nzyyftry","content":"<p><img src=\"/uploads/diary-18.jpg\" alt=\"\"></p>\n<p>传说中，现在这段元旦到除夕的时间<br>由于不知该称之“今年”或“明年”<br>有人就说，叫薛定谔的年好了！<br>这么一想，好像许多东西都可以跟薛定谔扯上关系了。</p>\n<p>比如这周，每天醒来第一件事<br>就是到12306查一下有没有薛定谔的票<br>有了，就输入那个神才知道对不对的薛定谔验证码<br>去完成这笔鬼才知道成不成功的薛定谔订单</p>\n<p>这世道，上半年的代码，到下半年能不能编译都要打个问号<br>就不要试想真切地看清这繁华世界啦。<br>Mr.Big不断重复着：Oh baby baby it’s a wild world ….<br>有时候发现我等的就是这几个字。</p>\n<a id=\"more\"></a>\n<hr>\n<p>这周把kindle的书摘和笔记导了出来，是时候整理一下了。<br>不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。</p>\n<p>以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？<br>但批判一件事，就得先完成它。<br>等到真正看完，你又突然明白了喜爱的理由。<br>这种奇妙感觉已经太久没遇到了。</p>\n<p>然后友谊书城变得越来越吵<br>而且很会调果茶的那个漂亮姐姐也走了<br>不知道这两回事有没有必然联系…<br>反正我是很少再去。</p>\n<p>不过看着笔记还是能想起很多事情。<br>有些摘录根本不知所以，但模糊不清反而会更有意思<br>仿佛一种梦境的延伸。<br>它们的存在，证明时光的缝隙里<br>出现过一瞬间薛定谔式的触动与喜欢</p>\n<p>仅此而已，就可知足，就能圆满。<br>因为有时候，一瞬间的心有灵犀<br>比一万年的细水长流要隽永得多。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/uploads/diary-18.jpg\" alt=\"\"></p>\n<p>传说中，现在这段元旦到除夕的时间<br>由于不知该称之“今年”或“明年”<br>有人就说，叫薛定谔的年好了！<br>这么一想，好像许多东西都可以跟薛定谔扯上关系了。</p>\n<p>比如这周，每天醒来第一件事<br>就是到12306查一下有没有薛定谔的票<br>有了，就输入那个神才知道对不对的薛定谔验证码<br>去完成这笔鬼才知道成不成功的薛定谔订单</p>\n<p>这世道，上半年的代码，到下半年能不能编译都要打个问号<br>就不要试想真切地看清这繁华世界啦。<br>Mr.Big不断重复着：Oh baby baby it’s a wild world ….<br>有时候发现我等的就是这几个字。</p>","more":"<hr>\n<p>这周把kindle的书摘和笔记导了出来，是时候整理一下了。<br>不过这一年的读书感受并不好，也不仅是对最近的畅销书大失所望。</p>\n<p>以前有些书看到一半就觉得很糟糕，疑惑怎么会有这么多人喜欢呢？<br>但批判一件事，就得先完成它。<br>等到真正看完，你又突然明白了喜爱的理由。<br>这种奇妙感觉已经太久没遇到了。</p>\n<p>然后友谊书城变得越来越吵<br>而且很会调果茶的那个漂亮姐姐也走了<br>不知道这两回事有没有必然联系…<br>反正我是很少再去。</p>\n<p>不过看着笔记还是能想起很多事情。<br>有些摘录根本不知所以，但模糊不清反而会更有意思<br>仿佛一种梦境的延伸。<br>它们的存在，证明时光的缝隙里<br>出现过一瞬间薛定谔式的触动与喜欢</p>\n<p>仅此而已，就可知足，就能圆满。<br>因为有时候，一瞬间的心有灵犀<br>比一万年的细水长流要隽永得多。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj94blp4f0008v0v5kkh326ot","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp4s000gv0v585tesfdk"},{"post_id":"cj94blp3s0000v0v5256o27nn","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp4w000lv0v5rv0zvcld"},{"post_id":"cj94blp4g000av0v56t4liyh6","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp51000ov0v5h7ophml3"},{"post_id":"cj94blp4n000ev0v5c3cdsqxe","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp55000sv0v5wogyb6hg"},{"post_id":"cj94blp440002v0v5jqg9blbg","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp57000vv0v5kzssgigd"},{"post_id":"cj94blp4c0006v0v5e05q9jej","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp5b000yv0v525dh06m5"},{"post_id":"cj94blp59000xv0v5a7u9d764","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp5k0016v0v5npd3tuln"},{"post_id":"cj94blp5f0013v0v5nzpbgnat","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp5t001cv0v5x5lbhhqn"},{"post_id":"cj94blp5i0015v0v54zgspsjz","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp5w001gv0v50am3zp6w"},{"post_id":"cj94blp5o0019v0v5olek0tq7","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp60001jv0v590075jut"},{"post_id":"cj94blp5r001bv0v5zdjrz3s9","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp63001mv0v5afl4c6de"},{"post_id":"cj94blp5u001fv0v54uqquedl","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp6a001pv0v5b78yc8vk"},{"post_id":"cj94blp5y001iv0v5pyicvtn3","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp6g001sv0v5ebw1hvic"},{"post_id":"cj94blp62001lv0v50ahoweda","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp6k001vv0v5yd0nhqmw"},{"post_id":"cj94blp65001ov0v5aj3cavhp","category_id":"cj94blp480004v0v5hiz7917y","_id":"cj94blp6n0020v0v5ek6mzj1f"},{"post_id":"cj94blp6d001rv0v5tci6hcax","category_id":"cj94blp6k001xv0v5se7095ec","_id":"cj94blp6s0028v0v50ajiymj8"},{"post_id":"cj94blp6j001uv0v590sm3c84","category_id":"cj94blp6k001xv0v5se7095ec","_id":"cj94blp6w002cv0v5aj6emhjl"},{"post_id":"cj94blp6l001zv0v5nzyyftry","category_id":"cj94blp6k001xv0v5se7095ec","_id":"cj94blp6y002gv0v5h8iycdij"}],"PostTag":[{"post_id":"cj94blp4n000ev0v5c3cdsqxe","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp4v000jv0v5p6qraqvn"},{"post_id":"cj94blp4n000ev0v5c3cdsqxe","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp4z000mv0v5tpezoegh"},{"post_id":"cj94blp3s0000v0v5256o27nn","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp53000qv0v5ao5hx4g1"},{"post_id":"cj94blp3s0000v0v5256o27nn","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp55000tv0v54rdh1ule"},{"post_id":"cj94blp440002v0v5jqg9blbg","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp5b000zv0v5v94cvt01"},{"post_id":"cj94blp440002v0v5jqg9blbg","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp5e0011v0v5oyfx145t"},{"post_id":"cj94blp59000xv0v5a7u9d764","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp5h0014v0v5dxtb42ld"},{"post_id":"cj94blp59000xv0v5a7u9d764","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp5k0017v0v5ky9l3c1u"},{"post_id":"cj94blp5f0013v0v5nzpbgnat","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp5p001av0v57al0itxr"},{"post_id":"cj94blp5f0013v0v5nzpbgnat","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp5t001dv0v5q1tx9o21"},{"post_id":"cj94blp4c0006v0v5e05q9jej","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp5w001hv0v5b6fburwh"},{"post_id":"cj94blp4c0006v0v5e05q9jej","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp60001kv0v55947qan2"},{"post_id":"cj94blp5i0015v0v54zgspsjz","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp64001nv0v5o74e4wex"},{"post_id":"cj94blp5i0015v0v54zgspsjz","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6b001qv0v523305nth"},{"post_id":"cj94blp5o0019v0v5olek0tq7","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6h001tv0v5g0bd7bcw"},{"post_id":"cj94blp5o0019v0v5olek0tq7","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6k001wv0v5sbusbcah"},{"post_id":"cj94blp4f0008v0v5kkh326ot","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6n0021v0v5on6s1187"},{"post_id":"cj94blp4f0008v0v5kkh326ot","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6o0022v0v5i40pquoc"},{"post_id":"cj94blp5r001bv0v5zdjrz3s9","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6q0025v0v505qhmhtl"},{"post_id":"cj94blp5r001bv0v5zdjrz3s9","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6r0026v0v5n26hd1ce"},{"post_id":"cj94blp5u001fv0v54uqquedl","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6s0029v0v5zbhncxqq"},{"post_id":"cj94blp5u001fv0v54uqquedl","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6v002bv0v5q2xc0w7j"},{"post_id":"cj94blp4g000av0v56t4liyh6","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6w002dv0v5vtus05cj"},{"post_id":"cj94blp4g000av0v56t4liyh6","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp6x002fv0v5bj0zqpf1"},{"post_id":"cj94blp5y001iv0v5pyicvtn3","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp6y002hv0v5f74fbj54"},{"post_id":"cj94blp5y001iv0v5pyicvtn3","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp70002jv0v5x4mhigj0"},{"post_id":"cj94blp62001lv0v50ahoweda","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp71002kv0v5xu3hcdi0"},{"post_id":"cj94blp62001lv0v50ahoweda","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp72002lv0v5xgbm278c"},{"post_id":"cj94blp65001ov0v5aj3cavhp","tag_id":"cj94blp4a0005v0v5jj4nqmxk","_id":"cj94blp72002mv0v5ea5m9hux"},{"post_id":"cj94blp65001ov0v5aj3cavhp","tag_id":"cj94blp4i000cv0v5byyok96d","_id":"cj94blp73002nv0v5fy3i44nu"},{"post_id":"cj94blp6d001rv0v5tci6hcax","tag_id":"cj94blp6l001yv0v5y86i2rzq","_id":"cj94blp74002ov0v5s92t1u7h"},{"post_id":"cj94blp6d001rv0v5tci6hcax","tag_id":"cj94blp6p0024v0v521z9vw17","_id":"cj94blp75002pv0v5hu52oh1a"},{"post_id":"cj94blp6j001uv0v590sm3c84","tag_id":"cj94blp6u002av0v54wngcb1h","_id":"cj94blp75002qv0v5925i6ylv"},{"post_id":"cj94blp6j001uv0v590sm3c84","tag_id":"cj94blp6x002ev0v52sl7jcuj","_id":"cj94blp76002rv0v5j7fzn2pv"},{"post_id":"cj94blp6l001zv0v5nzyyftry","tag_id":"cj94blp6p0024v0v521z9vw17","_id":"cj94blp76002sv0v5jnj4mxgf"}],"Tag":[{"name":"java","_id":"cj94blp4a0005v0v5jj4nqmxk"},{"name":"转载","_id":"cj94blp4i000cv0v5byyok96d"},{"name":"游戏","_id":"cj94blp6l001yv0v5y86i2rzq"},{"name":"旧事","_id":"cj94blp6p0024v0v521z9vw17"},{"name":"前端","_id":"cj94blp6u002av0v54wngcb1h"},{"name":"nginx","_id":"cj94blp6x002ev0v52sl7jcuj"}]}}